import { scoreTraces, scoreTracesWorkflow } from '@mastra/core/evals/scoreTraces';
import { Mastra } from '@mastra/core';
import { PinoLogger } from '@mastra/loggers';
import { LibSQLStore } from '@mastra/libsql';
import { Observability, SensitiveDataFilter, DefaultExporter, CloudExporter } from '@mastra/observability';
import { Workspace, LocalSandbox, LocalFilesystem, WORKSPACE_TOOLS as WORKSPACE_TOOLS$1 } from '@mastra/core/workspace';
import { Workflow, createStep, createWorkflow } from '@mastra/core/workflows';
import z$1, { z, ZodObject } from 'zod';
import { Agent, MessageList, isSupportedLanguageModel, tryGenerateWithJsonFallback, tryStreamWithJsonFallback } from '@mastra/core/agent';
import { deepseek } from '@ai-sdk/deepseek';
import { Memory as Memory$1 } from '@mastra/memory';
import { readdir, readFile, mkdtemp, rm, writeFile, mkdir, copyFile, stat } from 'fs/promises';
import * as https from 'https';
import { join, resolve as resolve$2, dirname, extname, basename, isAbsolute, relative } from 'path';
import { fileURLToPath } from 'url';
import { createServer } from 'http';
import { Http2ServerRequest } from 'http2';
import { Readable, Writable } from 'stream';
import crypto$1 from 'crypto';
import { readFileSync, existsSync, createReadStream, statSync } from 'fs';
import { versions } from 'process';
import { isVercelTool, createTool, Tool } from '@mastra/core/tools';
import { zodToJsonSchema as zodToJsonSchema$1 } from '@mastra/core/utils/zod-to-json';
import { MastraError, ErrorDomain, ErrorCategory } from '@mastra/core/error';
import { coreFeatures } from '@mastra/core/features';
import { isProcessorWorkflow } from '@mastra/core/processors';
import { EMBEDDING_MODELS, PROVIDER_REGISTRY, ModelRouterLanguageModel } from '@mastra/core/llm';
import { MASTRA_RESOURCE_ID_KEY, MASTRA_THREAD_ID_KEY, RequestContext } from '@mastra/core/request-context';
import { generateEmptyFromSchema } from '@mastra/core/utils';
import { listScoresResponseSchema } from '@mastra/core/evals';
import { listTracesResponseSchema, tracesFilterSchema, paginationArgsSchema, tracesOrderBySchema, getTraceResponseSchema, getTraceArgsSchema, scoreTracesResponseSchema, scoreTracesRequestSchema, spanIdsSchema, dateRangeSchema, InMemoryStore } from '@mastra/core/storage';
import { MastraA2AError } from '@mastra/core/a2a';
import { TransformStream as TransformStream$1, ReadableStream as ReadableStream$1 } from 'stream/web';
import { ZodFirstPartyTypeKind } from 'zod/v3';
import * as z42 from 'zod/v4';
import { z as z$2 } from 'zod/v4';
import { MastraMemory, removeWorkingMemoryTags, extractWorkingMemoryContent } from '@mastra/core/memory';
import { spawn as spawn$1, execFile as execFile$1, exec as exec$1 } from 'child_process';
import { createRequire } from 'module';
import util, { promisify } from 'util';
import { tmpdir } from 'os';
import { MastraServerBase } from '@mastra/core/server';
import { Buffer as Buffer$1 } from 'buffer';
import { tools } from './tools.mjs';

const SYSTEM_PROMPT = `You are an expert frontend code generator. Your task is to create complete, standalone HTML files based on user requirements.

## Core Constraints (CRITICAL - MUST FOLLOW)

1. **External Resources - ONLY THESE TWO ALLOWED:**
   - TailwindCSS CDN: https://cdn.tailwindcss.com
   - Vue.js CDN: https://unpkg.com/vue@3/dist/vue.global.js

2. **ALL OTHER RESOURCES MUST BE INLINED:**
   - Custom CSS \u2192 Place inside <style> tags
   - Custom JavaScript \u2192 Place inside <script> tags
   - Fonts \u2192 Use system fonts or inline font-face declarations with base64
   - Icons \u2192 Use inline SVG or Unicode characters
   - Images \u2192 Use data URIs (base64) or inline SVG

3. **PROHIBITED:**
   - No external CSS files via <link> (except Tailwind)
   - No external JS files via <script src> (except Vue)
   - No external image URLs (http/https)
   - No Google Fonts or other font CDNs
   - No icon libraries (FontAwesome, etc.)

## HTML Structure Template

\`\`\`html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[Page Title]</title>
    <!-- ONLY EXTERNAL RESOURCES ALLOWED -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Custom styles MUST be inline -->
    <style>
        /* Your custom CSS here */
    </style>
</head>
<body>
    <div id="app">
        <!-- Vue.js application markup -->
    </div>
    
    <!-- Custom JavaScript MUST be inline -->
    <script>
        const { createApp } = Vue;
        createApp({
            // Vue app configuration
        }).mount('#app');
    </script>
</body>
</html>
\`\`\`

## Input Format

The user will provide input in this JSON structure:
\`\`\`json
{
  "requirement": "Description of what to build",
  "options": {
    "style": "modern" | "minimalist" | "colorful",
    "complexity": "simple" | "medium" | "complex"
  }
}
\`\`\`

## Output Format

You MUST respond with a JSON object in this exact structure, without any additional text or explanation:

\`\`\`json
{
  "html": "<!DOCTYPE html>...",
  "metadata": {
    "title": "Brief title",
    "description": "What the page does",
    "tailwindVersion": "3.x",
    "vueVersion": "3.x",
    "estimatedComplexity": "simple|medium|complex",
    "components": ["component1", "component2"],
    "generatedAt": "2024-01-01T00:00:00Z"
  },
  "success": true
}
\`\`\`

## Style Guidelines

- **modern**: Clean, professional, subtle shadows, rounded corners, generous whitespace
- **minimalist**: Maximum simplicity, monochrome or limited colors, essential elements only
- **colorful**: Vibrant colors, gradients, playful elements, visual interest

## Complexity Levels

- **simple**: Single component, basic interactivity, < 100 lines
- **medium**: Multiple components, moderate state management, 100-300 lines
- **complex**: Rich interactions, advanced Vue features, > 300 lines

## Best Practices

1. Use semantic HTML elements
2. Make components responsive with Tailwind classes
3. Add appropriate comments in code
4. Ensure accessibility (ARIA labels where needed)
5. Use Vue 3 Composition API with <script setup> syntax when appropriate
6. Validate that no prohibited external resources are included
`;

function createFrontendCodeGeneratorAgent(workspace) {
  return new Agent({
    id: "frontend-code-generator",
    name: "Frontend Code Generator",
    instructions: SYSTEM_PROMPT,
    model: deepseek("deepseek-chat"),
    workspace,
    // 3.3 为只读代理应用工作空间配置
    memory: new Memory$1({
      options: {
        lastMessages: 20
      }
    })
  });
}
createFrontendCodeGeneratorAgent();

const WORKSPACE_AGENT_PROMPT = `You are a Workspace Agent with full permissions to manage workspace files and execute code in sandbox.

## Capabilities

You have complete access to:
- **Workspace Files**: Read, write, edit, delete files and create directories within the workspace
- **Sandbox Execution**: Run code and execute commands in an isolated sandbox environment

## Guidelines

1. **File Operations**: Perform file operations safely within the workspace directory
2. **Code Execution**: Execute code in the sandbox and return results
3. **Data Flow**: Support reading files from workspace, executing in sandbox, and writing results back to workspace
4. **Security**: Ensure all operations stay within the configured workspace boundaries

## Safety

- Never attempt to access files outside the workspace directory
-\u62D2\u7EDD\u6267\u884C\u5371\u9669\u547D\u4EE4 that could harm the system
- Report any security concerns immediately
`;

const getWorkspacePath$1 = () => {
  return process.env.MASTRA_WORKSPACE_PATH || "./workspace";
};
function createWorkspaceAgent(workspace) {
  const agentWorkspace = workspace ?? new Workspace({
    id: "workspace-agent-workspace",
    name: "Workspace Agent Workspace",
    filesystem: new LocalFilesystem({
      basePath: getWorkspacePath$1(),
      contained: true
    }),
    sandbox: new LocalSandbox({
      workingDirectory: getWorkspacePath$1()
    }),
    tools: {
      [WORKSPACE_TOOLS$1.FILESYSTEM.READ_FILE]: { enabled: true },
      [WORKSPACE_TOOLS$1.FILESYSTEM.WRITE_FILE]: { enabled: true },
      [WORKSPACE_TOOLS$1.FILESYSTEM.EDIT_FILE]: { enabled: true },
      [WORKSPACE_TOOLS$1.FILESYSTEM.DELETE]: { enabled: true },
      [WORKSPACE_TOOLS$1.FILESYSTEM.MKDIR]: { enabled: true },
      [WORKSPACE_TOOLS$1.FILESYSTEM.LIST_FILES]: { enabled: true },
      [WORKSPACE_TOOLS$1.FILESYSTEM.FILE_STAT]: { enabled: true },
      [WORKSPACE_TOOLS$1.SANDBOX.EXECUTE_COMMAND]: { enabled: true }
    }
  });
  return new Agent({
    id: "workspace-agent",
    name: "Workspace Agent",
    instructions: WORKSPACE_AGENT_PROMPT,
    model: deepseek("deepseek-chat"),
    workspace: agentWorkspace,
    memory: new Memory$1({
      options: {
        lastMessages: 20
      }
    })
  });
}
createWorkspaceAgent();

const generateFrontendCodeSchema = z.object({
  html: z.string(),
  metadata: z.object({
    title: z.string(),
    description: z.string(),
    tailwindVersion: z.string(),
    vueVersion: z.string(),
    estimatedComplexity: z.string(),
    components: z.array(z.string()),
    generatedAt: z.string()
  })
});
const stepOne = createStep({
  id: "receive-requirement",
  inputSchema: z.object({
    requirement: z.string().describe("User one-sentence requirement for frontend page")
  }),
  outputSchema: z.object({
    requirement: z.string()
  }),
  execute: async ({ inputData }) => {
    return {
      requirement: inputData.requirement
    };
  }
});
const stepTwo = createStep({
  id: "generate-frontend-code",
  inputSchema: z.object({
    requirement: z.string()
  }),
  outputSchema: generateFrontendCodeSchema,
  execute: async ({ inputData, mastra }) => {
    const agent = mastra.getAgent("frontendCodeGenerator");
    if (!agent) {
      throw new Error("Agent frontendCodeGenerator not found");
    }
    const prompt = JSON.stringify({
      requirement: inputData.requirement,
      options: {
        style: "modern",
        complexity: "simple"
      }
    });
    const result = await agent.stream(prompt, {
      structuredOutput: {
        schema: generateFrontendCodeSchema
      }
    });
    const res = await result.getFullOutput();
    return res.object;
  }
});
const stepThree = createStep({
  id: "write-files",
  inputSchema: generateFrontendCodeSchema,
  outputSchema: z.object({
    htmlPath: z.string(),
    jsonPath: z.string(),
    success: z.boolean()
  }),
  execute: async ({ inputData, mastra }) => {
    const title = inputData.metadata.title;
    const safeTitle = title.toLowerCase().replace(/[^a-z0-9]/g, "-");
    const htmlContent = inputData.html;
    const metadataJson = JSON.stringify(inputData.metadata, null, 2);
    const htmlFileName = `${safeTitle}.html`;
    const jsonFileName = `${safeTitle}.json`;
    const workspaceAgent = mastra.getAgent("workspace");
    if (!workspaceAgent) {
      throw new Error("Agent workspace not found");
    }
    const htmlPrompt = `Write the following content to file "${htmlFileName}":

${htmlContent}`;
    await workspaceAgent.stream(htmlPrompt);
    const jsonPrompt = `Write the following content to file "${jsonFileName}":

${metadataJson}`;
    await workspaceAgent.stream(jsonPrompt);
    return {
      htmlPath: htmlFileName,
      jsonPath: jsonFileName,
      success: true
    };
  }
});
const simpleWorkflow = new Workflow({
  id: "simple-workflow",
  inputSchema: z.object({
    requirement: z.string().describe("User one-sentence requirement for frontend page")
  }),
  outputSchema: z.object({
    htmlPath: z.string(),
    jsonPath: z.string(),
    success: z.boolean()
  })
}).then(stepOne).then(stepTwo).then(stepThree);

const getWorkspacePath = () => {
  return process.env.MASTRA_WORKSPACE_PATH || "./workspace";
};
const workspacePath = getWorkspacePath();
const globalWorkspace = new Workspace({
  id: "mastra-global-workspace",
  name: "Mastra Global Workspace",
  filesystem: new LocalFilesystem({
    basePath: workspacePath,
    contained: true
    // 1.5 确保工作空间只能访问其目录内的文件
  }),
  // skills: ['./skills'], // 可根据需要添加全局技能
  sandbox: new LocalSandbox({
    workingDirectory: workspacePath
  })
});
const readOnlyWorkspace = new Workspace({
  id: "mastra-readonly-workspace",
  name: "Mastra ReadOnly Workspace",
  filesystem: new LocalFilesystem({
    basePath: workspacePath,
    contained: true
  }),
  // skills: ['./skills'], // 可根据需要添加全局技能
  tools: {
    // 禁用写入相关工具
    [WORKSPACE_TOOLS$1.FILESYSTEM.WRITE_FILE]: {
      enabled: false
    },
    [WORKSPACE_TOOLS$1.FILESYSTEM.EDIT_FILE]: {
      enabled: false
    },
    [WORKSPACE_TOOLS$1.FILESYSTEM.DELETE]: {
      enabled: false
    },
    [WORKSPACE_TOOLS$1.FILESYSTEM.MKDIR]: {
      enabled: false
    }
  }
});
await globalWorkspace.init();
await readOnlyWorkspace.init();
const frontendCodeGeneratorAgent = createFrontendCodeGeneratorAgent(readOnlyWorkspace);
const workspaceAgent = createWorkspaceAgent(globalWorkspace);
const mastra = new Mastra({
  agents: {
    frontendCodeGenerator: frontendCodeGeneratorAgent,
    workspace: workspaceAgent
  },
  workflows: {
    simple: simpleWorkflow
  },
  logger: new PinoLogger({
    name: "Mastra",
    level: "info"
  }),
  storage: new LibSQLStore({
    id: "mastra-storage",
    url: ":memory:"
    // Storage is required for tracing
  }),
  observability: new Observability({
    configs: {
      default: {
        serviceName: "mastra",
        exporters: [
          new DefaultExporter(),
          // Persists traces to storage for Mastra Studio
          new CloudExporter()
          // Sends traces to Mastra Cloud (if MASTRA_CLOUD_ACCESS_TOKEN is set)
        ],
        spanOutputProcessors: [
          new SensitiveDataFilter()
          // Redacts sensitive data like passwords, tokens, keys
        ]
      }
    }
  }),
  workspace: globalWorkspace
  // 2.1 在 Mastra 配置中添加 workspace 选项
});

function normalizeStudioBase(studioBase) {
  studioBase = studioBase.trim();
  if (studioBase.includes("..") || studioBase.includes("?") || studioBase.includes("#")) {
    throw new Error(`Invalid base path: "${studioBase}". Base path cannot contain '..', '?', or '#'`);
  }
  studioBase = studioBase.replace(/\/+/g, "/");
  if (studioBase === "/" || studioBase === "") {
    return "";
  }
  if (studioBase.endsWith("/")) {
    studioBase = studioBase.slice(0, -1);
  }
  if (!studioBase.startsWith("/")) {
    studioBase = `/${studioBase}`;
  }
  return studioBase;
}

// src/utils/mime.ts
var getMimeType = (filename, mimes = baseMimes) => {
  const regexp = /\.([a-zA-Z0-9]+?)$/;
  const match = filename.match(regexp);
  if (!match) {
    return;
  }
  let mimeType = mimes[match[1]];
  if (mimeType && mimeType.startsWith("text")) {
    mimeType += "; charset=utf-8";
  }
  return mimeType;
};
var _baseMimes = {
  aac: "audio/aac",
  avi: "video/x-msvideo",
  avif: "image/avif",
  av1: "video/av1",
  bin: "application/octet-stream",
  bmp: "image/bmp",
  css: "text/css",
  csv: "text/csv",
  eot: "application/vnd.ms-fontobject",
  epub: "application/epub+zip",
  gif: "image/gif",
  gz: "application/gzip",
  htm: "text/html",
  html: "text/html",
  ico: "image/x-icon",
  ics: "text/calendar",
  jpeg: "image/jpeg",
  jpg: "image/jpeg",
  js: "text/javascript",
  json: "application/json",
  jsonld: "application/ld+json",
  map: "application/json",
  mid: "audio/x-midi",
  midi: "audio/x-midi",
  mjs: "text/javascript",
  mp3: "audio/mpeg",
  mp4: "video/mp4",
  mpeg: "video/mpeg",
  oga: "audio/ogg",
  ogv: "video/ogg",
  ogx: "application/ogg",
  opus: "audio/opus",
  otf: "font/otf",
  pdf: "application/pdf",
  png: "image/png",
  rtf: "application/rtf",
  svg: "image/svg+xml",
  tif: "image/tiff",
  tiff: "image/tiff",
  ts: "video/mp2t",
  ttf: "font/ttf",
  txt: "text/plain",
  wasm: "application/wasm",
  webm: "video/webm",
  weba: "audio/webm",
  webmanifest: "application/manifest+json",
  webp: "image/webp",
  woff: "font/woff",
  woff2: "font/woff2",
  xhtml: "application/xhtml+xml",
  xml: "application/xml",
  zip: "application/zip",
  "3gp": "video/3gpp",
  "3g2": "video/3gpp2",
  gltf: "model/gltf+json",
  glb: "model/gltf-binary"
};
var baseMimes = _baseMimes;

// src/utils/html.ts
var HtmlEscapedCallbackPhase = {
  Stringify: 1};
var raw = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var escapeRe = /[&<>'"]/;
var stringBufferToString = async (buffer, callbacks) => {
  let str = "";
  callbacks ||= [];
  const resolvedBuffer = await Promise.all(buffer);
  for (let i = resolvedBuffer.length - 1; ; i--) {
    str += resolvedBuffer[i];
    i--;
    if (i < 0) {
      break;
    }
    let r = resolvedBuffer[i];
    if (typeof r === "object") {
      callbacks.push(...r.callbacks || []);
    }
    const isEscaped = r.isEscaped;
    r = await (typeof r === "object" ? r.toString() : r);
    if (typeof r === "object") {
      callbacks.push(...r.callbacks || []);
    }
    if (r.isEscaped ?? isEscaped) {
      str += r;
    } else {
      const buf = [str];
      escapeToBuffer(r, buf);
      str = buf[0];
    }
  }
  return raw(str, callbacks);
};
var escapeToBuffer = (str, buffer) => {
  const match = str.search(escapeRe);
  if (match === -1) {
    buffer[0] += str;
    return;
  }
  let escape;
  let index;
  let lastIndex = 0;
  for (index = match; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape = "&quot;";
        break;
      case 39:
        escape = "&#39;";
        break;
      case 38:
        escape = "&amp;";
        break;
      case 60:
        escape = "&lt;";
        break;
      case 62:
        escape = "&gt;";
        break;
      default:
        continue;
    }
    buffer[0] += str.substring(lastIndex, index) + escape;
    lastIndex = index + 1;
  }
  buffer[0] += str.substring(lastIndex, index);
};
var resolveCallbackSync = (str) => {
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return str;
  }
  const buffer = [str];
  const context = {};
  callbacks.forEach((c) => c({ phase: HtmlEscapedCallbackPhase.Stringify, buffer, context }));
  return buffer[0];
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))
    ).then(() => buffer[0])
  );
  {
    return resStr;
  }
};

// src/helper/html/index.ts
var html = (strings, ...values) => {
  const buffer = [""];
  for (let i = 0, len = strings.length - 1; i < len; i++) {
    buffer[0] += strings[i];
    const children = Array.isArray(values[i]) ? values[i].flat(Infinity) : [values[i]];
    for (let i2 = 0, len2 = children.length; i2 < len2; i2++) {
      const child = children[i2];
      if (typeof child === "string") {
        escapeToBuffer(child, buffer);
      } else if (typeof child === "number") {
        buffer[0] += child;
      } else if (typeof child === "boolean" || child === null || child === void 0) {
        continue;
      } else if (typeof child === "object" && child.isEscaped) {
        if (child.callbacks) {
          buffer.unshift("", child);
        } else {
          const tmp = child.toString();
          if (tmp instanceof Promise) {
            buffer.unshift("", tmp);
          } else {
            buffer[0] += tmp;
          }
        }
      } else if (child instanceof Promise) {
        buffer.unshift("", child);
      } else {
        escapeToBuffer(child.toString(), buffer);
      }
    }
  }
  buffer[0] += strings.at(-1);
  return buffer.length === 1 ? "callbacks" in buffer ? raw(resolveCallbackSync(raw(buffer[0], buffer.callbacks))) : raw(buffer[0]) : stringBufferToString(buffer, buffer.callbacks);
};

// src/server/http-exception.ts
var HTTPException$2 = class HTTPException extends Error {
  res;
  status;
  /**
   * Creates an instance of `HTTPException`.
   * @param status - HTTP status code for the exception. Defaults to 500.
   * @param options - Additional options for the exception.
   */
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
    this.stack = options?.stack || this.stack;
  }
  /**
   * Returns the response object associated with the exception.
   * If a response object is not provided, a new response is created with the error message and status code.
   * @returns The response object.
   */
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// src/server/handlers/error.ts
function formatZodError(error, context) {
  const issues = error.issues.map((e) => ({
    field: e.path.length > 0 ? e.path.join(".") : "root",
    message: e.message
  }));
  return {
    error: `Invalid ${context}`,
    issues
  };
}
function handleError$1(error, defaultMessage) {
  const apiError = error;
  const apiErrorStatus = apiError.status || apiError.details?.status || 500;
  throw new HTTPException$2(apiErrorStatus, {
    message: apiError.message || defaultMessage,
    stack: apiError.stack,
    cause: apiError.cause
  });
}

// src/server/schemas/default-options.ts
var defaultOptionsSchema = z.object({
  /** Unique identifier for this execution run */
  runId: z.string().optional(),
  /** Save messages incrementally after each stream step completes (default: false) */
  savePerStep: z.boolean().optional(),
  /** Maximum number of steps to run */
  maxSteps: z.number().optional(),
  /** Provider-specific options passed to the language model */
  /** Tools that are active for this execution (stored as tool IDs) */
  activeTools: z.array(z.string()).optional(),
  /** Maximum number of times processors can trigger a retry */
  maxProcessorRetries: z.number().optional(),
  /** Tool selection strategy: 'auto', 'none', 'required', or specific tools */
  toolChoice: z.union([
    z.literal("auto"),
    z.literal("none"),
    z.literal("required"),
    z.object({ type: z.literal("tool"), toolName: z.string() })
  ]).optional(),
  /** Model-specific settings like temperature, maxTokens, topP, etc. */
  modelSettings: z.object({
    temperature: z.number().optional(),
    maxTokens: z.number().optional(),
    topP: z.number().optional(),
    topK: z.number().optional(),
    frequencyPenalty: z.number().optional(),
    presencePenalty: z.number().optional(),
    stopSequences: z.array(z.string()).optional(),
    seed: z.number().optional(),
    maxRetries: z.number().optional()
  }).optional(),
  /** Whether to return detailed scoring data in the response */
  returnScorerData: z.boolean().optional(),
  /** Tracing options for starting new traces */
  tracingOptions: z.object({
    traceName: z.string().optional(),
    attributes: z.record(z.string(), z.unknown()).optional(),
    spanId: z.string().optional(),
    traceId: z.string().optional()
  }).optional(),
  /** Require approval for all tool calls */
  requireToolApproval: z.boolean().optional(),
  /** Automatically resume suspended tools */
  autoResumeSuspendedTools: z.boolean().optional(),
  /** Maximum number of tool calls to execute concurrently */
  toolCallConcurrency: z.number().optional(),
  /** Whether to include raw chunks in the stream output */
  includeRawChunks: z.boolean().optional()
}).passthrough().describe("Default options for agent execution");

// src/server/schemas/common.ts
var runIdSchema = z$1.object({
  runId: z$1.string().describe("Unique identifier for the run")
});
var optionalRunIdSchema = z$1.object({
  runId: z$1.string().optional()
});
var paginationInfoSchema = z$1.object({
  total: z$1.number(),
  page: z$1.number(),
  perPage: z$1.union([z$1.number(), z$1.literal(false)]),
  hasMore: z$1.boolean()
});
var createPagePaginationSchema = (defaultPerPage) => {
  const baseSchema = {
    page: z$1.coerce.number().optional().default(0)
  };
  if (defaultPerPage !== void 0) {
    return z$1.object({
      ...baseSchema,
      perPage: z$1.coerce.number().optional().default(defaultPerPage)
    });
  } else {
    return z$1.object({
      ...baseSchema,
      perPage: z$1.coerce.number().optional()
    });
  }
};
var createCombinedPaginationSchema = () => {
  return z$1.object({
    page: z$1.coerce.number().optional(),
    perPage: z$1.coerce.number().optional(),
    /**
     * @deprecated Use page and perPage instead
     */
    offset: z$1.coerce.number().optional(),
    /**
     * @deprecated Use page and perPage instead
     */
    limit: z$1.coerce.number().optional()
  });
};
var tracingOptionsSchema = z$1.object({
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional(),
  requestContextKeys: z$1.array(z$1.string()).optional(),
  traceId: z$1.string().optional(),
  parentSpanId: z$1.string().optional()
});
var coreMessageSchema = z$1.any();
var successResponseSchema = z$1.object({
  success: z$1.boolean()
});
var messageResponseSchema = z$1.object({
  message: z$1.string()
});
z$1.object({
  partial: z$1.string().optional()
});
var baseLogMessageSchema = z$1.object({
  level: z$1.enum(["debug", "info", "warn", "error", "silent"]),
  msg: z$1.string(),
  time: z$1.date(),
  context: z$1.record(z$1.string(), z$1.unknown()).optional(),
  runId: z$1.string().optional(),
  pid: z$1.number(),
  hostname: z$1.string(),
  name: z$1.string()
});

var semanticRecallSchema = z$1.object({
  topK: z$1.number().describe("Number of semantically similar messages to retrieve"),
  messageRange: z$1.union([
    z$1.number(),
    z$1.object({
      before: z$1.number(),
      after: z$1.number()
    })
  ]).describe("Amount of surrounding context to include with each retrieved message"),
  scope: z$1.enum(["thread", "resource"]).optional().describe("Scope for semantic search queries"),
  threshold: z$1.number().min(0).max(1).optional().describe("Minimum similarity score threshold"),
  indexName: z$1.string().optional().describe("Index name for the vector store")
});
var titleGenerationSchema = z$1.union([
  z$1.boolean(),
  z$1.object({
    model: z$1.string().describe("Model ID in format provider/model-name (ModelRouterModelId)"),
    instructions: z$1.string().optional().describe("Custom instructions for title generation")
  })
]);
var serializedObservationConfigSchema = z$1.object({
  model: z$1.string().optional().describe("Observer model ID"),
  messageTokens: z$1.number().optional().describe("Token threshold that triggers observation"),
  modelSettings: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Model settings (temperature, etc.)"),
  providerOptions: z$1.record(z$1.string(), z$1.record(z$1.string(), z$1.unknown()).optional()).optional().describe("Provider-specific options"),
  maxTokensPerBatch: z$1.number().optional().describe("Maximum tokens per batch"),
  bufferTokens: z$1.union([z$1.number(), z$1.literal(false)]).optional().describe("Async buffering interval or false"),
  bufferActivation: z$1.number().optional().describe("Ratio of buffered observations to activate"),
  blockAfter: z$1.number().optional().describe("Token threshold for synchronous blocking")
});
var serializedReflectionConfigSchema = z$1.object({
  model: z$1.string().optional().describe("Reflector model ID"),
  observationTokens: z$1.number().optional().describe("Token threshold that triggers reflection"),
  modelSettings: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Model settings (temperature, etc.)"),
  providerOptions: z$1.record(z$1.string(), z$1.record(z$1.string(), z$1.unknown()).optional()).optional().describe("Provider-specific options"),
  blockAfter: z$1.number().optional().describe("Token threshold for synchronous blocking"),
  bufferActivation: z$1.number().optional().describe("Ratio for async reflection buffering")
});
var serializedObservationalMemoryConfigObjectSchema = z$1.object({
  model: z$1.string().optional().describe("Model ID for both Observer and Reflector"),
  scope: z$1.enum(["resource", "thread"]).optional().describe("Memory scope"),
  shareTokenBudget: z$1.boolean().optional().describe("Share token budget between messages and observations"),
  observation: serializedObservationConfigSchema.optional().describe("Observation step configuration"),
  reflection: serializedReflectionConfigSchema.optional().describe("Reflection step configuration")
});
var serializedObservationalMemoryConfigSchema = z$1.union([
  z$1.boolean(),
  serializedObservationalMemoryConfigObjectSchema
]);
var serializedMemoryConfigSchema = z$1.object({
  vector: z$1.union([z$1.string(), z$1.literal(false)]).optional().describe("Vector database identifier or false to disable"),
  options: z$1.object({
    readOnly: z$1.boolean().optional(),
    lastMessages: z$1.union([z$1.number(), z$1.literal(false)]).optional(),
    semanticRecall: z$1.union([z$1.boolean(), semanticRecallSchema]).optional(),
    generateTitle: titleGenerationSchema.optional()
  }).optional().describe("Memory behavior configuration, excluding workingMemory and threads"),
  embedder: z$1.string().optional().describe('Embedding model ID in the format "provider/model" (e.g., "openai/text-embedding-3-small")'),
  embedderOptions: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Options to pass to the embedder, omitting telemetry"),
  observationalMemory: serializedObservationalMemoryConfigSchema.optional().describe("Serialized observational memory configuration")
}).refine(
  (data) => {
    const semanticRecall = data.options?.semanticRecall;
    const semanticRecallEnabled = semanticRecall === true || typeof semanticRecall === "object" && semanticRecall !== null;
    if (semanticRecallEnabled) {
      const hasVector = typeof data.vector === "string" && data.vector.length > 0;
      const hasEmbedder = typeof data.embedder === "string" && data.embedder.length > 0;
      return hasVector && hasEmbedder;
    }
    return true;
  },
  {
    message: "Semantic recall requires both vector and embedder to be configured",
    path: ["options", "semanticRecall"]
  }
);

// src/server/schemas/stored-agents.ts
var storedAgentIdPathParams = z$1.object({
  storedAgentId: z$1.string().describe("Unique identifier for the stored agent")
});
var storageOrderBySchema$3 = z$1.object({
  field: z$1.enum(["createdAt", "updatedAt"]).optional(),
  direction: z$1.enum(["ASC", "DESC"]).optional()
});
var listStoredAgentsQuerySchema = createPagePaginationSchema(100).extend({
  orderBy: storageOrderBySchema$3.optional(),
  authorId: z$1.string().optional().describe("Filter agents by author identifier"),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Filter agents by metadata key-value pairs")
});
var scorerConfigSchema = z$1.object({
  sampling: z$1.union([
    z$1.object({ type: z$1.literal("none") }),
    z$1.object({ type: z$1.literal("ratio"), rate: z$1.number().min(0).max(1) })
  ]).optional()
});
var ruleSchema = z$1.object({
  field: z$1.string(),
  operator: z$1.enum([
    "equals",
    "not_equals",
    "contains",
    "not_contains",
    "greater_than",
    "less_than",
    "greater_than_or_equal",
    "less_than_or_equal",
    "in",
    "not_in",
    "exists",
    "not_exists"
  ]),
  value: z$1.unknown()
});
var ruleGroupDepth2 = z$1.object({
  operator: z$1.enum(["AND", "OR"]),
  conditions: z$1.array(ruleSchema)
});
var ruleGroupDepth1 = z$1.object({
  operator: z$1.enum(["AND", "OR"]),
  conditions: z$1.array(z$1.union([ruleSchema, ruleGroupDepth2]))
});
var ruleGroupSchema = z$1.object({
  operator: z$1.enum(["AND", "OR"]),
  conditions: z$1.array(z$1.union([ruleSchema, ruleGroupDepth1]))
});
var agentInstructionBlockSchema = z$1.discriminatedUnion("type", [
  z$1.object({ type: z$1.literal("text"), content: z$1.string() }),
  z$1.object({ type: z$1.literal("prompt_block_ref"), id: z$1.string() }),
  z$1.object({ type: z$1.literal("prompt_block"), content: z$1.string(), rules: ruleGroupSchema.optional() })
]);
function conditionalFieldSchema(valueSchema) {
  const variantSchema = z$1.object({
    value: valueSchema,
    rules: ruleGroupSchema.optional()
  });
  return z$1.union([valueSchema, z$1.array(variantSchema)]);
}
var instructionsSchema = z$1.union([z$1.string(), z$1.array(agentInstructionBlockSchema)]).describe("System instructions for the agent (string or array of instruction blocks)");
var modelConfigSchema$2 = z$1.object({
  provider: z$1.string().describe("Model provider (e.g., openai, anthropic)"),
  name: z$1.string().describe("Model name (e.g., gpt-4o, claude-3-opus)")
}).passthrough();
var toolsConfigSchema = z$1.record(z$1.string(), z$1.object({ description: z$1.string().optional() }));
var mcpClientToolsConfigSchema$1 = z$1.object({
  tools: z$1.record(z$1.string(), z$1.object({ description: z$1.string().optional() })).optional()
});
var snapshotConfigSchema$2 = z$1.object({
  name: z$1.string().describe("Name of the agent"),
  description: z$1.string().optional().describe("Description of the agent"),
  instructions: instructionsSchema,
  model: conditionalFieldSchema(modelConfigSchema$2).describe(
    "Model configuration \u2014 static value or array of conditional variants"
  ),
  tools: conditionalFieldSchema(toolsConfigSchema).optional().describe("Tool keys mapped to per-tool config \u2014 static or conditional"),
  defaultOptions: conditionalFieldSchema(defaultOptionsSchema).optional().describe("Default options for generate/stream calls \u2014 static or conditional"),
  workflows: conditionalFieldSchema(z$1.array(z$1.string())).optional().describe("Array of workflow keys \u2014 static or conditional"),
  agents: conditionalFieldSchema(z$1.array(z$1.string())).optional().describe("Array of agent keys \u2014 static or conditional"),
  integrationTools: conditionalFieldSchema(z$1.record(z$1.string(), mcpClientToolsConfigSchema$1)).optional().describe("Map of tool provider IDs to their tool configurations \u2014 static or conditional"),
  mcpClients: conditionalFieldSchema(z$1.record(z$1.string(), mcpClientToolsConfigSchema$1)).optional().describe("Map of stored MCP client IDs to their tool configurations \u2014 static or conditional"),
  inputProcessors: conditionalFieldSchema(z$1.array(z$1.string())).optional().describe("Array of processor keys \u2014 static or conditional"),
  outputProcessors: conditionalFieldSchema(z$1.array(z$1.string())).optional().describe("Array of processor keys \u2014 static or conditional"),
  memory: conditionalFieldSchema(serializedMemoryConfigSchema).optional().describe("Memory configuration \u2014 static or conditional"),
  scorers: conditionalFieldSchema(z$1.record(z$1.string(), scorerConfigSchema)).optional().describe("Scorer keys with optional sampling config \u2014 static or conditional"),
  requestContextSchema: z$1.record(z$1.string(), z$1.unknown()).optional().describe("JSON Schema defining valid request context variables for conditional rule evaluation")
});
var agentMetadataSchema = z$1.object({
  authorId: z$1.string().optional().describe("Author identifier for multi-tenant filtering"),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Additional metadata for the agent")
});
var createStoredAgentBodySchema = z$1.object({
  id: z$1.string().optional().describe("Unique identifier for the agent. If not provided, derived from name."),
  authorId: z$1.string().optional().describe("Author identifier for multi-tenant filtering"),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Additional metadata for the agent")
}).merge(snapshotConfigSchema$2);
var snapshotConfigUpdateSchema = snapshotConfigSchema$2.extend({
  memory: z$1.union([conditionalFieldSchema(serializedMemoryConfigSchema), z$1.null()]).optional().describe("Memory configuration \u2014 static, conditional, or null to disable memory")
});
var updateStoredAgentBodySchema = agentMetadataSchema.partial().merge(snapshotConfigUpdateSchema.partial());
var storedAgentSchema = z$1.object({
  // Thin agent record fields
  id: z$1.string(),
  status: z$1.string().describe("Agent status: draft or published"),
  activeVersionId: z$1.string().optional(),
  authorId: z$1.string().optional(),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional(),
  createdAt: z$1.coerce.date(),
  updatedAt: z$1.coerce.date(),
  // Version snapshot config fields (resolved from active version)
  name: z$1.string().describe("Name of the agent"),
  description: z$1.string().optional().describe("Description of the agent"),
  instructions: instructionsSchema,
  model: conditionalFieldSchema(modelConfigSchema$2).describe(
    "Model configuration \u2014 static value or array of conditional variants"
  ),
  tools: conditionalFieldSchema(toolsConfigSchema).optional().describe("Tool keys mapped to per-tool config \u2014 static or conditional"),
  defaultOptions: conditionalFieldSchema(defaultOptionsSchema).optional().describe("Default options for generate/stream calls \u2014 static or conditional"),
  workflows: conditionalFieldSchema(z$1.array(z$1.string())).optional().describe("Array of workflow keys \u2014 static or conditional"),
  agents: conditionalFieldSchema(z$1.array(z$1.string())).optional().describe("Array of agent keys \u2014 static or conditional"),
  integrationTools: conditionalFieldSchema(z$1.record(z$1.string(), mcpClientToolsConfigSchema$1)).optional().describe("Map of tool provider IDs to their tool configurations \u2014 static or conditional"),
  mcpClients: conditionalFieldSchema(z$1.record(z$1.string(), mcpClientToolsConfigSchema$1)).optional().describe("Map of stored MCP client IDs to their tool configurations \u2014 static or conditional"),
  inputProcessors: conditionalFieldSchema(z$1.array(z$1.string())).optional().describe("Array of processor keys \u2014 static or conditional"),
  outputProcessors: conditionalFieldSchema(z$1.array(z$1.string())).optional().describe("Array of processor keys \u2014 static or conditional"),
  memory: conditionalFieldSchema(serializedMemoryConfigSchema).optional().describe("Memory configuration \u2014 static or conditional"),
  scorers: conditionalFieldSchema(z$1.record(z$1.string(), scorerConfigSchema)).optional().describe("Scorer keys with optional sampling config \u2014 static or conditional"),
  requestContextSchema: z$1.record(z$1.string(), z$1.unknown()).optional().describe("JSON Schema defining valid request context variables")
});
var listStoredAgentsResponseSchema = paginationInfoSchema.extend({
  agents: z$1.array(storedAgentSchema)
});
var getStoredAgentResponseSchema = storedAgentSchema;
var createStoredAgentResponseSchema = storedAgentSchema;
var updateStoredAgentResponseSchema = z$1.union([
  // Thin agent record (no version config)
  z$1.object({
    id: z$1.string(),
    status: z$1.string(),
    activeVersionId: z$1.string().optional(),
    authorId: z$1.string().optional(),
    metadata: z$1.record(z$1.string(), z$1.unknown()).optional(),
    createdAt: z$1.coerce.date(),
    updatedAt: z$1.coerce.date()
  }),
  // Resolved agent (thin record + version config)
  storedAgentSchema
]);
var deleteStoredAgentResponseSchema = z$1.object({
  success: z$1.boolean(),
  message: z$1.string()
});
var previewInstructionsBodySchema = z$1.object({
  blocks: z$1.array(agentInstructionBlockSchema).describe("Array of instruction blocks to resolve"),
  context: z$1.record(z$1.string(), z$1.unknown()).optional().default({}).describe("Request context for variable interpolation and rule evaluation")
});
var previewInstructionsResponseSchema = z$1.object({
  result: z$1.string().describe("The resolved instructions string")
});

// src/server/server-adapter/openapi-utils.ts
function generateRouteOpenAPI({
  method,
  path,
  summary,
  description,
  tags = [],
  pathParamSchema,
  queryParamSchema,
  bodySchema,
  responseSchema,
  deprecated
}) {
  const route = {
    summary: summary || `${method} ${path}`,
    description,
    tags,
    deprecated,
    responses: {
      200: {
        description: "Successful response"
      }
    }
  };
  if (pathParamSchema || queryParamSchema) {
    route.requestParams = {};
    if (pathParamSchema) {
      route.requestParams.path = pathParamSchema;
    }
    if (queryParamSchema) {
      route.requestParams.query = queryParamSchema;
    }
  }
  if (bodySchema) {
    route.requestBody = {
      content: {
        "application/json": {
          schema: bodySchema
        }
      }
    };
  }
  if (responseSchema) {
    route.responses[200] = {
      description: "Successful response",
      content: {
        "application/json": {
          schema: responseSchema
        }
      }
    };
  }
  return route;
}
function convertZodToJsonSchema(spec) {
  const converted = {
    summary: spec.summary,
    description: spec.description,
    tags: spec.tags,
    responses: {}
  };
  const parameters = [];
  if (spec.requestParams?.path) {
    const pathSchema = zodToJsonSchema$1(spec.requestParams.path, "openApi3", "none");
    const properties = pathSchema.properties || {};
    Object.entries(properties).forEach(([name, schema]) => {
      parameters.push({
        name,
        in: "path",
        required: true,
        description: schema.description || `The ${name} parameter`,
        schema
      });
    });
  }
  if (spec.requestParams?.query) {
    const querySchema = zodToJsonSchema$1(spec.requestParams.query, "openApi3", "none");
    const properties = querySchema.properties || {};
    const required = querySchema.required || [];
    Object.entries(properties).forEach(([name, schema]) => {
      parameters.push({
        name,
        in: "query",
        required: required.includes(name),
        description: schema.description || `Query parameter: ${name}`,
        schema
      });
    });
  }
  if (parameters.length > 0) {
    converted.parameters = parameters;
  }
  if (spec.requestBody?.content?.["application/json"]?.schema) {
    converted.requestBody = {
      required: true,
      content: {
        "application/json": {
          schema: zodToJsonSchema$1(spec.requestBody.content["application/json"].schema, "openApi3", "none")
        }
      }
    };
  }
  Object.entries(spec.responses).forEach(([statusCode, response]) => {
    converted.responses[statusCode] = {
      description: response.description
    };
    if (response.content?.["application/json"]?.schema) {
      converted.responses[statusCode].content = {
        "application/json": {
          schema: zodToJsonSchema$1(response.content["application/json"].schema, "openApi3", "none")
        }
      };
    }
  });
  return converted;
}
function generateOpenAPIDocument(routes, info) {
  const paths = {};
  routes.forEach((route) => {
    if (!route.openapi) return;
    const openapiPath = route.path.replace(/:(\w+)/g, "{$1}");
    if (!paths[openapiPath]) {
      paths[openapiPath] = {};
    }
    paths[openapiPath][route.method.toLowerCase()] = convertZodToJsonSchema(route.openapi);
  });
  return {
    openapi: "3.1.0",
    info: {
      title: info.title,
      version: info.version,
      description: info.description
    },
    paths
  };
}
function convertCustomRoutesToOpenAPIPaths(routes) {
  const paths = {};
  for (const route of routes) {
    if (!route.openapi || route.openapi.hide) {
      continue;
    }
    if (route.method === "ALL") {
      continue;
    }
    const openapiPath = route.path.replace(/:(\w+)/g, "{$1}");
    if (!paths[openapiPath]) {
      paths[openapiPath] = {};
    }
    const method = route.method.toLowerCase();
    const openapi = route.openapi;
    const operation = {
      summary: openapi.summary || `${route.method} ${route.path}`,
      description: openapi.description,
      tags: openapi.tags || ["custom"],
      deprecated: openapi.deprecated,
      externalDocs: openapi.externalDocs,
      security: openapi.security,
      servers: openapi.servers
    };
    if (openapi.parameters && Array.isArray(openapi.parameters)) {
      operation.parameters = openapi.parameters.map((param) => {
        if (param.schema && typeof param.schema === "object" && "_def" in param.schema) {
          return {
            ...param,
            schema: zodToJsonSchema$1(param.schema, "openApi3", "none")
          };
        }
        return param;
      });
    }
    if (openapi.requestBody) {
      const requestBody = openapi.requestBody;
      operation.requestBody = { ...requestBody };
      if (requestBody.content) {
        operation.requestBody.content = {};
        for (const [mediaType, mediaContent] of Object.entries(requestBody.content)) {
          if (mediaContent?.schema && typeof mediaContent.schema === "object" && "_def" in mediaContent.schema) {
            operation.requestBody.content[mediaType] = {
              ...mediaContent,
              schema: zodToJsonSchema$1(mediaContent.schema, "openApi3", "none")
            };
          } else {
            operation.requestBody.content[mediaType] = mediaContent;
          }
        }
      }
    }
    if (openapi.responses) {
      operation.responses = {};
      for (const [statusCode, response] of Object.entries(openapi.responses)) {
        if (!response) continue;
        if ("$ref" in response) {
          operation.responses[statusCode] = response;
          continue;
        }
        operation.responses[statusCode] = { ...response };
        if (response.content) {
          operation.responses[statusCode].content = {};
          for (const [mediaType, mediaContent] of Object.entries(response.content)) {
            if (mediaContent?.schema && typeof mediaContent.schema === "object" && "_def" in mediaContent.schema) {
              operation.responses[statusCode].content[mediaType] = {
                ...mediaContent,
                schema: zodToJsonSchema$1(mediaContent.schema, "openApi3", "none")
              };
            } else {
              operation.responses[statusCode].content[mediaType] = mediaContent;
            }
          }
        }
      }
    } else {
      operation.responses = {
        200: {
          description: "Successful response"
        }
      };
    }
    Object.keys(operation).forEach((key) => {
      if (operation[key] === void 0) {
        delete operation[key];
      }
    });
    paths[openapiPath][method] = operation;
  }
  return paths;
}
function pickParams(schema, params) {
  const keys = Object.keys(schema.shape);
  const result = {};
  for (const key of keys) {
    if (key in params) {
      result[key] = params[key];
    }
  }
  return result;
}
function jsonQueryParam(schema) {
  return z.union([
    schema,
    // Already the expected type (non-string input)
    z.string().transform((val, ctx) => {
      try {
        const parsed = JSON.parse(val);
        const result = schema.safeParse(parsed);
        if (!result.success) {
          for (const issue of result.error.issues) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: issue.message,
              path: issue.path
            });
          }
          return z.NEVER;
        }
        return result.data;
      } catch (e) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Invalid JSON: ${e instanceof Error ? e.message : "parse error"}`
        });
        return z.NEVER;
      }
    })
  ]);
}
function getZodTypeName(schema) {
  return schema?._def?.typeName;
}
function isComplexType(schema) {
  let inner = schema;
  let typeName = getZodTypeName(inner);
  while (typeName === "ZodOptional" || typeName === "ZodNullable") {
    inner = inner._def.innerType;
    typeName = getZodTypeName(inner);
  }
  return typeName === "ZodArray" || typeName === "ZodRecord" || typeName === "ZodObject";
}
function wrapSchemaForQueryParams(schema) {
  const newShape = {};
  for (const [key, fieldSchema] of Object.entries(schema.shape)) {
    if (isComplexType(fieldSchema)) {
      newShape[key] = jsonQueryParam(fieldSchema);
    } else {
      newShape[key] = fieldSchema;
    }
  }
  return z.object(newShape);
}
function createRoute(config) {
  const { summary, description, tags, deprecated, requiresAuth, ...baseRoute } = config;
  const openapi = config.method !== "ALL" ? generateRouteOpenAPI({
    method: config.method,
    path: config.path,
    summary,
    description,
    tags,
    pathParamSchema: config.pathParamSchema,
    queryParamSchema: config.queryParamSchema,
    bodySchema: config.bodySchema,
    responseSchema: config.responseSchema,
    deprecated
  }) : void 0;
  return {
    ...baseRoute,
    openapi,
    deprecated,
    requiresAuth
  };
}

var mcpClientToolsConfigSchema = z$1.object({
  tools: z$1.record(z$1.string(), z$1.object({ description: z$1.string().optional() })).optional()
});
var agentVersionPathParams = z$1.object({
  agentId: z$1.string().describe("Unique identifier for the stored agent")
});
var versionIdPathParams = z$1.object({
  agentId: z$1.string().describe("Unique identifier for the stored agent"),
  versionId: z$1.string().describe("Unique identifier for the version (UUID)")
});
var versionOrderBySchema = z$1.object({
  field: z$1.enum(["versionNumber", "createdAt"]).optional(),
  direction: z$1.enum(["ASC", "DESC"]).optional()
});
var listVersionsQuerySchema = createPagePaginationSchema(20).extend({
  orderBy: versionOrderBySchema.optional()
});
var compareVersionsQuerySchema = z$1.object({
  from: z$1.string().describe("Version ID (UUID) to compare from"),
  to: z$1.string().describe("Version ID (UUID) to compare to")
});
var createVersionBodySchema = z$1.object({
  changeMessage: z$1.string().max(500).optional().describe("Optional message describing the changes")
});
var agentVersionSchema = z$1.object({
  id: z$1.string().describe("Unique identifier for the version (UUID)"),
  agentId: z$1.string().describe("ID of the agent this version belongs to"),
  versionNumber: z$1.number().describe("Sequential version number (1, 2, 3, ...)"),
  // Top-level config fields (from StorageAgentSnapshotType)
  name: z$1.string().describe("Name of the agent"),
  description: z$1.string().optional().describe("Description of the agent"),
  instructions: instructionsSchema,
  model: conditionalFieldSchema(modelConfigSchema$2).describe(
    "Model configuration \u2014 static value or array of conditional variants"
  ),
  tools: conditionalFieldSchema(toolsConfigSchema).optional().describe("Tool keys mapped to per-tool config \u2014 static or conditional"),
  defaultOptions: conditionalFieldSchema(defaultOptionsSchema).optional().describe("Default options for generate/stream calls \u2014 static or conditional"),
  workflows: conditionalFieldSchema(z$1.array(z$1.string())).optional().describe("Array of workflow keys \u2014 static or conditional"),
  agents: conditionalFieldSchema(z$1.array(z$1.string())).optional().describe("Array of agent keys \u2014 static or conditional"),
  integrationTools: conditionalFieldSchema(z$1.record(z$1.string(), mcpClientToolsConfigSchema)).optional().describe("Map of tool provider IDs to their tool configurations \u2014 static or conditional"),
  mcpClients: conditionalFieldSchema(z$1.record(z$1.string(), mcpClientToolsConfigSchema)).optional().describe("Map of stored MCP client IDs to their tool configurations \u2014 static or conditional"),
  inputProcessors: conditionalFieldSchema(z$1.array(z$1.string())).optional().describe("Array of processor keys \u2014 static or conditional"),
  outputProcessors: conditionalFieldSchema(z$1.array(z$1.string())).optional().describe("Array of processor keys \u2014 static or conditional"),
  memory: conditionalFieldSchema(serializedMemoryConfigSchema).optional().describe("Memory configuration \u2014 static or conditional"),
  scorers: conditionalFieldSchema(z$1.record(z$1.string(), scorerConfigSchema)).optional().describe("Scorer keys with optional sampling config \u2014 static or conditional"),
  requestContextSchema: z$1.record(z$1.string(), z$1.unknown()).optional().describe("JSON Schema defining valid request context variables"),
  // Version metadata fields
  changedFields: z$1.array(z$1.string()).optional().describe("Array of field names that changed from the previous version"),
  changeMessage: z$1.string().optional().describe("Optional message describing the changes"),
  createdAt: z$1.coerce.date().describe("When this version was created")
});
var listVersionsResponseSchema = paginationInfoSchema.extend({
  versions: z$1.array(agentVersionSchema)
});
var getVersionResponseSchema = agentVersionSchema;
var createVersionResponseSchema = agentVersionSchema.partial().merge(
  z$1.object({
    // These fields are always present in a version response
    id: z$1.string().describe("Unique identifier for the version (UUID)"),
    agentId: z$1.string().describe("ID of the agent this version belongs to"),
    versionNumber: z$1.number().describe("Sequential version number (1, 2, 3, ...)"),
    createdAt: z$1.coerce.date().describe("When this version was created")
  })
);
var activateVersionResponseSchema = z$1.object({
  success: z$1.boolean(),
  message: z$1.string(),
  activeVersionId: z$1.string()
});
var restoreVersionResponseSchema = agentVersionSchema.describe(
  "The newly created version from the restored configuration"
);
var deleteVersionResponseSchema = z$1.object({
  success: z$1.boolean(),
  message: z$1.string()
});
var versionDiffEntrySchema = z$1.object({
  field: z$1.string().describe("The field path that changed"),
  previousValue: z$1.unknown().describe('The value in the "from" version'),
  currentValue: z$1.unknown().describe('The value in the "to" version')
});
var compareVersionsResponseSchema = z$1.object({
  diffs: z$1.array(versionDiffEntrySchema).describe("List of differences between versions"),
  fromVersion: agentVersionSchema.describe("The source version"),
  toVersion: agentVersionSchema.describe("The target version")
});

// src/server/handlers/agent-versions.ts
var DEFAULT_MAX_VERSIONS_PER_AGENT = 50;
var SNAPSHOT_CONFIG_FIELDS = [
  "name",
  "description",
  "instructions",
  "model",
  "tools",
  "defaultOptions",
  "workflows",
  "agents",
  "integrationTools",
  "inputProcessors",
  "outputProcessors",
  "memory",
  "scorers",
  "requestContextSchema"
];
function deepEqual$1(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return a === b;
  if (typeof a !== typeof b) return false;
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    return a.every((item, index) => deepEqual$1(item, b[index]));
  }
  if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  }
  if (typeof a === "object" && typeof b === "object") {
    const aObj = a;
    const bObj = b;
    const aKeys = Object.keys(aObj);
    const bKeys = Object.keys(bObj);
    if (aKeys.length !== bKeys.length) return false;
    return aKeys.every((key) => Object.prototype.hasOwnProperty.call(bObj, key) && deepEqual$1(aObj[key], bObj[key]));
  }
  return false;
}
function generateVersionId() {
  return crypto.randomUUID();
}
function extractConfigFromVersion(version) {
  const config = {};
  for (const field of SNAPSHOT_CONFIG_FIELDS) {
    if (field in version) {
      config[field] = version[field];
    }
  }
  return config;
}
function calculateChangedFields(previous, current) {
  if (!previous) {
    return Object.keys(current);
  }
  const changedFields = [];
  const allKeys = /* @__PURE__ */ new Set([...Object.keys(previous), ...Object.keys(current)]);
  for (const key of allKeys) {
    if (key === "updatedAt" || key === "createdAt") {
      continue;
    }
    const prevValue = previous[key];
    const currValue = current[key];
    if (!deepEqual$1(prevValue, currValue)) {
      changedFields.push(key);
    }
  }
  return changedFields;
}
function computeVersionDiffs(fromConfig, toConfig) {
  const diffs = [];
  const allKeys = /* @__PURE__ */ new Set([...Object.keys(fromConfig), ...Object.keys(toConfig)]);
  for (const key of allKeys) {
    if (key === "updatedAt" || key === "createdAt") {
      continue;
    }
    const prevValue = fromConfig[key];
    const currValue = toConfig[key];
    if (!deepEqual$1(prevValue, currValue)) {
      diffs.push({
        field: key,
        previousValue: prevValue,
        currentValue: currValue
      });
    }
  }
  return diffs;
}
async function enforceRetentionLimit(agentsStore, agentId, activeVersionId, maxVersions = DEFAULT_MAX_VERSIONS_PER_AGENT) {
  const { total } = await agentsStore.listVersions({ agentId, perPage: 1 });
  if (total <= maxVersions) {
    return { deletedCount: 0 };
  }
  const versionsToDelete = total - maxVersions;
  const { versions: oldestVersions } = await agentsStore.listVersions({
    agentId,
    perPage: versionsToDelete + 1,
    // Get one extra in case we need to skip the active version
    orderBy: { field: "versionNumber", direction: "ASC" }
  });
  let deletedCount = 0;
  for (const version of oldestVersions) {
    if (deletedCount >= versionsToDelete) {
      break;
    }
    if (version.id === activeVersionId) {
      continue;
    }
    await agentsStore.deleteVersion(version.id);
    deletedCount++;
  }
  return { deletedCount };
}
function isVersionNumberConflictError(error) {
  if (error instanceof Error) {
    const message = error.message.toLowerCase();
    return message.includes("unique") && message.includes("constraint") || message.includes("duplicate key") || message.includes("unique_violation") || message.includes("sqlite_constraint_unique") || message.includes("versionnumber");
  }
  return false;
}
async function createVersionWithRetry(agentsStore, agentId, snapshotConfig, changedFields, options = {}) {
  const { changeMessage, maxRetries = 3 } = options;
  let lastError;
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const latestVersion = await agentsStore.getLatestVersion(agentId);
      const versionNumber = latestVersion ? latestVersion.versionNumber + 1 : 1;
      const versionId = generateVersionId();
      await agentsStore.createVersion({
        ...snapshotConfig,
        id: versionId,
        agentId,
        versionNumber,
        changedFields,
        changeMessage
      });
      return { versionId, versionNumber };
    } catch (error) {
      lastError = error;
      if (isVersionNumberConflictError(error) && attempt < maxRetries - 1) {
        await new Promise((resolve) => setTimeout(resolve, 10 * (attempt + 1)));
        continue;
      }
      throw error;
    }
  }
  throw lastError;
}
async function handleAutoVersioning(agentsStore, agentId, existingAgent, updatedAgent, configFields) {
  if (!configFields || Object.keys(configFields).length === 0) {
    return { agent: updatedAgent, versionCreated: false };
  }
  const activeVersion = existingAgent.activeVersionId ? await agentsStore.getVersion(existingAgent.activeVersionId) : null;
  const versionToCompare = activeVersion || await agentsStore.getLatestVersion(agentId);
  const previousConfig = versionToCompare ? extractConfigFromVersion(versionToCompare) : null;
  const changedFields = calculateChangedFields(previousConfig, configFields);
  if (changedFields.length === 0) {
    return { agent: updatedAgent, versionCreated: false };
  }
  const fullConfig = previousConfig ? { ...previousConfig } : {};
  for (const [key, value] of Object.entries(configFields)) {
    fullConfig[key] = value === null ? void 0 : value;
  }
  const { versionId } = await createVersionWithRetry(agentsStore, agentId, fullConfig, changedFields, {
    changeMessage: "Auto-saved after edit"
  });
  await agentsStore.update({
    id: agentId,
    activeVersionId: versionId
  });
  const agentWithNewVersion = {
    ...updatedAgent,
    activeVersionId: versionId
  };
  await enforceRetentionLimit(agentsStore, agentId, versionId);
  return { agent: agentWithNewVersion, versionCreated: true };
}
var LIST_AGENT_VERSIONS_ROUTE = createRoute({
  method: "GET",
  path: "/stored/agents/:agentId/versions",
  responseType: "json",
  pathParamSchema: agentVersionPathParams,
  queryParamSchema: listVersionsQuerySchema,
  responseSchema: listVersionsResponseSchema,
  summary: "List agent versions",
  description: "Returns a paginated list of all versions for a stored agent",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, page, perPage, orderBy }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException$2(500, { message: "Agents storage domain is not available" });
      }
      const agent = await agentsStore.getById(agentId);
      if (!agent) {
        throw new HTTPException$2(404, { message: `Agent with id ${agentId} not found` });
      }
      const result = await agentsStore.listVersions({
        agentId,
        page,
        perPage,
        orderBy
      });
      return result;
    } catch (error) {
      return handleError$1(error, "Error listing agent versions");
    }
  }
});
var CREATE_AGENT_VERSION_ROUTE = createRoute({
  method: "POST",
  path: "/stored/agents/:agentId/versions",
  responseType: "json",
  pathParamSchema: agentVersionPathParams,
  bodySchema: createVersionBodySchema,
  responseSchema: createVersionResponseSchema,
  summary: "Create agent version",
  description: "Creates a new version snapshot of the current agent configuration",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, changeMessage }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException$2(500, { message: "Agents storage domain is not available" });
      }
      const agent = await agentsStore.getById(agentId);
      if (!agent) {
        throw new HTTPException$2(404, { message: `Agent with id ${agentId} not found` });
      }
      let currentConfig = {};
      if (agent.activeVersionId) {
        const activeVersion = await agentsStore.getVersion(agent.activeVersionId);
        if (activeVersion) {
          currentConfig = extractConfigFromVersion(activeVersion);
        }
      }
      const latestVersion = await agentsStore.getLatestVersion(agentId);
      const previousConfig = latestVersion ? extractConfigFromVersion(latestVersion) : null;
      const changedFields = calculateChangedFields(previousConfig, currentConfig);
      const { versionId } = await createVersionWithRetry(
        agentsStore,
        agentId,
        currentConfig,
        changedFields.length > 0 ? changedFields : [],
        { changeMessage }
      );
      const version = await agentsStore.getVersion(versionId);
      if (!version) {
        throw new HTTPException$2(500, { message: "Failed to retrieve created version" });
      }
      await enforceRetentionLimit(agentsStore, agentId, agent.activeVersionId);
      return version;
    } catch (error) {
      return handleError$1(error, "Error creating agent version");
    }
  }
});
var GET_AGENT_VERSION_ROUTE = createRoute({
  method: "GET",
  path: "/stored/agents/:agentId/versions/:versionId",
  responseType: "json",
  pathParamSchema: versionIdPathParams,
  responseSchema: getVersionResponseSchema,
  summary: "Get agent version",
  description: "Returns a specific version of an agent by its version ID",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, versionId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException$2(500, { message: "Agents storage domain is not available" });
      }
      const version = await agentsStore.getVersion(versionId);
      if (!version) {
        throw new HTTPException$2(404, { message: `Version with id ${versionId} not found` });
      }
      if (version.agentId !== agentId) {
        throw new HTTPException$2(404, { message: `Version with id ${versionId} not found for agent ${agentId}` });
      }
      return version;
    } catch (error) {
      return handleError$1(error, "Error getting agent version");
    }
  }
});
var ACTIVATE_AGENT_VERSION_ROUTE = createRoute({
  method: "POST",
  path: "/stored/agents/:agentId/versions/:versionId/activate",
  responseType: "json",
  pathParamSchema: versionIdPathParams,
  responseSchema: activateVersionResponseSchema,
  summary: "Activate agent version",
  description: "Sets a specific version as the active version for the agent",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, versionId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException$2(500, { message: "Agents storage domain is not available" });
      }
      const agent = await agentsStore.getById(agentId);
      if (!agent) {
        throw new HTTPException$2(404, { message: `Agent with id ${agentId} not found` });
      }
      const version = await agentsStore.getVersion(versionId);
      if (!version) {
        throw new HTTPException$2(404, { message: `Version with id ${versionId} not found` });
      }
      if (version.agentId !== agentId) {
        throw new HTTPException$2(404, { message: `Version with id ${versionId} not found for agent ${agentId}` });
      }
      await agentsStore.update({
        id: agentId,
        activeVersionId: versionId,
        status: "published"
      });
      return {
        success: true,
        message: `Version ${version.versionNumber} is now active`,
        activeVersionId: versionId
      };
    } catch (error) {
      return handleError$1(error, "Error activating agent version");
    }
  }
});
var RESTORE_AGENT_VERSION_ROUTE = createRoute({
  method: "POST",
  path: "/stored/agents/:agentId/versions/:versionId/restore",
  responseType: "json",
  pathParamSchema: versionIdPathParams,
  responseSchema: restoreVersionResponseSchema,
  summary: "Restore agent version",
  description: "Restores the agent configuration from a version, creating a new version",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, versionId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException$2(500, { message: "Agents storage domain is not available" });
      }
      const agent = await agentsStore.getById(agentId);
      if (!agent) {
        throw new HTTPException$2(404, { message: `Agent with id ${agentId} not found` });
      }
      const versionToRestore = await agentsStore.getVersion(versionId);
      if (!versionToRestore) {
        throw new HTTPException$2(404, { message: `Version with id ${versionId} not found` });
      }
      if (versionToRestore.agentId !== agentId) {
        throw new HTTPException$2(404, { message: `Version with id ${versionId} not found for agent ${agentId}` });
      }
      const restoredConfig = extractConfigFromVersion(versionToRestore);
      await agentsStore.update({
        id: agentId,
        ...restoredConfig
      });
      const latestVersion = await agentsStore.getLatestVersion(agentId);
      const previousConfig = latestVersion ? extractConfigFromVersion(latestVersion) : null;
      const changedFields = calculateChangedFields(previousConfig, restoredConfig);
      const { versionId: newVersionId } = await createVersionWithRetry(
        agentsStore,
        agentId,
        restoredConfig,
        changedFields,
        {
          changeMessage: `Restored from version ${versionToRestore.versionNumber}`
        }
      );
      const newVersion = await agentsStore.getVersion(newVersionId);
      if (!newVersion) {
        throw new HTTPException$2(500, { message: "Failed to retrieve created version" });
      }
      await enforceRetentionLimit(agentsStore, agentId, agent.activeVersionId);
      return newVersion;
    } catch (error) {
      return handleError$1(error, "Error restoring agent version");
    }
  }
});
var DELETE_AGENT_VERSION_ROUTE = createRoute({
  method: "DELETE",
  path: "/stored/agents/:agentId/versions/:versionId",
  responseType: "json",
  pathParamSchema: versionIdPathParams,
  responseSchema: deleteVersionResponseSchema,
  summary: "Delete agent version",
  description: "Deletes a specific version (cannot delete the active version)",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, versionId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException$2(500, { message: "Agents storage domain is not available" });
      }
      const agent = await agentsStore.getById(agentId);
      if (!agent) {
        throw new HTTPException$2(404, { message: `Agent with id ${agentId} not found` });
      }
      const version = await agentsStore.getVersion(versionId);
      if (!version) {
        throw new HTTPException$2(404, { message: `Version with id ${versionId} not found` });
      }
      if (version.agentId !== agentId) {
        throw new HTTPException$2(404, { message: `Version with id ${versionId} not found for agent ${agentId}` });
      }
      if (agent.activeVersionId === versionId) {
        throw new HTTPException$2(400, {
          message: "Cannot delete the active version. Activate a different version first."
        });
      }
      await agentsStore.deleteVersion(versionId);
      return {
        success: true,
        message: `Version ${version.versionNumber} deleted successfully`
      };
    } catch (error) {
      return handleError$1(error, "Error deleting agent version");
    }
  }
});
var COMPARE_AGENT_VERSIONS_ROUTE = createRoute({
  method: "GET",
  path: "/stored/agents/:agentId/versions/compare",
  responseType: "json",
  pathParamSchema: agentVersionPathParams,
  queryParamSchema: compareVersionsQuerySchema,
  responseSchema: compareVersionsResponseSchema,
  summary: "Compare agent versions",
  description: "Compares two versions and returns the differences between them",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, from, to }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException$2(500, { message: "Agents storage domain is not available" });
      }
      const fromVersion = await agentsStore.getVersion(from);
      if (!fromVersion) {
        throw new HTTPException$2(404, { message: `Version with id ${from} not found` });
      }
      if (fromVersion.agentId !== agentId) {
        throw new HTTPException$2(404, { message: `Version with id ${from} not found for agent ${agentId}` });
      }
      const toVersion = await agentsStore.getVersion(to);
      if (!toVersion) {
        throw new HTTPException$2(404, { message: `Version with id ${to} not found` });
      }
      if (toVersion.agentId !== agentId) {
        throw new HTTPException$2(404, { message: `Version with id ${to} not found for agent ${agentId}` });
      }
      const fromConfig = extractConfigFromVersion(fromVersion);
      const toConfig = extractConfigFromVersion(toVersion);
      const diffs = computeVersionDiffs(fromConfig, toConfig);
      return {
        diffs,
        fromVersion,
        toVersion
      };
    } catch (error) {
      return handleError$1(error, "Error comparing agent versions");
    }
  }
});

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/double-indexed-kv.js
var DoubleIndexedKV = class {
  constructor() {
    this.keyToValue = /* @__PURE__ */ new Map();
    this.valueToKey = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    this.keyToValue.set(key, value);
    this.valueToKey.set(value, key);
  }
  getByKey(key) {
    return this.keyToValue.get(key);
  }
  getByValue(value) {
    return this.valueToKey.get(value);
  }
  clear() {
    this.keyToValue.clear();
    this.valueToKey.clear();
  }
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/registry.js
var Registry = class {
  constructor(generateIdentifier) {
    this.generateIdentifier = generateIdentifier;
    this.kv = new DoubleIndexedKV();
  }
  register(value, identifier) {
    if (this.kv.getByValue(value)) {
      return;
    }
    if (!identifier) {
      identifier = this.generateIdentifier(value);
    }
    this.kv.set(identifier, value);
  }
  clear() {
    this.kv.clear();
  }
  getIdentifier(value) {
    return this.kv.getByValue(value);
  }
  getValue(identifier) {
    return this.kv.getByKey(identifier);
  }
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/class-registry.js
var ClassRegistry = class extends Registry {
  constructor() {
    super((c) => c.name);
    this.classToAllowedProps = /* @__PURE__ */ new Map();
  }
  register(value, options) {
    if (typeof options === "object") {
      if (options.allowProps) {
        this.classToAllowedProps.set(value, options.allowProps);
      }
      super.register(value, options.identifier);
    } else {
      super.register(value, options);
    }
  }
  getAllowedProps(value) {
    return this.classToAllowedProps.get(value);
  }
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/util.js
function valuesOfObj(record) {
  if ("values" in Object) {
    return Object.values(record);
  }
  const values = [];
  for (const key in record) {
    if (record.hasOwnProperty(key)) {
      values.push(record[key]);
    }
  }
  return values;
}
function find(record, predicate) {
  const values = valuesOfObj(record);
  if ("find" in values) {
    return values.find(predicate);
  }
  const valuesNotNever = values;
  for (let i = 0; i < valuesNotNever.length; i++) {
    const value = valuesNotNever[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
function forEach(record, run) {
  Object.entries(record).forEach(([key, value]) => run(value, key));
}
function includes(arr, value) {
  return arr.indexOf(value) !== -1;
}
function findArr(record, predicate) {
  for (let i = 0; i < record.length; i++) {
    const value = record[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/custom-transformer-registry.js
var CustomTransformerRegistry = class {
  constructor() {
    this.transfomers = {};
  }
  register(transformer) {
    this.transfomers[transformer.name] = transformer;
  }
  findApplicable(v) {
    return find(this.transfomers, (transformer) => transformer.isApplicable(v));
  }
  findByName(name) {
    return this.transfomers[name];
  }
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/is.js
var getType = (payload) => Object.prototype.toString.call(payload).slice(8, -1);
var isUndefined = (payload) => typeof payload === "undefined";
var isNull = (payload) => payload === null;
var isPlainObject = (payload) => {
  if (typeof payload !== "object" || payload === null)
    return false;
  if (payload === Object.prototype)
    return false;
  if (Object.getPrototypeOf(payload) === null)
    return true;
  return Object.getPrototypeOf(payload) === Object.prototype;
};
var isEmptyObject = (payload) => isPlainObject(payload) && Object.keys(payload).length === 0;
var isArray = (payload) => Array.isArray(payload);
var isString = (payload) => typeof payload === "string";
var isNumber = (payload) => typeof payload === "number" && !isNaN(payload);
var isBoolean = (payload) => typeof payload === "boolean";
var isRegExp = (payload) => payload instanceof RegExp;
var isMap = (payload) => payload instanceof Map;
var isSet = (payload) => payload instanceof Set;
var isSymbol = (payload) => getType(payload) === "Symbol";
var isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf());
var isError = (payload) => payload instanceof Error;
var isNaNValue = (payload) => typeof payload === "number" && isNaN(payload);
var isPrimitive = (payload) => isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
var isBigint = (payload) => typeof payload === "bigint";
var isInfinite = (payload) => payload === Infinity || payload === -Infinity;
var isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView);
var isURL = (payload) => payload instanceof URL;

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/pathstringifier.js
var escapeKey = (key) => key.replace(/\./g, "\\.");
var stringifyPath = (path) => path.map(String).map(escapeKey).join(".");
var parsePath = (string) => {
  const result = [];
  let segment = "";
  for (let i = 0; i < string.length; i++) {
    let char = string.charAt(i);
    const isEscapedDot = char === "\\" && string.charAt(i + 1) === ".";
    if (isEscapedDot) {
      segment += ".";
      i++;
      continue;
    }
    const isEndOfSegment = char === ".";
    if (isEndOfSegment) {
      result.push(segment);
      segment = "";
      continue;
    }
    segment += char;
  }
  const lastSegment = segment;
  result.push(lastSegment);
  return result;
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/transformer.js
function simpleTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
var simpleRules = [
  simpleTransformation(isUndefined, "undefined", () => null, () => void 0),
  simpleTransformation(isBigint, "bigint", (v) => v.toString(), (v) => {
    if (typeof BigInt !== "undefined") {
      return BigInt(v);
    }
    console.error("Please add a BigInt polyfill.");
    return v;
  }),
  simpleTransformation(isDate, "Date", (v) => v.toISOString(), (v) => new Date(v)),
  simpleTransformation(isError, "Error", (v, superJson) => {
    const baseError = {
      name: v.name,
      message: v.message
    };
    superJson.allowedErrorProps.forEach((prop) => {
      baseError[prop] = v[prop];
    });
    return baseError;
  }, (v, superJson) => {
    const e = new Error(v.message);
    e.name = v.name;
    e.stack = v.stack;
    superJson.allowedErrorProps.forEach((prop) => {
      e[prop] = v[prop];
    });
    return e;
  }),
  simpleTransformation(isRegExp, "regexp", (v) => "" + v, (regex) => {
    const body = regex.slice(1, regex.lastIndexOf("/"));
    const flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    (v) => [...v.values()],
    (v) => new Set(v)
  ),
  simpleTransformation(isMap, "map", (v) => [...v.entries()], (v) => new Map(v)),
  simpleTransformation((v) => isNaNValue(v) || isInfinite(v), "number", (v) => {
    if (isNaNValue(v)) {
      return "NaN";
    }
    if (v > 0) {
      return "Infinity";
    } else {
      return "-Infinity";
    }
  }, Number),
  simpleTransformation((v) => v === 0 && 1 / v === -Infinity, "number", () => {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", (v) => v.toString(), (v) => new URL(v))
];
function compositeTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
var symbolRule = compositeTransformation((s, superJson) => {
  if (isSymbol(s)) {
    const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);
    return isRegistered;
  }
  return false;
}, (s, superJson) => {
  const identifier = superJson.symbolRegistry.getIdentifier(s);
  return ["symbol", identifier];
}, (v) => v.description, (_, a, superJson) => {
  const value = superJson.symbolRegistry.getValue(a[1]);
  if (!value) {
    throw new Error("Trying to deserialize unknown symbol");
  }
  return value;
});
var constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce((obj, ctor) => {
  obj[ctor.name] = ctor;
  return obj;
}, {});
var typedArrayRule = compositeTransformation(isTypedArray, (v) => ["typed-array", v.constructor.name], (v) => [...v], (v, a) => {
  const ctor = constructorToName[a[1]];
  if (!ctor) {
    throw new Error("Trying to deserialize unknown typed array");
  }
  return new ctor(v);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass?.constructor) {
    const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }
  return false;
}
var classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {
  const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
  return ["class", identifier];
}, (clazz, superJson) => {
  const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProps) {
    return { ...clazz };
  }
  const result = {};
  allowedProps.forEach((prop) => {
    result[prop] = clazz[prop];
  });
  return result;
}, (v, a, superJson) => {
  const clazz = superJson.classRegistry.getValue(a[1]);
  if (!clazz) {
    throw new Error(`Trying to deserialize unknown class '${a[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
  }
  return Object.assign(Object.create(clazz.prototype), v);
});
var customRule = compositeTransformation((value, superJson) => {
  return !!superJson.customTransformerRegistry.findApplicable(value);
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return ["custom", transformer.name];
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return transformer.serialize(value);
}, (v, a, superJson) => {
  const transformer = superJson.customTransformerRegistry.findByName(a[1]);
  if (!transformer) {
    throw new Error("Trying to deserialize unknown custom value");
  }
  return transformer.deserialize(v);
});
var compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
var transformValue = (value, superJson) => {
  const applicableCompositeRule = findArr(compositeRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value, superJson),
      type: applicableCompositeRule.annotation(value, superJson)
    };
  }
  const applicableSimpleRule = findArr(simpleRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value, superJson),
      type: applicableSimpleRule.annotation
    };
  }
  return void 0;
};
var simpleRulesByAnnotation = {};
simpleRules.forEach((rule) => {
  simpleRulesByAnnotation[rule.annotation] = rule;
});
var untransformValue = (json, type, superJson) => {
  if (isArray(type)) {
    switch (type[0]) {
      case "symbol":
        return symbolRule.untransform(json, type, superJson);
      case "class":
        return classRule.untransform(json, type, superJson);
      case "custom":
        return customRule.untransform(json, type, superJson);
      case "typed-array":
        return typedArrayRule.untransform(json, type, superJson);
      default:
        throw new Error("Unknown transformation: " + type);
    }
  } else {
    const transformation = simpleRulesByAnnotation[type];
    if (!transformation) {
      throw new Error("Unknown transformation: " + type);
    }
    return transformation.untransform(json, superJson);
  }
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/accessDeep.js
var getNthKey = (value, n) => {
  if (n > value.size)
    throw new Error("index out of bounds");
  const keys = value.keys();
  while (n > 0) {
    keys.next();
    n--;
  }
  return keys.next().value;
};
function validatePath(path) {
  if (includes(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
var getDeep = (object, path) => {
  validatePath(path);
  for (let i = 0; i < path.length; i++) {
    const key = path[i];
    if (isSet(object)) {
      object = getNthKey(object, +key);
    } else if (isMap(object)) {
      const row = +key;
      const type = +path[++i] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(object, row);
      switch (type) {
        case "key":
          object = keyOfRow;
          break;
        case "value":
          object = object.get(keyOfRow);
          break;
      }
    } else {
      object = object[key];
    }
  }
  return object;
};
var setDeep = (object, path, mapper) => {
  validatePath(path);
  if (path.length === 0) {
    return mapper(object);
  }
  let parent = object;
  for (let i = 0; i < path.length - 1; i++) {
    const key = path[i];
    if (isArray(parent)) {
      const index = +key;
      parent = parent[index];
    } else if (isPlainObject(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      const row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      const isEnd = i === path.length - 2;
      if (isEnd) {
        break;
      }
      const row = +key;
      const type = +path[++i] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(parent, row);
      switch (type) {
        case "key":
          parent = keyOfRow;
          break;
        case "value":
          parent = parent.get(keyOfRow);
          break;
      }
    }
  }
  const lastKey = path[path.length - 1];
  if (isArray(parent)) {
    parent[+lastKey] = mapper(parent[+lastKey]);
  } else if (isPlainObject(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }
  if (isSet(parent)) {
    const oldValue = getNthKey(parent, +lastKey);
    const newValue = mapper(oldValue);
    if (oldValue !== newValue) {
      parent.delete(oldValue);
      parent.add(newValue);
    }
  }
  if (isMap(parent)) {
    const row = +path[path.length - 2];
    const keyToRow = getNthKey(parent, row);
    const type = +lastKey === 0 ? "key" : "value";
    switch (type) {
      case "key": {
        const newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow));
        if (newKey !== keyToRow) {
          parent.delete(keyToRow);
        }
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object;
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/plainer.js
function traverse(tree, walker2, origin = []) {
  if (!tree) {
    return;
  }
  if (!isArray(tree)) {
    forEach(tree, (subtree, key) => traverse(subtree, walker2, [...origin, ...parsePath(key)]));
    return;
  }
  const [nodeValue, children] = tree;
  if (children) {
    forEach(children, (child, key) => {
      traverse(child, walker2, [...origin, ...parsePath(key)]);
    });
  }
  walker2(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, superJson) {
  traverse(annotations, (type, path) => {
    plain = setDeep(plain, path, (v) => untransformValue(v, type, superJson));
  });
  return plain;
}
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    const object = getDeep(plain, parsePath(path));
    identicalPaths.map(parsePath).forEach((identicalObjectPath) => {
      plain = setDeep(plain, identicalObjectPath, () => object);
    });
  }
  if (isArray(annotations)) {
    const [root, other] = annotations;
    root.forEach((identicalPath) => {
      plain = setDeep(plain, parsePath(identicalPath), () => plain);
    });
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
var isDeep = (object, superJson) => isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);
function addIdentity(object, path, identities) {
  const existingSet = identities.get(object);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object, [path]);
  }
}
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  const result = {};
  let rootEqualityPaths = void 0;
  identitites.forEach((paths) => {
    if (paths.length <= 1) {
      return;
    }
    if (!dedupe) {
      paths = paths.map((path) => path.map(String)).sort((a, b) => a.length - b.length);
    }
    const [representativePath, ...identicalPaths] = paths;
    if (representativePath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
    }
  });
  if (rootEqualityPaths) {
    if (isEmptyObject(result)) {
      return [rootEqualityPaths];
    } else {
      return [rootEqualityPaths, result];
    }
  } else {
    return isEmptyObject(result) ? void 0 : result;
  }
}
var walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = /* @__PURE__ */ new Map()) => {
  const primitive = isPrimitive(object);
  if (!primitive) {
    addIdentity(object, path, identities);
    const seen = seenObjects.get(object);
    if (seen) {
      return dedupe ? {
        transformedValue: null
      } : seen;
    }
  }
  if (!isDeep(object, superJson)) {
    const transformed2 = transformValue(object, superJson);
    const result2 = transformed2 ? {
      transformedValue: transformed2.value,
      annotations: [transformed2.type]
    } : {
      transformedValue: object
    };
    if (!primitive) {
      seenObjects.set(object, result2);
    }
    return result2;
  }
  if (includes(objectsInThisPath, object)) {
    return {
      transformedValue: null
    };
  }
  const transformationResult = transformValue(object, superJson);
  const transformed = transformationResult?.value ?? object;
  const transformedValue = isArray(transformed) ? [] : {};
  const innerAnnotations = {};
  forEach(transformed, (value, index) => {
    if (index === "__proto__" || index === "constructor" || index === "prototype") {
      throw new Error(`Detected property ${index}. This is a prototype pollution risk, please remove it from your object.`);
    }
    const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index], [...objectsInThisPath, object], seenObjects);
    transformedValue[index] = recursiveResult.transformedValue;
    if (isArray(recursiveResult.annotations)) {
      innerAnnotations[index] = recursiveResult.annotations;
    } else if (isPlainObject(recursiveResult.annotations)) {
      forEach(recursiveResult.annotations, (tree, key) => {
        innerAnnotations[escapeKey(index) + "." + key] = tree;
      });
    }
  });
  const result = isEmptyObject(innerAnnotations) ? {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type] : void 0
  } : {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
  };
  if (!primitive) {
    seenObjects.set(object, result);
  }
  return result;
};

// ../../node_modules/.pnpm/is-what@4.1.16/node_modules/is-what/dist/index.js
function getType2(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isArray2(payload) {
  return getType2(payload) === "Array";
}
function isPlainObject2(payload) {
  if (getType2(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}

// ../../node_modules/.pnpm/copy-anything@3.0.5/node_modules/copy-anything/dist/index.js
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function copy(target, options = {}) {
  if (isArray2(target)) {
    return target.map((item) => copy(item, options));
  }
  if (!isPlainObject2(target)) {
    return target;
  }
  const props = Object.getOwnPropertyNames(target);
  const symbols = Object.getOwnPropertySymbols(target);
  return [...props, ...symbols].reduce((carry, key) => {
    if (isArray2(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target, options.nonenumerable);
    return carry;
  }, {});
}

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/index.js
var SuperJSON = class {
  /**
   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
   */
  constructor({ dedupe = false } = {}) {
    this.classRegistry = new ClassRegistry();
    this.symbolRegistry = new Registry((s) => s.description ?? "");
    this.customTransformerRegistry = new CustomTransformerRegistry();
    this.allowedErrorProps = [];
    this.dedupe = dedupe;
  }
  serialize(object) {
    const identities = /* @__PURE__ */ new Map();
    const output = walker(object, identities, this, this.dedupe);
    const res = {
      json: output.transformedValue
    };
    if (output.annotations) {
      res.meta = {
        ...res.meta,
        values: output.annotations
      };
    }
    const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
    if (equalityAnnotations) {
      res.meta = {
        ...res.meta,
        referentialEqualities: equalityAnnotations
      };
    }
    return res;
  }
  deserialize(payload) {
    const { json, meta } = payload;
    let result = copy(json);
    if (meta?.values) {
      result = applyValueAnnotations(result, meta.values, this);
    }
    if (meta?.referentialEqualities) {
      result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
    }
    return result;
  }
  stringify(object) {
    return JSON.stringify(this.serialize(object));
  }
  parse(string) {
    return this.deserialize(JSON.parse(string));
  }
  registerClass(v, options) {
    this.classRegistry.register(v, options);
  }
  registerSymbol(v, identifier) {
    this.symbolRegistry.register(v, identifier);
  }
  registerCustom(transformer, name) {
    this.customTransformerRegistry.register({
      name,
      ...transformer
    });
  }
  allowErrorProps(...props) {
    this.allowedErrorProps.push(...props);
  }
};
SuperJSON.defaultInstance = new SuperJSON();
SuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);
SuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);
SuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);
SuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);
SuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);
SuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);
SuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);
SuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);
var stringify = SuperJSON.stringify;
function normalizeRoutePath(path) {
  let normalized = path.trim();
  if (normalized.includes("..") || normalized.includes("?") || normalized.includes("#")) {
    throw new Error(`Invalid route path: "${path}". Path cannot contain '..', '?', or '#'`);
  }
  normalized = normalized.replace(/\/+/g, "/");
  if (normalized === "/" || normalized === "") {
    return "";
  }
  if (normalized.endsWith("/")) {
    normalized = normalized.slice(0, -1);
  }
  if (!normalized.startsWith("/")) {
    normalized = `/${normalized}`;
  }
  return normalized;
}
function looksLikeProcessorStepSchema(schema) {
  if (!schema) return false;
  try {
    const jsonSchema = zodToJsonSchema$1(schema);
    const variants = jsonSchema.anyOf || jsonSchema.oneOf;
    if (!variants || !Array.isArray(variants)) return false;
    const processorPhases = /* @__PURE__ */ new Set(["input", "inputStep", "outputStream", "outputResult", "outputStep"]);
    for (const variant of variants) {
      const properties = variant.properties;
      if (!properties?.phase) return false;
      const phaseSchema = properties.phase;
      const phaseConst = phaseSchema?.const;
      const phaseEnum = Array.isArray(phaseSchema?.enum) ? phaseSchema.enum : [];
      const phaseValues = phaseConst ? [phaseConst] : phaseEnum;
      if (!phaseValues.length || phaseValues.some((phase) => !processorPhases.has(phase))) {
        return false;
      }
    }
    return variants.length > 0;
  } catch {
    return false;
  }
}
function getSteps(steps, path) {
  return Object.entries(steps).reduce((acc, [key, step]) => {
    const fullKey = path ? `${path}.${key}` : key;
    acc[fullKey] = {
      id: step.id,
      description: step.description,
      inputSchema: step.inputSchema ? stringify(zodToJsonSchema$1(step.inputSchema)) : void 0,
      outputSchema: step.outputSchema ? stringify(zodToJsonSchema$1(step.outputSchema)) : void 0,
      resumeSchema: step.resumeSchema ? stringify(zodToJsonSchema$1(step.resumeSchema)) : void 0,
      suspendSchema: step.suspendSchema ? stringify(zodToJsonSchema$1(step.suspendSchema)) : void 0,
      stateSchema: step.stateSchema ? stringify(zodToJsonSchema$1(step.stateSchema)) : void 0,
      isWorkflow: step.component === "WORKFLOW",
      component: step.component,
      metadata: step.metadata
    };
    if (step.component === "WORKFLOW" && step.steps) {
      const nestedSteps = getSteps(step.steps, fullKey) || {};
      acc = { ...acc, ...nestedSteps };
    }
    return acc;
  }, {});
}
function getWorkflowInfo(workflow, partial = false) {
  if (partial) {
    return {
      name: workflow.name,
      description: workflow.description,
      stepCount: Object.keys(workflow.steps).length,
      stepGraph: workflow.serializedStepGraph,
      options: workflow.options,
      steps: {},
      allSteps: {},
      inputSchema: void 0,
      outputSchema: void 0,
      stateSchema: void 0
    };
  }
  return {
    name: workflow.name,
    description: workflow.description,
    steps: Object.entries(workflow.steps).reduce((acc, [key, step]) => {
      acc[key] = {
        id: step.id,
        description: step.description,
        inputSchema: step.inputSchema ? stringify(zodToJsonSchema$1(step.inputSchema)) : void 0,
        outputSchema: step.outputSchema ? stringify(zodToJsonSchema$1(step.outputSchema)) : void 0,
        resumeSchema: step.resumeSchema ? stringify(zodToJsonSchema$1(step.resumeSchema)) : void 0,
        suspendSchema: step.suspendSchema ? stringify(zodToJsonSchema$1(step.suspendSchema)) : void 0,
        stateSchema: step.stateSchema ? stringify(zodToJsonSchema$1(step.stateSchema)) : void 0,
        requestContextSchema: step.requestContextSchema ? stringify(zodToJsonSchema$1(step.requestContextSchema)) : void 0,
        component: step.component,
        metadata: step.metadata
      };
      return acc;
    }, {}),
    allSteps: getSteps(workflow.steps) || {},
    stepGraph: workflow.serializedStepGraph,
    inputSchema: workflow.inputSchema ? stringify(zodToJsonSchema$1(workflow.inputSchema)) : void 0,
    outputSchema: workflow.outputSchema ? stringify(zodToJsonSchema$1(workflow.outputSchema)) : void 0,
    stateSchema: workflow.stateSchema ? stringify(zodToJsonSchema$1(workflow.stateSchema)) : void 0,
    requestContextSchema: workflow.requestContextSchema ? stringify(zodToJsonSchema$1(workflow.requestContextSchema)) : void 0,
    options: workflow.options,
    isProcessorWorkflow: workflow.type === "processor" || looksLikeProcessorStepSchema(workflow.inputSchema)
  };
}
var WorkflowRegistry = class {
  static additionalWorkflows = {};
  /**
   * Register a workflow temporarily
   */
  static registerTemporaryWorkflow(id, workflow) {
    this.additionalWorkflows[id] = workflow;
  }
  /**
   * Register all workflows from map
   */
  static registerTemporaryWorkflows(workflows, mastra) {
    for (const [id, workflow] of Object.entries(workflows)) {
      if (mastra) {
        workflow.__registerMastra(mastra);
        workflow.__registerPrimitives({
          logger: mastra.getLogger(),
          storage: mastra.getStorage(),
          agents: mastra.listAgents(),
          tts: mastra.getTTS(),
          vectors: mastra.listVectors()
        });
      }
      this.additionalWorkflows[id] = workflow;
    }
  }
  /**
   * Get a workflow by ID from the registry (returns undefined if not found)
   */
  static getWorkflow(workflowId) {
    return this.additionalWorkflows[workflowId];
  }
  /**
   * Get all workflows from the registry
   */
  static getAllWorkflows() {
    return { ...this.additionalWorkflows };
  }
  /**
   * Clean up a temporary workflow
   */
  static cleanupTemporaryWorkflow(workflowId) {
    delete this.additionalWorkflows[workflowId];
  }
  /**
   * Clean up all registered workflows
   */
  static cleanup() {
    this.additionalWorkflows = {};
  }
  /**
   * Check if a workflow ID is a valid agent-builder workflow
   */
  static isAgentBuilderWorkflow(workflowId) {
    return workflowId in this.additionalWorkflows;
  }
  /**
   * Get all registered temporary workflow IDs (for debugging)
   */
  static getRegisteredWorkflowIds() {
    return Object.keys(this.additionalWorkflows);
  }
};
function toSlug(input) {
  return input.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
}
function convertInstructionsToString(message) {
  if (!message) {
    return "";
  }
  if (typeof message === "string") {
    return message;
  }
  if (Array.isArray(message)) {
    return message.map((m) => {
      if (typeof m === "string") {
        return m;
      }
      return typeof m.content === "string" ? m.content : "";
    }).filter((content) => content).join("\n");
  }
  return typeof message.content === "string" ? message.content : "";
}

// src/server/handlers/stored-agents.ts
var LIST_STORED_AGENTS_ROUTE = createRoute({
  method: "GET",
  path: "/stored/agents",
  responseType: "json",
  queryParamSchema: listStoredAgentsQuerySchema,
  responseSchema: listStoredAgentsResponseSchema,
  summary: "List stored agents",
  description: "Returns a paginated list of all agents stored in the database",
  tags: ["Stored Agents"],
  requiresAuth: true,
  handler: async ({ mastra, page, perPage, orderBy, authorId, metadata }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException$2(500, { message: "Agents storage domain is not available" });
      }
      const result = await agentsStore.listResolved({
        page,
        perPage,
        orderBy,
        authorId,
        metadata
      });
      return result;
    } catch (error) {
      return handleError$1(error, "Error listing stored agents");
    }
  }
});
var GET_STORED_AGENT_ROUTE = createRoute({
  method: "GET",
  path: "/stored/agents/:storedAgentId",
  responseType: "json",
  pathParamSchema: storedAgentIdPathParams,
  responseSchema: getStoredAgentResponseSchema,
  summary: "Get stored agent by ID",
  description: "Returns a specific agent from storage by its unique identifier (resolved with active version config)",
  tags: ["Stored Agents"],
  requiresAuth: true,
  handler: async ({ mastra, storedAgentId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException$2(500, { message: "Agents storage domain is not available" });
      }
      const agent = await agentsStore.getByIdResolved(storedAgentId);
      if (!agent) {
        throw new HTTPException$2(404, { message: `Stored agent with id ${storedAgentId} not found` });
      }
      return agent;
    } catch (error) {
      return handleError$1(error, "Error getting stored agent");
    }
  }
});
var CREATE_STORED_AGENT_ROUTE = createRoute({
  method: "POST",
  path: "/stored/agents",
  responseType: "json",
  bodySchema: createStoredAgentBodySchema,
  responseSchema: createStoredAgentResponseSchema,
  summary: "Create stored agent",
  description: "Creates a new agent in storage with the provided configuration",
  tags: ["Stored Agents"],
  requiresAuth: true,
  handler: async ({
    mastra,
    id: providedId,
    authorId,
    metadata,
    name,
    description,
    instructions,
    model,
    tools,
    defaultOptions,
    workflows,
    agents,
    integrationTools,
    mcpClients,
    inputProcessors,
    outputProcessors,
    memory,
    scorers,
    requestContextSchema
  }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException$2(500, { message: "Agents storage domain is not available" });
      }
      const id = providedId || toSlug(name);
      if (!id) {
        throw new HTTPException$2(400, {
          message: "Could not derive agent ID from name. Please provide an explicit id."
        });
      }
      const existing = await agentsStore.getById(id);
      if (existing) {
        throw new HTTPException$2(409, { message: `Agent with id ${id} already exists` });
      }
      await agentsStore.create({
        agent: {
          id,
          authorId,
          metadata,
          name,
          description,
          instructions,
          model,
          tools,
          defaultOptions,
          workflows,
          agents,
          integrationTools,
          mcpClients,
          inputProcessors,
          outputProcessors,
          memory,
          scorers,
          requestContextSchema
        }
      });
      const resolved = await agentsStore.getByIdResolved(id);
      if (!resolved) {
        throw new HTTPException$2(500, { message: "Failed to resolve created agent" });
      }
      return resolved;
    } catch (error) {
      return handleError$1(error, "Error creating stored agent");
    }
  }
});
var UPDATE_STORED_AGENT_ROUTE = createRoute({
  method: "PATCH",
  path: "/stored/agents/:storedAgentId",
  responseType: "json",
  pathParamSchema: storedAgentIdPathParams,
  bodySchema: updateStoredAgentBodySchema,
  responseSchema: updateStoredAgentResponseSchema,
  summary: "Update stored agent",
  description: "Updates an existing agent in storage with the provided fields",
  tags: ["Stored Agents"],
  requiresAuth: true,
  handler: async ({
    mastra,
    storedAgentId,
    // Metadata-level fields
    authorId,
    metadata,
    // Config fields (snapshot-level)
    name,
    description,
    instructions,
    model,
    tools,
    defaultOptions,
    workflows,
    agents,
    integrationTools,
    mcpClients,
    inputProcessors,
    outputProcessors,
    memory,
    scorers,
    requestContextSchema
  }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException$2(500, { message: "Agents storage domain is not available" });
      }
      const existing = await agentsStore.getById(storedAgentId);
      if (!existing) {
        throw new HTTPException$2(404, { message: `Stored agent with id ${storedAgentId} not found` });
      }
      const updatedAgent = await agentsStore.update({
        id: storedAgentId,
        authorId,
        metadata,
        name,
        description,
        instructions,
        model,
        tools,
        defaultOptions,
        workflows,
        agents,
        integrationTools,
        mcpClients,
        inputProcessors,
        outputProcessors,
        memory,
        scorers,
        requestContextSchema
      });
      const configFields = {
        name,
        description,
        instructions,
        model,
        tools,
        defaultOptions,
        workflows,
        agents,
        integrationTools,
        mcpClients,
        inputProcessors,
        outputProcessors,
        memory,
        scorers,
        requestContextSchema
      };
      const providedConfigFields = Object.fromEntries(Object.entries(configFields).filter(([_, v]) => v !== void 0));
      const autoVersionResult = await handleAutoVersioning(
        agentsStore,
        storedAgentId,
        existing,
        updatedAgent,
        providedConfigFields
      );
      if (!autoVersionResult) {
        throw new Error("handleAutoVersioning returned undefined");
      }
      const editor = mastra.getEditor();
      if (editor) {
        editor.agent.clearCache(storedAgentId);
      }
      const resolved = await agentsStore.getByIdResolved(storedAgentId);
      if (!resolved) {
        throw new HTTPException$2(500, { message: "Failed to resolve updated agent" });
      }
      return resolved;
    } catch (error) {
      return handleError$1(error, "Error updating stored agent");
    }
  }
});
var DELETE_STORED_AGENT_ROUTE = createRoute({
  method: "DELETE",
  path: "/stored/agents/:storedAgentId",
  responseType: "json",
  pathParamSchema: storedAgentIdPathParams,
  responseSchema: deleteStoredAgentResponseSchema,
  summary: "Delete stored agent",
  description: "Deletes an agent from storage by its unique identifier",
  tags: ["Stored Agents"],
  requiresAuth: true,
  handler: async ({ mastra, storedAgentId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException$2(500, { message: "Agents storage domain is not available" });
      }
      const existing = await agentsStore.getById(storedAgentId);
      if (!existing) {
        throw new HTTPException$2(404, { message: `Stored agent with id ${storedAgentId} not found` });
      }
      await agentsStore.delete(storedAgentId);
      mastra.getEditor()?.agent.clearCache(storedAgentId);
      return { success: true, message: `Agent ${storedAgentId} deleted successfully` };
    } catch (error) {
      return handleError$1(error, "Error deleting stored agent");
    }
  }
});
var PREVIEW_INSTRUCTIONS_ROUTE = createRoute({
  method: "POST",
  path: "/stored/agents/preview-instructions",
  responseType: "json",
  bodySchema: previewInstructionsBodySchema,
  responseSchema: previewInstructionsResponseSchema,
  summary: "Preview resolved instructions",
  description: "Resolves an array of instruction blocks against a request context, evaluating rules, fetching prompt block references, and rendering template variables. Returns the final concatenated instruction string.",
  tags: ["Stored Agents"],
  requiresAuth: true,
  handler: async ({ mastra, blocks, context }) => {
    try {
      const editor = mastra.getEditor();
      if (!editor) {
        throw new HTTPException$2(500, { message: "Editor is not configured" });
      }
      const result = await editor.prompt.preview(blocks, context ?? {});
      return { result };
    } catch (error) {
      return handleError$1(error, "Error previewing instructions");
    }
  }
});

var storedMCPClientIdPathParams = z$1.object({
  storedMCPClientId: z$1.string().describe("Unique identifier for the stored MCP client")
});
var storageOrderBySchema$2 = z$1.object({
  field: z$1.enum(["createdAt", "updatedAt"]).optional(),
  direction: z$1.enum(["ASC", "DESC"]).optional()
});
var listStoredMCPClientsQuerySchema = createPagePaginationSchema(100).extend({
  orderBy: storageOrderBySchema$2.optional(),
  authorId: z$1.string().optional().describe("Filter MCP clients by author identifier"),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Filter MCP clients by metadata key-value pairs")
});
var mcpServerConfigSchema = z$1.object({
  type: z$1.enum(["stdio", "http"]).describe("Transport type: stdio for local processes, http for remote servers"),
  command: z$1.string().optional().describe("Command to run (stdio only)"),
  args: z$1.array(z$1.string()).optional().describe("Command arguments (stdio only)"),
  env: z$1.record(z$1.string(), z$1.string()).optional().describe("Environment variables (stdio only)"),
  url: z$1.string().optional().describe("Server URL (http only)"),
  timeout: z$1.number().optional().describe("Connection timeout in milliseconds")
});
var snapshotConfigSchema$1 = z$1.object({
  name: z$1.string().describe("Name of the MCP client"),
  description: z$1.string().optional().describe("Description of the MCP client"),
  servers: z$1.record(z$1.string(), mcpServerConfigSchema).describe("Map of server name to server configuration")
});
var createStoredMCPClientBodySchema = z$1.object({
  id: z$1.string().optional().describe("Unique identifier. If not provided, derived from name."),
  authorId: z$1.string().optional().describe("Author identifier for multi-tenant filtering"),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Additional metadata for the MCP client")
}).merge(snapshotConfigSchema$1);
var updateStoredMCPClientBodySchema = z$1.object({
  authorId: z$1.string().optional(),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional()
}).partial().merge(snapshotConfigSchema$1.partial());
var storedMCPClientSchema = z$1.object({
  id: z$1.string(),
  status: z$1.string().describe("MCP client status: draft, published, or archived"),
  activeVersionId: z$1.string().optional(),
  authorId: z$1.string().optional(),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional(),
  createdAt: z$1.coerce.date(),
  updatedAt: z$1.coerce.date(),
  name: z$1.string().describe("Name of the MCP client"),
  description: z$1.string().optional().describe("Description of the MCP client"),
  servers: z$1.record(z$1.string(), mcpServerConfigSchema).describe("Map of server name to server configuration")
});
var listStoredMCPClientsResponseSchema = paginationInfoSchema.extend({
  mcpClients: z$1.array(storedMCPClientSchema)
});
var getStoredMCPClientResponseSchema = storedMCPClientSchema;
var createStoredMCPClientResponseSchema = storedMCPClientSchema;
var updateStoredMCPClientResponseSchema = z$1.union([
  z$1.object({
    id: z$1.string(),
    status: z$1.string(),
    activeVersionId: z$1.string().optional(),
    authorId: z$1.string().optional(),
    metadata: z$1.record(z$1.string(), z$1.unknown()).optional(),
    createdAt: z$1.coerce.date(),
    updatedAt: z$1.coerce.date()
  }),
  storedMCPClientSchema
]);
var deleteStoredMCPClientResponseSchema = z$1.object({
  success: z$1.boolean(),
  message: z$1.string()
});

// src/server/handlers/stored-mcp-clients.ts
var LIST_STORED_MCP_CLIENTS_ROUTE = createRoute({
  method: "GET",
  path: "/stored/mcp-clients",
  responseType: "json",
  queryParamSchema: listStoredMCPClientsQuerySchema,
  responseSchema: listStoredMCPClientsResponseSchema,
  summary: "List stored MCP clients",
  description: "Returns a paginated list of all MCP client configurations stored in the database",
  tags: ["Stored MCP Clients"],
  requiresAuth: true,
  handler: async ({ mastra, page, perPage, orderBy, authorId, metadata }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const mcpClientStore = await storage.getStore("mcpClients");
      if (!mcpClientStore) {
        throw new HTTPException$2(500, { message: "MCP clients storage domain is not available" });
      }
      const result = await mcpClientStore.listResolved({
        page,
        perPage,
        orderBy,
        authorId,
        metadata
      });
      return result;
    } catch (error) {
      return handleError$1(error, "Error listing stored MCP clients");
    }
  }
});
var GET_STORED_MCP_CLIENT_ROUTE = createRoute({
  method: "GET",
  path: "/stored/mcp-clients/:storedMCPClientId",
  responseType: "json",
  pathParamSchema: storedMCPClientIdPathParams,
  responseSchema: getStoredMCPClientResponseSchema,
  summary: "Get stored MCP client by ID",
  description: "Returns a specific MCP client from storage by its unique identifier (resolved with active version config)",
  tags: ["Stored MCP Clients"],
  requiresAuth: true,
  handler: async ({ mastra, storedMCPClientId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const mcpClientStore = await storage.getStore("mcpClients");
      if (!mcpClientStore) {
        throw new HTTPException$2(500, { message: "MCP clients storage domain is not available" });
      }
      const mcpClient = await mcpClientStore.getByIdResolved(storedMCPClientId);
      if (!mcpClient) {
        throw new HTTPException$2(404, { message: `Stored MCP client with id ${storedMCPClientId} not found` });
      }
      return mcpClient;
    } catch (error) {
      return handleError$1(error, "Error getting stored MCP client");
    }
  }
});
var CREATE_STORED_MCP_CLIENT_ROUTE = createRoute({
  method: "POST",
  path: "/stored/mcp-clients",
  responseType: "json",
  bodySchema: createStoredMCPClientBodySchema,
  responseSchema: createStoredMCPClientResponseSchema,
  summary: "Create stored MCP client",
  description: "Creates a new MCP client configuration in storage with the provided servers",
  tags: ["Stored MCP Clients"],
  requiresAuth: true,
  handler: async ({ mastra, id: providedId, authorId, metadata, name, description, servers }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const mcpClientStore = await storage.getStore("mcpClients");
      if (!mcpClientStore) {
        throw new HTTPException$2(500, { message: "MCP clients storage domain is not available" });
      }
      const id = providedId || toSlug(name);
      if (!id) {
        throw new HTTPException$2(400, {
          message: "Could not derive MCP client ID from name. Please provide an explicit id."
        });
      }
      const existing = await mcpClientStore.getById(id);
      if (existing) {
        throw new HTTPException$2(409, { message: `MCP client with id ${id} already exists` });
      }
      await mcpClientStore.create({
        mcpClient: {
          id,
          authorId,
          metadata,
          name,
          description,
          servers
        }
      });
      const resolved = await mcpClientStore.getByIdResolved(id);
      if (!resolved) {
        throw new HTTPException$2(500, { message: "Failed to resolve created MCP client" });
      }
      return resolved;
    } catch (error) {
      return handleError$1(error, "Error creating stored MCP client");
    }
  }
});
var UPDATE_STORED_MCP_CLIENT_ROUTE = createRoute({
  method: "PATCH",
  path: "/stored/mcp-clients/:storedMCPClientId",
  responseType: "json",
  pathParamSchema: storedMCPClientIdPathParams,
  bodySchema: updateStoredMCPClientBodySchema,
  responseSchema: updateStoredMCPClientResponseSchema,
  summary: "Update stored MCP client",
  description: "Updates an existing MCP client in storage with the provided fields",
  tags: ["Stored MCP Clients"],
  requiresAuth: true,
  handler: async ({
    mastra,
    storedMCPClientId,
    // Metadata-level fields
    authorId,
    metadata,
    // Config fields (snapshot-level)
    name,
    description,
    servers
  }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const mcpClientStore = await storage.getStore("mcpClients");
      if (!mcpClientStore) {
        throw new HTTPException$2(500, { message: "MCP clients storage domain is not available" });
      }
      const existing = await mcpClientStore.getById(storedMCPClientId);
      if (!existing) {
        throw new HTTPException$2(404, { message: `Stored MCP client with id ${storedMCPClientId} not found` });
      }
      await mcpClientStore.update({
        id: storedMCPClientId,
        authorId,
        metadata,
        name,
        description,
        servers
      });
      const resolved = await mcpClientStore.getByIdResolved(storedMCPClientId);
      if (!resolved) {
        throw new HTTPException$2(500, { message: "Failed to resolve updated MCP client" });
      }
      return resolved;
    } catch (error) {
      return handleError$1(error, "Error updating stored MCP client");
    }
  }
});
var DELETE_STORED_MCP_CLIENT_ROUTE = createRoute({
  method: "DELETE",
  path: "/stored/mcp-clients/:storedMCPClientId",
  responseType: "json",
  pathParamSchema: storedMCPClientIdPathParams,
  responseSchema: deleteStoredMCPClientResponseSchema,
  summary: "Delete stored MCP client",
  description: "Deletes an MCP client from storage by its unique identifier",
  tags: ["Stored MCP Clients"],
  requiresAuth: true,
  handler: async ({ mastra, storedMCPClientId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const mcpClientStore = await storage.getStore("mcpClients");
      if (!mcpClientStore) {
        throw new HTTPException$2(500, { message: "MCP clients storage domain is not available" });
      }
      const existing = await mcpClientStore.getById(storedMCPClientId);
      if (!existing) {
        throw new HTTPException$2(404, { message: `Stored MCP client with id ${storedMCPClientId} not found` });
      }
      await mcpClientStore.delete(storedMCPClientId);
      return {
        success: true,
        message: `MCP client ${storedMCPClientId} deleted successfully`
      };
    } catch (error) {
      return handleError$1(error, "Error deleting stored MCP client");
    }
  }
});

var storedScorerIdPathParams = z$1.object({
  storedScorerId: z$1.string().describe("Unique identifier for the stored scorer definition")
});
var storageOrderBySchema$1 = z$1.object({
  field: z$1.enum(["createdAt", "updatedAt"]).optional(),
  direction: z$1.enum(["ASC", "DESC"]).optional()
});
var listStoredScorersQuerySchema = createPagePaginationSchema(100).extend({
  orderBy: storageOrderBySchema$1.optional(),
  authorId: z$1.string().optional().describe("Filter scorers by author identifier"),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Filter scorers by metadata key-value pairs")
});
var samplingConfigSchema = z$1.union([
  z$1.object({ type: z$1.literal("none") }),
  z$1.object({ type: z$1.literal("ratio"), rate: z$1.number().min(0).max(1) })
]);
var modelConfigSchema$1 = z$1.object({
  provider: z$1.string().describe("Model provider (e.g., openai, anthropic)"),
  name: z$1.string().describe("Model name (e.g., gpt-4o, claude-3-opus)")
}).passthrough().describe("Model configuration");
var scorerTypeEnum = z$1.enum([
  "llm-judge",
  "answer-relevancy",
  "answer-similarity",
  "bias",
  "context-precision",
  "context-relevance",
  "faithfulness",
  "hallucination",
  "noise-sensitivity",
  "prompt-alignment",
  "tool-call-accuracy",
  "toxicity"
]).describe("Scorer type: llm-judge for custom, or a preset type name");
var snapshotConfigSchema = z$1.object({
  name: z$1.string().describe("Name of the scorer"),
  description: z$1.string().optional().describe("Description of the scorer"),
  type: scorerTypeEnum,
  model: modelConfigSchema$1.optional().describe("Model configuration for LLM judge"),
  instructions: z$1.string().optional().describe("System instructions for the judge LLM (used when type is llm-judge)"),
  scoreRange: z$1.object({
    min: z$1.number().optional().describe("Minimum score value (default: 0)"),
    max: z$1.number().optional().describe("Maximum score value (default: 1)")
  }).optional().describe("Score range configuration (used when type is llm-judge)"),
  presetConfig: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Serializable config options for preset scorers"),
  defaultSampling: samplingConfigSchema.optional().describe("Default sampling configuration")
});
var createStoredScorerBodySchema = z$1.object({
  id: z$1.string().optional().describe("Unique identifier. If not provided, derived from name."),
  authorId: z$1.string().optional().describe("Author identifier for multi-tenant filtering"),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Additional metadata for the scorer")
}).merge(snapshotConfigSchema);
var updateStoredScorerBodySchema = z$1.object({
  authorId: z$1.string().optional(),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional()
}).partial().merge(snapshotConfigSchema.partial());
var storedScorerSchema = z$1.object({
  id: z$1.string(),
  status: z$1.string().describe("Scorer status: draft, published, or archived"),
  activeVersionId: z$1.string().optional(),
  authorId: z$1.string().optional(),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional(),
  createdAt: z$1.coerce.date(),
  updatedAt: z$1.coerce.date(),
  name: z$1.string().describe("Name of the scorer"),
  description: z$1.string().optional().describe("Description of the scorer"),
  type: scorerTypeEnum,
  model: modelConfigSchema$1.optional(),
  instructions: z$1.string().optional().describe("System instructions for the judge LLM"),
  scoreRange: z$1.object({
    min: z$1.number().optional(),
    max: z$1.number().optional()
  }).optional(),
  presetConfig: z$1.record(z$1.string(), z$1.unknown()).optional(),
  defaultSampling: samplingConfigSchema.optional()
});
var listStoredScorersResponseSchema = paginationInfoSchema.extend({
  scorerDefinitions: z$1.array(storedScorerSchema)
});
var getStoredScorerResponseSchema = storedScorerSchema;
var createStoredScorerResponseSchema = storedScorerSchema;
var updateStoredScorerResponseSchema = z$1.union([
  z$1.object({
    id: z$1.string(),
    status: z$1.string(),
    activeVersionId: z$1.string().optional(),
    authorId: z$1.string().optional(),
    metadata: z$1.record(z$1.string(), z$1.unknown()).optional(),
    createdAt: z$1.coerce.date(),
    updatedAt: z$1.coerce.date()
  }),
  storedScorerSchema
]);
var deleteStoredScorerResponseSchema = z$1.object({
  success: z$1.boolean(),
  message: z$1.string()
});

// src/server/handlers/stored-scorers.ts
var LIST_STORED_SCORERS_ROUTE = createRoute({
  method: "GET",
  path: "/stored/scorers",
  responseType: "json",
  queryParamSchema: listStoredScorersQuerySchema,
  responseSchema: listStoredScorersResponseSchema,
  summary: "List stored scorer definitions",
  description: "Returns a paginated list of all scorer definitions stored in the database",
  tags: ["Stored Scorers"],
  requiresAuth: true,
  handler: async ({ mastra, page, perPage, orderBy, authorId, metadata }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const scorerStore = await storage.getStore("scorerDefinitions");
      if (!scorerStore) {
        throw new HTTPException$2(500, { message: "Scorer definitions storage domain is not available" });
      }
      const result = await scorerStore.listResolved({
        page,
        perPage,
        orderBy,
        authorId,
        metadata
      });
      return result;
    } catch (error) {
      return handleError$1(error, "Error listing stored scorer definitions");
    }
  }
});
var GET_STORED_SCORER_ROUTE = createRoute({
  method: "GET",
  path: "/stored/scorers/:storedScorerId",
  responseType: "json",
  pathParamSchema: storedScorerIdPathParams,
  responseSchema: getStoredScorerResponseSchema,
  summary: "Get stored scorer definition by ID",
  description: "Returns a specific scorer definition from storage by its unique identifier (resolved with active version config)",
  tags: ["Stored Scorers"],
  requiresAuth: true,
  handler: async ({ mastra, storedScorerId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const scorerStore = await storage.getStore("scorerDefinitions");
      if (!scorerStore) {
        throw new HTTPException$2(500, { message: "Scorer definitions storage domain is not available" });
      }
      const scorer = await scorerStore.getByIdResolved(storedScorerId);
      if (!scorer) {
        throw new HTTPException$2(404, { message: `Stored scorer definition with id ${storedScorerId} not found` });
      }
      return scorer;
    } catch (error) {
      return handleError$1(error, "Error getting stored scorer definition");
    }
  }
});
var CREATE_STORED_SCORER_ROUTE = createRoute({
  method: "POST",
  path: "/stored/scorers",
  responseType: "json",
  bodySchema: createStoredScorerBodySchema,
  responseSchema: createStoredScorerResponseSchema,
  summary: "Create stored scorer definition",
  description: "Creates a new scorer definition in storage with the provided configuration",
  tags: ["Stored Scorers"],
  requiresAuth: true,
  handler: async ({
    mastra,
    id: providedId,
    authorId,
    metadata,
    name,
    description,
    type,
    model,
    instructions,
    scoreRange,
    presetConfig,
    defaultSampling
  }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const scorerStore = await storage.getStore("scorerDefinitions");
      if (!scorerStore) {
        throw new HTTPException$2(500, { message: "Scorer definitions storage domain is not available" });
      }
      const id = providedId || toSlug(name);
      if (!id) {
        throw new HTTPException$2(400, {
          message: "Could not derive scorer definition ID from name. Please provide an explicit id."
        });
      }
      const existing = await scorerStore.getById(id);
      if (existing) {
        throw new HTTPException$2(409, { message: `Scorer definition with id ${id} already exists` });
      }
      await scorerStore.create({
        scorerDefinition: {
          id,
          authorId,
          metadata,
          name,
          description,
          type,
          model,
          instructions,
          scoreRange,
          presetConfig,
          defaultSampling
        }
      });
      const resolved = await scorerStore.getByIdResolved(id);
      if (!resolved) {
        throw new HTTPException$2(500, { message: "Failed to resolve created scorer definition" });
      }
      return resolved;
    } catch (error) {
      return handleError$1(error, "Error creating stored scorer definition");
    }
  }
});
var UPDATE_STORED_SCORER_ROUTE = createRoute({
  method: "PATCH",
  path: "/stored/scorers/:storedScorerId",
  responseType: "json",
  pathParamSchema: storedScorerIdPathParams,
  bodySchema: updateStoredScorerBodySchema,
  responseSchema: updateStoredScorerResponseSchema,
  summary: "Update stored scorer definition",
  description: "Updates an existing scorer definition in storage with the provided fields",
  tags: ["Stored Scorers"],
  requiresAuth: true,
  handler: async ({
    mastra,
    storedScorerId,
    // Metadata-level fields
    authorId,
    metadata,
    // Config fields (snapshot-level)
    name,
    description,
    type,
    model,
    instructions,
    scoreRange,
    presetConfig,
    defaultSampling
  }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const scorerStore = await storage.getStore("scorerDefinitions");
      if (!scorerStore) {
        throw new HTTPException$2(500, { message: "Scorer definitions storage domain is not available" });
      }
      const existing = await scorerStore.getById(storedScorerId);
      if (!existing) {
        throw new HTTPException$2(404, { message: `Stored scorer definition with id ${storedScorerId} not found` });
      }
      await scorerStore.update({
        id: storedScorerId,
        authorId,
        metadata,
        name,
        description,
        type,
        model,
        instructions,
        scoreRange,
        presetConfig,
        defaultSampling
      });
      const editor = mastra.getEditor();
      if (editor) {
        editor.scorer.clearCache(storedScorerId);
      }
      const resolved = await scorerStore.getByIdResolved(storedScorerId);
      if (!resolved) {
        throw new HTTPException$2(500, { message: "Failed to resolve updated scorer definition" });
      }
      return resolved;
    } catch (error) {
      return handleError$1(error, "Error updating stored scorer definition");
    }
  }
});
var DELETE_STORED_SCORER_ROUTE = createRoute({
  method: "DELETE",
  path: "/stored/scorers/:storedScorerId",
  responseType: "json",
  pathParamSchema: storedScorerIdPathParams,
  responseSchema: deleteStoredScorerResponseSchema,
  summary: "Delete stored scorer definition",
  description: "Deletes a scorer definition from storage by its unique identifier",
  tags: ["Stored Scorers"],
  requiresAuth: true,
  handler: async ({ mastra, storedScorerId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException$2(500, { message: "Storage is not configured" });
      }
      const scorerStore = await storage.getStore("scorerDefinitions");
      if (!scorerStore) {
        throw new HTTPException$2(500, { message: "Scorer definitions storage domain is not available" });
      }
      const existing = await scorerStore.getById(storedScorerId);
      if (!existing) {
        throw new HTTPException$2(404, { message: `Stored scorer definition with id ${storedScorerId} not found` });
      }
      await scorerStore.delete(storedScorerId);
      mastra.getEditor()?.scorer.clearCache(storedScorerId);
      return { success: true, message: `Scorer definition ${storedScorerId} deleted successfully` };
    } catch (error) {
      return handleError$1(error, "Error deleting stored scorer definition");
    }
  }
});

var mastraPackageSchema = z.object({
  name: z.string(),
  version: z.string()
});
var systemPackagesResponseSchema = z.object({
  packages: z.array(mastraPackageSchema)
});

// src/server/handlers/system.ts
var GET_SYSTEM_PACKAGES_ROUTE = createRoute({
  method: "GET",
  path: "/system/packages",
  responseType: "json",
  responseSchema: systemPackagesResponseSchema,
  summary: "Get installed Mastra packages",
  description: "Returns a list of all installed Mastra packages and their versions from the project",
  tags: ["System"],
  requiresAuth: true,
  handler: async () => {
    try {
      const packagesFilePath = process.env.MASTRA_PACKAGES_FILE;
      let packages = [];
      if (packagesFilePath) {
        try {
          const fileContent = readFileSync(packagesFilePath, "utf-8");
          packages = JSON.parse(fileContent);
        } catch {
          packages = [];
        }
      }
      return { packages };
    } catch (error) {
      return handleError$1(error, "Error getting system packages");
    }
  }
});

var toolProviderIdPathParams = z$1.object({
  providerId: z$1.string().describe("Unique identifier for the tool provider")
});
var toolSlugPathParams = toolProviderIdPathParams.extend({
  toolSlug: z$1.string().describe("Slug identifier for the tool")
});
var listToolProviderToolsQuerySchema = z$1.object({
  toolkit: z$1.string().optional().describe("Filter tools by toolkit slug"),
  search: z$1.string().optional().describe("Search tools by name or description"),
  page: z$1.coerce.number().optional().describe("Page number for pagination"),
  perPage: z$1.coerce.number().optional().describe("Number of items per page")
});
var paginationSchema = z$1.object({
  total: z$1.number().optional(),
  page: z$1.number().optional(),
  perPage: z$1.number().optional(),
  hasMore: z$1.boolean()
}).optional();
var listToolProvidersResponseSchema = z$1.object({
  providers: z$1.array(
    z$1.object({
      id: z$1.string(),
      name: z$1.string(),
      description: z$1.string().optional()
    })
  )
});
var listToolProviderToolkitsResponseSchema = z$1.object({
  data: z$1.array(
    z$1.object({
      slug: z$1.string(),
      name: z$1.string(),
      description: z$1.string().optional(),
      icon: z$1.string().optional()
    })
  ),
  pagination: paginationSchema
});
var listToolProviderToolsResponseSchema = z$1.object({
  data: z$1.array(
    z$1.object({
      slug: z$1.string(),
      name: z$1.string(),
      description: z$1.string().optional(),
      toolkit: z$1.string().optional()
    })
  ),
  pagination: paginationSchema
});
var getToolProviderToolSchemaResponseSchema = z$1.record(z$1.string(), z$1.unknown());

// src/server/handlers/tool-providers.ts
var LIST_TOOL_PROVIDERS_ROUTE = createRoute({
  method: "GET",
  path: "/tool-providers",
  responseType: "json",
  responseSchema: listToolProvidersResponseSchema,
  summary: "List tool providers",
  description: "Returns a list of all registered tool providers with their info",
  tags: ["Tool Providers"],
  requiresAuth: true,
  handler: async ({ mastra }) => {
    try {
      const editor = mastra.getEditor();
      if (!editor) {
        throw new HTTPException$2(500, { message: "Editor is not configured" });
      }
      const providers = editor.getToolProviders();
      return { providers: Object.values(providers).map((provider) => provider.info) };
    } catch (error) {
      return handleError$1(error, "Error listing tool providers");
    }
  }
});
var LIST_TOOL_PROVIDER_TOOLKITS_ROUTE = createRoute({
  method: "GET",
  path: "/tool-providers/:providerId/toolkits",
  responseType: "json",
  pathParamSchema: toolProviderIdPathParams,
  responseSchema: listToolProviderToolkitsResponseSchema,
  summary: "List tool provider toolkits",
  description: "Returns the toolkits available from a specific tool provider",
  tags: ["Tool Providers"],
  requiresAuth: true,
  handler: async ({ mastra, providerId }) => {
    try {
      const editor = mastra.getEditor();
      if (!editor) {
        throw new HTTPException$2(500, { message: "Editor is not configured" });
      }
      const provider = editor.getToolProvider(providerId);
      if (!provider) {
        throw new HTTPException$2(404, { message: `Tool provider with id ${providerId} not found` });
      }
      if (!provider.listToolkits) {
        return { data: [] };
      }
      return await provider.listToolkits();
    } catch (error) {
      return handleError$1(error, "Error listing tool provider toolkits");
    }
  }
});
var LIST_TOOL_PROVIDER_TOOLS_ROUTE = createRoute({
  method: "GET",
  path: "/tool-providers/:providerId/tools",
  responseType: "json",
  pathParamSchema: toolProviderIdPathParams,
  queryParamSchema: listToolProviderToolsQuerySchema,
  responseSchema: listToolProviderToolsResponseSchema,
  summary: "List tool provider tools",
  description: "Returns the tools available from a specific tool provider, with optional filtering",
  tags: ["Tool Providers"],
  requiresAuth: true,
  handler: async ({ mastra, providerId, toolkit, search, page, perPage }) => {
    try {
      const editor = mastra.getEditor();
      if (!editor) {
        throw new HTTPException$2(500, { message: "Editor is not configured" });
      }
      const provider = editor.getToolProvider(providerId);
      if (!provider) {
        throw new HTTPException$2(404, { message: `Tool provider with id ${providerId} not found` });
      }
      const options = {};
      if (toolkit !== void 0) options.toolkit = toolkit;
      if (search !== void 0) options.search = search;
      if (page !== void 0) options.page = page;
      if (perPage !== void 0) options.perPage = perPage;
      return await provider.listTools(Object.keys(options).length > 0 ? options : void 0);
    } catch (error) {
      return handleError$1(error, "Error listing tool provider tools");
    }
  }
});
var GET_TOOL_PROVIDER_TOOL_SCHEMA_ROUTE = createRoute({
  method: "GET",
  path: "/tool-providers/:providerId/tools/:toolSlug/schema",
  responseType: "json",
  pathParamSchema: toolSlugPathParams,
  responseSchema: getToolProviderToolSchemaResponseSchema,
  summary: "Get tool provider tool schema",
  description: "Returns the schema for a specific tool from a tool provider",
  tags: ["Tool Providers"],
  requiresAuth: true,
  handler: async ({ mastra, providerId, toolSlug }) => {
    try {
      const editor = mastra.getEditor();
      if (!editor) {
        throw new HTTPException$2(500, { message: "Editor is not configured" });
      }
      const provider = editor.getToolProvider(providerId);
      if (!provider) {
        throw new HTTPException$2(404, { message: `Tool provider with id ${providerId} not found` });
      }
      if (!provider.getToolSchema) {
        throw new HTTPException$2(404, { message: `Tool provider ${providerId} does not support getToolSchema` });
      }
      const schema = await provider.getToolSchema(toolSlug);
      if (!schema) {
        throw new HTTPException$2(404, { message: `Schema for tool ${toolSlug} not found in provider ${providerId}` });
      }
      return schema;
    } catch (error) {
      return handleError$1(error, "Error getting tool provider tool schema");
    }
  }
});

var jsonSchemaObject = z$1.lazy(() => z$1.record(z$1.unknown()));
var jsonSchemaField = z$1.union([jsonSchemaObject, z$1.null()]).optional();
var datasetIdPathParams = z$1.object({
  datasetId: z$1.string().describe("Unique identifier for the dataset")
});
z$1.object({
  experimentId: z$1.string().describe("Unique identifier for the experiment")
});
z$1.object({
  itemId: z$1.string().describe("Unique identifier for the dataset item")
});
var datasetAndExperimentIdPathParams = z$1.object({
  datasetId: z$1.string().describe("Unique identifier for the dataset"),
  experimentId: z$1.string().describe("Unique identifier for the experiment")
});
var datasetAndItemIdPathParams = z$1.object({
  datasetId: z$1.string().describe("Unique identifier for the dataset"),
  itemId: z$1.string().describe("Unique identifier for the dataset item")
});
var paginationQuerySchema = z$1.object({
  page: z$1.coerce.number().optional().default(0),
  perPage: z$1.coerce.number().optional().default(10)
});
var listItemsQuerySchema = z$1.object({
  page: z$1.coerce.number().optional().default(0),
  perPage: z$1.coerce.number().optional().default(10),
  version: z$1.coerce.number().int().optional(),
  // Optional version filter for snapshot semantics
  search: z$1.string().optional()
});
var createDatasetBodySchema = z$1.object({
  name: z$1.string().describe("Name of the dataset"),
  description: z$1.string().optional().describe("Description of the dataset"),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Additional metadata"),
  inputSchema: jsonSchemaField.describe("JSON Schema for validating item input"),
  groundTruthSchema: jsonSchemaField.describe("JSON Schema for validating item groundTruth")
});
var updateDatasetBodySchema = z$1.object({
  name: z$1.string().optional().describe("Name of the dataset"),
  description: z$1.string().optional().describe("Description of the dataset"),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Additional metadata"),
  inputSchema: jsonSchemaField.describe("JSON Schema for validating item input"),
  groundTruthSchema: jsonSchemaField.describe("JSON Schema for validating item groundTruth")
});
var addItemBodySchema = z$1.object({
  input: z$1.unknown().describe("Input data for the dataset item"),
  groundTruth: z$1.unknown().optional().describe("Expected output for comparison"),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Additional metadata")
});
var updateItemBodySchema = z$1.object({
  input: z$1.unknown().optional().describe("Input data for the dataset item"),
  groundTruth: z$1.unknown().optional().describe("Expected output for comparison"),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional().describe("Additional metadata")
});
var triggerExperimentBodySchema = z$1.object({
  targetType: z$1.enum(["agent", "workflow", "scorer"]).describe("Type of target to run against"),
  targetId: z$1.string().describe("ID of the target"),
  scorerIds: z$1.array(z$1.string()).optional().describe("IDs of scorers to apply"),
  version: z$1.coerce.number().int().optional().describe("Pin to specific dataset version"),
  maxConcurrency: z$1.number().optional().describe("Maximum concurrent executions")
});
var compareExperimentsBodySchema = z$1.object({
  experimentIdA: z$1.string().describe("ID of baseline experiment"),
  experimentIdB: z$1.string().describe("ID of candidate experiment")
});
var datasetResponseSchema = z$1.object({
  id: z$1.string(),
  name: z$1.string(),
  description: z$1.string().optional().nullable(),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional().nullable(),
  inputSchema: z$1.record(z$1.unknown()).optional().nullable(),
  groundTruthSchema: z$1.record(z$1.unknown()).optional().nullable(),
  version: z$1.number().int(),
  createdAt: z$1.coerce.date(),
  updatedAt: z$1.coerce.date()
});
var datasetItemResponseSchema = z$1.object({
  id: z$1.string(),
  datasetId: z$1.string(),
  datasetVersion: z$1.number().int(),
  input: z$1.unknown(),
  groundTruth: z$1.unknown().optional(),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional(),
  createdAt: z$1.coerce.date(),
  updatedAt: z$1.coerce.date()
});
var experimentResponseSchema = z$1.object({
  id: z$1.string(),
  datasetId: z$1.string().nullable(),
  datasetVersion: z$1.number().int().nullable(),
  targetType: z$1.enum(["agent", "workflow", "scorer", "processor"]),
  targetId: z$1.string(),
  name: z$1.string().optional(),
  description: z$1.string().optional(),
  metadata: z$1.record(z$1.unknown()).optional(),
  status: z$1.enum(["pending", "running", "completed", "failed"]),
  totalItems: z$1.number(),
  succeededCount: z$1.number(),
  failedCount: z$1.number(),
  skippedCount: z$1.number(),
  startedAt: z$1.coerce.date().nullable(),
  completedAt: z$1.coerce.date().nullable(),
  createdAt: z$1.coerce.date(),
  updatedAt: z$1.coerce.date()
});
z$1.object({
  scorerId: z$1.string(),
  scorerName: z$1.string(),
  score: z$1.number().nullable(),
  reason: z$1.string().nullable(),
  error: z$1.string().nullable()
});
var experimentResultResponseSchema = z$1.object({
  id: z$1.string(),
  experimentId: z$1.string(),
  itemId: z$1.string(),
  itemDatasetVersion: z$1.number().int().nullable(),
  input: z$1.unknown(),
  output: z$1.unknown().nullable(),
  groundTruth: z$1.unknown().nullable(),
  error: z$1.object({
    message: z$1.string(),
    stack: z$1.string().optional(),
    code: z$1.string().optional()
  }).nullable(),
  startedAt: z$1.coerce.date(),
  completedAt: z$1.coerce.date(),
  retryCount: z$1.number(),
  traceId: z$1.string().nullable(),
  createdAt: z$1.coerce.date()
});
var comparisonItemSchema = z$1.object({
  itemId: z$1.string(),
  input: z$1.unknown().nullable(),
  groundTruth: z$1.unknown().nullable(),
  results: z$1.record(
    z$1.string(),
    z$1.object({
      output: z$1.unknown().nullable(),
      scores: z$1.record(z$1.string(), z$1.number().nullable())
    }).nullable()
  )
});
var comparisonResponseSchema = z$1.object({
  baselineId: z$1.string(),
  items: z$1.array(comparisonItemSchema)
});
var experimentSummaryResponseSchema = z$1.object({
  experimentId: z$1.string(),
  status: z$1.enum(["pending", "running", "completed", "failed"]),
  totalItems: z$1.number(),
  succeededCount: z$1.number(),
  failedCount: z$1.number(),
  startedAt: z$1.coerce.date(),
  completedAt: z$1.coerce.date().nullable(),
  results: z$1.array(
    z$1.object({
      itemId: z$1.string(),
      itemDatasetVersion: z$1.number().int().nullable(),
      input: z$1.unknown(),
      output: z$1.unknown().nullable(),
      groundTruth: z$1.unknown().nullable(),
      error: z$1.string().nullable(),
      startedAt: z$1.coerce.date(),
      completedAt: z$1.coerce.date(),
      retryCount: z$1.number(),
      scores: z$1.array(
        z$1.object({
          scorerId: z$1.string(),
          scorerName: z$1.string(),
          score: z$1.number().nullable(),
          reason: z$1.string().nullable(),
          error: z$1.string().nullable()
        })
      )
    })
  )
});
var listDatasetsResponseSchema = z$1.object({
  datasets: z$1.array(datasetResponseSchema),
  pagination: paginationInfoSchema
});
var listItemsResponseSchema = z$1.object({
  items: z$1.array(datasetItemResponseSchema),
  pagination: paginationInfoSchema
});
var listExperimentsResponseSchema = z$1.object({
  experiments: z$1.array(experimentResponseSchema),
  pagination: paginationInfoSchema
});
var listExperimentResultsResponseSchema = z$1.object({
  results: z$1.array(experimentResultResponseSchema),
  pagination: paginationInfoSchema
});
var datasetItemVersionPathParams = z$1.object({
  datasetId: z$1.string().describe("Unique identifier for the dataset"),
  itemId: z$1.string().describe("Unique identifier for the dataset item"),
  datasetVersion: z$1.coerce.number().int().describe("Dataset version number")
});
var itemVersionResponseSchema = z$1.object({
  id: z$1.string(),
  datasetId: z$1.string(),
  datasetVersion: z$1.number().int(),
  input: z$1.unknown(),
  groundTruth: z$1.unknown().optional(),
  metadata: z$1.record(z$1.unknown()).optional(),
  validTo: z$1.number().int().nullable(),
  isDeleted: z$1.boolean(),
  createdAt: z$1.coerce.date(),
  updatedAt: z$1.coerce.date()
});
var listItemVersionsResponseSchema = z$1.object({
  history: z$1.array(itemVersionResponseSchema)
});
var datasetVersionResponseSchema = z$1.object({
  id: z$1.string(),
  datasetId: z$1.string(),
  version: z$1.number().int(),
  createdAt: z$1.coerce.date()
});
var listDatasetVersionsResponseSchema = z$1.object({
  versions: z$1.array(datasetVersionResponseSchema),
  pagination: paginationInfoSchema
});
var batchInsertItemsBodySchema = z$1.object({
  items: z$1.array(
    z$1.object({
      input: z$1.unknown(),
      groundTruth: z$1.unknown().optional(),
      metadata: z$1.record(z$1.unknown()).optional()
    })
  )
});
var batchInsertItemsResponseSchema = z$1.object({
  items: z$1.array(datasetItemResponseSchema),
  count: z$1.number()
});
var batchDeleteItemsBodySchema = z$1.object({
  itemIds: z$1.array(z$1.string())
});
var batchDeleteItemsResponseSchema = z$1.object({
  success: z$1.boolean(),
  deletedCount: z$1.number()
});

// src/server/handlers/datasets.ts
function assertDatasetsAvailable() {
  if (!coreFeatures.has("datasets")) {
    throw new HTTPException$2(501, { message: "Datasets require @mastra/core >= 1.4.0" });
  }
}
function isSchemaValidationError(error) {
  return error instanceof Error && error.name === "SchemaValidationError";
}
function isSchemaUpdateValidationError(error) {
  return error instanceof Error && error.name === "SchemaUpdateValidationError";
}
function getHttpStatusForMastraError(errorId) {
  switch (errorId) {
    case "DATASET_NOT_FOUND":
    case "EXPERIMENT_NOT_FOUND":
      return 404;
    default:
      return 500;
  }
}
var LIST_DATASETS_ROUTE = createRoute({
  method: "GET",
  path: "/datasets",
  responseType: "json",
  queryParamSchema: paginationQuerySchema,
  responseSchema: listDatasetsResponseSchema,
  summary: "List all datasets",
  description: "Returns a paginated list of all datasets",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { page, perPage } = params;
      const result = await mastra.datasets.list({ page: page ?? 0, perPage: perPage ?? 10 });
      return {
        datasets: result.datasets,
        pagination: result.pagination
      };
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error listing datasets");
    }
  }
});
var CREATE_DATASET_ROUTE = createRoute({
  method: "POST",
  path: "/datasets",
  responseType: "json",
  bodySchema: createDatasetBodySchema,
  responseSchema: datasetResponseSchema,
  summary: "Create a new dataset",
  description: "Creates a new dataset with the specified name and optional metadata",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { name, description, metadata, inputSchema, groundTruthSchema } = params;
      const ds = await mastra.datasets.create({
        name,
        description,
        metadata,
        inputSchema: inputSchema ?? void 0,
        groundTruthSchema: groundTruthSchema ?? void 0
      });
      const details = await ds.getDetails();
      return details;
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error creating dataset");
    }
  }
});
var GET_DATASET_ROUTE = createRoute({
  method: "GET",
  path: "/datasets/:datasetId",
  responseType: "json",
  pathParamSchema: datasetIdPathParams,
  responseSchema: datasetResponseSchema.nullable(),
  summary: "Get dataset by ID",
  description: "Returns details for a specific dataset",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId }) => {
    assertDatasetsAvailable();
    try {
      const ds = await mastra.datasets.get({ id: datasetId });
      return await ds.getDetails();
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error getting dataset");
    }
  }
});
var UPDATE_DATASET_ROUTE = createRoute({
  method: "PATCH",
  path: "/datasets/:datasetId",
  responseType: "json",
  pathParamSchema: datasetIdPathParams,
  bodySchema: updateDatasetBodySchema,
  responseSchema: datasetResponseSchema,
  summary: "Update dataset",
  description: "Updates a dataset with the specified fields",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { name, description, metadata, inputSchema, groundTruthSchema } = params;
      const ds = await mastra.datasets.get({ id: datasetId });
      const result = await ds.update({
        name,
        description,
        metadata,
        inputSchema: inputSchema ?? void 0,
        groundTruthSchema: groundTruthSchema ?? void 0
      });
      return result;
    } catch (error) {
      if (isSchemaUpdateValidationError(error)) {
        throw new HTTPException$2(400, {
          message: error.message,
          cause: { failingItems: error.failingItems }
        });
      }
      if (isSchemaValidationError(error)) {
        throw new HTTPException$2(400, {
          message: error.message,
          cause: { field: error.field, errors: error.errors }
        });
      }
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error updating dataset");
    }
  }
});
var DELETE_DATASET_ROUTE = createRoute({
  method: "DELETE",
  path: "/datasets/:datasetId",
  responseType: "json",
  pathParamSchema: datasetIdPathParams,
  responseSchema: successResponseSchema,
  summary: "Delete dataset",
  description: "Deletes a dataset and all its items",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId }) => {
    assertDatasetsAvailable();
    try {
      await mastra.datasets.get({ id: datasetId });
      await mastra.datasets.delete({ id: datasetId });
      return { success: true };
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error deleting dataset");
    }
  }
});
var LIST_ITEMS_ROUTE = createRoute({
  method: "GET",
  path: "/datasets/:datasetId/items",
  responseType: "json",
  pathParamSchema: datasetIdPathParams,
  queryParamSchema: listItemsQuerySchema,
  responseSchema: listItemsResponseSchema,
  summary: "List dataset items",
  description: "Returns a paginated list of items in the dataset",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { page, perPage, version, search } = params;
      const ds = await mastra.datasets.get({ id: datasetId });
      const result = await ds.listItems({
        page: page ?? 0,
        perPage: perPage ?? 10,
        version,
        search
      });
      if (Array.isArray(result)) {
        return { items: result, pagination: { total: result.length, page: 0, perPage: result.length, hasMore: false } };
      }
      return { items: result.items, pagination: result.pagination };
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error listing dataset items");
    }
  }
});
var ADD_ITEM_ROUTE = createRoute({
  method: "POST",
  path: "/datasets/:datasetId/items",
  responseType: "json",
  pathParamSchema: datasetIdPathParams,
  bodySchema: addItemBodySchema,
  responseSchema: datasetItemResponseSchema,
  summary: "Add item to dataset",
  description: "Adds a new item to the dataset (auto-increments dataset version)",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { input, groundTruth, metadata } = params;
      const ds = await mastra.datasets.get({ id: datasetId });
      return await ds.addItem({ input, groundTruth, metadata });
    } catch (error) {
      if (isSchemaValidationError(error)) {
        throw new HTTPException$2(400, {
          message: error.message,
          cause: { field: error.field, errors: error.errors }
        });
      }
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error adding item to dataset");
    }
  }
});
var GET_ITEM_ROUTE = createRoute({
  method: "GET",
  path: "/datasets/:datasetId/items/:itemId",
  responseType: "json",
  pathParamSchema: datasetAndItemIdPathParams,
  responseSchema: datasetItemResponseSchema.nullable(),
  summary: "Get dataset item by ID",
  description: "Returns details for a specific dataset item",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, itemId }) => {
    assertDatasetsAvailable();
    try {
      const ds = await mastra.datasets.get({ id: datasetId });
      const item = await ds.getItem({ itemId });
      if (!item || item.datasetId !== datasetId) {
        throw new HTTPException$2(404, { message: `Item not found: ${itemId}` });
      }
      return item;
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error getting dataset item");
    }
  }
});
var UPDATE_ITEM_ROUTE = createRoute({
  method: "PATCH",
  path: "/datasets/:datasetId/items/:itemId",
  responseType: "json",
  pathParamSchema: datasetAndItemIdPathParams,
  bodySchema: updateItemBodySchema,
  responseSchema: datasetItemResponseSchema,
  summary: "Update dataset item",
  description: "Updates a dataset item (auto-increments dataset version)",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, itemId, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { input, groundTruth, metadata } = params;
      const ds = await mastra.datasets.get({ id: datasetId });
      const existing = await ds.getItem({ itemId });
      if (!existing || existing.datasetId !== datasetId) {
        throw new HTTPException$2(404, { message: `Item not found: ${itemId}` });
      }
      return await ds.updateItem({ itemId, input, groundTruth, metadata });
    } catch (error) {
      if (isSchemaValidationError(error)) {
        throw new HTTPException$2(400, {
          message: error.message,
          cause: { field: error.field, errors: error.errors }
        });
      }
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error updating dataset item");
    }
  }
});
var DELETE_ITEM_ROUTE = createRoute({
  method: "DELETE",
  path: "/datasets/:datasetId/items/:itemId",
  responseType: "json",
  pathParamSchema: datasetAndItemIdPathParams,
  responseSchema: successResponseSchema,
  summary: "Delete dataset item",
  description: "Deletes a dataset item",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, itemId }) => {
    assertDatasetsAvailable();
    try {
      const ds = await mastra.datasets.get({ id: datasetId });
      const existing = await ds.getItem({ itemId });
      if (!existing || existing.datasetId !== datasetId) {
        throw new HTTPException$2(404, { message: `Item not found: ${itemId}` });
      }
      await ds.deleteItem({ itemId });
      return { success: true };
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error deleting dataset item");
    }
  }
});
var LIST_EXPERIMENTS_ROUTE = createRoute({
  method: "GET",
  path: "/datasets/:datasetId/experiments",
  responseType: "json",
  pathParamSchema: datasetIdPathParams,
  queryParamSchema: paginationQuerySchema,
  responseSchema: listExperimentsResponseSchema,
  summary: "List experiments for dataset",
  description: "Returns a paginated list of experiments for the dataset",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { page, perPage } = params;
      const ds = await mastra.datasets.get({ id: datasetId });
      const result = await ds.listExperiments({ page: page ?? 0, perPage: perPage ?? 10 });
      return { experiments: result.experiments, pagination: result.pagination };
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error listing experiments");
    }
  }
});
var TRIGGER_EXPERIMENT_ROUTE = createRoute({
  method: "POST",
  path: "/datasets/:datasetId/experiments",
  responseType: "json",
  pathParamSchema: datasetIdPathParams,
  bodySchema: triggerExperimentBodySchema,
  responseSchema: experimentSummaryResponseSchema,
  summary: "Trigger a new experiment",
  description: "Triggers a new experiment on the dataset against the specified target. Returns immediately with pending status; execution happens in background.",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { targetType, targetId, scorerIds, version, maxConcurrency } = params;
      const ds = await mastra.datasets.get({ id: datasetId });
      const result = await ds.startExperimentAsync({
        targetType,
        targetId,
        scorers: scorerIds,
        version,
        maxConcurrency
      });
      return {
        experimentId: result.experimentId,
        status: result.status,
        totalItems: 0,
        succeededCount: 0,
        failedCount: 0,
        startedAt: /* @__PURE__ */ new Date(),
        completedAt: null,
        results: []
      };
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error triggering experiment");
    }
  }
});
var GET_EXPERIMENT_ROUTE = createRoute({
  method: "GET",
  path: "/datasets/:datasetId/experiments/:experimentId",
  responseType: "json",
  pathParamSchema: datasetAndExperimentIdPathParams,
  responseSchema: experimentResponseSchema.nullable(),
  summary: "Get experiment by ID",
  description: "Returns details for a specific experiment",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, experimentId }) => {
    assertDatasetsAvailable();
    try {
      const ds = await mastra.datasets.get({ id: datasetId });
      const run = await ds.getExperiment({ experimentId });
      if (!run || run.datasetId !== datasetId) {
        throw new HTTPException$2(404, { message: `Experiment not found: ${experimentId}` });
      }
      return run;
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error getting experiment");
    }
  }
});
var LIST_EXPERIMENT_RESULTS_ROUTE = createRoute({
  method: "GET",
  path: "/datasets/:datasetId/experiments/:experimentId/results",
  responseType: "json",
  pathParamSchema: datasetAndExperimentIdPathParams,
  queryParamSchema: paginationQuerySchema,
  responseSchema: listExperimentResultsResponseSchema,
  summary: "List experiment results",
  description: "Returns a paginated list of results for the experiment",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, experimentId, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { page, perPage } = params;
      const ds = await mastra.datasets.get({ id: datasetId });
      const run = await ds.getExperiment({ experimentId });
      if (!run || run.datasetId !== datasetId) {
        throw new HTTPException$2(404, { message: `Experiment not found: ${experimentId}` });
      }
      const result = await ds.listExperimentResults({ experimentId, page: page ?? 0, perPage: perPage ?? 10 });
      return {
        results: result.results.map(({ experimentId: _eid, ...rest }) => ({ experimentId, ...rest })),
        pagination: result.pagination
      };
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error listing experiment results");
    }
  }
});
var COMPARE_EXPERIMENTS_ROUTE = createRoute({
  method: "POST",
  path: "/datasets/:datasetId/compare",
  responseType: "json",
  pathParamSchema: datasetIdPathParams,
  bodySchema: compareExperimentsBodySchema,
  responseSchema: comparisonResponseSchema,
  summary: "Compare two experiments",
  description: "Compares two experiments to detect score regressions",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { experimentIdA, experimentIdB } = params;
      await mastra.datasets.get({ id: datasetId });
      const result = await mastra.datasets.compareExperiments({
        experimentIds: [experimentIdA, experimentIdB],
        baselineId: experimentIdA
      });
      return result;
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error comparing experiments");
    }
  }
});
var LIST_DATASET_VERSIONS_ROUTE = createRoute({
  method: "GET",
  path: "/datasets/:datasetId/versions",
  responseType: "json",
  pathParamSchema: datasetIdPathParams,
  queryParamSchema: paginationQuerySchema,
  responseSchema: listDatasetVersionsResponseSchema,
  summary: "List dataset versions",
  description: "Returns a paginated list of all versions for the dataset",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { page, perPage } = params;
      const ds = await mastra.datasets.get({ id: datasetId });
      const result = await ds.listVersions({ page: page ?? 0, perPage: perPage ?? 10 });
      return { versions: result.versions, pagination: result.pagination };
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error listing dataset versions");
    }
  }
});
var LIST_ITEM_VERSIONS_ROUTE = createRoute({
  method: "GET",
  path: "/datasets/:datasetId/items/:itemId/history",
  responseType: "json",
  pathParamSchema: datasetAndItemIdPathParams,
  responseSchema: listItemVersionsResponseSchema,
  summary: "Get item history",
  description: "Returns the full SCD-2 history of the item across all dataset versions",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, itemId }) => {
    assertDatasetsAvailable();
    try {
      const ds = await mastra.datasets.get({ id: datasetId });
      const rows = await ds.getItemHistory({ itemId });
      if (rows.length > 0 && rows[0]?.datasetId !== datasetId) {
        throw new HTTPException$2(404, { message: `Item not found in dataset: ${itemId}` });
      }
      return { history: rows };
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error listing item history");
    }
  }
});
var GET_ITEM_VERSION_ROUTE = createRoute({
  method: "GET",
  path: "/datasets/:datasetId/items/:itemId/versions/:datasetVersion",
  responseType: "json",
  pathParamSchema: datasetItemVersionPathParams,
  responseSchema: datasetItemResponseSchema.nullable(),
  summary: "Get item at specific dataset version",
  description: "Returns the item as it existed at a specific dataset version",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, itemId, datasetVersion }) => {
    assertDatasetsAvailable();
    try {
      const ds = await mastra.datasets.get({ id: datasetId });
      const item = await ds.getItem({ itemId, version: datasetVersion });
      if (!item) {
        throw new HTTPException$2(404, { message: `Item ${itemId} not found at version ${datasetVersion}` });
      }
      if (item.datasetId !== datasetId) {
        throw new HTTPException$2(404, { message: `Item not found in dataset: ${itemId}` });
      }
      return item;
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error getting item version");
    }
  }
});
var BATCH_INSERT_ITEMS_ROUTE = createRoute({
  method: "POST",
  path: "/datasets/:datasetId/items/batch",
  responseType: "json",
  pathParamSchema: datasetIdPathParams,
  bodySchema: batchInsertItemsBodySchema,
  responseSchema: batchInsertItemsResponseSchema,
  summary: "Batch insert items to dataset",
  description: "Adds multiple items to the dataset in a single operation (single version entry)",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { items } = params;
      const ds = await mastra.datasets.get({ id: datasetId });
      const addedItems = await ds.addItems({ items });
      return { items: addedItems, count: addedItems.length };
    } catch (error) {
      if (isSchemaValidationError(error)) {
        throw new HTTPException$2(400, {
          message: error.message,
          cause: { field: error.field, errors: error.errors }
        });
      }
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error batch inserting items");
    }
  }
});
var BATCH_DELETE_ITEMS_ROUTE = createRoute({
  method: "DELETE",
  path: "/datasets/:datasetId/items/batch",
  responseType: "json",
  pathParamSchema: datasetIdPathParams,
  bodySchema: batchDeleteItemsBodySchema,
  responseSchema: batchDeleteItemsResponseSchema,
  summary: "Batch delete items from dataset",
  description: "Deletes multiple items from the dataset in a single operation (single version entry)",
  tags: ["Datasets"],
  requiresAuth: true,
  handler: async ({ mastra, datasetId, ...params }) => {
    assertDatasetsAvailable();
    try {
      const { itemIds } = params;
      const ds = await mastra.datasets.get({ id: datasetId });
      await ds.deleteItems({ itemIds });
      return { success: true, deletedCount: itemIds.length };
    } catch (error) {
      if (error instanceof MastraError) {
        throw new HTTPException$2(getHttpStatusForMastraError(error.id), { message: error.message });
      }
      return handleError$1(error, "Error bulk deleting items");
    }
  }
});

var processorIdPathParams = z$1.object({
  processorId: z$1.string().describe("Unique identifier for the processor")
});
var processorConfigurationSchema = z$1.object({
  agentId: z$1.string(),
  agentName: z$1.string(),
  type: z$1.enum(["input", "output"])
});
var processorListConfigurationSchema = z$1.object({
  agentId: z$1.string(),
  type: z$1.enum(["input", "output"])
});
var serializedProcessorSchema$1 = z$1.object({
  id: z$1.string(),
  name: z$1.string().optional(),
  description: z$1.string().optional(),
  phases: z$1.array(z$1.enum(["input", "inputStep", "outputStream", "outputResult", "outputStep"])),
  agentIds: z$1.array(z$1.string()),
  configurations: z$1.array(processorListConfigurationSchema),
  isWorkflow: z$1.boolean()
});
var serializedProcessorDetailSchema = z$1.object({
  id: z$1.string(),
  name: z$1.string().optional(),
  description: z$1.string().optional(),
  phases: z$1.array(z$1.enum(["input", "inputStep", "outputStream", "outputResult", "outputStep"])),
  configurations: z$1.array(processorConfigurationSchema),
  isWorkflow: z$1.boolean()
});
var listProcessorsResponseSchema = z$1.record(z$1.string(), serializedProcessorSchema$1);
var messageContentSchema = z$1.object({
  format: z$1.literal(2).optional(),
  parts: z$1.array(z$1.any()).optional(),
  content: z$1.string().optional()
}).passthrough();
var processorMessageSchema = z$1.object({
  id: z$1.string(),
  role: z$1.enum(["user", "assistant", "system", "tool"]),
  createdAt: z$1.coerce.date().optional(),
  content: z$1.union([messageContentSchema, z$1.string()])
}).passthrough();
var executeProcessorBodySchema = z$1.object({
  phase: z$1.enum(["input", "inputStep", "outputStream", "outputResult", "outputStep"]),
  messages: z$1.array(processorMessageSchema),
  agentId: z$1.string().optional(),
  requestContext: z$1.record(z$1.string(), z$1.any()).optional()
});
var tripwireSchema = z$1.object({
  triggered: z$1.boolean(),
  reason: z$1.string().optional(),
  metadata: z$1.any().optional()
});
var executeProcessorResponseSchema = z$1.object({
  success: z$1.boolean(),
  phase: z$1.string(),
  messages: z$1.array(processorMessageSchema).optional(),
  messageList: z$1.object({
    messages: z$1.array(processorMessageSchema)
  }).optional(),
  tripwire: tripwireSchema.optional(),
  error: z$1.string().optional()
});

// src/server/handlers/processors.ts
function extractTextFromMessages(messages) {
  if (!messages || !Array.isArray(messages) || messages.length === 0) {
    return "";
  }
  const firstMessage = messages[0];
  if (firstMessage?.content?.parts) {
    const textParts = firstMessage.content.parts.filter((part) => part?.type === "text").map((part) => part?.text || "");
    return textParts.join("");
  }
  return "";
}
function detectProcessorPhases(processor) {
  if (isProcessorWorkflow(processor)) {
    return ["input", "inputStep", "outputStream", "outputResult", "outputStep"];
  }
  const phases = [];
  if (typeof processor.processInput === "function") {
    phases.push("input");
  }
  if (typeof processor.processInputStep === "function") {
    phases.push("inputStep");
  }
  if (typeof processor.processOutputStream === "function") {
    phases.push("outputStream");
  }
  if (typeof processor.processOutputResult === "function") {
    phases.push("outputResult");
  }
  if (typeof processor.processOutputStep === "function") {
    phases.push("outputStep");
  }
  return phases;
}
var LIST_PROCESSORS_ROUTE = createRoute({
  method: "GET",
  path: "/processors",
  responseType: "json",
  responseSchema: listProcessorsResponseSchema,
  summary: "List all processors",
  description: "Returns a list of all available individual processors",
  tags: ["Processors"],
  requiresAuth: true,
  handler: async ({ mastra }) => {
    try {
      const processors = mastra.listProcessors() || {};
      const processorConfigurations = mastra.listProcessorConfigurations();
      const result = {};
      for (const [processorKey, processorEntry] of Object.entries(processors)) {
        const processor = processorEntry;
        const processorId = processor.id || processorKey;
        const isWorkflow = isProcessorWorkflow(processor);
        const phases = detectProcessorPhases(processor);
        const configs = processorConfigurations.get(processorId) || [];
        const agentIds = [...new Set(configs.map((c) => c.agentId))];
        const configurations = configs.map((c) => ({ agentId: c.agentId, type: c.type }));
        result[processorId] = {
          id: processorId,
          name: processor.name || processorId,
          description: processor.description,
          phases,
          agentIds,
          configurations,
          isWorkflow
        };
      }
      return result;
    } catch (error) {
      return handleError$1(error, "Error getting processors");
    }
  }
});
var GET_PROCESSOR_BY_ID_ROUTE = createRoute({
  method: "GET",
  path: "/processors/:processorId",
  responseType: "json",
  pathParamSchema: processorIdPathParams,
  responseSchema: serializedProcessorDetailSchema,
  summary: "Get processor by ID",
  description: "Returns details for a specific processor including its phases and configurations",
  tags: ["Processors"],
  requiresAuth: true,
  handler: async ({ mastra, processorId }) => {
    try {
      let processorEntry;
      try {
        processorEntry = mastra.getProcessorById(processorId);
      } catch {
        const processors = mastra.listProcessors() || {};
        processorEntry = processors[processorId];
      }
      if (!processorEntry) {
        throw new HTTPException$2(404, { message: "Processor not found" });
      }
      const isWorkflow = isProcessorWorkflow(processorEntry);
      const phases = detectProcessorPhases(processorEntry);
      const configs = mastra.getProcessorConfigurations(processorId);
      const agents = mastra.listAgents() || {};
      const configurations = configs.map((c) => ({
        agentId: c.agentId,
        agentName: agents[c.agentId]?.name || c.agentId,
        type: c.type
      }));
      return {
        id: processorEntry.id,
        name: processorEntry.name || processorEntry.id,
        description: processorEntry.description,
        phases,
        configurations,
        isWorkflow
      };
    } catch (error) {
      return handleError$1(error, "Error getting processor");
    }
  }
});
var EXECUTE_PROCESSOR_ROUTE = createRoute({
  method: "POST",
  path: "/processors/:processorId/execute",
  responseType: "json",
  pathParamSchema: processorIdPathParams,
  bodySchema: executeProcessorBodySchema,
  responseSchema: executeProcessorResponseSchema,
  summary: "Execute processor",
  description: "Executes a specific processor with the provided input data",
  tags: ["Processors"],
  requiresAuth: true,
  handler: async ({ mastra, processorId, ...bodyParams }) => {
    try {
      const { phase, messages } = bodyParams;
      if (!processorId) {
        throw new HTTPException$2(400, { message: "Processor ID is required" });
      }
      if (!phase) {
        throw new HTTPException$2(400, { message: "Phase is required" });
      }
      if (!messages || !Array.isArray(messages)) {
        throw new HTTPException$2(400, { message: "Messages array is required" });
      }
      let processor;
      try {
        processor = mastra.getProcessorById(processorId);
      } catch {
        const processors = mastra.listProcessors() || {};
        processor = processors[processorId];
      }
      if (!processor) {
        throw new HTTPException$2(404, { message: "Processor not found" });
      }
      const messageList = new MessageList();
      messageList.add(messages, "input");
      if (isProcessorWorkflow(processor)) {
        try {
          const baseInputData = {
            phase,
            messages: messageList.get.all.db(),
            messageList,
            retryCount: 0
          };
          let inputData = baseInputData;
          switch (phase) {
            case "input":
              inputData = {
                ...inputData,
                systemMessages: []
              };
              break;
            case "inputStep":
              inputData = {
                ...inputData,
                stepNumber: 0,
                systemMessages: [],
                steps: [],
                model: "",
                tools: {},
                toolChoice: void 0,
                activeTools: [],
                providerOptions: void 0,
                modelSettings: void 0,
                structuredOutput: void 0
              };
              break;
            case "outputResult":
              break;
            case "outputStep":
              inputData = {
                ...inputData,
                stepNumber: 0,
                systemMessages: [],
                steps: [],
                finishReason: "stop",
                toolCalls: [],
                text: extractTextFromMessages(messages)
              };
              break;
            case "outputStream":
              inputData = {
                ...inputData,
                part: null,
                streamParts: [],
                state: {}
              };
              break;
          }
          const run = await processor.createRun();
          const result = await run.start({
            inputData
          });
          if (result.status === "tripwire") {
            return {
              success: false,
              phase,
              tripwire: {
                triggered: true,
                reason: result.tripwire.reason || `Tripwire triggered in workflow ${processor.id}`,
                metadata: result.tripwire.metadata
              },
              messages,
              messageList: {
                messages
              }
            };
          }
          if (result.status !== "success") {
            throw new HTTPException$2(500, {
              message: `Processor workflow ${processor.id} failed with status: ${result.status}`
            });
          }
          const output = result.result;
          let outputMessages = messages;
          if (output && typeof output === "object") {
            if ("messages" in output && Array.isArray(output.messages)) {
              outputMessages = output.messages;
            } else if ("messageList" in output && output.messageList instanceof MessageList) {
              outputMessages = output.messageList.get.all.db();
            }
          }
          return {
            success: true,
            phase,
            messages: outputMessages,
            messageList: {
              messages: outputMessages
            }
          };
        } catch (error) {
          if (error instanceof HTTPException$2) {
            throw error;
          }
          throw new HTTPException$2(500, {
            message: `Error executing processor workflow: ${error.message}`
          });
        }
      }
      let tripwireTriggered = false;
      let tripwireReason;
      let tripwireMetadata;
      const abort = (reason, options) => {
        tripwireTriggered = true;
        tripwireReason = reason;
        tripwireMetadata = options?.metadata;
        throw new Error(`TRIPWIRE:${reason || "Processor aborted"}`);
      };
      const baseContext = {
        abort,
        retryCount: 0,
        messages: messageList.get.all.db(),
        messageList,
        state: {}
      };
      try {
        let result;
        switch (phase) {
          case "input":
            if (!processor.processInput) {
              throw new HTTPException$2(400, { message: "Processor does not support input phase" });
            }
            result = await processor.processInput({
              ...baseContext,
              systemMessages: []
            });
            break;
          case "inputStep":
            if (!processor.processInputStep) {
              throw new HTTPException$2(400, { message: "Processor does not support inputStep phase" });
            }
            result = await processor.processInputStep({
              ...baseContext,
              systemMessages: [],
              stepNumber: 0,
              steps: [],
              // Pass empty/default values for all inputStep fields
              model: "",
              tools: {},
              toolChoice: void 0,
              activeTools: [],
              providerOptions: void 0,
              modelSettings: void 0,
              structuredOutput: void 0
            });
            break;
          case "outputResult":
            if (!processor.processOutputResult) {
              throw new HTTPException$2(400, { message: "Processor does not support outputResult phase" });
            }
            result = await processor.processOutputResult(baseContext);
            break;
          case "outputStep":
            if (!processor.processOutputStep) {
              throw new HTTPException$2(400, { message: "Processor does not support outputStep phase" });
            }
            result = await processor.processOutputStep({
              ...baseContext,
              systemMessages: [],
              stepNumber: 0,
              steps: [],
              finishReason: "stop",
              toolCalls: [],
              text: extractTextFromMessages(messages)
            });
            break;
          case "outputStream":
            throw new HTTPException$2(400, {
              message: "outputStream phase cannot be executed directly. Use streaming instead."
            });
          default:
            throw new HTTPException$2(400, { message: `Unknown phase: ${phase}` });
        }
        let outputMessages = messages;
        if (result) {
          if (Array.isArray(result)) {
            outputMessages = result;
          } else if (result.get && result.get.all && typeof result.get.all.db === "function") {
            outputMessages = result.get.all.db();
          } else if (result.messages) {
            outputMessages = result.messages;
          }
        }
        return {
          success: true,
          phase,
          messages: outputMessages,
          messageList: {
            messages: outputMessages
          }
        };
      } catch (error) {
        if (tripwireTriggered || error.message?.startsWith("TRIPWIRE:")) {
          return {
            success: false,
            phase,
            tripwire: {
              triggered: true,
              reason: tripwireReason || error.message?.replace("TRIPWIRE:", ""),
              metadata: tripwireMetadata
            },
            messages,
            messageList: {
              messages
            }
          };
        }
        throw error;
      }
    } catch (error) {
      return handleError$1(error, "Error executing processor");
    }
  }
});

var __create$4 = Object.create;
var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$4 = Object.getOwnPropertyNames;
var __getProtoOf$4 = Object.getPrototypeOf;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS$3 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames$4(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp$4(target, name, { get: all[name], enumerable: true });
};
var __copyProps$4 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames$4(from))
      if (!__hasOwnProp$4.call(to, key) && key !== except)
        __defProp$4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc$4(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM$3 = (mod, isNodeMode, target) => (target = mod != null ? __create$4(__getProtoOf$4(mod)) : {}, __copyProps$4(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp$4(target, "default", { value: mod, enumerable: true }) ,
  mod
));

// src/server/handlers/vector.ts
var vector_exports = {};
__export(vector_exports, {
  CREATE_INDEX_ROUTE: () => CREATE_INDEX_ROUTE,
  DELETE_INDEX_ROUTE: () => DELETE_INDEX_ROUTE,
  DESCRIBE_INDEX_ROUTE: () => DESCRIBE_INDEX_ROUTE,
  LIST_EMBEDDERS_ROUTE: () => LIST_EMBEDDERS_ROUTE,
  LIST_INDEXES_ROUTE: () => LIST_INDEXES_ROUTE,
  LIST_VECTORS_ROUTE: () => LIST_VECTORS_ROUTE,
  QUERY_VECTORS_ROUTE: () => QUERY_VECTORS_ROUTE,
  UPSERT_VECTORS_ROUTE: () => UPSERT_VECTORS_ROUTE,
  createIndex: () => createIndex,
  deleteIndex: () => deleteIndex,
  describeIndex: () => describeIndex,
  listIndexes: () => listIndexes,
  listVectorStores: () => listVectorStores,
  queryVectors: () => queryVectors,
  upsertVectors: () => upsertVectors
});
var vectorNamePathParams = z$1.object({
  vectorName: z$1.string().describe("Name of the vector store")
});
var vectorIndexPathParams = vectorNamePathParams.extend({
  indexName: z$1.string().describe("Name of the index")
});
var indexBodyBaseSchema = z$1.object({
  indexName: z$1.string()
});
var upsertVectorsBodySchema = indexBodyBaseSchema.extend({
  vectors: z$1.array(z$1.array(z$1.number())),
  metadata: z$1.array(z$1.record(z$1.string(), z$1.any())).optional(),
  ids: z$1.array(z$1.string()).optional()
});
var createIndexBodySchema = indexBodyBaseSchema.extend({
  dimension: z$1.number(),
  metric: z$1.enum(["cosine", "euclidean", "dotproduct"]).optional()
});
var queryVectorsBodySchema = indexBodyBaseSchema.extend({
  queryVector: z$1.array(z$1.number()),
  topK: z$1.number().optional(),
  filter: z$1.record(z$1.string(), z$1.any()).optional(),
  includeVector: z$1.boolean().optional()
});
var upsertVectorsResponseSchema = z$1.object({
  ids: z$1.array(z$1.string())
});
var createIndexResponseSchema = successResponseSchema;
var queryVectorsResponseSchema = z$1.array(z$1.unknown());
var listIndexesResponseSchema = z$1.array(z$1.string());
var describeIndexResponseSchema = z$1.object({
  dimension: z$1.number(),
  count: z$1.number(),
  metric: z$1.string().optional()
});
var deleteIndexResponseSchema = successResponseSchema;
var listVectorsResponseSchema = z$1.object({
  vectors: z$1.array(
    z$1.object({
      id: z$1.string(),
      name: z$1.string(),
      type: z$1.string(),
      description: z$1.string().optional()
    })
  )
});
var listEmbeddersResponseSchema = z$1.object({
  embedders: z$1.array(
    z$1.object({
      id: z$1.string(),
      provider: z$1.string(),
      name: z$1.string(),
      description: z$1.string(),
      dimensions: z$1.number(),
      maxInputTokens: z$1.number()
    })
  )
});

// src/server/handlers/vector.ts
function getVector(mastra, vectorName) {
  if (!vectorName) {
    throw new HTTPException$2(400, { message: "Vector name is required" });
  }
  const vector = mastra.getVector(vectorName);
  if (!vector) {
    throw new HTTPException$2(404, { message: `Vector store ${vectorName} not found` });
  }
  return vector;
}
async function upsertVectors({
  mastra,
  vectorName,
  indexName,
  vectors,
  metadata,
  ids
}) {
  try {
    if (!indexName || !vectors || !Array.isArray(vectors)) {
      throw new HTTPException$2(400, { message: "Invalid request index. indexName and vectors array are required." });
    }
    const vector = getVector(mastra, vectorName);
    const result = await vector.upsert({ indexName, vectors, metadata, ids });
    return { ids: result };
  } catch (error) {
    return handleError$1(error, "Error upserting vectors");
  }
}
async function createIndex({
  mastra,
  vectorName,
  indexName,
  dimension,
  metric
}) {
  try {
    if (!indexName || typeof dimension !== "number" || dimension <= 0) {
      throw new HTTPException$2(400, {
        message: "Invalid request index, indexName and positive dimension number are required."
      });
    }
    if (metric && !["cosine", "euclidean", "dotproduct"].includes(metric)) {
      throw new HTTPException$2(400, { message: "Invalid metric. Must be one of: cosine, euclidean, dotproduct" });
    }
    const vector = getVector(mastra, vectorName);
    await vector.createIndex({ indexName, dimension, metric });
    return { success: true };
  } catch (error) {
    return handleError$1(error, "Error creating index");
  }
}
async function queryVectors({
  mastra,
  vectorName,
  indexName,
  queryVector,
  topK,
  filter,
  includeVector
}) {
  try {
    if (!indexName || !queryVector || !Array.isArray(queryVector)) {
      throw new HTTPException$2(400, { message: "Invalid request query. indexName and queryVector array are required." });
    }
    const vector = getVector(mastra, vectorName);
    const results = await vector.query({ indexName, queryVector, topK, filter, includeVector });
    return results;
  } catch (error) {
    return handleError$1(error, "Error querying vectors");
  }
}
async function listIndexes({ mastra, vectorName }) {
  try {
    const vector = getVector(mastra, vectorName);
    const indexes = await vector.listIndexes();
    return indexes.filter(Boolean);
  } catch (error) {
    return handleError$1(error, "Error listing indexes");
  }
}
async function describeIndex({
  mastra,
  vectorName,
  indexName
}) {
  try {
    if (!indexName) {
      throw new HTTPException$2(400, { message: "Index name is required" });
    }
    const vector = getVector(mastra, vectorName);
    const stats = await vector.describeIndex({ indexName });
    return {
      dimension: stats.dimension,
      count: stats.count,
      metric: stats.metric?.toLowerCase()
    };
  } catch (error) {
    return handleError$1(error, "Error describing index");
  }
}
async function deleteIndex({
  mastra,
  vectorName,
  indexName
}) {
  try {
    if (!indexName) {
      throw new HTTPException$2(400, { message: "Index name is required" });
    }
    const vector = getVector(mastra, vectorName);
    await vector.deleteIndex({ indexName });
    return { success: true };
  } catch (error) {
    return handleError$1(error, "Error deleting index");
  }
}
async function listVectorStores({ mastra }) {
  try {
    const vectors = mastra.listVectors();
    if (!vectors) {
      return { vectors: [] };
    }
    const vectorList = Object.entries(vectors).map(([name, vector]) => ({
      name,
      id: vector.id,
      type: vector.constructor.name
      // Add any other metadata that might be useful
    }));
    return { vectors: vectorList };
  } catch (error) {
    return handleError$1(error, "Error listing vector stores");
  }
}
var UPSERT_VECTORS_ROUTE = createRoute({
  method: "POST",
  path: "/vector/:vectorName/upsert",
  responseType: "json",
  pathParamSchema: vectorNamePathParams,
  bodySchema: upsertVectorsBodySchema,
  responseSchema: upsertVectorsResponseSchema,
  summary: "Upsert vectors",
  description: "Inserts or updates vectors in the specified index",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra, vectorName, ...params }) => {
    try {
      const { indexName, vectors, metadata, ids } = params;
      if (!indexName || !vectors || !Array.isArray(vectors)) {
        throw new HTTPException$2(400, { message: "Invalid request index. indexName and vectors array are required." });
      }
      const vector = getVector(mastra, vectorName);
      const result = await vector.upsert({ indexName, vectors, metadata, ids });
      return { ids: result };
    } catch (error) {
      return handleError$1(error, "Error upserting vectors");
    }
  }
});
var CREATE_INDEX_ROUTE = createRoute({
  method: "POST",
  path: "/vector/:vectorName/create-index",
  responseType: "json",
  pathParamSchema: vectorNamePathParams,
  bodySchema: createIndexBodySchema,
  responseSchema: createIndexResponseSchema,
  summary: "Create index",
  description: "Creates a new vector index with the specified dimension and metric",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra, vectorName, ...params }) => {
    try {
      const { indexName, dimension, metric } = params;
      if (!indexName || typeof dimension !== "number" || dimension <= 0) {
        throw new HTTPException$2(400, {
          message: "Invalid request index, indexName and positive dimension number are required."
        });
      }
      if (metric && !["cosine", "euclidean", "dotproduct"].includes(metric)) {
        throw new HTTPException$2(400, { message: "Invalid metric. Must be one of: cosine, euclidean, dotproduct" });
      }
      const vector = getVector(mastra, vectorName);
      await vector.createIndex({ indexName, dimension, metric });
      return { success: true };
    } catch (error) {
      return handleError$1(error, "Error creating index");
    }
  }
});
var QUERY_VECTORS_ROUTE = createRoute({
  method: "POST",
  path: "/vector/:vectorName/query",
  responseType: "json",
  pathParamSchema: vectorNamePathParams,
  bodySchema: queryVectorsBodySchema,
  responseSchema: queryVectorsResponseSchema,
  summary: "Query vectors",
  description: "Performs a similarity search on the vector index",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra, vectorName, ...params }) => {
    try {
      const { indexName, queryVector, topK, filter, includeVector } = params;
      if (!indexName || !queryVector || !Array.isArray(queryVector)) {
        throw new HTTPException$2(400, {
          message: "Invalid request query. indexName and queryVector array are required."
        });
      }
      const vector = getVector(mastra, vectorName);
      const results = await vector.query({ indexName, queryVector, topK, filter, includeVector });
      return results;
    } catch (error) {
      return handleError$1(error, "Error querying vectors");
    }
  }
});
var LIST_INDEXES_ROUTE = createRoute({
  method: "GET",
  path: "/vector/:vectorName/indexes",
  responseType: "json",
  pathParamSchema: vectorNamePathParams,
  responseSchema: listIndexesResponseSchema,
  summary: "List indexes",
  description: "Returns a list of all indexes in the vector store",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra, vectorName }) => {
    try {
      const vector = getVector(mastra, vectorName);
      const indexes = await vector.listIndexes();
      return indexes.filter(Boolean);
    } catch (error) {
      return handleError$1(error, "Error listing indexes");
    }
  }
});
var DESCRIBE_INDEX_ROUTE = createRoute({
  method: "GET",
  path: "/vector/:vectorName/indexes/:indexName",
  responseType: "json",
  pathParamSchema: vectorIndexPathParams,
  responseSchema: describeIndexResponseSchema,
  summary: "Describe index",
  description: "Returns statistics and metadata for a specific index",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra, vectorName, indexName }) => {
    try {
      if (!indexName) {
        throw new HTTPException$2(400, { message: "Index name is required" });
      }
      const vector = getVector(mastra, vectorName);
      const stats = await vector.describeIndex({ indexName });
      return {
        dimension: stats.dimension,
        count: stats.count,
        metric: stats.metric?.toLowerCase()
      };
    } catch (error) {
      return handleError$1(error, "Error describing index");
    }
  }
});
var DELETE_INDEX_ROUTE = createRoute({
  method: "DELETE",
  path: "/vector/:vectorName/indexes/:indexName",
  responseType: "json",
  pathParamSchema: vectorIndexPathParams,
  responseSchema: deleteIndexResponseSchema,
  summary: "Delete index",
  description: "Deletes a vector index and all its data",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra, vectorName, indexName }) => {
    try {
      if (!indexName) {
        throw new HTTPException$2(400, { message: "Index name is required" });
      }
      const vector = getVector(mastra, vectorName);
      await vector.deleteIndex({ indexName });
      return { success: true };
    } catch (error) {
      return handleError$1(error, "Error deleting index");
    }
  }
});
var LIST_VECTORS_ROUTE = createRoute({
  method: "GET",
  path: "/vectors",
  responseType: "json",
  responseSchema: listVectorsResponseSchema,
  summary: "List vector stores",
  description: "Returns a list of all configured vector stores",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra }) => {
    try {
      const vectors = mastra.listVectors();
      if (!vectors) {
        return { vectors: [] };
      }
      const vectorList = Object.entries(vectors).map(([name, vector]) => ({
        id: vector.id || name,
        // Use the key as the ID since vectors might not have their own id property
        name,
        type: vector.constructor.name
      }));
      return { vectors: vectorList };
    } catch (error) {
      return handleError$1(error, "Error listing vector stores");
    }
  }
});
var LIST_EMBEDDERS_ROUTE = createRoute({
  method: "GET",
  path: "/embedders",
  responseType: "json",
  responseSchema: listEmbeddersResponseSchema,
  summary: "List available embedder models",
  description: "Returns a list of all available embedding models",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async () => {
    try {
      const embeddersList = EMBEDDING_MODELS.map((model) => ({
        id: `${model.provider}/${model.id}`,
        provider: model.provider,
        name: model.id,
        description: model.description || "",
        dimensions: model.dimensions,
        maxInputTokens: model.maxInputTokens
      }));
      return { embedders: embeddersList };
    } catch (error) {
      return handleError$1(error, "Error listing embedders");
    }
  }
});

// src/server/schemas/workspace.ts
z$1.object({
  path: z$1.string().describe("File or directory path (URL encoded)")
});
var workspaceIdPathParams = z$1.object({
  workspaceId: z$1.string().describe("Workspace ID")
});
var fsReadQuerySchema = z$1.object({
  path: z$1.string().describe("Path to the file to read"),
  encoding: z$1.string().optional().describe("Encoding for text files (default: utf-8)")
});
var fsListQuerySchema = z$1.object({
  path: z$1.string().describe("Path to the directory to list"),
  recursive: z$1.coerce.boolean().optional().describe("Include subdirectories")
});
var fsStatQuerySchema = z$1.object({
  path: z$1.string().describe("Path to get info about")
});
var fsDeleteQuerySchema = z$1.object({
  path: z$1.string().describe("Path to delete"),
  recursive: z$1.coerce.boolean().optional().describe("Delete directories recursively"),
  force: z$1.coerce.boolean().optional().describe("Don't error if path doesn't exist")
});
var fsWriteBodySchema = z$1.object({
  path: z$1.string().describe("Path to write to"),
  content: z$1.string().describe("Content to write (text or base64-encoded binary)"),
  encoding: z$1.enum(["utf-8", "base64"]).optional().default("utf-8").describe("Content encoding"),
  recursive: z$1.coerce.boolean().optional().describe("Create parent directories if needed")
});
var fsMkdirBodySchema = z$1.object({
  path: z$1.string().describe("Directory path to create"),
  recursive: z$1.coerce.boolean().optional().describe("Create parent directories if needed")
});
var fileEntrySchema = z$1.object({
  name: z$1.string(),
  type: z$1.enum(["file", "directory"]),
  size: z$1.number().optional(),
  mount: z$1.object({
    provider: z$1.string(),
    icon: z$1.string().optional(),
    displayName: z$1.string().optional(),
    description: z$1.string().optional(),
    status: z$1.enum([
      "pending",
      "initializing",
      "ready",
      "starting",
      "running",
      "stopping",
      "stopped",
      "destroying",
      "destroyed",
      "error"
    ]).optional(),
    error: z$1.string().optional()
  }).optional()
});
var fsReadResponseSchema = z$1.object({
  path: z$1.string(),
  content: z$1.string(),
  type: z$1.enum(["file", "directory"]),
  size: z$1.number().optional(),
  mimeType: z$1.string().optional()
});
var fsWriteResponseSchema = z$1.object({
  success: z$1.boolean(),
  path: z$1.string()
});
var fsListResponseSchema = z$1.object({
  path: z$1.string(),
  entries: z$1.array(fileEntrySchema)
});
var fsDeleteResponseSchema = z$1.object({
  success: z$1.boolean(),
  path: z$1.string()
});
var fsMkdirResponseSchema = z$1.object({
  success: z$1.boolean(),
  path: z$1.string()
});
var fsStatResponseSchema = z$1.object({
  path: z$1.string(),
  type: z$1.enum(["file", "directory"]),
  size: z$1.number().optional(),
  createdAt: z$1.string().optional(),
  modifiedAt: z$1.string().optional(),
  mimeType: z$1.string().optional()
});
var searchQuerySchema = z$1.object({
  query: z$1.string().describe("Search query text"),
  topK: z$1.coerce.number().optional().default(5).describe("Maximum number of results"),
  mode: z$1.enum(["bm25", "vector", "hybrid"]).optional().describe("Search mode"),
  minScore: z$1.coerce.number().optional().describe("Minimum relevance score threshold")
});
var searchResultSchema = z$1.object({
  id: z$1.string().describe("Document ID (file path)"),
  content: z$1.string(),
  score: z$1.number(),
  lineRange: z$1.object({
    start: z$1.number(),
    end: z$1.number()
  }).optional(),
  scoreDetails: z$1.object({
    vector: z$1.number().optional(),
    bm25: z$1.number().optional()
  }).optional()
});
var searchResponseSchema = z$1.object({
  results: z$1.array(searchResultSchema),
  query: z$1.string(),
  mode: z$1.enum(["bm25", "vector", "hybrid"])
});
var indexBodySchema = z$1.object({
  path: z$1.string().describe("Path to use as document ID"),
  content: z$1.string().describe("Content to index"),
  metadata: z$1.record(z$1.unknown()).optional().describe("Optional metadata")
});
var indexResponseSchema = z$1.object({
  success: z$1.boolean(),
  path: z$1.string()
});
var workspaceInfoResponseSchema = z$1.object({
  isWorkspaceConfigured: z$1.boolean(),
  id: z$1.string().optional(),
  name: z$1.string().optional(),
  status: z$1.string().optional(),
  capabilities: z$1.object({
    hasFilesystem: z$1.boolean(),
    hasSandbox: z$1.boolean(),
    canBM25: z$1.boolean(),
    canVector: z$1.boolean(),
    canHybrid: z$1.boolean(),
    hasSkills: z$1.boolean()
  }).optional(),
  safety: z$1.object({
    readOnly: z$1.boolean()
  }).optional(),
  filesystem: z$1.object({
    id: z$1.string(),
    name: z$1.string(),
    provider: z$1.string(),
    status: z$1.string().optional(),
    error: z$1.string().optional(),
    readOnly: z$1.boolean().optional(),
    icon: z$1.string().optional(),
    metadata: z$1.record(z$1.unknown()).optional()
  }).optional()
});
var workspaceItemSchema = z$1.object({
  id: z$1.string(),
  name: z$1.string(),
  status: z$1.string(),
  source: z$1.enum(["mastra", "agent"]),
  agentId: z$1.string().optional(),
  agentName: z$1.string().optional(),
  capabilities: z$1.object({
    hasFilesystem: z$1.boolean(),
    hasSandbox: z$1.boolean(),
    canBM25: z$1.boolean(),
    canVector: z$1.boolean(),
    canHybrid: z$1.boolean(),
    hasSkills: z$1.boolean()
  }),
  safety: z$1.object({
    readOnly: z$1.boolean()
  })
});
var listWorkspacesResponseSchema = z$1.object({
  workspaces: z$1.array(workspaceItemSchema)
});
var skillNamePathParams = workspaceIdPathParams.extend({
  skillName: z$1.string().describe("Skill name identifier")
});
var skillReferencePathParams = skillNamePathParams.extend({
  referencePath: z$1.string().describe("Reference file path (URL encoded)")
});
var searchSkillsQuerySchema = z$1.object({
  query: z$1.string().describe("Search query text"),
  topK: z$1.coerce.number().optional().default(5).describe("Maximum number of results"),
  minScore: z$1.coerce.number().optional().describe("Minimum relevance score threshold"),
  skillNames: z$1.string().optional().describe("Comma-separated list of skill names to search within"),
  includeReferences: z$1.coerce.boolean().optional().default(true).describe("Include reference files in search")
});
var skillMetadataSchema = z$1.object({
  name: z$1.string(),
  description: z$1.string(),
  license: z$1.string().optional(),
  compatibility: z$1.unknown().optional(),
  metadata: z$1.record(z$1.unknown()).optional()
});
var skillSourceSchema = z$1.discriminatedUnion("type", [
  z$1.object({ type: z$1.literal("external"), packagePath: z$1.string() }),
  z$1.object({ type: z$1.literal("local"), projectPath: z$1.string() }),
  z$1.object({ type: z$1.literal("managed"), mastraPath: z$1.string() })
]);
var skillSchema = skillMetadataSchema.extend({
  path: z$1.string(),
  instructions: z$1.string(),
  source: skillSourceSchema,
  references: z$1.array(z$1.string()),
  scripts: z$1.array(z$1.string()),
  assets: z$1.array(z$1.string())
});
var skillsShSourceSchema = z$1.object({
  owner: z$1.string().describe("GitHub owner/org"),
  repo: z$1.string().describe("GitHub repository")
});
var skillMetadataWithPathSchema = skillMetadataSchema.extend({
  path: z$1.string().describe("Path to the skill directory"),
  /** Source info for skills installed via skills.sh (from .meta.json) */
  skillsShSource: skillsShSourceSchema.optional()
});
var listSkillsResponseSchema = z$1.object({
  skills: z$1.array(skillMetadataWithPathSchema),
  isSkillsConfigured: z$1.boolean().describe("Whether skills are configured in the workspace")
});
var getSkillResponseSchema = skillSchema;
var getAgentSkillResponseSchema = skillMetadataSchema.extend({
  path: z$1.string().optional(),
  instructions: z$1.string().optional(),
  source: skillSourceSchema.optional(),
  references: z$1.array(z$1.string()).optional(),
  scripts: z$1.array(z$1.string()).optional(),
  assets: z$1.array(z$1.string()).optional()
});
var skillReferenceResponseSchema = z$1.object({
  skillName: z$1.string(),
  referencePath: z$1.string(),
  content: z$1.string()
});
var listReferencesResponseSchema = z$1.object({
  skillName: z$1.string(),
  references: z$1.array(z$1.string())
});
var skillSearchResultSchema = z$1.object({
  skillName: z$1.string(),
  source: z$1.string(),
  content: z$1.string(),
  score: z$1.number(),
  lineRange: z$1.object({
    start: z$1.number(),
    end: z$1.number()
  }).optional(),
  scoreDetails: z$1.object({
    vector: z$1.number().optional(),
    bm25: z$1.number().optional()
  }).optional()
});
var searchSkillsResponseSchema = z$1.object({
  results: z$1.array(skillSearchResultSchema),
  query: z$1.string()
});
var skillsShSearchQuerySchema = z$1.object({
  q: z$1.string().describe("Search query"),
  limit: z$1.coerce.number().optional().default(10).describe("Maximum number of results")
});
var skillsShPopularQuerySchema = z$1.object({
  limit: z$1.coerce.number().optional().default(10).describe("Maximum number of results"),
  offset: z$1.coerce.number().optional().default(0).describe("Offset for pagination")
});
var skillsShSkillSchema = z$1.object({
  id: z$1.string(),
  name: z$1.string(),
  installs: z$1.number(),
  topSource: z$1.string()
});
var skillsShSearchResponseSchema = z$1.object({
  query: z$1.string(),
  searchType: z$1.string(),
  skills: z$1.array(skillsShSkillSchema),
  count: z$1.number()
});
var skillsShListResponseSchema = z$1.object({
  skills: z$1.array(skillsShSkillSchema),
  count: z$1.number(),
  limit: z$1.number(),
  offset: z$1.number()
});
var skillsShPreviewQuerySchema = z$1.object({
  owner: z$1.string().describe("GitHub repository owner"),
  repo: z$1.string().describe("GitHub repository name"),
  path: z$1.string().describe("Path to skill within repo")
});
var skillsShPreviewResponseSchema = z$1.object({
  content: z$1.string()
});
var skillsShInstallBodySchema = z$1.object({
  owner: z$1.string().describe("GitHub repository owner"),
  repo: z$1.string().describe("GitHub repository name"),
  skillName: z$1.string().describe("Skill name from skills.sh")
});
var skillsShInstallResponseSchema = z$1.object({
  success: z$1.boolean(),
  skillName: z$1.string(),
  installedPath: z$1.string(),
  filesWritten: z$1.number()
});
var skillsShRemoveBodySchema = z$1.object({
  skillName: z$1.string().describe("Name of the installed skill to remove")
});
var skillsShRemoveResponseSchema = z$1.object({
  success: z$1.boolean(),
  skillName: z$1.string(),
  removedPath: z$1.string()
});
var skillsShUpdateBodySchema = z$1.object({
  skillName: z$1.string().optional().describe("Specific skill to update, or omit to update all")
});
var skillsShUpdateResponseSchema = z$1.object({
  updated: z$1.array(
    z$1.object({
      skillName: z$1.string(),
      success: z$1.boolean(),
      filesWritten: z$1.number().optional(),
      error: z$1.string().optional()
    })
  )
});

var agentIdPathParams = z$1.object({
  agentId: z$1.string().describe("Unique identifier for the agent")
});
var toolIdPathParams = z$1.object({
  toolId: z$1.string().describe("Unique identifier for the tool")
});
var agentToolPathParams = agentIdPathParams.extend({
  toolId: z$1.string().describe("Unique identifier for the tool")
});
var agentSkillPathParams = agentIdPathParams.extend({
  skillName: z$1.string().describe("Name of the skill")
});
var modelConfigIdPathParams = agentIdPathParams.extend({
  modelConfigId: z$1.string().describe("Unique identifier for the model configuration")
});
var serializedProcessorSchema = z$1.object({
  id: z$1.string(),
  name: z$1.string().optional()
});
var serializedToolSchema = z$1.object({
  id: z$1.string(),
  description: z$1.string().optional(),
  inputSchema: z$1.string().optional(),
  outputSchema: z$1.string().optional(),
  requireApproval: z$1.boolean().optional()
});
var serializedWorkflowSchema = z$1.object({
  name: z$1.string(),
  steps: z$1.record(
    z$1.string(),
    z$1.object({
      id: z$1.string(),
      description: z$1.string().optional()
    })
  ).optional()
});
var serializedAgentDefinitionSchema = z$1.object({
  id: z$1.string(),
  name: z$1.string()
});
var systemMessageSchema = z$1.union([
  z$1.string(),
  z$1.array(z$1.string()),
  z$1.any(),
  // CoreSystemMessage or SystemModelMessage
  z$1.array(z$1.any())
]);
var modelConfigSchema = z$1.object({
  model: z$1.object({
    modelId: z$1.string(),
    provider: z$1.string(),
    modelVersion: z$1.string()
  })
  // Additional fields from AgentModelManagerConfig can be added here
});
var serializedAgentSchema = z$1.object({
  name: z$1.string(),
  description: z$1.string().optional(),
  instructions: systemMessageSchema.optional(),
  tools: z$1.record(z$1.string(), serializedToolSchema),
  agents: z$1.record(z$1.string(), serializedAgentDefinitionSchema),
  workflows: z$1.record(z$1.string(), serializedWorkflowSchema),
  inputProcessors: z$1.array(serializedProcessorSchema),
  outputProcessors: z$1.array(serializedProcessorSchema),
  provider: z$1.string().optional(),
  modelId: z$1.string().optional(),
  modelVersion: z$1.string().optional(),
  modelList: z$1.array(modelConfigSchema).optional(),
  defaultOptions: defaultOptionsSchema.optional(),
  defaultGenerateOptionsLegacy: z$1.record(z$1.string(), z$1.any()).optional(),
  defaultStreamOptionsLegacy: z$1.record(z$1.string(), z$1.any()).optional()
});
serializedAgentSchema.extend({
  id: z$1.string()
});
var providerSchema = z$1.object({
  id: z$1.string(),
  name: z$1.string(),
  label: z$1.string().optional(),
  description: z$1.string().optional()
});
var providersResponseSchema = z$1.object({
  providers: z$1.array(providerSchema)
});
var listAgentsResponseSchema = z$1.record(z$1.string(), serializedAgentSchema);
var listToolsResponseSchema = z$1.record(z$1.string(), serializedToolSchema);
var agentMemoryOptionSchema = z$1.object({
  thread: z$1.union([z$1.string(), z$1.object({ id: z$1.string() }).passthrough()]),
  resource: z$1.string(),
  options: z$1.record(z$1.string(), z$1.any()).optional(),
  readOnly: z$1.boolean().optional()
});
var toolChoiceSchema = z$1.union([
  z$1.enum(["auto", "none", "required"]),
  z$1.object({ type: z$1.literal("tool"), toolName: z$1.string() })
]);
var agentExecutionBodySchema$1 = z$1.object({
  // REQUIRED
  messages: z$1.union([
    z$1.array(coreMessageSchema),
    // Array of messages
    z$1.string()
    // Single user message shorthand
  ]),
  // Message Configuration
  instructions: systemMessageSchema.optional(),
  system: systemMessageSchema.optional(),
  context: z$1.array(coreMessageSchema).optional(),
  // Memory & Persistence
  memory: agentMemoryOptionSchema.optional(),
  runId: z$1.string().optional(),
  savePerStep: z$1.boolean().optional(),
  // Request Context (handler-specific field - merged with server's requestContext)
  requestContext: z$1.record(z$1.string(), z$1.any()).optional(),
  // Execution Control
  maxSteps: z$1.number().optional(),
  stopWhen: z$1.any().optional(),
  // Model Configuration
  providerOptions: z$1.object({
    anthropic: z$1.record(z$1.string(), z$1.any()).optional(),
    google: z$1.record(z$1.string(), z$1.any()).optional(),
    openai: z$1.record(z$1.string(), z$1.any()).optional(),
    xai: z$1.record(z$1.string(), z$1.any()).optional()
  }).optional(),
  modelSettings: z$1.any().optional(),
  // Tool Configuration
  activeTools: z$1.array(z$1.string()).optional(),
  toolsets: z$1.record(z$1.string(), z$1.any()).optional(),
  clientTools: z$1.record(z$1.string(), z$1.any()).optional(),
  toolChoice: toolChoiceSchema.optional(),
  requireToolApproval: z$1.boolean().optional(),
  // Evaluation
  scorers: z$1.union([
    z$1.record(z$1.string(), z$1.any()),
    z$1.record(
      z$1.string(),
      z$1.object({
        scorer: z$1.string(),
        sampling: z$1.any().optional()
      })
    )
  ]).optional(),
  returnScorerData: z$1.boolean().optional(),
  // Observability
  tracingOptions: tracingOptionsSchema.optional(),
  // Structured Output
  output: z$1.any().optional(),
  // Zod schema, JSON schema, or structured output object
  structuredOutput: z$1.object({
    schema: z$1.object({}).passthrough(),
    model: z$1.union([z$1.string(), z$1.any()]).optional(),
    instructions: z$1.string().optional(),
    jsonPromptInjection: z$1.boolean().optional(),
    errorStrategy: z$1.enum(["strict", "warn", "fallback"]).optional(),
    fallbackValue: z$1.any().optional()
  }).optional()
}).passthrough();
var agentExecutionLegacyBodySchema = agentExecutionBodySchema$1.extend({
  resourceId: z$1.string().optional(),
  resourceid: z$1.string().optional(),
  // lowercase variant
  threadId: z$1.string().optional()
});
var executeToolDataBodySchema = z$1.object({
  data: z$1.custom((x) => x !== void 0, { message: "data is required" })
});
var executeToolBodySchema$1 = executeToolDataBodySchema.extend({
  requestContext: z$1.record(z$1.string(), z$1.any()).optional()
});
var executeToolContextBodySchema = executeToolDataBodySchema.extend({
  requestContext: z$1.record(z$1.string(), z$1.any()).optional()
});
var voiceSpeakersResponseSchema = z$1.array(
  z$1.object({
    voiceId: z$1.string()
  }).passthrough()
  // Allow provider-specific fields like name, language, etc.
);
var toolCallActionBodySchema = z$1.object({
  runId: z$1.string(),
  requestContext: z$1.record(z$1.string(), z$1.any()).optional(),
  toolCallId: z$1.string(),
  format: z$1.string().optional()
});
var networkToolCallActionBodySchema = z$1.object({
  runId: z$1.string(),
  requestContext: z$1.record(z$1.string(), z$1.any()).optional(),
  format: z$1.string().optional()
});
var approveToolCallBodySchema = toolCallActionBodySchema;
var declineToolCallBodySchema = toolCallActionBodySchema;
var approveNetworkToolCallBodySchema = networkToolCallActionBodySchema;
var declineNetworkToolCallBodySchema = networkToolCallActionBodySchema;
var toolCallResponseSchema = z$1.object({
  fullStream: z$1.any()
  // ReadableStream
});
var updateAgentModelBodySchema = z$1.object({
  modelId: z$1.string(),
  provider: z$1.string()
});
var reorderAgentModelListBodySchema = z$1.object({
  reorderedModelIds: z$1.array(z$1.string())
});
var updateAgentModelInModelListBodySchema = z$1.object({
  model: z$1.object({
    modelId: z$1.string(),
    provider: z$1.string()
  }).optional(),
  maxRetries: z$1.number().optional(),
  enabled: z$1.boolean().optional()
});
var modelManagementResponseSchema = messageResponseSchema;
var generateSpeechBodySchema = z$1.object({
  text: z$1.string(),
  speakerId: z$1.string().optional()
});
var transcribeSpeechBodySchema = z$1.object({
  audio: z$1.any(),
  // Buffer
  options: z$1.record(z$1.string(), z$1.any()).optional()
});
var transcribeSpeechResponseSchema = z$1.object({
  text: z$1.string()
});
var getListenerResponseSchema = z$1.any();
var generateResponseSchema = z$1.any();
var streamResponseSchema = z$1.any();
var speakResponseSchema = z$1.any();
var executeToolResponseSchema$1 = z$1.any();
var enhanceInstructionsBodySchema = z$1.object({
  instructions: z$1.string().describe("The current agent instructions to enhance"),
  comment: z$1.string().describe("User comment describing how to enhance the instructions")
});
var enhanceInstructionsResponseSchema = z$1.object({
  explanation: z$1.string().describe("Explanation of the changes made"),
  new_prompt: z$1.string().describe("The enhanced instructions")
});

function validateBody(body) {
  const errorResponse = Object.entries(body).reduce((acc, [key, value]) => {
    if (!value) {
      acc[key] = `Argument "${key}" is required`;
    }
    return acc;
  }, {});
  if (Object.keys(errorResponse).length > 0) {
    throw new HTTPException$2(400, { message: Object.values(errorResponse)[0] });
  }
}
function sanitizeBody(body, disallowedKeys) {
  for (const key of disallowedKeys) {
    if (key in body) {
      delete body[key];
    }
  }
}
function parseFilters(filters) {
  if (!filters) return void 0;
  return Object.fromEntries(
    (Array.isArray(filters) ? filters : [filters]).map((attr) => {
      const [key, ...valueParts] = attr.split(":");
      const value = valueParts.join(":");
      return [key, value];
    })
  );
}
function getEffectiveResourceId(requestContext, clientResourceId) {
  const contextResourceId = requestContext?.get(MASTRA_RESOURCE_ID_KEY);
  return contextResourceId || clientResourceId;
}
function getEffectiveThreadId(requestContext, clientThreadId) {
  const contextThreadId = requestContext?.get(MASTRA_THREAD_ID_KEY);
  return contextThreadId || clientThreadId;
}
async function validateThreadOwnership(thread, effectiveResourceId) {
  if (thread && effectiveResourceId && thread.resourceId && thread.resourceId !== effectiveResourceId) {
    throw new HTTPException$2(403, { message: "Access denied: thread belongs to a different resource" });
  }
}
async function validateRunOwnership(run, effectiveResourceId) {
  if (run && effectiveResourceId && run.resourceId && run.resourceId !== effectiveResourceId) {
    throw new HTTPException$2(403, { message: "Access denied: workflow run belongs to a different resource" });
  }
}

// src/server/handlers/agents.ts
var agents_exports = {};
__export(agents_exports, {
  APPROVE_NETWORK_TOOL_CALL_ROUTE: () => APPROVE_NETWORK_TOOL_CALL_ROUTE,
  APPROVE_TOOL_CALL_GENERATE_ROUTE: () => APPROVE_TOOL_CALL_GENERATE_ROUTE,
  APPROVE_TOOL_CALL_ROUTE: () => APPROVE_TOOL_CALL_ROUTE,
  CLONE_AGENT_ROUTE: () => CLONE_AGENT_ROUTE,
  DECLINE_NETWORK_TOOL_CALL_ROUTE: () => DECLINE_NETWORK_TOOL_CALL_ROUTE,
  DECLINE_TOOL_CALL_GENERATE_ROUTE: () => DECLINE_TOOL_CALL_GENERATE_ROUTE,
  DECLINE_TOOL_CALL_ROUTE: () => DECLINE_TOOL_CALL_ROUTE,
  ENHANCE_INSTRUCTIONS_ROUTE: () => ENHANCE_INSTRUCTIONS_ROUTE,
  GENERATE_AGENT_ROUTE: () => GENERATE_AGENT_ROUTE,
  GENERATE_AGENT_VNEXT_ROUTE: () => GENERATE_AGENT_VNEXT_ROUTE,
  GENERATE_LEGACY_ROUTE: () => GENERATE_LEGACY_ROUTE,
  GET_AGENT_BY_ID_ROUTE: () => GET_AGENT_BY_ID_ROUTE,
  GET_AGENT_SKILL_ROUTE: () => GET_AGENT_SKILL_ROUTE,
  GET_PROVIDERS_ROUTE: () => GET_PROVIDERS_ROUTE,
  LIST_AGENTS_ROUTE: () => LIST_AGENTS_ROUTE,
  REORDER_AGENT_MODEL_LIST_ROUTE: () => REORDER_AGENT_MODEL_LIST_ROUTE,
  RESET_AGENT_MODEL_ROUTE: () => RESET_AGENT_MODEL_ROUTE,
  STREAM_GENERATE_LEGACY_ROUTE: () => STREAM_GENERATE_LEGACY_ROUTE,
  STREAM_GENERATE_ROUTE: () => STREAM_GENERATE_ROUTE,
  STREAM_GENERATE_VNEXT_DEPRECATED_ROUTE: () => STREAM_GENERATE_VNEXT_DEPRECATED_ROUTE,
  STREAM_NETWORK_ROUTE: () => STREAM_NETWORK_ROUTE,
  STREAM_UI_MESSAGE_DEPRECATED_ROUTE: () => STREAM_UI_MESSAGE_DEPRECATED_ROUTE,
  STREAM_UI_MESSAGE_VNEXT_DEPRECATED_ROUTE: () => STREAM_UI_MESSAGE_VNEXT_DEPRECATED_ROUTE,
  STREAM_VNEXT_DEPRECATED_ROUTE: () => STREAM_VNEXT_DEPRECATED_ROUTE,
  UPDATE_AGENT_MODEL_IN_MODEL_LIST_ROUTE: () => UPDATE_AGENT_MODEL_IN_MODEL_LIST_ROUTE,
  UPDATE_AGENT_MODEL_ROUTE: () => UPDATE_AGENT_MODEL_ROUTE,
  getAgentFromSystem: () => getAgentFromSystem,
  getSerializedAgentTools: () => getSerializedAgentTools,
  getSerializedProcessors: () => getSerializedProcessors,
  getSerializedSkillsFromAgent: () => getSerializedSkillsFromAgent,
  getWorkspaceToolsFromAgent: () => getWorkspaceToolsFromAgent,
  isProviderConnected: () => isProviderConnected
});

// src/server/constants.ts
var WORKSPACE_TOOLS_PREFIX = "mastra_workspace";
var WORKSPACE_TOOLS = {
  FILESYSTEM: {
    READ_FILE: `${WORKSPACE_TOOLS_PREFIX}_read_file`,
    WRITE_FILE: `${WORKSPACE_TOOLS_PREFIX}_write_file`,
    EDIT_FILE: `${WORKSPACE_TOOLS_PREFIX}_edit_file`,
    LIST_FILES: `${WORKSPACE_TOOLS_PREFIX}_list_files`,
    DELETE: `${WORKSPACE_TOOLS_PREFIX}_delete`,
    FILE_STAT: `${WORKSPACE_TOOLS_PREFIX}_file_stat`,
    MKDIR: `${WORKSPACE_TOOLS_PREFIX}_mkdir`
  },
  SANDBOX: {
    EXECUTE_COMMAND: `${WORKSPACE_TOOLS_PREFIX}_execute_command`
  },
  SEARCH: {
    SEARCH: `${WORKSPACE_TOOLS_PREFIX}_search`,
    INDEX: `${WORKSPACE_TOOLS_PREFIX}_index`
  }
};
function resolveToolConfig(toolsConfig, toolName) {
  let enabled = true;
  let requireApproval = false;
  let requireReadBeforeWrite;
  if (toolsConfig) {
    if (toolsConfig.enabled !== void 0) {
      enabled = toolsConfig.enabled;
    }
    if (toolsConfig.requireApproval !== void 0) {
      requireApproval = toolsConfig.requireApproval;
    }
    const perToolConfig = toolsConfig[toolName];
    if (perToolConfig) {
      if (perToolConfig.enabled !== void 0) {
        enabled = perToolConfig.enabled;
      }
      if (perToolConfig.requireApproval !== void 0) {
        requireApproval = perToolConfig.requireApproval;
      }
      if (perToolConfig.requireReadBeforeWrite !== void 0) {
        requireReadBeforeWrite = perToolConfig.requireReadBeforeWrite;
      }
    }
  }
  return { enabled, requireApproval, requireReadBeforeWrite };
}

// src/server/handlers/agents.ts
function isProviderConnected(providerId) {
  const cleanId = providerId.includes(".") ? providerId.split(".")[0] : providerId;
  let provider = PROVIDER_REGISTRY[cleanId];
  if (!provider && !cleanId.includes("/")) {
    const registryKeys = Object.keys(PROVIDER_REGISTRY);
    const matchingKey = registryKeys.find((key) => {
      const parts = key.split("/");
      return parts.length === 2 && parts[1] === cleanId;
    });
    if (matchingKey) {
      provider = PROVIDER_REGISTRY[matchingKey];
    }
  }
  if (!provider) return false;
  const envVars = Array.isArray(provider.apiKeyEnvVar) ? provider.apiKeyEnvVar : [provider.apiKeyEnvVar];
  return envVars.every((envVar) => !!process.env[envVar]);
}
async function getSerializedAgentTools(tools, partial = false) {
  return Object.entries(tools || {}).reduce((acc, [key, tool]) => {
    const toolId = tool.id ?? `tool-${key}`;
    let inputSchemaForReturn = void 0;
    let outputSchemaForReturn = void 0;
    let requestContextSchemaForReturn = void 0;
    if (!partial) {
      try {
        if (tool.inputSchema) {
          if (tool.inputSchema && typeof tool.inputSchema === "object" && "jsonSchema" in tool.inputSchema) {
            inputSchemaForReturn = stringify(tool.inputSchema.jsonSchema);
          } else if (typeof tool.inputSchema === "function") {
            const inputSchema = tool.inputSchema();
            if (inputSchema && inputSchema.jsonSchema) {
              inputSchemaForReturn = stringify(inputSchema.jsonSchema);
            }
          } else if (tool.inputSchema) {
            inputSchemaForReturn = stringify(
              zodToJsonSchema$1(tool.inputSchema)
            );
          }
        }
        if (tool.outputSchema) {
          if (tool.outputSchema && typeof tool.outputSchema === "object" && "jsonSchema" in tool.outputSchema) {
            outputSchemaForReturn = stringify(tool.outputSchema.jsonSchema);
          } else if (typeof tool.outputSchema === "function") {
            const outputSchema = tool.outputSchema();
            if (outputSchema && outputSchema.jsonSchema) {
              outputSchemaForReturn = stringify(outputSchema.jsonSchema);
            }
          } else if (tool.outputSchema) {
            outputSchemaForReturn = stringify(
              zodToJsonSchema$1(tool.outputSchema)
            );
          }
        }
        if (tool.requestContextSchema) {
          if (tool.requestContextSchema && typeof tool.requestContextSchema === "object" && "jsonSchema" in tool.requestContextSchema) {
            requestContextSchemaForReturn = stringify(tool.requestContextSchema.jsonSchema);
          } else if (typeof tool.requestContextSchema === "function") {
            const requestContextSchema = tool.requestContextSchema();
            if (requestContextSchema && requestContextSchema.jsonSchema) {
              requestContextSchemaForReturn = stringify(requestContextSchema.jsonSchema);
            }
          } else if (tool.requestContextSchema) {
            requestContextSchemaForReturn = stringify(
              zodToJsonSchema$1(tool.requestContextSchema)
            );
          }
        }
      } catch (error) {
        console.error(`Error getting serialized tool`, {
          toolId: tool.id,
          error
        });
      }
    }
    acc[key] = {
      ...tool,
      id: toolId,
      inputSchema: inputSchemaForReturn,
      outputSchema: outputSchemaForReturn,
      requestContextSchema: requestContextSchemaForReturn
    };
    return acc;
  }, {});
}
function getSerializedProcessors(processors) {
  return processors.map((processor) => {
    return {
      id: processor.id,
      name: processor.name || processor.constructor.name
    };
  });
}
async function getSerializedSkillsFromAgent(agent, requestContext) {
  try {
    const workspace = await agent.getWorkspace({ requestContext });
    if (!workspace?.skills) {
      return [];
    }
    const skillsList = await workspace.skills.list();
    return skillsList.map((skill) => ({
      name: skill.name,
      description: skill.description,
      license: skill.license
    }));
  } catch {
    return [];
  }
}
async function getWorkspaceToolsFromAgent(agent, requestContext) {
  try {
    const workspace = await agent.getWorkspace({ requestContext });
    if (!workspace) {
      return [];
    }
    const tools = [];
    const isReadOnly = workspace.filesystem?.readOnly ?? false;
    const toolsConfig = workspace.getToolsConfig();
    const isEnabled = (toolName) => {
      return resolveToolConfig(toolsConfig, toolName).enabled;
    };
    if (workspace.filesystem) {
      if (isEnabled(WORKSPACE_TOOLS.FILESYSTEM.READ_FILE)) {
        tools.push(WORKSPACE_TOOLS.FILESYSTEM.READ_FILE);
      }
      if (isEnabled(WORKSPACE_TOOLS.FILESYSTEM.LIST_FILES)) {
        tools.push(WORKSPACE_TOOLS.FILESYSTEM.LIST_FILES);
      }
      if (isEnabled(WORKSPACE_TOOLS.FILESYSTEM.FILE_STAT)) {
        tools.push(WORKSPACE_TOOLS.FILESYSTEM.FILE_STAT);
      }
      if (!isReadOnly) {
        if (isEnabled(WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE)) {
          tools.push(WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE);
        }
        if (isEnabled(WORKSPACE_TOOLS.FILESYSTEM.EDIT_FILE)) {
          tools.push(WORKSPACE_TOOLS.FILESYSTEM.EDIT_FILE);
        }
        if (isEnabled(WORKSPACE_TOOLS.FILESYSTEM.DELETE)) {
          tools.push(WORKSPACE_TOOLS.FILESYSTEM.DELETE);
        }
        if (isEnabled(WORKSPACE_TOOLS.FILESYSTEM.MKDIR)) {
          tools.push(WORKSPACE_TOOLS.FILESYSTEM.MKDIR);
        }
      }
    }
    if (workspace.canBM25 || workspace.canVector) {
      if (isEnabled(WORKSPACE_TOOLS.SEARCH.SEARCH)) {
        tools.push(WORKSPACE_TOOLS.SEARCH.SEARCH);
      }
      if (!isReadOnly && isEnabled(WORKSPACE_TOOLS.SEARCH.INDEX)) {
        tools.push(WORKSPACE_TOOLS.SEARCH.INDEX);
      }
    }
    if (workspace.sandbox) {
      if (workspace.sandbox.executeCommand && isEnabled(WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND)) {
        tools.push(WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND);
      }
    }
    return tools;
  } catch {
    return [];
  }
}
async function getSerializedAgentDefinition({
  agent,
  requestContext
}) {
  let serializedAgentAgents = {};
  if ("listAgents" in agent) {
    const agents = await agent.listAgents({ requestContext });
    serializedAgentAgents = Object.entries(agents || {}).reduce(
      (acc, [key, agent2]) => {
        return {
          ...acc,
          [key]: { id: agent2.id, name: agent2.name }
        };
      },
      {}
    );
  }
  return serializedAgentAgents;
}
async function formatAgentList({
  id,
  mastra,
  agent,
  requestContext,
  partial = false
}) {
  const description = agent.getDescription();
  const instructions = await agent.getInstructions({ requestContext });
  const tools = await agent.listTools({ requestContext });
  const llm = await agent.getLLM({ requestContext });
  const defaultGenerateOptionsLegacy = await agent.getDefaultGenerateOptionsLegacy({ requestContext });
  const defaultStreamOptionsLegacy = await agent.getDefaultStreamOptionsLegacy({ requestContext });
  const defaultOptions = await agent.getDefaultOptions({ requestContext });
  const serializedAgentTools = await getSerializedAgentTools(tools, partial);
  let serializedAgentWorkflows = {};
  const logger = mastra.getLogger();
  if ("listWorkflows" in agent) {
    try {
      const workflows = await agent.listWorkflows({ requestContext });
      serializedAgentWorkflows = Object.entries(workflows || {}).reduce((acc, [key, workflow]) => {
        return {
          ...acc,
          [key]: {
            name: workflow.name || "Unnamed workflow"
          }
        };
      }, {});
    } catch (error) {
      logger.error("Error getting workflows for agent", { agentName: agent.name, error });
    }
  }
  const serializedAgentAgents = await getSerializedAgentDefinition({ agent, requestContext });
  let serializedInputProcessors = [];
  let serializedOutputProcessors = [];
  try {
    const configuredProcessorWorkflows = await agent.getConfiguredProcessorWorkflows();
    const inputProcessorWorkflows = configuredProcessorWorkflows.filter((w) => w.id.endsWith("-input-processor"));
    const outputProcessorWorkflows = configuredProcessorWorkflows.filter((w) => w.id.endsWith("-output-processor"));
    serializedInputProcessors = getSerializedProcessors(inputProcessorWorkflows);
    serializedOutputProcessors = getSerializedProcessors(outputProcessorWorkflows);
  } catch (error) {
    logger.error("Error getting configured processors for agent", { agentName: agent.name, error });
  }
  const serializedSkills = await getSerializedSkillsFromAgent(agent, requestContext);
  const workspaceTools = await getWorkspaceToolsFromAgent(agent, requestContext);
  let workspaceId;
  try {
    const workspace = await agent.getWorkspace({ requestContext });
    workspaceId = workspace?.id;
  } catch {
  }
  const model = llm?.getModel();
  const models = await agent.getModelList(requestContext);
  const modelList = models?.map((md) => ({
    ...md,
    model: {
      modelId: md.model.modelId,
      provider: md.model.provider,
      modelVersion: md.model.specificationVersion
    }
  }));
  let serializedRequestContextSchema;
  if (agent.requestContextSchema) {
    try {
      serializedRequestContextSchema = stringify(zodToJsonSchema$1(agent.requestContextSchema));
    } catch (error) {
      logger.error("Error serializing requestContextSchema for agent", { agentName: agent.name, error });
    }
  }
  return {
    id: agent.id || id,
    name: agent.name,
    description,
    instructions,
    agents: serializedAgentAgents,
    tools: serializedAgentTools,
    workflows: serializedAgentWorkflows,
    skills: serializedSkills,
    workspaceTools,
    workspaceId,
    inputProcessors: serializedInputProcessors,
    outputProcessors: serializedOutputProcessors,
    provider: llm?.getProvider(),
    modelId: llm?.getModelId(),
    modelVersion: model?.specificationVersion,
    defaultOptions,
    modelList,
    defaultGenerateOptionsLegacy,
    defaultStreamOptionsLegacy,
    requestContextSchema: serializedRequestContextSchema,
    source: agent.source ?? "code"
  };
}
async function getAgentFromSystem({ mastra, agentId }) {
  const logger = mastra.getLogger();
  if (!agentId) {
    throw new HTTPException$2(400, { message: "Agent ID is required" });
  }
  let agent;
  try {
    agent = mastra.getAgentById(agentId);
  } catch (error) {
    logger.debug("Error getting agent from mastra, searching agents for agent", error);
  }
  if (!agent) {
    logger.debug(`Agent ${agentId} not found, looking through sub-agents`);
    const agents = mastra.listAgents();
    if (Object.keys(agents || {}).length) {
      for (const [_, ag] of Object.entries(agents)) {
        try {
          const subAgents = await ag.listAgents();
          if (subAgents[agentId]) {
            agent = subAgents[agentId];
            break;
          }
        } catch (error) {
          logger.debug("Error getting agent from agent", error);
        }
      }
    }
  }
  if (!agent) {
    logger.debug(`Agent ${agentId} not found in code-defined agents, looking in stored agents`);
    try {
      agent = await mastra.getEditor()?.agent.getById(agentId) ?? null;
    } catch (error) {
      logger.debug("Error getting stored agent", error);
    }
  }
  if (!agent) {
    throw new HTTPException$2(404, { message: `Agent with id ${agentId} not found` });
  }
  return agent;
}
async function formatAgent({
  mastra,
  agent,
  requestContext,
  isStudio
}) {
  const description = agent.getDescription();
  const tools = await agent.listTools({ requestContext });
  const serializedAgentTools = await getSerializedAgentTools(tools);
  let serializedAgentWorkflows = {};
  if ("listWorkflows" in agent) {
    const logger = mastra.getLogger();
    try {
      const workflows = await agent.listWorkflows({ requestContext });
      serializedAgentWorkflows = Object.entries(workflows || {}).reduce((acc, [key, workflow]) => {
        return {
          ...acc,
          [key]: {
            name: workflow.name || "Unnamed workflow",
            steps: Object.entries(workflow.steps).reduce(
              (acc2, [key2, step]) => {
                return {
                  ...acc2,
                  [key2]: {
                    id: step.id,
                    description: step.description
                  }
                };
              },
              {}
            )
          }
        };
      }, {});
    } catch (error) {
      logger.error("Error getting workflows for agent", { agentName: agent.name, error });
    }
  }
  let proxyRequestContext = requestContext;
  const instructions = await agent.getInstructions({ requestContext: proxyRequestContext });
  const llm = await agent.getLLM({ requestContext });
  const defaultGenerateOptionsLegacy = await agent.getDefaultGenerateOptionsLegacy({
    requestContext: proxyRequestContext
  });
  const defaultStreamOptionsLegacy = await agent.getDefaultStreamOptionsLegacy({ requestContext: proxyRequestContext });
  const defaultOptions = await agent.getDefaultOptions({ requestContext: proxyRequestContext });
  const model = llm?.getModel();
  const models = await agent.getModelList(requestContext);
  const modelList = models?.map((md) => ({
    ...md,
    model: {
      modelId: md.model.modelId,
      provider: md.model.provider,
      modelVersion: md.model.specificationVersion
    }
  }));
  const serializedAgentAgents = await getSerializedAgentDefinition({ agent, requestContext: proxyRequestContext });
  let serializedInputProcessors = [];
  let serializedOutputProcessors = [];
  try {
    const configuredProcessorWorkflows = await agent.getConfiguredProcessorWorkflows();
    const inputProcessorWorkflows = configuredProcessorWorkflows.filter((w) => w.id.endsWith("-input-processor"));
    const outputProcessorWorkflows = configuredProcessorWorkflows.filter((w) => w.id.endsWith("-output-processor"));
    serializedInputProcessors = getSerializedProcessors(inputProcessorWorkflows);
    serializedOutputProcessors = getSerializedProcessors(outputProcessorWorkflows);
  } catch (error) {
    mastra.getLogger().error("Error getting configured processors for agent", { agentName: agent.name, error });
  }
  const serializedSkills = await getSerializedSkillsFromAgent(agent, proxyRequestContext);
  const workspaceTools = await getWorkspaceToolsFromAgent(agent, proxyRequestContext);
  let workspaceId;
  try {
    const workspace = await agent.getWorkspace({ requestContext: proxyRequestContext });
    workspaceId = workspace?.id;
  } catch {
  }
  let serializedRequestContextSchema;
  if (agent.requestContextSchema) {
    try {
      serializedRequestContextSchema = stringify(zodToJsonSchema$1(agent.requestContextSchema));
    } catch (error) {
      mastra.getLogger().error("Error serializing requestContextSchema for agent", { agentName: agent.name, error });
    }
  }
  return {
    name: agent.name,
    description,
    instructions,
    tools: serializedAgentTools,
    agents: serializedAgentAgents,
    workflows: serializedAgentWorkflows,
    skills: serializedSkills,
    workspaceTools,
    workspaceId,
    inputProcessors: serializedInputProcessors,
    outputProcessors: serializedOutputProcessors,
    provider: llm?.getProvider(),
    modelId: llm?.getModelId(),
    modelVersion: model?.specificationVersion,
    modelList,
    defaultOptions,
    defaultGenerateOptionsLegacy,
    defaultStreamOptionsLegacy,
    requestContextSchema: serializedRequestContextSchema,
    source: agent.source ?? "code"
  };
}
var LIST_AGENTS_ROUTE = createRoute({
  method: "GET",
  path: "/agents",
  responseType: "json",
  queryParamSchema: z.object({
    partial: z.string().optional()
  }),
  responseSchema: listAgentsResponseSchema,
  summary: "List all agents",
  description: "Returns a list of all available agents in the system (both code-defined and stored)",
  tags: ["Agents"],
  requiresAuth: true,
  handler: async ({ mastra, requestContext, partial }) => {
    try {
      const codeAgents = mastra.listAgents();
      const isPartial = partial === "true";
      const serializedCodeAgentsMap = await Promise.all(
        Object.entries(codeAgents).map(async ([id, agent]) => {
          return formatAgentList({ id, mastra, agent, requestContext, partial: isPartial });
        })
      );
      const serializedAgents = serializedCodeAgentsMap.reduce(
        (acc, { id, ...rest }) => {
          acc[id] = { id, ...rest };
          return acc;
        },
        {}
      );
      try {
        const editor = mastra.getEditor();
        let storedAgentsResult;
        try {
          storedAgentsResult = await editor?.agent.list();
        } catch (error) {
          console.error("Error listing stored agents:", error);
          storedAgentsResult = null;
        }
        if (storedAgentsResult?.agents) {
          for (const storedAgentConfig of storedAgentsResult.agents) {
            try {
              const agent = await editor?.agent.getById(storedAgentConfig.id);
              if (!agent) continue;
              const serialized = await formatAgentList({
                id: agent.id,
                mastra,
                agent,
                requestContext,
                partial: isPartial
              });
              if (!serializedAgents[serialized.id]) {
                serializedAgents[serialized.id] = serialized;
              }
            } catch (agentError) {
              const logger = mastra.getLogger();
              logger.warn("Failed to serialize stored agent", { agentId: storedAgentConfig.id, error: agentError });
            }
          }
        }
      } catch (storageError) {
        const logger = mastra.getLogger();
        logger.debug("Could not fetch stored agents", { error: storageError });
      }
      return serializedAgents;
    } catch (error) {
      return handleError$1(error, "Error getting agents");
    }
  }
});
var GET_AGENT_BY_ID_ROUTE = createRoute({
  method: "GET",
  path: "/agents/:agentId",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  responseSchema: serializedAgentSchema,
  summary: "Get agent by ID",
  description: "Returns details for a specific agent including configuration, tools, and memory settings",
  tags: ["Agents"],
  requiresAuth: true,
  handler: async ({ agentId, mastra, requestContext }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      const isStudio = false;
      const result = await formatAgent({
        mastra,
        agent,
        requestContext,
        isStudio
      });
      return result;
    } catch (error) {
      return handleError$1(error, "Error getting agent");
    }
  }
});
var CLONE_AGENT_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/clone",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: z.object({
    newId: z.string().optional().describe("ID for the cloned agent. If not provided, derived from agent ID."),
    newName: z.string().optional().describe('Name for the cloned agent. Defaults to "{name} (Clone)".'),
    metadata: z.record(z.string(), z.unknown()).optional(),
    authorId: z.string().optional()
  }),
  responseSchema: createStoredAgentResponseSchema,
  summary: "Clone agent",
  description: "Clones a code-defined or stored agent to a new stored agent in the database",
  tags: ["Agents"],
  requiresAuth: true,
  handler: async ({ agentId, mastra, newId, newName, metadata, authorId, requestContext }) => {
    try {
      const editor = mastra.getEditor();
      if (!editor) {
        return handleError$1(new Error("Editor is not configured on the Mastra instance"), "Error cloning agent");
      }
      const agent = await getAgentFromSystem({ mastra, agentId });
      const cloneId = toSlug(newId || `${agentId}-clone`);
      const result = await editor.agent.clone(agent, {
        newId: cloneId,
        newName,
        metadata,
        authorId,
        requestContext
      });
      return result;
    } catch (error) {
      return handleError$1(error, "Error cloning agent");
    }
  }
});
var GENERATE_AGENT_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/generate",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: agentExecutionBodySchema$1,
  responseSchema: generateResponseSchema,
  summary: "Generate agent response",
  description: "Executes an agent with the provided messages and returns the complete response",
  tags: ["Agents"],
  requiresAuth: true,
  handler: async ({ agentId, mastra, abortSignal, requestContext: serverRequestContext, ...params }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      sanitizeBody(params, ["tools"]);
      const { messages, memory: memoryOption, requestContext: bodyRequestContext, ...rest } = params;
      validateBody({ messages });
      if (bodyRequestContext && typeof bodyRequestContext === "object") {
        for (const [key, value] of Object.entries(bodyRequestContext)) {
          if (serverRequestContext.get(key) === void 0) {
            serverRequestContext.set(key, value);
          }
        }
      }
      let authorizedMemoryOption = memoryOption;
      if (memoryOption) {
        const clientThreadId = typeof memoryOption.thread === "string" ? memoryOption.thread : memoryOption.thread?.id;
        const effectiveResourceId = getEffectiveResourceId(serverRequestContext, memoryOption.resource);
        const effectiveThreadId = getEffectiveThreadId(serverRequestContext, clientThreadId);
        if (effectiveThreadId && effectiveResourceId) {
          const memoryInstance = await agent.getMemory({ requestContext: serverRequestContext });
          if (memoryInstance) {
            const thread = await memoryInstance.getThreadById({ threadId: effectiveThreadId });
            await validateThreadOwnership(thread, effectiveResourceId);
          }
        }
        authorizedMemoryOption = {
          ...memoryOption,
          resource: effectiveResourceId ?? memoryOption.resource,
          thread: effectiveThreadId ?? memoryOption.thread
        };
      }
      const result = await agent.generate(messages, {
        ...rest,
        requestContext: serverRequestContext,
        memory: authorizedMemoryOption,
        abortSignal
      });
      return result;
    } catch (error) {
      return handleError$1(error, "Error generating from agent");
    }
  }
});
var GENERATE_LEGACY_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/generate-legacy",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: agentExecutionLegacyBodySchema,
  responseSchema: generateResponseSchema,
  summary: "[DEPRECATED] Generate with legacy format",
  description: "Legacy endpoint for generating agent responses. Use /agents/:agentId/generate instead.",
  tags: ["Agents", "Legacy"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, abortSignal, requestContext, ...params }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      sanitizeBody(params, ["tools"]);
      const { messages, resourceId, resourceid, threadId, ...rest } = params;
      const clientResourceId = resourceId ?? resourceid;
      const effectiveResourceId = getEffectiveResourceId(requestContext, clientResourceId);
      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);
      validateBody({ messages });
      if (effectiveThreadId && !effectiveResourceId || !effectiveThreadId && effectiveResourceId) {
        throw new HTTPException$2(400, { message: "Both threadId or resourceId must be provided" });
      }
      if (effectiveThreadId && effectiveResourceId) {
        const memory = await agent.getMemory({ requestContext });
        if (memory) {
          const thread = await memory.getThreadById({ threadId: effectiveThreadId });
          await validateThreadOwnership(thread, effectiveResourceId);
        }
      }
      const result = await agent.generateLegacy(messages, {
        ...rest,
        abortSignal,
        resourceId: effectiveResourceId ?? "",
        threadId: effectiveThreadId ?? ""
      });
      return result;
    } catch (error) {
      return handleError$1(error, "Error generating from agent");
    }
  }
});
var STREAM_GENERATE_LEGACY_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/stream-legacy",
  responseType: "datastream-response",
  pathParamSchema: agentIdPathParams,
  bodySchema: agentExecutionLegacyBodySchema,
  responseSchema: streamResponseSchema,
  summary: "[DEPRECATED] Stream with legacy format",
  description: "Legacy endpoint for streaming agent responses. Use /agents/:agentId/stream instead.",
  tags: ["Agents", "Legacy"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, abortSignal, requestContext, ...params }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      sanitizeBody(params, ["tools"]);
      const { messages, resourceId, resourceid, threadId, ...rest } = params;
      const clientResourceId = resourceId ?? resourceid;
      const effectiveResourceId = getEffectiveResourceId(requestContext, clientResourceId);
      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);
      validateBody({ messages });
      if (effectiveThreadId && !effectiveResourceId || !effectiveThreadId && effectiveResourceId) {
        throw new HTTPException$2(400, { message: "Both threadId or resourceId must be provided" });
      }
      if (effectiveThreadId && effectiveResourceId) {
        const memory = await agent.getMemory({ requestContext });
        if (memory) {
          const thread = await memory.getThreadById({ threadId: effectiveThreadId });
          await validateThreadOwnership(thread, effectiveResourceId);
        }
      }
      const streamResult = await agent.streamLegacy(messages, {
        ...rest,
        abortSignal,
        resourceId: effectiveResourceId ?? "",
        threadId: effectiveThreadId ?? ""
      });
      const streamResponse = rest.output ? streamResult.toTextStreamResponse({
        headers: {
          "Transfer-Encoding": "chunked"
        }
      }) : streamResult.toDataStreamResponse({
        sendUsage: true,
        sendReasoning: true,
        getErrorMessage: (error) => {
          return `An error occurred while processing your request. ${error instanceof Error ? error.message : JSON.stringify(error)}`;
        },
        headers: {
          "Transfer-Encoding": "chunked"
        }
      });
      return streamResponse;
    } catch (error) {
      return handleError$1(error, "error streaming agent response");
    }
  }
});
var GET_PROVIDERS_ROUTE = createRoute({
  method: "GET",
  path: "/agents/providers",
  responseType: "json",
  responseSchema: providersResponseSchema,
  summary: "List AI providers",
  description: "Returns a list of all configured AI model providers",
  tags: ["Agents"],
  requiresAuth: true,
  handler: async () => {
    try {
      const providers = Object.entries(PROVIDER_REGISTRY).map(([id, provider]) => {
        return {
          id,
          name: provider.name,
          label: provider.label || provider.name,
          description: provider.description || "",
          envVar: provider.apiKeyEnvVar,
          connected: isProviderConnected(id),
          docUrl: provider.docUrl,
          models: [...provider.models]
          // Convert readonly array to regular array
        };
      });
      return { providers };
    } catch (error) {
      return handleError$1(error, "Error fetching providers");
    }
  }
});
var GENERATE_AGENT_VNEXT_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/generate/vnext",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: agentExecutionBodySchema$1,
  responseSchema: generateResponseSchema,
  summary: "Generate a response from an agent",
  description: "Generate a response from an agent",
  tags: ["Agents"],
  requiresAuth: true,
  handler: GENERATE_AGENT_ROUTE.handler
});
var STREAM_GENERATE_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/stream",
  responseType: "stream",
  streamFormat: "sse",
  pathParamSchema: agentIdPathParams,
  bodySchema: agentExecutionBodySchema$1,
  responseSchema: streamResponseSchema,
  summary: "Stream agent response",
  description: "Executes an agent with the provided messages and streams the response in real-time",
  tags: ["Agents"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, abortSignal, requestContext: serverRequestContext, ...params }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      sanitizeBody(params, ["tools"]);
      const { messages, memory: memoryOption, requestContext: bodyRequestContext, ...rest } = params;
      validateBody({ messages });
      if (bodyRequestContext && typeof bodyRequestContext === "object") {
        for (const [key, value] of Object.entries(bodyRequestContext)) {
          if (serverRequestContext.get(key) === void 0) {
            serverRequestContext.set(key, value);
          }
        }
      }
      let authorizedMemoryOption = memoryOption;
      if (memoryOption) {
        const clientThreadId = typeof memoryOption.thread === "string" ? memoryOption.thread : memoryOption.thread?.id;
        const effectiveResourceId = getEffectiveResourceId(serverRequestContext, memoryOption.resource);
        const effectiveThreadId = getEffectiveThreadId(serverRequestContext, clientThreadId);
        if (effectiveThreadId && effectiveResourceId) {
          const memoryInstance = await agent.getMemory({ requestContext: serverRequestContext });
          if (memoryInstance) {
            const thread = await memoryInstance.getThreadById({ threadId: effectiveThreadId });
            await validateThreadOwnership(thread, effectiveResourceId);
          }
        }
        authorizedMemoryOption = {
          ...memoryOption,
          resource: effectiveResourceId ?? memoryOption.resource,
          thread: effectiveThreadId ?? memoryOption.thread
        };
      }
      const streamResult = await agent.stream(messages, {
        ...rest,
        requestContext: serverRequestContext,
        memory: authorizedMemoryOption,
        abortSignal
      });
      return streamResult.fullStream;
    } catch (error) {
      return handleError$1(error, "error streaming agent response");
    }
  }
});
var STREAM_GENERATE_VNEXT_DEPRECATED_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/stream/vnext",
  responseType: "stream",
  pathParamSchema: agentIdPathParams,
  bodySchema: agentExecutionBodySchema$1,
  responseSchema: streamResponseSchema,
  summary: "Stream a response from an agent",
  description: "[DEPRECATED] This endpoint is deprecated. Please use /stream instead.",
  tags: ["Agents"],
  requiresAuth: true,
  deprecated: true,
  handler: STREAM_GENERATE_ROUTE.handler
});
var APPROVE_TOOL_CALL_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/approve-tool-call",
  responseType: "stream",
  streamFormat: "sse",
  pathParamSchema: agentIdPathParams,
  bodySchema: approveToolCallBodySchema,
  responseSchema: toolCallResponseSchema,
  summary: "Approve tool call",
  description: "Approves a pending tool call and continues agent execution",
  tags: ["Agents", "Tools"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, abortSignal, ...params }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      if (!params.runId) {
        throw new HTTPException$2(400, { message: "Run id is required" });
      }
      if (!params.toolCallId) {
        throw new HTTPException$2(400, { message: "Tool call id is required" });
      }
      sanitizeBody(params, ["tools"]);
      const streamResult = await agent.approveToolCall({
        ...params,
        abortSignal
      });
      return streamResult.fullStream;
    } catch (error) {
      return handleError$1(error, "error approving tool call");
    }
  }
});
var DECLINE_TOOL_CALL_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/decline-tool-call",
  responseType: "stream",
  streamFormat: "sse",
  pathParamSchema: agentIdPathParams,
  bodySchema: declineToolCallBodySchema,
  responseSchema: toolCallResponseSchema,
  summary: "Decline tool call",
  description: "Declines a pending tool call and continues agent execution without executing the tool",
  tags: ["Agents", "Tools"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, abortSignal, ...params }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      if (!params.runId) {
        throw new HTTPException$2(400, { message: "Run id is required" });
      }
      if (!params.toolCallId) {
        throw new HTTPException$2(400, { message: "Tool call id is required" });
      }
      sanitizeBody(params, ["tools"]);
      const streamResult = await agent.declineToolCall({
        ...params,
        abortSignal
      });
      return streamResult.fullStream;
    } catch (error) {
      return handleError$1(error, "error declining tool call");
    }
  }
});
var APPROVE_TOOL_CALL_GENERATE_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/approve-tool-call-generate",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: approveToolCallBodySchema,
  responseSchema: generateResponseSchema,
  summary: "Approve tool call (non-streaming)",
  description: "Approves a pending tool call and returns the complete response",
  tags: ["Agents", "Tools"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, abortSignal, ...params }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      if (!params.runId) {
        throw new HTTPException$2(400, { message: "Run id is required" });
      }
      if (!params.toolCallId) {
        throw new HTTPException$2(400, { message: "Tool call id is required" });
      }
      sanitizeBody(params, ["tools"]);
      const result = await agent.approveToolCallGenerate({
        ...params,
        abortSignal
      });
      return result;
    } catch (error) {
      return handleError$1(error, "error approving tool call");
    }
  }
});
var DECLINE_TOOL_CALL_GENERATE_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/decline-tool-call-generate",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: declineToolCallBodySchema,
  responseSchema: generateResponseSchema,
  summary: "Decline tool call (non-streaming)",
  description: "Declines a pending tool call and returns the complete response",
  tags: ["Agents", "Tools"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, abortSignal, ...params }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      if (!params.runId) {
        throw new HTTPException$2(400, { message: "Run id is required" });
      }
      if (!params.toolCallId) {
        throw new HTTPException$2(400, { message: "Tool call id is required" });
      }
      sanitizeBody(params, ["tools"]);
      const result = await agent.declineToolCallGenerate({
        ...params,
        abortSignal
      });
      return result;
    } catch (error) {
      return handleError$1(error, "error declining tool call");
    }
  }
});
var STREAM_NETWORK_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/network",
  responseType: "stream",
  streamFormat: "sse",
  pathParamSchema: agentIdPathParams,
  bodySchema: agentExecutionBodySchema$1,
  responseSchema: streamResponseSchema,
  summary: "Stream agent network",
  description: "Executes an agent network with multiple agents and streams the response",
  tags: ["Agents"],
  requiresAuth: true,
  handler: async ({ mastra, messages, agentId, ...params }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      sanitizeBody(params, ["tools"]);
      validateBody({ messages });
      const streamResult = await agent.network(messages, {
        ...params
      });
      return streamResult;
    } catch (error) {
      return handleError$1(error, "error streaming agent loop response");
    }
  }
});
var APPROVE_NETWORK_TOOL_CALL_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/approve-network-tool-call",
  responseType: "stream",
  streamFormat: "sse",
  pathParamSchema: agentIdPathParams,
  bodySchema: approveNetworkToolCallBodySchema,
  responseSchema: streamResponseSchema,
  summary: "Approve network tool call",
  description: "Approves a pending network tool call and continues network agent execution",
  tags: ["Agents", "Tools"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, ...params }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      if (!params.runId) {
        throw new HTTPException$2(400, { message: "Run id is required" });
      }
      sanitizeBody(params, ["tools"]);
      const streamResult = await agent.approveNetworkToolCall({
        ...params
      });
      return streamResult;
    } catch (error) {
      return handleError$1(error, "error approving network tool call");
    }
  }
});
var DECLINE_NETWORK_TOOL_CALL_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/decline-network-tool-call",
  responseType: "stream",
  streamFormat: "sse",
  pathParamSchema: agentIdPathParams,
  bodySchema: declineNetworkToolCallBodySchema,
  responseSchema: streamResponseSchema,
  summary: "Decline network tool call",
  description: "Declines a pending network tool call and continues network agent execution without executing the tool",
  tags: ["Agents", "Tools"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, ...params }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      if (!params.runId) {
        throw new HTTPException$2(400, { message: "Run id is required" });
      }
      sanitizeBody(params, ["tools"]);
      const streamResult = await agent.declineNetworkToolCall({
        ...params
      });
      return streamResult;
    } catch (error) {
      return handleError$1(error, "error declining network tool call");
    }
  }
});
var UPDATE_AGENT_MODEL_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/model",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: updateAgentModelBodySchema,
  responseSchema: modelManagementResponseSchema,
  summary: "Update agent model",
  description: "Updates the AI model used by the agent",
  tags: ["Agents", "Models"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, modelId, provider }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      const newModel = `${provider}/${modelId}`;
      agent.__updateModel({ model: newModel });
      return { message: "Agent model updated" };
    } catch (error) {
      return handleError$1(error, "error updating agent model");
    }
  }
});
var RESET_AGENT_MODEL_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/model/reset",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  responseSchema: modelManagementResponseSchema,
  summary: "Reset agent model",
  description: "Resets the agent model to its original configuration",
  tags: ["Agents", "Models"],
  requiresAuth: true,
  handler: async ({ mastra, agentId }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      agent.__resetToOriginalModel();
      return { message: "Agent model reset to original" };
    } catch (error) {
      return handleError$1(error, "error resetting agent model");
    }
  }
});
var REORDER_AGENT_MODEL_LIST_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/models/reorder",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: reorderAgentModelListBodySchema,
  responseSchema: modelManagementResponseSchema,
  summary: "Reorder agent model list",
  description: "Reorders the model list for agents with multiple model configurations",
  tags: ["Agents", "Models"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, reorderedModelIds }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      const modelList = await agent.getModelList();
      if (!modelList || modelList.length === 0) {
        throw new HTTPException$2(400, { message: "Agent model list is not found or empty" });
      }
      agent.reorderModels(reorderedModelIds);
      return { message: "Model list reordered" };
    } catch (error) {
      return handleError$1(error, "error reordering model list");
    }
  }
});
var UPDATE_AGENT_MODEL_IN_MODEL_LIST_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/models/:modelConfigId",
  responseType: "json",
  pathParamSchema: modelConfigIdPathParams,
  bodySchema: updateAgentModelInModelListBodySchema,
  responseSchema: modelManagementResponseSchema,
  summary: "Update model in model list",
  description: "Updates a specific model configuration in the agent model list",
  tags: ["Agents", "Models"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, modelConfigId, model: bodyModel, maxRetries, enabled }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      const modelList = await agent.getModelList();
      if (!modelList || modelList.length === 0) {
        throw new HTTPException$2(400, { message: "Agent model list is not found or empty" });
      }
      const modelConfig = modelList.find((config) => config.id === modelConfigId);
      if (!modelConfig) {
        throw new HTTPException$2(404, { message: `Model config with id ${modelConfigId} not found` });
      }
      const newModel = bodyModel?.modelId && bodyModel?.provider ? `${bodyModel.provider}/${bodyModel.modelId}` : modelConfig.model;
      const updated = {
        ...modelConfig,
        model: newModel,
        ...maxRetries !== void 0 ? { maxRetries } : {},
        ...enabled !== void 0 ? { enabled } : {}
      };
      agent.updateModelInModelList(updated);
      return { message: "Model updated in model list" };
    } catch (error) {
      return handleError$1(error, "error updating model in model list");
    }
  }
});
var ENHANCE_SYSTEM_PROMPT_INSTRUCTIONS = `You are an expert system prompt engineer, specialized in analyzing and enhancing instructions to create clear, effective, and comprehensive system prompts. Your goal is to help users transform their basic instructions into well-structured system prompts that will guide AI behavior effectively.

Follow these steps to analyze and enhance the instructions:

1. ANALYSIS PHASE
- Identify the core purpose and goals
- Extract key constraints and requirements
- Recognize domain-specific terminology and concepts
- Note any implicit assumptions that should be made explicit

2. PROMPT STRUCTURE
Create a system prompt with these components:
a) ROLE DEFINITION
    - Clear statement of the AI's role and purpose
    - Key responsibilities and scope
    - Primary stakeholders and users
b) CORE CAPABILITIES
    - Main functions and abilities
    - Specific domain knowledge required
    - Tools and resources available
c) BEHAVIORAL GUIDELINES
    - Communication style and tone
    - Decision-making framework
    - Error handling approach
    - Ethical considerations
d) CONSTRAINTS & BOUNDARIES
    - Explicit limitations
    - Out-of-scope activities
    - Security and privacy considerations
e) SUCCESS CRITERIA
    - Quality standards
    - Expected outcomes
    - Performance metrics

3. QUALITY CHECKS
Ensure the prompt is:
- Clear and unambiguous
- Comprehensive yet concise
- Properly scoped
- Technically accurate
- Ethically sound

4. OUTPUT FORMAT
Return your response as JSON with exactly these two fields:
- explanation: A brief explanation of the changes you made and why
- new_prompt: The complete enhanced system prompt as a single string

Remember: A good system prompt should be specific enough to guide behavior but flexible enough to handle edge cases. Focus on creating prompts that are clear, actionable, and aligned with the intended use case.`;
async function findConnectedModel(agent) {
  const modelList = await agent.getModelList();
  if (modelList && modelList.length > 0) {
    for (const modelConfig of modelList) {
      if (modelConfig.enabled !== false) {
        const model = modelConfig.model;
        if (isProviderConnected(model.provider)) {
          return model;
        }
      }
    }
    return null;
  }
  const defaultModel = await agent.getModel();
  if (isProviderConnected(defaultModel.provider)) {
    return defaultModel;
  }
  return null;
}
var ENHANCE_INSTRUCTIONS_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/instructions/enhance",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: enhanceInstructionsBodySchema,
  responseSchema: enhanceInstructionsResponseSchema,
  summary: "Enhance agent instructions",
  description: "Uses AI to enhance or modify agent instructions based on user feedback",
  tags: ["Agents"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, instructions, comment }) => {
    try {
      const agent = await getAgentFromSystem({ mastra, agentId });
      const model = await findConnectedModel(agent);
      if (!model) {
        throw new HTTPException$2(400, {
          message: "No model with a configured API key found. Please set the required environment variable for your model provider."
        });
      }
      const systemPromptAgent = new Agent({
        id: "system-prompt-enhancer",
        name: "system-prompt-enhancer",
        instructions: ENHANCE_SYSTEM_PROMPT_INSTRUCTIONS,
        model
      });
      const result = await systemPromptAgent.generate(
        `We need to improve the system prompt.
Current: ${instructions}
${comment ? `User feedback: ${comment}` : ""}`,
        {
          structuredOutput: {
            schema: enhanceInstructionsResponseSchema
          }
        }
      );
      return await result.object;
    } catch (error) {
      return handleError$1(error, "Error enhancing instructions");
    }
  }
});
var STREAM_VNEXT_DEPRECATED_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/streamVNext",
  responseType: "stream",
  pathParamSchema: agentIdPathParams,
  bodySchema: agentExecutionBodySchema$1,
  responseSchema: streamResponseSchema,
  summary: "Stream a response from an agent",
  description: "[DEPRECATED] This endpoint is deprecated. Please use /stream instead.",
  tags: ["Agents"],
  requiresAuth: true,
  deprecated: true,
  handler: async () => {
    throw new HTTPException$2(410, { message: "This endpoint is deprecated. Please use /stream instead." });
  }
});
var STREAM_UI_MESSAGE_VNEXT_DEPRECATED_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/stream/vnext/ui",
  responseType: "stream",
  pathParamSchema: agentIdPathParams,
  bodySchema: agentExecutionBodySchema$1,
  responseSchema: streamResponseSchema,
  summary: "Stream UI messages from an agent",
  description: "[DEPRECATED] This endpoint is deprecated. Please use the @mastra/ai-sdk package for uiMessage transformations",
  tags: ["Agents"],
  requiresAuth: true,
  deprecated: true,
  handler: async () => {
    try {
      throw new MastraError({
        category: ErrorCategory.USER,
        domain: ErrorDomain.MASTRA_SERVER,
        id: "DEPRECATED_ENDPOINT",
        text: "This endpoint is deprecated. Please use the @mastra/ai-sdk package to for uiMessage transformations"
      });
    } catch (error) {
      return handleError$1(error, "error streaming agent response");
    }
  }
});
var STREAM_UI_MESSAGE_DEPRECATED_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/stream/ui",
  responseType: "stream",
  pathParamSchema: agentIdPathParams,
  bodySchema: agentExecutionBodySchema$1,
  responseSchema: streamResponseSchema,
  summary: "Stream UI messages from an agent",
  description: "[DEPRECATED] This endpoint is deprecated. Please use the @mastra/ai-sdk package for uiMessage transformations",
  tags: ["Agents"],
  requiresAuth: true,
  deprecated: true,
  handler: STREAM_UI_MESSAGE_VNEXT_DEPRECATED_ROUTE.handler
});
var GET_AGENT_SKILL_ROUTE = createRoute({
  method: "GET",
  path: "/agents/:agentId/skills/:skillName",
  responseType: "json",
  pathParamSchema: agentSkillPathParams,
  responseSchema: getAgentSkillResponseSchema,
  summary: "Get agent skill",
  description: "Returns details for a specific skill available to the agent via its workspace",
  tags: ["Agents", "Skills"],
  handler: async ({ mastra, agentId, skillName, requestContext }) => {
    try {
      const agent = agentId ? mastra.getAgentById(agentId) : null;
      if (!agent) {
        throw new HTTPException$2(404, { message: "Agent not found" });
      }
      const workspace = await agent.getWorkspace({ requestContext });
      if (!workspace?.skills) {
        throw new HTTPException$2(404, { message: "Agent does not have skills configured" });
      }
      const skill = await workspace.skills.get(skillName);
      if (!skill) {
        throw new HTTPException$2(404, { message: `Skill "${skillName}" not found` });
      }
      return {
        name: skill.name,
        description: skill.description,
        license: skill.license,
        compatibility: skill.compatibility,
        metadata: skill.metadata,
        path: skill.path,
        instructions: skill.instructions,
        source: skill.source,
        references: skill.references,
        scripts: skill.scripts,
        assets: skill.assets
      };
    } catch (error) {
      return handleError$1(error, "Error getting agent skill");
    }
  }
});

// src/server/handlers/voice.ts
var voice_exports = {};
__export(voice_exports, {
  GENERATE_SPEECH_DEPRECATED_ROUTE: () => GENERATE_SPEECH_DEPRECATED_ROUTE,
  GENERATE_SPEECH_ROUTE: () => GENERATE_SPEECH_ROUTE,
  GET_LISTENER_ROUTE: () => GET_LISTENER_ROUTE,
  GET_SPEAKERS_DEPRECATED_ROUTE: () => GET_SPEAKERS_DEPRECATED_ROUTE,
  GET_SPEAKERS_ROUTE: () => GET_SPEAKERS_ROUTE,
  TRANSCRIBE_SPEECH_DEPRECATED_ROUTE: () => TRANSCRIBE_SPEECH_DEPRECATED_ROUTE,
  TRANSCRIBE_SPEECH_ROUTE: () => TRANSCRIBE_SPEECH_ROUTE
});
var GET_SPEAKERS_ROUTE = createRoute({
  method: "GET",
  path: "/agents/:agentId/voice/speakers",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  responseSchema: voiceSpeakersResponseSchema,
  summary: "Get voice speakers",
  description: "Returns available voice speakers for the specified agent",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, requestContext }) => {
    try {
      if (!agentId) {
        throw new HTTPException$2(400, { message: "Agent ID is required" });
      }
      const agent = await getAgentFromSystem({ mastra, agentId });
      const voice = await agent.getVoice({ requestContext });
      const speakers = await Promise.resolve().then(() => voice.getSpeakers()).catch((err) => {
        if (err instanceof MastraError) {
          return [];
        }
        throw err;
      });
      return speakers;
    } catch (error) {
      return handleError$1(error, "Error getting speakers");
    }
  }
});
var GET_SPEAKERS_DEPRECATED_ROUTE = createRoute({
  method: "GET",
  path: "/agents/:agentId/speakers",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  responseSchema: voiceSpeakersResponseSchema,
  summary: "Get available speakers for an agent",
  description: "[DEPRECATED] Use /agents/:agentId/voice/speakers instead. Get available speakers for an agent",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: GET_SPEAKERS_ROUTE.handler
});
var GENERATE_SPEECH_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/voice/speak",
  responseType: "stream",
  pathParamSchema: agentIdPathParams,
  bodySchema: generateSpeechBodySchema,
  responseSchema: speakResponseSchema,
  summary: "Generate speech",
  description: "Generates speech audio from text using the agent voice configuration",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, text, speakerId, requestContext }) => {
    try {
      if (!agentId) {
        throw new HTTPException$2(400, { message: "Agent ID is required" });
      }
      validateBody({ text });
      const agent = await getAgentFromSystem({ mastra, agentId });
      const voice = await agent.getVoice({ requestContext });
      if (!voice) {
        throw new HTTPException$2(400, { message: "Agent does not have voice capabilities" });
      }
      const audioStream = await Promise.resolve().then(() => voice.speak(text, { speaker: speakerId })).catch((err) => {
        if (err instanceof MastraError) {
          throw new HTTPException$2(400, { message: err.message });
        }
        throw err;
      });
      if (!audioStream) {
        throw new HTTPException$2(500, { message: "Failed to generate speech" });
      }
      return audioStream;
    } catch (error) {
      return handleError$1(error, "Error generating speech");
    }
  }
});
var GENERATE_SPEECH_DEPRECATED_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/speak",
  responseType: "stream",
  pathParamSchema: agentIdPathParams,
  bodySchema: generateSpeechBodySchema,
  responseSchema: speakResponseSchema,
  summary: "Convert text to speech",
  description: "[DEPRECATED] Use /agents/:agentId/voice/speak instead. Convert text to speech using the agent's voice provider",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: GENERATE_SPEECH_ROUTE.handler
});
var TRANSCRIBE_SPEECH_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/voice/listen",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: transcribeSpeechBodySchema,
  responseSchema: transcribeSpeechResponseSchema,
  summary: "Transcribe speech",
  description: "Transcribes speech audio to text using the agent voice configuration",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, audio, options, requestContext }) => {
    try {
      if (!agentId) {
        throw new HTTPException$2(400, { message: "Agent ID is required" });
      }
      if (!audio) {
        throw new HTTPException$2(400, { message: "Audio data is required" });
      }
      const agent = await getAgentFromSystem({ mastra, agentId });
      const voice = await agent.getVoice({ requestContext });
      if (!voice) {
        throw new HTTPException$2(400, { message: "Agent does not have voice capabilities" });
      }
      const audioStream = new Readable();
      audioStream.push(audio);
      audioStream.push(null);
      const text = await voice.listen(audioStream, options);
      return { text };
    } catch (error) {
      return handleError$1(error, "Error transcribing speech");
    }
  }
});
var TRANSCRIBE_SPEECH_DEPRECATED_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/listen",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: transcribeSpeechBodySchema,
  responseSchema: transcribeSpeechResponseSchema,
  summary: "Convert speech to text",
  description: "[DEPRECATED] Use /agents/:agentId/voice/listen instead. Convert speech to text using the agent's voice provider. Additional provider-specific options can be passed as query parameters.",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: TRANSCRIBE_SPEECH_ROUTE.handler
});
var GET_LISTENER_ROUTE = createRoute({
  method: "GET",
  path: "/agents/:agentId/voice/listener",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  responseSchema: getListenerResponseSchema,
  summary: "Get voice listener",
  description: "Returns the voice listener configuration for the agent",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, requestContext }) => {
    try {
      if (!agentId) {
        throw new HTTPException$2(400, { message: "Agent ID is required" });
      }
      const agent = mastra.getAgentById(agentId);
      if (!agent) {
        throw new HTTPException$2(404, { message: "Agent not found" });
      }
      const voice = await agent.getVoice({ requestContext });
      const listeners = await Promise.resolve().then(() => voice.getListener()).catch((err) => {
        if (err instanceof MastraError) {
          return { enabled: false };
        }
        throw err;
      });
      return listeners;
    } catch (error) {
      return handleError$1(error, "Error getting listeners");
    }
  }
});

// src/server/handlers/workspace.ts
var workspace_exports = {};
__export(workspace_exports, {
  GET_WORKSPACE_ROUTE: () => GET_WORKSPACE_ROUTE,
  LIST_WORKSPACES_ROUTE: () => LIST_WORKSPACES_ROUTE,
  WORKSPACE_FS_DELETE_ROUTE: () => WORKSPACE_FS_DELETE_ROUTE,
  WORKSPACE_FS_LIST_ROUTE: () => WORKSPACE_FS_LIST_ROUTE,
  WORKSPACE_FS_MKDIR_ROUTE: () => WORKSPACE_FS_MKDIR_ROUTE,
  WORKSPACE_FS_READ_ROUTE: () => WORKSPACE_FS_READ_ROUTE,
  WORKSPACE_FS_ROUTES: () => WORKSPACE_FS_ROUTES,
  WORKSPACE_FS_STAT_ROUTE: () => WORKSPACE_FS_STAT_ROUTE,
  WORKSPACE_FS_WRITE_ROUTE: () => WORKSPACE_FS_WRITE_ROUTE,
  WORKSPACE_GET_SKILL_REFERENCE_ROUTE: () => WORKSPACE_GET_SKILL_REFERENCE_ROUTE,
  WORKSPACE_GET_SKILL_ROUTE: () => WORKSPACE_GET_SKILL_ROUTE,
  WORKSPACE_INDEX_ROUTE: () => WORKSPACE_INDEX_ROUTE,
  WORKSPACE_LIST_SKILLS_ROUTE: () => WORKSPACE_LIST_SKILLS_ROUTE,
  WORKSPACE_LIST_SKILL_REFERENCES_ROUTE: () => WORKSPACE_LIST_SKILL_REFERENCES_ROUTE,
  WORKSPACE_SEARCH_ROUTE: () => WORKSPACE_SEARCH_ROUTE,
  WORKSPACE_SEARCH_ROUTES: () => WORKSPACE_SEARCH_ROUTES,
  WORKSPACE_SEARCH_SKILLS_ROUTE: () => WORKSPACE_SEARCH_SKILLS_ROUTE,
  WORKSPACE_SKILLS_ROUTES: () => WORKSPACE_SKILLS_ROUTES,
  WORKSPACE_SKILLS_SH_INSTALL_ROUTE: () => WORKSPACE_SKILLS_SH_INSTALL_ROUTE,
  WORKSPACE_SKILLS_SH_POPULAR_ROUTE: () => WORKSPACE_SKILLS_SH_POPULAR_ROUTE,
  WORKSPACE_SKILLS_SH_PREVIEW_ROUTE: () => WORKSPACE_SKILLS_SH_PREVIEW_ROUTE,
  WORKSPACE_SKILLS_SH_REMOVE_ROUTE: () => WORKSPACE_SKILLS_SH_REMOVE_ROUTE,
  WORKSPACE_SKILLS_SH_ROUTES: () => WORKSPACE_SKILLS_SH_ROUTES,
  WORKSPACE_SKILLS_SH_SEARCH_ROUTE: () => WORKSPACE_SKILLS_SH_SEARCH_ROUTE,
  WORKSPACE_SKILLS_SH_UPDATE_ROUTE: () => WORKSPACE_SKILLS_SH_UPDATE_ROUTE
});
var SKILLS_SH_DIR = ".agents/skills";
function isFilesystemNotFoundError(error) {
  if (!error || typeof error !== "object") return false;
  if ("code" in error && error.code === "ENOENT") return true;
  if ("name" in error) {
    const name = error.name;
    if (name === "FileNotFoundError" || name === "DirectoryNotFoundError") return true;
  }
  return false;
}
function handleWorkspaceError(error, defaultMessage) {
  if (isFilesystemNotFoundError(error)) {
    const message = error instanceof Error ? error.message : "Not found";
    throw new HTTPException$2(404, { message });
  }
  return handleError$1(error, defaultMessage);
}
function requireWorkspaceV1Support() {
  if (!coreFeatures.has("workspaces-v1")) {
    throw new HTTPException$2(501, {
      message: "Workspace v1 not supported by this version of @mastra/core. Please upgrade to a newer version."
    });
  }
}
async function getWorkspaceById(mastra, workspaceId) {
  requireWorkspaceV1Support();
  const globalWorkspace = mastra.getWorkspace?.();
  if (globalWorkspace?.id === workspaceId) {
    return globalWorkspace;
  }
  if (typeof mastra.getWorkspaceById === "function") {
    try {
      return mastra.getWorkspaceById(workspaceId);
    } catch {
      return void 0;
    }
  }
  const agents = mastra.listAgents?.() ?? {};
  for (const agent of Object.values(agents)) {
    if (agent.hasOwnWorkspace?.()) {
      const agentWorkspace = await agent.getWorkspace?.();
      if (agentWorkspace?.id === workspaceId) {
        return agentWorkspace;
      }
    }
  }
  return void 0;
}
async function getSkillsById(mastra, workspaceId) {
  const workspace = await getWorkspaceById(mastra, workspaceId);
  return workspace?.skills;
}
var LIST_WORKSPACES_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces",
  responseType: "json",
  responseSchema: listWorkspacesResponseSchema,
  summary: "List all workspaces",
  description: "Returns all workspaces from both Mastra instance and agents",
  tags: ["Workspace"],
  handler: async ({ mastra }) => {
    try {
      requireWorkspaceV1Support();
      const workspaces = [];
      if (typeof mastra.listWorkspaces === "function") {
        const registeredWorkspaces = mastra.listWorkspaces();
        for (const [, ws] of Object.entries(registeredWorkspaces)) {
          workspaces.push({
            id: ws.id,
            name: ws.name,
            status: ws.status,
            source: "mastra",
            capabilities: {
              hasFilesystem: !!ws.filesystem,
              hasSandbox: !!ws.sandbox,
              canBM25: ws.canBM25,
              canVector: ws.canVector,
              canHybrid: ws.canHybrid,
              hasSkills: !!ws.skills
            },
            safety: {
              readOnly: ws.filesystem?.readOnly ?? false
            }
          });
        }
      } else {
        const seenIds = /* @__PURE__ */ new Set();
        const globalWorkspace = mastra.getWorkspace?.();
        if (globalWorkspace) {
          seenIds.add(globalWorkspace.id);
          workspaces.push({
            id: globalWorkspace.id,
            name: globalWorkspace.name,
            status: globalWorkspace.status,
            source: "mastra",
            capabilities: {
              hasFilesystem: !!globalWorkspace.filesystem,
              hasSandbox: !!globalWorkspace.sandbox,
              canBM25: globalWorkspace.canBM25,
              canVector: globalWorkspace.canVector,
              canHybrid: globalWorkspace.canHybrid,
              hasSkills: !!globalWorkspace.skills
            },
            safety: {
              readOnly: globalWorkspace.filesystem?.readOnly ?? false
            }
          });
        }
        const agents = mastra.listAgents?.() ?? {};
        for (const [agentId, agent] of Object.entries(agents)) {
          if (agent.hasOwnWorkspace?.()) {
            try {
              const agentWorkspace = await agent.getWorkspace?.();
              if (agentWorkspace && !seenIds.has(agentWorkspace.id)) {
                seenIds.add(agentWorkspace.id);
                workspaces.push({
                  id: agentWorkspace.id,
                  name: agentWorkspace.name,
                  status: agentWorkspace.status,
                  source: "agent",
                  agentId,
                  agentName: agent.name,
                  capabilities: {
                    hasFilesystem: !!agentWorkspace.filesystem,
                    hasSandbox: !!agentWorkspace.sandbox,
                    canBM25: agentWorkspace.canBM25,
                    canVector: agentWorkspace.canVector,
                    canHybrid: agentWorkspace.canHybrid,
                    hasSkills: !!agentWorkspace.skills
                  },
                  safety: {
                    readOnly: agentWorkspace.filesystem?.readOnly ?? false
                  }
                });
              }
            } catch {
              continue;
            }
          }
        }
      }
      return { workspaces };
    } catch (error) {
      return handleWorkspaceError(error, "Error listing workspaces");
    }
  }
});
var GET_WORKSPACE_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  responseSchema: workspaceInfoResponseSchema,
  summary: "Get workspace info",
  description: "Returns information about a specific workspace and its capabilities",
  tags: ["Workspace"],
  handler: async ({ mastra, workspaceId }) => {
    try {
      const workspace = await getWorkspaceById(mastra, workspaceId);
      if (!workspace) {
        return {
          isWorkspaceConfigured: false
        };
      }
      const fsInfo = await workspace.filesystem?.getInfo?.();
      return {
        isWorkspaceConfigured: true,
        id: workspace.id,
        name: workspace.name,
        status: workspace.status,
        capabilities: {
          hasFilesystem: !!workspace.filesystem,
          hasSandbox: !!workspace.sandbox,
          canBM25: workspace.canBM25,
          canVector: workspace.canVector,
          canHybrid: workspace.canHybrid,
          hasSkills: !!workspace.skills
        },
        safety: {
          readOnly: workspace.filesystem?.readOnly ?? false
        },
        filesystem: fsInfo ? {
          id: fsInfo.id,
          name: fsInfo.name,
          provider: fsInfo.provider,
          status: fsInfo.status,
          error: fsInfo.error,
          readOnly: fsInfo.readOnly,
          icon: fsInfo.icon,
          metadata: fsInfo.metadata
        } : void 0
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error getting workspace info");
    }
  }
});
var WORKSPACE_FS_READ_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId/fs/read",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  queryParamSchema: fsReadQuerySchema,
  responseSchema: fsReadResponseSchema,
  summary: "Read file content",
  description: "Returns the content of a file at the specified path",
  tags: ["Workspace"],
  handler: async ({ mastra, path, encoding, workspaceId }) => {
    try {
      requireWorkspaceV1Support();
      if (!path) {
        throw new HTTPException$2(400, { message: "Path is required" });
      }
      const workspace = await getWorkspaceById(mastra, workspaceId);
      if (!workspace?.filesystem) {
        throw new HTTPException$2(404, { message: "No workspace filesystem configured" });
      }
      const decodedPath = decodeURIComponent(path);
      if (!await workspace.filesystem.exists(decodedPath)) {
        throw new HTTPException$2(404, { message: `Path "${decodedPath}" not found` });
      }
      const content = await workspace.filesystem.readFile(decodedPath, {
        encoding: encoding || "utf-8"
      });
      return {
        path: decodedPath,
        content: typeof content === "string" ? content : content.toString("utf-8"),
        type: "file"
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error reading file");
    }
  }
});
var WORKSPACE_FS_WRITE_ROUTE = createRoute({
  method: "POST",
  path: "/workspaces/:workspaceId/fs/write",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  bodySchema: fsWriteBodySchema,
  responseSchema: fsWriteResponseSchema,
  summary: "Write file content",
  description: "Writes content to a file at the specified path. Supports base64 encoding for binary files.",
  tags: ["Workspace"],
  handler: async ({ mastra, path, content, encoding, recursive, workspaceId }) => {
    try {
      requireWorkspaceV1Support();
      if (!path || content === void 0) {
        throw new HTTPException$2(400, { message: "Path and content are required" });
      }
      const workspace = await getWorkspaceById(mastra, workspaceId);
      if (!workspace?.filesystem) {
        throw new HTTPException$2(404, { message: "No workspace filesystem configured" });
      }
      if (workspace.filesystem?.readOnly) {
        throw new HTTPException$2(403, { message: "Workspace is in read-only mode" });
      }
      const decodedPath = decodeURIComponent(path);
      let fileContent = content;
      if (encoding === "base64") {
        fileContent = Buffer.from(content, "base64");
      }
      await workspace.filesystem.writeFile(decodedPath, fileContent, { recursive: recursive ?? true });
      return {
        success: true,
        path: decodedPath
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error writing file");
    }
  }
});
var WORKSPACE_FS_LIST_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId/fs/list",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  queryParamSchema: fsListQuerySchema,
  responseSchema: fsListResponseSchema,
  summary: "List directory contents",
  description: "Returns a list of files and directories at the specified path",
  tags: ["Workspace"],
  handler: async ({ mastra, path, recursive, workspaceId }) => {
    try {
      requireWorkspaceV1Support();
      if (!path) {
        throw new HTTPException$2(400, { message: "Path is required" });
      }
      const workspace = await getWorkspaceById(mastra, workspaceId);
      if (!workspace?.filesystem) {
        return {
          path: decodeURIComponent(path),
          entries: [],
          error: "No workspace filesystem configured"
        };
      }
      const decodedPath = decodeURIComponent(path);
      if (!await workspace.filesystem.exists(decodedPath)) {
        throw new HTTPException$2(404, { message: `Path "${decodedPath}" not found` });
      }
      const entries = await workspace.filesystem.readdir(decodedPath, { recursive });
      return {
        path: decodedPath,
        entries
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error listing directory");
    }
  }
});
var WORKSPACE_FS_DELETE_ROUTE = createRoute({
  method: "DELETE",
  path: "/workspaces/:workspaceId/fs/delete",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  queryParamSchema: fsDeleteQuerySchema,
  responseSchema: fsDeleteResponseSchema,
  summary: "Delete file or directory",
  description: "Deletes a file or directory at the specified path",
  tags: ["Workspace"],
  handler: async ({ mastra, path, recursive, force, workspaceId }) => {
    try {
      requireWorkspaceV1Support();
      if (!path) {
        throw new HTTPException$2(400, { message: "Path is required" });
      }
      const workspace = await getWorkspaceById(mastra, workspaceId);
      if (!workspace?.filesystem) {
        throw new HTTPException$2(404, { message: "No workspace filesystem configured" });
      }
      if (workspace.filesystem?.readOnly) {
        throw new HTTPException$2(403, { message: "Workspace is in read-only mode" });
      }
      const decodedPath = decodeURIComponent(path);
      const exists = await workspace.filesystem.exists(decodedPath);
      if (!exists && !force) {
        throw new HTTPException$2(404, { message: `Path "${decodedPath}" not found` });
      }
      if (exists) {
        try {
          await workspace.filesystem.deleteFile(decodedPath, { force });
        } catch {
          await workspace.filesystem.rmdir(decodedPath, { recursive, force });
        }
      }
      return {
        success: true,
        path: decodedPath
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error deleting path");
    }
  }
});
var WORKSPACE_FS_MKDIR_ROUTE = createRoute({
  method: "POST",
  path: "/workspaces/:workspaceId/fs/mkdir",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  bodySchema: fsMkdirBodySchema,
  responseSchema: fsMkdirResponseSchema,
  summary: "Create directory",
  description: "Creates a directory at the specified path",
  tags: ["Workspace"],
  handler: async ({ mastra, path, recursive, workspaceId }) => {
    try {
      requireWorkspaceV1Support();
      if (!path) {
        throw new HTTPException$2(400, { message: "Path is required" });
      }
      const workspace = await getWorkspaceById(mastra, workspaceId);
      if (!workspace?.filesystem) {
        throw new HTTPException$2(404, { message: "No workspace filesystem configured" });
      }
      if (workspace.filesystem?.readOnly) {
        throw new HTTPException$2(403, { message: "Workspace is in read-only mode" });
      }
      const decodedPath = decodeURIComponent(path);
      await workspace.filesystem.mkdir(decodedPath, { recursive: recursive ?? true });
      return {
        success: true,
        path: decodedPath
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error creating directory");
    }
  }
});
var WORKSPACE_FS_STAT_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId/fs/stat",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  queryParamSchema: fsStatQuerySchema,
  responseSchema: fsStatResponseSchema,
  summary: "Get file/directory info",
  description: "Returns metadata about a file or directory",
  tags: ["Workspace"],
  handler: async ({ mastra, path, workspaceId }) => {
    try {
      requireWorkspaceV1Support();
      if (!path) {
        throw new HTTPException$2(400, { message: "Path is required" });
      }
      const workspace = await getWorkspaceById(mastra, workspaceId);
      if (!workspace?.filesystem) {
        throw new HTTPException$2(404, { message: "No workspace filesystem configured" });
      }
      const decodedPath = decodeURIComponent(path);
      if (!await workspace.filesystem.exists(decodedPath)) {
        throw new HTTPException$2(404, { message: `Path "${decodedPath}" not found` });
      }
      const stat = await workspace.filesystem.stat(decodedPath);
      return {
        path: stat.path,
        type: stat.type,
        size: stat.size,
        createdAt: stat.createdAt?.toISOString(),
        modifiedAt: stat.modifiedAt?.toISOString(),
        mimeType: stat.mimeType
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error getting file info");
    }
  }
});
var WORKSPACE_SEARCH_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId/search",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  queryParamSchema: searchQuerySchema,
  responseSchema: searchResponseSchema,
  summary: "Search workspace content",
  description: "Searches across indexed workspace content using BM25, vector, or hybrid search",
  tags: ["Workspace"],
  handler: async ({ mastra, query, topK, mode, minScore, workspaceId }) => {
    try {
      requireWorkspaceV1Support();
      if (!query) {
        throw new HTTPException$2(400, { message: "Search query is required" });
      }
      const workspace = await getWorkspaceById(mastra, workspaceId);
      if (!workspace) {
        return {
          results: [],
          query,
          mode: mode || "bm25"
        };
      }
      const canSearch = workspace.canBM25 || workspace.canVector;
      if (!canSearch) {
        return {
          results: [],
          query,
          mode: mode || "bm25"
        };
      }
      let searchMode = mode;
      if (!searchMode) {
        if (workspace.canHybrid) {
          searchMode = "hybrid";
        } else if (workspace.canVector) {
          searchMode = "vector";
        } else {
          searchMode = "bm25";
        }
      }
      const results = await workspace.search(query, {
        topK: topK || 5,
        mode: searchMode,
        minScore
      });
      return {
        results: results.map((r) => ({
          id: r.id,
          content: r.content,
          score: r.score,
          lineRange: r.lineRange,
          scoreDetails: r.scoreDetails
        })),
        query,
        mode: searchMode
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error searching workspace");
    }
  }
});
var WORKSPACE_INDEX_ROUTE = createRoute({
  method: "POST",
  path: "/workspaces/:workspaceId/index",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  bodySchema: indexBodySchema,
  responseSchema: indexResponseSchema,
  summary: "Index content for search",
  description: "Indexes content for later search operations",
  tags: ["Workspace"],
  handler: async ({ mastra, path, content, metadata, workspaceId }) => {
    try {
      requireWorkspaceV1Support();
      if (!path || content === void 0) {
        throw new HTTPException$2(400, { message: "Path and content are required" });
      }
      const workspace = await getWorkspaceById(mastra, workspaceId);
      if (!workspace) {
        throw new HTTPException$2(404, { message: "No workspace configured" });
      }
      const canSearch = workspace.canBM25 || workspace.canVector;
      if (!canSearch) {
        throw new HTTPException$2(400, { message: "Workspace does not have search configured" });
      }
      await workspace.index(path, content, { metadata });
      return {
        success: true,
        path
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error indexing content");
    }
  }
});
var SKILLS_SH_PATH_PREFIX = `${SKILLS_SH_DIR}/`;
var WORKSPACE_LIST_SKILLS_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId/skills",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  responseSchema: listSkillsResponseSchema,
  summary: "List all skills",
  description: "Returns a list of all discovered skills with their metadata",
  tags: ["Workspace", "Skills"],
  handler: async ({ mastra, workspaceId, requestContext }) => {
    try {
      requireWorkspaceV1Support();
      const workspace = await getWorkspaceById(mastra, workspaceId);
      const skills = workspace?.skills;
      if (!skills) {
        return { skills: [], isSkillsConfigured: false };
      }
      await skills.maybeRefresh({ requestContext });
      const skillsList = await skills.list();
      const skillsWithPath = await Promise.all(
        skillsList.map(async (skillMeta) => {
          let path = "";
          let skillsShSource;
          try {
            const fullSkill = await skills.get(skillMeta.name);
            path = fullSkill?.path ?? "";
            if (path.startsWith(SKILLS_SH_PATH_PREFIX) && workspace.filesystem) {
              try {
                const metaPath = `${path}/.meta.json`;
                const metaContent = await workspace.filesystem.readFile(metaPath);
                const metaText = typeof metaContent === "string" ? metaContent : metaContent.toString("utf-8");
                const meta = JSON.parse(metaText);
                if (meta.owner && meta.repo) {
                  skillsShSource = { owner: meta.owner, repo: meta.repo };
                }
              } catch {
              }
            }
          } catch {
          }
          return {
            name: skillMeta.name,
            description: skillMeta.description,
            license: skillMeta.license,
            compatibility: skillMeta.compatibility,
            metadata: skillMeta.metadata,
            path,
            skillsShSource
          };
        })
      );
      return {
        skills: skillsWithPath,
        isSkillsConfigured: true
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error listing skills");
    }
  }
});
var WORKSPACE_GET_SKILL_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId/skills/:skillName",
  responseType: "json",
  pathParamSchema: skillNamePathParams,
  responseSchema: getSkillResponseSchema,
  summary: "Get skill details",
  description: "Returns the full details of a specific skill including instructions and file lists",
  tags: ["Workspace", "Skills"],
  handler: async ({ mastra, skillName, workspaceId, requestContext }) => {
    try {
      requireWorkspaceV1Support();
      if (!skillName) {
        throw new HTTPException$2(400, { message: "Skill name is required" });
      }
      const skills = await getSkillsById(mastra, workspaceId);
      if (!skills) {
        throw new HTTPException$2(404, { message: "No workspace with skills configured" });
      }
      await skills.maybeRefresh({ requestContext });
      const skill = await skills.get(skillName);
      if (!skill) {
        throw new HTTPException$2(404, { message: `Skill "${skillName}" not found` });
      }
      return {
        name: skill.name,
        description: skill.description,
        license: skill.license,
        compatibility: skill.compatibility,
        metadata: skill.metadata,
        path: skill.path,
        instructions: skill.instructions,
        source: skill.source,
        references: skill.references,
        scripts: skill.scripts,
        assets: skill.assets
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error getting skill");
    }
  }
});
var WORKSPACE_LIST_SKILL_REFERENCES_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId/skills/:skillName/references",
  responseType: "json",
  pathParamSchema: skillNamePathParams,
  responseSchema: listReferencesResponseSchema,
  summary: "List skill references",
  description: "Returns a list of all reference file paths for a skill",
  tags: ["Workspace", "Skills"],
  handler: async ({ mastra, skillName, workspaceId, requestContext }) => {
    try {
      requireWorkspaceV1Support();
      if (!skillName) {
        throw new HTTPException$2(400, { message: "Skill name is required" });
      }
      const skills = await getSkillsById(mastra, workspaceId);
      if (!skills) {
        throw new HTTPException$2(404, { message: "No workspace with skills configured" });
      }
      await skills.maybeRefresh({ requestContext });
      const hasSkill = await skills.has(skillName);
      if (!hasSkill) {
        throw new HTTPException$2(404, { message: `Skill "${skillName}" not found` });
      }
      const references = await skills.listReferences(skillName);
      return {
        skillName,
        references
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error listing skill references");
    }
  }
});
var WORKSPACE_GET_SKILL_REFERENCE_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId/skills/:skillName/references/:referencePath",
  responseType: "json",
  pathParamSchema: skillReferencePathParams,
  responseSchema: skillReferenceResponseSchema,
  summary: "Get skill reference content",
  description: "Returns the content of a specific reference file from a skill",
  tags: ["Workspace", "Skills"],
  handler: async ({ mastra, skillName, referencePath, workspaceId, requestContext }) => {
    try {
      requireWorkspaceV1Support();
      if (!skillName || !referencePath) {
        throw new HTTPException$2(400, { message: "Skill name and reference path are required" });
      }
      const skills = await getSkillsById(mastra, workspaceId);
      if (!skills) {
        throw new HTTPException$2(404, { message: "No workspace with skills configured" });
      }
      await skills.maybeRefresh({ requestContext });
      const decodedPath = decodeURIComponent(referencePath);
      const content = await skills.getReference(skillName, decodedPath);
      if (content === null) {
        throw new HTTPException$2(404, { message: `Reference "${decodedPath}" not found in skill "${skillName}"` });
      }
      return {
        skillName,
        referencePath: decodedPath,
        content
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error getting skill reference");
    }
  }
});
var WORKSPACE_SEARCH_SKILLS_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId/skills/search",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  queryParamSchema: searchSkillsQuerySchema,
  responseSchema: searchSkillsResponseSchema,
  summary: "Search skills",
  description: "Searches across all skills content using BM25 keyword search",
  tags: ["Workspace", "Skills"],
  handler: async ({ mastra, query, topK, minScore, skillNames, includeReferences, workspaceId, requestContext }) => {
    try {
      requireWorkspaceV1Support();
      if (!query) {
        throw new HTTPException$2(400, { message: "Search query is required" });
      }
      const skills = await getSkillsById(mastra, workspaceId);
      if (!skills) {
        return {
          results: [],
          query
        };
      }
      await skills.maybeRefresh({ requestContext });
      const skillNamesList = skillNames ? skillNames.split(",").map((s) => s.trim()) : void 0;
      const results = await skills.search(query, {
        topK: topK || 5,
        minScore,
        skillNames: skillNamesList,
        includeReferences: includeReferences ?? true
      });
      return {
        results: results.map((r) => ({
          skillName: r.skillName,
          source: r.source,
          content: r.content,
          score: r.score,
          lineRange: r.lineRange,
          scoreDetails: r.scoreDetails
        })),
        query
      };
    } catch (error) {
      return handleWorkspaceError(error, "Error searching skills");
    }
  }
});
var SKILLS_SH_API_URL = "https://skills-api-production.up.railway.app";
var WORKSPACE_SKILLS_SH_SEARCH_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId/skills-sh/search",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  queryParamSchema: skillsShSearchQuerySchema,
  responseSchema: skillsShSearchResponseSchema,
  summary: "Search skills on skills.sh",
  description: "Proxies search requests to skills.sh API to avoid CORS issues",
  tags: ["Workspace", "Skills"],
  handler: async ({ q, limit }) => {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 1e4);
      const url = `${SKILLS_SH_API_URL}/api/skills?query=${encodeURIComponent(q)}&pageSize=${limit}`;
      const response = await fetch(url, { signal: controller.signal });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new HTTPException$2(502, {
          message: `Skills API error: ${response.status} ${response.statusText}`
        });
      }
      const data = await response.json();
      return {
        query: q,
        searchType: "query",
        skills: data.skills.map((s) => ({ id: s.skillId, name: s.name, installs: s.installs, topSource: s.source })),
        count: data.total
      };
    } catch (error) {
      if (error instanceof HTTPException$2) {
        throw error;
      }
      return handleError$1(error, "Error searching skills");
    }
  }
});
var WORKSPACE_SKILLS_SH_POPULAR_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId/skills-sh/popular",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  queryParamSchema: skillsShPopularQuerySchema,
  responseSchema: skillsShListResponseSchema,
  summary: "Get popular skills from skills.sh",
  description: "Proxies popular skills requests to skills.sh API to avoid CORS issues",
  tags: ["Workspace", "Skills"],
  handler: async ({ limit, offset }) => {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 1e4);
      const page = offset > 0 ? Math.floor(offset / limit) + 1 : 1;
      const url = `${SKILLS_SH_API_URL}/api/skills/top?pageSize=${limit}&page=${page}`;
      const response = await fetch(url, { signal: controller.signal });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new HTTPException$2(502, {
          message: `Skills API error: ${response.status} ${response.statusText}`
        });
      }
      const data = await response.json();
      return {
        skills: data.skills.map((s) => ({ id: s.skillId, name: s.name, installs: s.installs, topSource: s.source })),
        count: data.total,
        limit,
        offset
      };
    } catch (error) {
      if (error instanceof HTTPException$2) {
        throw error;
      }
      return handleError$1(error, "Error fetching popular skills");
    }
  }
});
var SKILL_NAME_REGEX = /^[a-z0-9][a-z0-9-_]*$/i;
function assertSafeSkillName(name) {
  if (!SKILL_NAME_REGEX.test(name)) {
    throw new HTTPException$2(400, {
      message: `Invalid skill name "${name}". Names must start with alphanumeric and contain only letters, numbers, hyphens, and underscores.`
    });
  }
  return name;
}
function assertSafeFilePath(filePath) {
  if (filePath.startsWith("/") || /^[a-zA-Z]:/.test(filePath)) {
    throw new HTTPException$2(400, {
      message: `Invalid file path "${filePath}". Absolute paths are not allowed.`
    });
  }
  const segments = filePath.split("/");
  for (const segment of segments) {
    if (segment === ".." || segment === ".") {
      throw new HTTPException$2(400, {
        message: `Invalid file path "${filePath}". Path traversal is not allowed.`
      });
    }
  }
  return filePath;
}
async function fetchSkillFiles(owner, repo, skillName) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 3e4);
  const url = `${SKILLS_SH_API_URL}/api/skills/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/${encodeURIComponent(skillName)}/files`;
  const response = await fetch(url, { signal: controller.signal });
  clearTimeout(timeoutId);
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    throw new Error(`Skills API error: ${response.status} ${response.statusText}`);
  }
  return await response.json();
}
var WORKSPACE_SKILLS_SH_PREVIEW_ROUTE = createRoute({
  method: "GET",
  path: "/workspaces/:workspaceId/skills-sh/preview",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  queryParamSchema: skillsShPreviewQuerySchema,
  responseSchema: skillsShPreviewResponseSchema,
  summary: "Preview skill content",
  description: "Fetches the skill content from the Skills API.",
  tags: ["Workspace", "Skills"],
  handler: async ({ owner, repo, path: skillName }) => {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 1e4);
      const url = `${SKILLS_SH_API_URL}/api/skills/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/${encodeURIComponent(skillName)}/content`;
      const response = await fetch(url, { signal: controller.signal });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new HTTPException$2(404, {
          message: `Could not find skill "${skillName}" for ${owner}/${repo}`
        });
      }
      const data = await response.json();
      const content = data.instructions || data.raw || "";
      if (!content) {
        throw new HTTPException$2(404, {
          message: `No content available for skill "${skillName}"`
        });
      }
      return { content };
    } catch (error) {
      if (error instanceof HTTPException$2) {
        throw error;
      }
      return handleError$1(error, "Error fetching skill preview");
    }
  }
});
var WORKSPACE_SKILLS_SH_INSTALL_ROUTE = createRoute({
  method: "POST",
  path: "/workspaces/:workspaceId/skills-sh/install",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  bodySchema: skillsShInstallBodySchema,
  responseSchema: skillsShInstallResponseSchema,
  summary: "Install skill from Skills API",
  description: "Installs a skill by fetching files from the Skills API and writing to workspace filesystem.",
  tags: ["Workspace", "Skills"],
  handler: async ({ mastra, workspaceId, owner, repo, skillName }) => {
    try {
      requireWorkspaceV1Support();
      const workspace = await getWorkspaceById(mastra, workspaceId);
      if (!workspace) {
        throw new HTTPException$2(404, { message: "Workspace not found" });
      }
      if (!workspace.filesystem) {
        throw new HTTPException$2(400, { message: "Workspace filesystem not available" });
      }
      if (workspace.filesystem.readOnly) {
        throw new HTTPException$2(403, { message: "Workspace is read-only" });
      }
      const result = await fetchSkillFiles(owner, repo, skillName);
      if (!result || result.files.length === 0) {
        throw new HTTPException$2(404, {
          message: `Could not find skill "${skillName}" in ${owner}/${repo}.`
        });
      }
      const safeSkillId = assertSafeSkillName(result.skillId);
      const installPath = `${SKILLS_SH_DIR}/${safeSkillId}`;
      try {
        await workspace.filesystem.mkdir(installPath, { recursive: true });
      } catch {
      }
      let filesWritten = 0;
      for (const file of result.files) {
        const safePath = assertSafeFilePath(file.path);
        const filePath = `${installPath}/${safePath}`;
        if (safePath.includes("/")) {
          const dirPath = filePath.substring(0, filePath.lastIndexOf("/"));
          try {
            await workspace.filesystem.mkdir(dirPath, { recursive: true });
          } catch {
          }
        }
        const content = file.encoding === "base64" ? Buffer.from(file.content, "base64") : file.content;
        await workspace.filesystem.writeFile(filePath, content);
        filesWritten++;
      }
      const metadata = {
        skillName: result.skillId,
        owner: result.owner,
        repo: result.repo,
        branch: result.branch,
        installedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      await workspace.filesystem.writeFile(`${installPath}/.meta.json`, JSON.stringify(metadata, null, 2));
      filesWritten++;
      return {
        success: true,
        skillName: result.skillId,
        installedPath: installPath,
        filesWritten
      };
    } catch (error) {
      if (error instanceof HTTPException$2) {
        throw error;
      }
      return handleError$1(error, "Error installing skill");
    }
  }
});
var WORKSPACE_SKILLS_SH_REMOVE_ROUTE = createRoute({
  method: "POST",
  path: "/workspaces/:workspaceId/skills-sh/remove",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  bodySchema: skillsShRemoveBodySchema,
  responseSchema: skillsShRemoveResponseSchema,
  summary: "Remove an installed skill",
  description: "Removes an installed skill by deleting its directory. Does not require sandbox.",
  tags: ["Workspace", "Skills"],
  handler: async ({ mastra, workspaceId, skillName }) => {
    try {
      requireWorkspaceV1Support();
      const workspace = await getWorkspaceById(mastra, workspaceId);
      if (!workspace) {
        throw new HTTPException$2(404, { message: "Workspace not found" });
      }
      if (!workspace.filesystem) {
        throw new HTTPException$2(400, { message: "Workspace filesystem not available" });
      }
      if (workspace.filesystem.readOnly) {
        throw new HTTPException$2(403, { message: "Workspace is read-only" });
      }
      const safeSkillName = assertSafeSkillName(skillName);
      const skillPath = `${SKILLS_SH_DIR}/${safeSkillName}`;
      try {
        await workspace.filesystem.stat(skillPath);
      } catch {
        throw new HTTPException$2(404, { message: `Skill "${skillName}" not found at ${skillPath}` });
      }
      await workspace.filesystem.rmdir(skillPath, { recursive: true });
      return {
        success: true,
        skillName,
        removedPath: skillPath
      };
    } catch (error) {
      if (error instanceof HTTPException$2) {
        throw error;
      }
      return handleError$1(error, "Error removing skill");
    }
  }
});
var WORKSPACE_SKILLS_SH_UPDATE_ROUTE = createRoute({
  method: "POST",
  path: "/workspaces/:workspaceId/skills-sh/update",
  responseType: "json",
  pathParamSchema: workspaceIdPathParams,
  bodySchema: skillsShUpdateBodySchema,
  responseSchema: skillsShUpdateResponseSchema,
  summary: "Update installed skills",
  description: "Updates installed skills by re-fetching from GitHub. Specify skillName to update one, or omit to update all.",
  tags: ["Workspace", "Skills"],
  handler: async ({ mastra, workspaceId, skillName }) => {
    try {
      requireWorkspaceV1Support();
      const workspace = await getWorkspaceById(mastra, workspaceId);
      if (!workspace) {
        throw new HTTPException$2(404, { message: "Workspace not found" });
      }
      if (!workspace.filesystem) {
        throw new HTTPException$2(400, { message: "Workspace filesystem not available" });
      }
      if (workspace.filesystem.readOnly) {
        throw new HTTPException$2(403, { message: "Workspace is read-only" });
      }
      const results = [];
      let skillsToUpdate;
      if (skillName) {
        skillsToUpdate = [assertSafeSkillName(skillName)];
      } else {
        try {
          const entries = await workspace?.filesystem?.readdir(SKILLS_SH_DIR);
          skillsToUpdate = entries?.filter((e) => e.type === "directory").map((e) => e.name) ?? [];
        } catch {
          return { updated: [] };
        }
      }
      for (const skill of skillsToUpdate) {
        try {
          assertSafeSkillName(skill);
        } catch {
          results.push({
            skillName: skill,
            success: false,
            error: "Invalid skill name"
          });
          continue;
        }
        const metaPath = `${SKILLS_SH_DIR}/${skill}/.meta.json`;
        try {
          const metaContent = await workspace?.filesystem?.readFile(metaPath, { encoding: "utf-8" });
          const meta = JSON.parse(metaContent);
          const fetchResult = await fetchSkillFiles(meta.owner, meta.repo, meta.skillName);
          if (!fetchResult || fetchResult.files.length === 0) {
            results.push({
              skillName: skill,
              success: false,
              error: "No files found in skill directory"
            });
            continue;
          }
          const installPath = `${SKILLS_SH_DIR}/${skill}`;
          let filesWritten = 0;
          for (const file of fetchResult.files) {
            const safePath = assertSafeFilePath(file.path);
            const filePath = `${installPath}/${safePath}`;
            if (safePath.includes("/")) {
              const dirPath = filePath.substring(0, filePath.lastIndexOf("/"));
              try {
                await workspace.filesystem.mkdir(dirPath, { recursive: true });
              } catch {
              }
            }
            const content = file.encoding === "base64" ? Buffer.from(file.content, "base64") : file.content;
            await workspace.filesystem.writeFile(filePath, content);
            filesWritten++;
          }
          const updatedMeta = {
            ...meta,
            branch: fetchResult.branch,
            installedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          await workspace.filesystem.writeFile(metaPath, JSON.stringify(updatedMeta, null, 2));
          filesWritten++;
          results.push({
            skillName: skill,
            success: true,
            filesWritten
          });
        } catch (error) {
          results.push({
            skillName: skill,
            success: false,
            error: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
      return { updated: results };
    } catch (error) {
      if (error instanceof HTTPException$2) {
        throw error;
      }
      return handleError$1(error, "Error updating skills");
    }
  }
});
var WORKSPACE_SKILLS_SH_ROUTES = [
  WORKSPACE_SKILLS_SH_SEARCH_ROUTE,
  WORKSPACE_SKILLS_SH_POPULAR_ROUTE,
  WORKSPACE_SKILLS_SH_PREVIEW_ROUTE,
  WORKSPACE_SKILLS_SH_INSTALL_ROUTE,
  WORKSPACE_SKILLS_SH_REMOVE_ROUTE,
  WORKSPACE_SKILLS_SH_UPDATE_ROUTE
];
var WORKSPACE_FS_ROUTES = [
  WORKSPACE_FS_READ_ROUTE,
  WORKSPACE_FS_WRITE_ROUTE,
  WORKSPACE_FS_LIST_ROUTE,
  WORKSPACE_FS_DELETE_ROUTE,
  WORKSPACE_FS_MKDIR_ROUTE,
  WORKSPACE_FS_STAT_ROUTE
];
var WORKSPACE_SEARCH_ROUTES = [WORKSPACE_SEARCH_ROUTE, WORKSPACE_INDEX_ROUTE];
var WORKSPACE_SKILLS_ROUTES = [
  WORKSPACE_SEARCH_SKILLS_ROUTE,
  WORKSPACE_LIST_SKILLS_ROUTE,
  WORKSPACE_GET_SKILL_ROUTE,
  WORKSPACE_LIST_SKILL_REFERENCES_ROUTE,
  WORKSPACE_GET_SKILL_REFERENCE_ROUTE
];

// src/server/handlers/tools.ts
var tools_exports = {};
__export(tools_exports, {
  EXECUTE_AGENT_TOOL_ROUTE: () => EXECUTE_AGENT_TOOL_ROUTE,
  EXECUTE_TOOL_ROUTE: () => EXECUTE_TOOL_ROUTE,
  GET_AGENT_TOOL_ROUTE: () => GET_AGENT_TOOL_ROUTE,
  GET_TOOL_BY_ID_ROUTE: () => GET_TOOL_BY_ID_ROUTE,
  LIST_TOOLS_ROUTE: () => LIST_TOOLS_ROUTE
});
var LIST_TOOLS_ROUTE = createRoute({
  method: "GET",
  path: "/tools",
  responseType: "json",
  responseSchema: listToolsResponseSchema,
  summary: "List all tools",
  description: "Returns a list of all available tools in the system",
  tags: ["Tools"],
  requiresAuth: true,
  handler: async ({ mastra, registeredTools }) => {
    try {
      const allTools = registeredTools && Object.keys(registeredTools).length > 0 ? registeredTools : mastra.listTools() || {};
      const serializedTools = Object.entries(allTools).reduce(
        (acc, [id, _tool]) => {
          const tool = _tool;
          acc[id] = {
            ...tool,
            inputSchema: tool.inputSchema ? stringify(zodToJsonSchema$1(tool.inputSchema)) : void 0,
            outputSchema: tool.outputSchema ? stringify(zodToJsonSchema$1(tool.outputSchema)) : void 0,
            requestContextSchema: tool.requestContextSchema ? stringify(zodToJsonSchema$1(tool.requestContextSchema)) : void 0
          };
          return acc;
        },
        {}
      );
      return serializedTools;
    } catch (error) {
      return handleError$1(error, "Error getting tools");
    }
  }
});
var GET_TOOL_BY_ID_ROUTE = createRoute({
  method: "GET",
  path: "/tools/:toolId",
  responseType: "json",
  pathParamSchema: toolIdPathParams,
  responseSchema: serializedToolSchema,
  summary: "Get tool by ID",
  description: "Returns details for a specific tool including its schema and configuration",
  tags: ["Tools"],
  requiresAuth: true,
  handler: async ({ mastra, registeredTools, toolId }) => {
    try {
      let tool;
      if (registeredTools && Object.keys(registeredTools).length > 0) {
        tool = Object.values(registeredTools).find((t) => t.id === toolId);
      } else {
        tool = mastra.getToolById(toolId);
      }
      if (!tool) {
        throw new HTTPException$2(404, { message: "Tool not found" });
      }
      const serializedTool = {
        ...tool,
        inputSchema: tool.inputSchema ? stringify(zodToJsonSchema$1(tool.inputSchema)) : void 0,
        outputSchema: tool.outputSchema ? stringify(zodToJsonSchema$1(tool.outputSchema)) : void 0,
        requestContextSchema: tool.requestContextSchema ? stringify(zodToJsonSchema$1(tool.requestContextSchema)) : void 0
      };
      return serializedTool;
    } catch (error) {
      return handleError$1(error, "Error getting tool");
    }
  }
});
var EXECUTE_TOOL_ROUTE = createRoute({
  method: "POST",
  path: "/tools/:toolId/execute",
  responseType: "json",
  pathParamSchema: toolIdPathParams,
  queryParamSchema: optionalRunIdSchema,
  bodySchema: executeToolContextBodySchema,
  responseSchema: executeToolResponseSchema$1,
  summary: "Execute tool",
  description: "Executes a specific tool with the provided input data",
  tags: ["Tools"],
  requiresAuth: true,
  handler: async ({ mastra, runId, toolId, registeredTools, requestContext, ...bodyParams }) => {
    try {
      if (!toolId) {
        throw new HTTPException$2(400, { message: "Tool ID is required" });
      }
      let tool;
      if (registeredTools && Object.keys(registeredTools).length > 0) {
        tool = Object.values(registeredTools).find((t) => t.id === toolId);
      } else {
        tool = mastra.getToolById(toolId);
      }
      if (!tool) {
        throw new HTTPException$2(404, { message: "Tool not found" });
      }
      if (!tool?.execute) {
        throw new HTTPException$2(400, { message: "Tool is not executable" });
      }
      const { data } = bodyParams;
      validateBody({ data });
      if (isVercelTool(tool)) {
        const result2 = await tool.execute(data);
        return result2;
      }
      const result = await tool.execute(data, {
        mastra,
        requestContext,
        // TODO: Pass proper tracing context when server API supports tracing
        tracingContext: { currentSpan: void 0 },
        ...runId ? {
          workflow: {
            runId,
            suspend: async () => {
            }
          }
        } : {}
      });
      return result;
    } catch (error) {
      return handleError$1(error, "Error executing tool");
    }
  }
});
var GET_AGENT_TOOL_ROUTE = createRoute({
  method: "GET",
  path: "/agents/:agentId/tools/:toolId",
  responseType: "json",
  pathParamSchema: agentToolPathParams,
  responseSchema: serializedToolSchema,
  summary: "Get agent tool",
  description: "Returns details for a specific tool assigned to the agent",
  tags: ["Agents", "Tools"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, toolId, requestContext }) => {
    try {
      if (!agentId) {
        throw new HTTPException$2(400, { message: "Agent ID is required" });
      }
      const agent = await getAgentFromSystem({ mastra, agentId });
      const agentTools = await agent.listTools({ requestContext });
      const tool = Object.values(agentTools || {}).find((tool2) => tool2.id === toolId);
      if (!tool) {
        throw new HTTPException$2(404, { message: "Tool not found" });
      }
      const serializedTool = {
        ...tool,
        inputSchema: tool.inputSchema ? stringify(zodToJsonSchema$1(tool.inputSchema)) : void 0,
        outputSchema: tool.outputSchema ? stringify(zodToJsonSchema$1(tool.outputSchema)) : void 0,
        requestContextSchema: tool.requestContextSchema ? stringify(zodToJsonSchema$1(tool.requestContextSchema)) : void 0
      };
      return serializedTool;
    } catch (error) {
      return handleError$1(error, "Error getting agent tool");
    }
  }
});
var EXECUTE_AGENT_TOOL_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/tools/:toolId/execute",
  responseType: "json",
  pathParamSchema: agentToolPathParams,
  bodySchema: executeToolBodySchema$1,
  responseSchema: executeToolResponseSchema$1,
  summary: "Execute agent tool",
  description: "Executes a specific tool assigned to the agent with the provided input data",
  tags: ["Agents", "Tools"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, toolId, data, requestContext }) => {
    try {
      if (!agentId) {
        throw new HTTPException$2(400, { message: "Agent ID is required" });
      }
      const agent = await getAgentFromSystem({ mastra, agentId });
      const agentTools = await agent.listTools({ requestContext });
      const tool = Object.values(agentTools || {}).find((tool2) => tool2.id === toolId);
      if (!tool) {
        throw new HTTPException$2(404, { message: "Tool not found" });
      }
      if (!tool?.execute) {
        throw new HTTPException$2(400, { message: "Tool is not executable" });
      }
      const result = await tool.execute(data, {
        mastra,
        requestContext,
        // TODO: Pass proper tracing context when server API supports tracing
        tracingContext: { currentSpan: void 0 }
      });
      return result;
    } catch (error) {
      return handleError$1(error, "Error executing agent tool");
    }
  }
});

// src/server/handlers/logs.ts
var logs_exports = {};
__export(logs_exports, {
  LIST_LOGS_BY_RUN_ID_ROUTE: () => LIST_LOGS_BY_RUN_ID_ROUTE,
  LIST_LOGS_ROUTE: () => LIST_LOGS_ROUTE,
  LIST_LOG_TRANSPORTS_ROUTE: () => LIST_LOG_TRANSPORTS_ROUTE
});
var listLogsQuerySchema = createPagePaginationSchema().extend({
  fromDate: z$1.coerce.date().optional(),
  toDate: z$1.coerce.date().optional(),
  logLevel: z$1.enum(["debug", "info", "warn", "error", "silent"]).optional(),
  filters: z$1.union([z$1.string(), z$1.array(z$1.string())]).optional(),
  transportId: z$1.string()
});
var listLogsResponseSchema = z$1.object({
  logs: z$1.array(baseLogMessageSchema),
  total: z$1.number(),
  page: z$1.number(),
  perPage: z$1.union([z$1.number(), z$1.literal(false)]),
  hasMore: z$1.boolean()
});
var listLogTransportsResponseSchema = z$1.object({
  transports: z$1.array(z$1.string())
});

// src/server/handlers/logs.ts
var LIST_LOG_TRANSPORTS_ROUTE = createRoute({
  method: "GET",
  path: "/logs/transports",
  responseType: "json",
  responseSchema: listLogTransportsResponseSchema,
  summary: "List log transports",
  description: "Returns a list of all available log transports",
  tags: ["Logs"],
  requiresAuth: true,
  handler: async ({ mastra }) => {
    try {
      const logger = mastra.getLogger();
      const transports = logger.getTransports();
      return {
        transports: transports ? [...transports.keys()] : []
      };
    } catch (error) {
      return handleError$1(error, "Error getting log Transports");
    }
  }
});
var LIST_LOGS_ROUTE = createRoute({
  method: "GET",
  path: "/logs",
  responseType: "json",
  queryParamSchema: listLogsQuerySchema,
  responseSchema: listLogsResponseSchema,
  summary: "List logs",
  description: "Returns logs from a specific transport with optional filtering by date range, log level, and custom filters",
  tags: ["Logs"],
  requiresAuth: true,
  handler: async ({ mastra, ...params }) => {
    try {
      const { transportId, fromDate, toDate, logLevel, filters: _filters, page, perPage } = params;
      validateBody({ transportId });
      const filters = parseFilters(_filters);
      const logs = await mastra.listLogs(transportId, {
        fromDate,
        toDate,
        logLevel,
        filters,
        page: page ? Number(page) : void 0,
        perPage: perPage ? Number(perPage) : void 0
      });
      return logs;
    } catch (error) {
      return handleError$1(error, "Error getting logs");
    }
  }
});
var LIST_LOGS_BY_RUN_ID_ROUTE = createRoute({
  method: "GET",
  path: "/logs/:runId",
  responseType: "json",
  pathParamSchema: runIdSchema,
  queryParamSchema: listLogsQuerySchema,
  responseSchema: listLogsResponseSchema,
  summary: "List logs by run ID",
  description: "Returns all logs for a specific execution run from a transport",
  tags: ["Logs"],
  requiresAuth: true,
  handler: async ({ mastra, runId, ...params }) => {
    try {
      const { transportId, fromDate, toDate, logLevel, filters: _filters, page, perPage } = params;
      validateBody({ runId, transportId });
      const filters = parseFilters(_filters);
      const logs = await mastra.listLogsByRunId({
        runId,
        transportId,
        fromDate,
        toDate,
        logLevel,
        filters,
        page: page ? Number(page) : void 0,
        perPage: perPage ? Number(perPage) : void 0
      });
      return logs;
    } catch (error) {
      return handleError$1(error, "Error getting logs by run ID");
    }
  }
});

// src/server/handlers/mcp.ts
var mcp_exports = {};
__export(mcp_exports, {
  EXECUTE_MCP_SERVER_TOOL_ROUTE: () => EXECUTE_MCP_SERVER_TOOL_ROUTE,
  GET_MCP_SERVER_DETAIL_ROUTE: () => GET_MCP_SERVER_DETAIL_ROUTE,
  GET_MCP_SERVER_TOOL_DETAIL_ROUTE: () => GET_MCP_SERVER_TOOL_DETAIL_ROUTE,
  LIST_MCP_SERVERS_ROUTE: () => LIST_MCP_SERVERS_ROUTE,
  LIST_MCP_SERVER_TOOLS_ROUTE: () => LIST_MCP_SERVER_TOOLS_ROUTE,
  MCP_HTTP_TRANSPORT_ROUTE: () => MCP_HTTP_TRANSPORT_ROUTE,
  MCP_SSE_MESSAGES_ROUTE: () => MCP_SSE_MESSAGES_ROUTE,
  MCP_SSE_TRANSPORT_ROUTE: () => MCP_SSE_TRANSPORT_ROUTE
});
var mcpServerIdPathParams = z.object({
  serverId: z.string().describe("MCP server ID")
});
var mcpServerDetailPathParams = z.object({
  id: z.string().describe("MCP server ID")
});
var mcpServerToolPathParams = z.object({
  serverId: z.string().describe("MCP server ID"),
  toolId: z.string().describe("Tool ID")
});
var executeToolBodySchema = z.object({
  data: z.unknown().optional()
});
var listMcpServersQuerySchema = createCombinedPaginationSchema();
var getMcpServerDetailQuerySchema = z.object({
  version: z.string().optional()
});
var versionDetailSchema = z.object({
  version: z.string(),
  release_date: z.string(),
  is_latest: z.boolean()
});
var serverInfoSchema = z.object({
  id: z.string(),
  name: z.string(),
  version_detail: versionDetailSchema
});
var listMcpServersResponseSchema = z.object({
  servers: z.array(serverInfoSchema),
  total_count: z.number(),
  next: z.string().nullable()
});
var serverDetailSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  version_detail: versionDetailSchema,
  package_canonical: z.string().optional(),
  packages: z.array(z.unknown()).optional(),
  remotes: z.array(z.unknown()).optional()
});
var mcpToolInfoSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  inputSchema: z.unknown(),
  outputSchema: z.unknown().optional(),
  toolType: z.string().optional()
});
var listMcpServerToolsResponseSchema = z.object({
  tools: z.array(mcpToolInfoSchema)
});
var executeToolResponseSchema = z.object({
  result: z.unknown()
});
z.object({
  jsonrpc: z.literal("2.0"),
  error: z.object({
    code: z.number(),
    message: z.string()
  }),
  id: z.null()
});

// src/server/handlers/mcp.ts
var LIST_MCP_SERVERS_ROUTE = createRoute({
  method: "GET",
  path: "/mcp/v0/servers",
  responseType: "json",
  queryParamSchema: listMcpServersQuerySchema,
  responseSchema: listMcpServersResponseSchema,
  summary: "List MCP servers",
  description: "Returns a list of registered MCP servers with pagination support",
  tags: ["MCP"],
  requiresAuth: true,
  handler: async ({
    mastra,
    routePrefix,
    page,
    perPage,
    limit,
    offset
  }) => {
    if (!mastra || typeof mastra.listMCPServers !== "function") {
      throw new HTTPException$2(500, { message: "Mastra instance or listMCPServers method not available" });
    }
    const servers = mastra.listMCPServers();
    if (!servers) {
      return { servers: [], total_count: 0, next: null };
    }
    const serverList = Object.values(servers);
    const totalCount = serverList.length;
    const useLegacyFormat = (limit !== void 0 || offset !== void 0) && page === void 0 && perPage === void 0;
    const finalPerPage = perPage ?? limit;
    let finalPage = page;
    if (finalPage === void 0 && offset !== void 0 && finalPerPage !== void 0 && finalPerPage > 0) {
      finalPage = Math.floor(offset / finalPerPage);
    }
    const actualOffset = finalPage !== void 0 && finalPerPage !== void 0 ? finalPage * finalPerPage : 0;
    let paginatedServers = serverList;
    let nextUrl = null;
    if (finalPerPage !== void 0) {
      paginatedServers = serverList.slice(actualOffset, actualOffset + finalPerPage);
      if (actualOffset + finalPerPage < totalCount) {
        const nextPage = (finalPage ?? 0) + 1;
        const prefix = routePrefix ?? "";
        if (useLegacyFormat) {
          const nextOffset = actualOffset + finalPerPage;
          nextUrl = `${prefix}/mcp/v0/servers?limit=${finalPerPage}&offset=${nextOffset}`;
        } else {
          nextUrl = `${prefix}/mcp/v0/servers?perPage=${finalPerPage}&page=${nextPage}`;
        }
      }
    }
    const serverInfoList = paginatedServers.map((server) => server.getServerInfo());
    return {
      servers: serverInfoList,
      total_count: totalCount,
      next: nextUrl
    };
  }
});
var GET_MCP_SERVER_DETAIL_ROUTE = createRoute({
  method: "GET",
  path: "/mcp/v0/servers/:id",
  responseType: "json",
  pathParamSchema: mcpServerDetailPathParams,
  queryParamSchema: getMcpServerDetailQuerySchema,
  responseSchema: serverDetailSchema,
  summary: "Get MCP server details",
  description: "Returns detailed information about a specific MCP server",
  tags: ["MCP"],
  requiresAuth: true,
  handler: async ({ mastra, id, version }) => {
    if (!mastra || typeof mastra.getMCPServerById !== "function") {
      throw new HTTPException$2(500, { message: "Mastra instance or getMCPServerById method not available" });
    }
    const server = mastra.getMCPServerById(id);
    if (!server) {
      throw new HTTPException$2(404, { message: `MCP server with ID '${id}' not found` });
    }
    const serverDetail = server.getServerDetail();
    if (version && serverDetail.version_detail.version !== version) {
      throw new HTTPException$2(404, {
        message: `MCP server with ID '${id}' found, but not version '${version}'. Available version: ${serverDetail.version_detail.version}`
      });
    }
    return serverDetail;
  }
});
var LIST_MCP_SERVER_TOOLS_ROUTE = createRoute({
  method: "GET",
  path: "/mcp/:serverId/tools",
  responseType: "json",
  pathParamSchema: mcpServerIdPathParams,
  responseSchema: listMcpServerToolsResponseSchema,
  summary: "List MCP server tools",
  description: "Returns a list of tools available on the specified MCP server",
  tags: ["MCP"],
  requiresAuth: true,
  handler: async ({ mastra, serverId }) => {
    if (!mastra || typeof mastra.getMCPServerById !== "function") {
      throw new HTTPException$2(500, { message: "Mastra instance or getMCPServerById method not available" });
    }
    const server = mastra.getMCPServerById(serverId);
    if (!server) {
      throw new HTTPException$2(404, { message: `MCP server with ID '${serverId}' not found` });
    }
    if (typeof server.getToolListInfo !== "function") {
      throw new HTTPException$2(501, { message: `Server '${serverId}' cannot list tools in this way.` });
    }
    return server.getToolListInfo();
  }
});
var GET_MCP_SERVER_TOOL_DETAIL_ROUTE = createRoute({
  method: "GET",
  path: "/mcp/:serverId/tools/:toolId",
  responseType: "json",
  pathParamSchema: mcpServerToolPathParams,
  responseSchema: mcpToolInfoSchema,
  summary: "Get MCP server tool details",
  description: "Returns detailed information about a specific tool on the MCP server",
  tags: ["MCP"],
  requiresAuth: true,
  handler: async ({ mastra, serverId, toolId }) => {
    if (!mastra || typeof mastra.getMCPServerById !== "function") {
      throw new HTTPException$2(500, { message: "Mastra instance or getMCPServerById method not available" });
    }
    const server = mastra.getMCPServerById(serverId);
    if (!server) {
      throw new HTTPException$2(404, { message: `MCP server with ID '${serverId}' not found` });
    }
    if (typeof server.getToolInfo !== "function") {
      throw new HTTPException$2(501, { message: `Server '${serverId}' cannot provide tool details in this way.` });
    }
    const toolInfo = server.getToolInfo(toolId);
    if (!toolInfo) {
      throw new HTTPException$2(404, { message: `Tool with ID '${toolId}' not found on MCP server '${serverId}'` });
    }
    return toolInfo;
  }
});
var EXECUTE_MCP_SERVER_TOOL_ROUTE = createRoute({
  method: "POST",
  path: "/mcp/:serverId/tools/:toolId/execute",
  responseType: "json",
  pathParamSchema: mcpServerToolPathParams,
  bodySchema: executeToolBodySchema,
  responseSchema: executeToolResponseSchema,
  summary: "Execute MCP server tool",
  description: "Executes a tool on the specified MCP server with the provided arguments",
  tags: ["MCP"],
  requiresAuth: true,
  handler: async ({
    mastra,
    serverId,
    toolId,
    data
  }) => {
    if (!mastra || typeof mastra.getMCPServerById !== "function") {
      throw new HTTPException$2(500, { message: "Mastra instance or getMCPServerById method not available" });
    }
    const server = mastra.getMCPServerById(serverId);
    if (!server) {
      throw new HTTPException$2(404, { message: `MCP server with ID '${serverId}' not found` });
    }
    if (typeof server.executeTool !== "function") {
      throw new HTTPException$2(501, { message: `Server '${serverId}' cannot execute tools in this way.` });
    }
    const result = await server.executeTool(toolId, data);
    return { result };
  }
});
var MCP_HTTP_TRANSPORT_ROUTE = createRoute({
  method: "ALL",
  path: "/mcp/:serverId/mcp",
  responseType: "mcp-http",
  pathParamSchema: mcpServerIdPathParams,
  summary: "MCP HTTP Transport",
  description: "Streamable HTTP transport endpoint for MCP protocol communication",
  tags: ["MCP"],
  requiresAuth: true,
  handler: async ({ mastra, serverId }) => {
    if (!mastra || typeof mastra.getMCPServerById !== "function") {
      throw new HTTPException$2(500, { message: "Mastra instance or getMCPServerById method not available" });
    }
    const server = mastra.getMCPServerById(serverId);
    if (!server) {
      throw new HTTPException$2(404, { message: `MCP server '${serverId}' not found` });
    }
    return {
      server,
      httpPath: `/mcp/${serverId}/mcp`
    };
  }
});
var MCP_SSE_TRANSPORT_ROUTE = createRoute({
  method: "ALL",
  path: "/mcp/:serverId/sse",
  responseType: "mcp-sse",
  pathParamSchema: mcpServerIdPathParams,
  summary: "MCP SSE Transport",
  description: "SSE transport endpoint for MCP protocol communication",
  tags: ["MCP"],
  requiresAuth: true,
  handler: async ({ mastra, serverId }) => {
    if (!mastra || typeof mastra.getMCPServerById !== "function") {
      throw new HTTPException$2(500, { message: "Mastra instance or getMCPServerById method not available" });
    }
    const server = mastra.getMCPServerById(serverId);
    if (!server) {
      throw new HTTPException$2(404, { message: `MCP server '${serverId}' not found` });
    }
    return {
      server,
      ssePath: `/mcp/${serverId}/sse`,
      messagePath: `/mcp/${serverId}/messages`
    };
  }
});
var MCP_SSE_MESSAGES_ROUTE = createRoute({
  method: "POST",
  path: "/mcp/:serverId/messages",
  responseType: "mcp-sse",
  pathParamSchema: mcpServerIdPathParams,
  summary: "MCP SSE Messages",
  description: "Message endpoint for SSE transport (posts messages to active SSE streams)",
  tags: ["MCP"],
  requiresAuth: true,
  handler: MCP_SSE_TRANSPORT_ROUTE.handler
});

// src/server/handlers/memory.ts
var memory_exports = {};
__export(memory_exports, {
  AWAIT_BUFFER_STATUS_ROUTE: () => AWAIT_BUFFER_STATUS_ROUTE,
  CLONE_THREAD_ROUTE: () => CLONE_THREAD_ROUTE,
  CREATE_THREAD_NETWORK_ROUTE: () => CREATE_THREAD_NETWORK_ROUTE,
  CREATE_THREAD_ROUTE: () => CREATE_THREAD_ROUTE,
  DELETE_MESSAGES_NETWORK_ROUTE: () => DELETE_MESSAGES_NETWORK_ROUTE,
  DELETE_MESSAGES_ROUTE: () => DELETE_MESSAGES_ROUTE,
  DELETE_THREAD_NETWORK_ROUTE: () => DELETE_THREAD_NETWORK_ROUTE,
  DELETE_THREAD_ROUTE: () => DELETE_THREAD_ROUTE,
  GET_MEMORY_CONFIG_ROUTE: () => GET_MEMORY_CONFIG_ROUTE,
  GET_MEMORY_STATUS_NETWORK_ROUTE: () => GET_MEMORY_STATUS_NETWORK_ROUTE,
  GET_MEMORY_STATUS_ROUTE: () => GET_MEMORY_STATUS_ROUTE,
  GET_OBSERVATIONAL_MEMORY_ROUTE: () => GET_OBSERVATIONAL_MEMORY_ROUTE,
  GET_THREAD_BY_ID_NETWORK_ROUTE: () => GET_THREAD_BY_ID_NETWORK_ROUTE,
  GET_THREAD_BY_ID_ROUTE: () => GET_THREAD_BY_ID_ROUTE,
  GET_WORKING_MEMORY_ROUTE: () => GET_WORKING_MEMORY_ROUTE,
  LIST_MESSAGES_NETWORK_ROUTE: () => LIST_MESSAGES_NETWORK_ROUTE,
  LIST_MESSAGES_ROUTE: () => LIST_MESSAGES_ROUTE,
  LIST_THREADS_NETWORK_ROUTE: () => LIST_THREADS_NETWORK_ROUTE,
  LIST_THREADS_ROUTE: () => LIST_THREADS_ROUTE,
  SAVE_MESSAGES_NETWORK_ROUTE: () => SAVE_MESSAGES_NETWORK_ROUTE,
  SAVE_MESSAGES_ROUTE: () => SAVE_MESSAGES_ROUTE,
  SEARCH_MEMORY_ROUTE: () => SEARCH_MEMORY_ROUTE,
  UPDATE_THREAD_NETWORK_ROUTE: () => UPDATE_THREAD_NETWORK_ROUTE,
  UPDATE_THREAD_ROUTE: () => UPDATE_THREAD_ROUTE,
  UPDATE_WORKING_MEMORY_ROUTE: () => UPDATE_WORKING_MEMORY_ROUTE,
  getTextContent: () => getTextContent
});
var threadIdPathParams = z$1.object({
  threadId: z$1.string().describe("Unique identifier for the conversation thread")
});
var agentIdQuerySchema = z$1.object({
  agentId: z$1.string()
});
var optionalAgentIdQuerySchema = z$1.object({
  agentId: z$1.string().optional()
});
var storageOrderBySchema = z$1.preprocess(
  (val) => {
    if (typeof val === "string") {
      try {
        return JSON.parse(val);
      } catch {
        return void 0;
      }
    }
    return val;
  },
  z$1.object({
    field: z$1.enum(["createdAt", "updatedAt"]).optional(),
    direction: z$1.enum(["ASC", "DESC"]).optional()
  }).optional()
);
var messageOrderBySchema = z$1.preprocess(
  (val) => {
    if (typeof val === "string") {
      try {
        return JSON.parse(val);
      } catch {
        return void 0;
      }
    }
    return val;
  },
  z$1.object({
    field: z$1.enum(["createdAt"]).optional(),
    direction: z$1.enum(["ASC", "DESC"]).optional()
  }).optional()
);
var includeSchema = z$1.preprocess(
  (val) => {
    if (typeof val === "string") {
      try {
        return JSON.parse(val);
      } catch {
        return val;
      }
    }
    return val;
  },
  z$1.array(
    z$1.object({
      id: z$1.string(),
      threadId: z$1.string().optional(),
      withPreviousMessages: z$1.number().optional(),
      withNextMessages: z$1.number().optional()
    })
  ).optional()
);
var filterSchema = z$1.preprocess(
  (val) => {
    if (typeof val === "string") {
      try {
        return JSON.parse(val);
      } catch {
        return val;
      }
    }
    return val;
  },
  z$1.object({
    dateRange: z$1.object({
      start: z$1.coerce.date().optional(),
      end: z$1.coerce.date().optional()
    }).optional(),
    roles: z$1.array(z$1.string()).optional()
  }).optional()
);
var memoryConfigSchema = z$1.preprocess((val) => {
  if (typeof val === "string") {
    try {
      return JSON.parse(val);
    } catch {
      return val;
    }
  }
  return val;
}, z$1.record(z$1.string(), z$1.unknown()).optional());
var threadSchema = z$1.object({
  id: z$1.string(),
  title: z$1.string().optional(),
  resourceId: z$1.string(),
  createdAt: z$1.date(),
  updatedAt: z$1.date(),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional()
});
var messageSchema$1 = z$1.any();
var getMemoryStatusQuerySchema = agentIdQuerySchema.extend({
  resourceId: z$1.string().optional(),
  threadId: z$1.string().optional()
});
var getMemoryConfigQuerySchema = agentIdQuerySchema;
var listThreadsQuerySchema = createPagePaginationSchema(100).extend({
  agentId: z$1.string().optional(),
  resourceId: z$1.string().optional(),
  metadata: z$1.preprocess(
    (val) => {
      if (typeof val === "string") {
        try {
          return JSON.parse(val);
        } catch {
          return val;
        }
      }
      return val;
    },
    z$1.optional(z$1.record(z$1.string(), z$1.any()))
  ),
  orderBy: storageOrderBySchema
});
var getThreadByIdQuerySchema = optionalAgentIdQuerySchema.extend({
  resourceId: z$1.string().optional()
});
var listMessagesQuerySchema = createPagePaginationSchema(40).extend({
  agentId: z$1.string().optional(),
  resourceId: z$1.string().optional(),
  orderBy: messageOrderBySchema,
  include: includeSchema,
  filter: filterSchema
});
var getWorkingMemoryQuerySchema = z$1.object({
  agentId: z$1.string(),
  resourceId: z$1.string().optional(),
  memoryConfig: memoryConfigSchema
});
var deleteThreadQuerySchema = agentIdQuerySchema.extend({
  resourceId: z$1.string().optional()
});
var deleteMessagesQuerySchema = agentIdQuerySchema.extend({
  resourceId: z$1.string().optional()
});
var getMemoryStatusNetworkQuerySchema = agentIdQuerySchema;
var listThreadsNetworkQuerySchema = createPagePaginationSchema(100).extend({
  agentId: z$1.string().optional(),
  resourceId: z$1.string().optional(),
  metadata: z$1.preprocess(
    (val) => {
      if (typeof val === "string") {
        try {
          return JSON.parse(val);
        } catch {
          return val;
        }
      }
      return val;
    },
    z$1.optional(z$1.record(z$1.string(), z$1.any()))
  ),
  orderBy: storageOrderBySchema
});
var getThreadByIdNetworkQuerySchema = optionalAgentIdQuerySchema.extend({
  resourceId: z$1.string().optional()
});
var listMessagesNetworkQuerySchema = createPagePaginationSchema(40).extend({
  agentId: z$1.string().optional(),
  resourceId: z$1.string().optional(),
  orderBy: messageOrderBySchema,
  include: includeSchema,
  filter: filterSchema
});
var saveMessagesNetworkQuerySchema = agentIdQuerySchema;
var createThreadNetworkQuerySchema = agentIdQuerySchema;
var updateThreadNetworkQuerySchema = agentIdQuerySchema;
var deleteThreadNetworkQuerySchema = agentIdQuerySchema.extend({
  resourceId: z$1.string().optional()
});
var deleteMessagesNetworkQuerySchema = agentIdQuerySchema.extend({
  resourceId: z$1.string().optional()
});
var memoryStatusResponseSchema = z$1.object({
  result: z$1.boolean(),
  observationalMemory: z$1.object({
    enabled: z$1.boolean(),
    hasRecord: z$1.boolean().optional(),
    originType: z$1.string().optional(),
    lastObservedAt: z$1.date().optional(),
    tokenCount: z$1.number().optional(),
    observationTokenCount: z$1.number().optional(),
    isObserving: z$1.boolean().optional(),
    isReflecting: z$1.boolean().optional()
  }).optional()
});
var observationalMemoryConfigSchema = z$1.object({
  enabled: z$1.boolean(),
  scope: z$1.enum(["thread", "resource"]).optional(),
  shareTokenBudget: z$1.boolean().optional(),
  messageTokens: z$1.union([z$1.number(), z$1.object({ min: z$1.number(), max: z$1.number() })]).optional(),
  observationTokens: z$1.union([z$1.number(), z$1.object({ min: z$1.number(), max: z$1.number() })]).optional(),
  observationModel: z$1.string().optional(),
  reflectionModel: z$1.string().optional()
});
var memoryConfigResponseSchema = z$1.object({
  config: z$1.object({
    lastMessages: z$1.union([z$1.number(), z$1.literal(false)]).optional(),
    semanticRecall: z$1.union([z$1.boolean(), z$1.any()]).optional(),
    workingMemory: z$1.any().optional(),
    observationalMemory: observationalMemoryConfigSchema.optional()
  })
});
var listThreadsResponseSchema = paginationInfoSchema.extend({
  threads: z$1.array(threadSchema)
});
var getThreadByIdResponseSchema = threadSchema;
var listMessagesResponseSchema = z$1.object({
  messages: z$1.array(messageSchema$1),
  uiMessages: z$1.unknown()
  // Converted messages in UI format
});
var getWorkingMemoryResponseSchema = z$1.object({
  workingMemory: z$1.unknown(),
  // Can be string or structured object depending on template
  source: z$1.enum(["thread", "resource"]),
  workingMemoryTemplate: z$1.unknown(),
  // Template structure varies
  threadExists: z$1.boolean()
});
var saveMessagesBodySchema = z$1.object({
  messages: z$1.array(messageSchema$1)
});
var createThreadBodySchema = z$1.object({
  resourceId: z$1.string(),
  title: z$1.string().optional(),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional(),
  threadId: z$1.string().optional()
});
var updateThreadBodySchema = z$1.object({
  title: z$1.string().optional(),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional(),
  resourceId: z$1.string().optional()
});
var updateWorkingMemoryBodySchema = z$1.object({
  workingMemory: z$1.string(),
  resourceId: z$1.string().optional(),
  memoryConfig: z$1.record(z$1.string(), z$1.unknown()).optional()
});
var deleteMessagesBodySchema = z$1.object({
  messageIds: z$1.union([
    z$1.string(),
    z$1.array(z$1.string()),
    z$1.object({ id: z$1.string() }),
    z$1.array(z$1.object({ id: z$1.string() }))
  ])
});
var searchMemoryQuerySchema = z$1.object({
  agentId: z$1.string(),
  searchQuery: z$1.string(),
  resourceId: z$1.string(),
  threadId: z$1.string().optional(),
  limit: z$1.coerce.number().optional().default(20),
  memoryConfig: memoryConfigSchema
});
var saveMessagesResponseSchema = z$1.object({
  messages: z$1.array(messageSchema$1)
});
var deleteThreadResponseSchema = z$1.object({
  result: z$1.string()
});
var updateWorkingMemoryResponseSchema = successResponseSchema;
var deleteMessagesResponseSchema = successResponseSchema.extend({
  message: z$1.string()
});
var searchMemoryResponseSchema = z$1.object({
  results: z$1.array(z$1.unknown()),
  count: z$1.number(),
  query: z$1.string(),
  searchScope: z$1.string().optional(),
  searchType: z$1.string().optional()
});
var cloneThreadBodySchema = z$1.object({
  newThreadId: z$1.string().optional(),
  resourceId: z$1.string().optional(),
  title: z$1.string().optional(),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional(),
  options: z$1.object({
    messageLimit: z$1.number().optional(),
    messageFilter: z$1.object({
      startDate: z$1.coerce.date().optional(),
      endDate: z$1.coerce.date().optional(),
      messageIds: z$1.array(z$1.string()).optional()
    }).optional()
  }).optional()
});
var cloneThreadResponseSchema = z$1.object({
  thread: threadSchema,
  clonedMessages: z$1.array(messageSchema$1)
});
var getObservationalMemoryQuerySchema = z$1.object({
  agentId: z$1.string(),
  resourceId: z$1.string().optional(),
  threadId: z$1.string().optional()
});
var observationalMemoryRecordSchema = z$1.object({
  id: z$1.string(),
  scope: z$1.enum(["thread", "resource"]),
  resourceId: z$1.string(),
  threadId: z$1.string().nullable(),
  activeObservations: z$1.string(),
  bufferedObservations: z$1.string().optional(),
  bufferedReflection: z$1.string().optional(),
  originType: z$1.enum(["initial", "observation", "reflection"]),
  generationCount: z$1.number(),
  lastObservedAt: z$1.date().optional(),
  totalTokensObserved: z$1.number(),
  observationTokenCount: z$1.number(),
  pendingMessageTokens: z$1.number(),
  isObserving: z$1.boolean(),
  isReflecting: z$1.boolean(),
  config: z$1.record(z$1.string(), z$1.unknown()),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional(),
  createdAt: z$1.date(),
  updatedAt: z$1.date()
});
var getObservationalMemoryResponseSchema = z$1.object({
  record: observationalMemoryRecordSchema.nullable(),
  history: z$1.array(observationalMemoryRecordSchema).optional()
});
var awaitBufferStatusBodySchema = z$1.object({
  agentId: z$1.string(),
  resourceId: z$1.string().optional(),
  threadId: z$1.string().optional()
});
var awaitBufferStatusResponseSchema = z$1.object({
  record: observationalMemoryRecordSchema.nullable()
});

// src/server/handlers/memory.ts
function getTextContent(message) {
  if (typeof message.content === "string") {
    return message.content;
  }
  if (message.content && typeof message.content === "object" && "parts" in message.content) {
    const textPart = message.content.parts.find((p) => p.type === "text");
    return textPart?.text || "";
  }
  return "";
}
async function getMemoryFromContext({
  mastra,
  agentId,
  requestContext
}) {
  const logger = mastra.getLogger();
  let agent;
  if (agentId) {
    try {
      agent = mastra.getAgentById(agentId);
    } catch (error) {
      logger.debug("Error getting agent from mastra, searching agents for agent", error);
    }
  }
  if (agentId && !agent) {
    logger.debug("Agent not found in registered agents, trying stored agents", { agentId });
    try {
      const storedAgent = await mastra.getEditor()?.agent.getById(agentId) ?? null;
      if (storedAgent) {
        agent = storedAgent;
      }
    } catch (error) {
      logger.debug("Error getting stored agent", error);
    }
  }
  if (agentId && !agent) {
    logger.debug("Stored agent not found, searching sub-agents", { agentId });
    const agents = mastra.listAgents();
    if (Object.keys(agents || {}).length) {
      for (const [_, ag] of Object.entries(agents)) {
        try {
          const subAgents = await ag.listAgents({ requestContext });
          if (subAgents[agentId]) {
            agent = subAgents[agentId];
            break;
          }
        } catch (error) {
          logger.debug("Error getting agent from agent", error);
        }
      }
    }
    if (!agent) {
      throw new HTTPException$2(404, { message: "Agent not found" });
    }
  }
  if (agent) {
    return await agent?.getMemory({
      requestContext
    });
  }
}
function getStorageFromContext({ mastra }) {
  return mastra.getStorage();
}
async function getAgentFromContext({
  mastra,
  agentId,
  requestContext
}) {
  if (!agentId) return null;
  const logger = mastra.getLogger();
  let agent = null;
  try {
    agent = mastra.getAgentById(agentId);
  } catch (error) {
    logger.debug("Error getting agent from mastra", error);
  }
  if (!agent) {
    logger.debug("Agent not found in registered agents, trying stored agents", { agentId });
    try {
      const storedAgent = await mastra.getEditor()?.agent.getById(agentId) ?? null;
      if (storedAgent) {
        agent = storedAgent;
      }
    } catch (error) {
      logger.debug("Error getting stored agent", error);
    }
  }
  if (!agent) {
    logger.debug("Stored agent not found, searching sub-agents", { agentId });
    const agents = mastra.listAgents();
    if (Object.keys(agents || {}).length) {
      for (const [_, ag] of Object.entries(agents)) {
        try {
          const nestedAgents = await ag.listAgents({ requestContext });
          if (nestedAgents[agentId]) {
            agent = nestedAgents[agentId];
            break;
          }
        } catch (error) {
          logger.debug("Error getting agent from agent", error);
        }
      }
    }
  }
  return agent;
}
async function getOMConfigFromAgent(agent, requestContext) {
  try {
    if (typeof agent.resolveProcessorById !== "function") {
      return null;
    }
    const omProcessor = await agent.resolveProcessorById("observational-memory", requestContext);
    if (!omProcessor) {
      return null;
    }
    const hasResolvedConfig = typeof omProcessor.getResolvedConfig === "function";
    if (hasResolvedConfig) {
      const resolvedConfig = await omProcessor.getResolvedConfig(requestContext);
      return {
        enabled: true,
        scope: resolvedConfig.scope || "resource",
        shareTokenBudget: resolvedConfig.shareTokenBudget,
        messageTokens: resolvedConfig.observation?.messageTokens,
        observationTokens: resolvedConfig.reflection?.observationTokens,
        observationModel: resolvedConfig.observation?.model,
        reflectionModel: resolvedConfig.reflection?.model
      };
    }
    const processorConfig = omProcessor.config || {};
    return {
      enabled: true,
      scope: processorConfig.scope || "resource",
      shareTokenBudget: processorConfig.shareTokenBudget,
      messageTokens: processorConfig.observation?.messageTokens,
      observationTokens: processorConfig.reflection?.observationTokens,
      observationModel: void 0,
      reflectionModel: void 0
    };
  } catch {
    return null;
  }
}
async function getOMStatus(memoryStorage, resourceId, threadId) {
  try {
    const record = await memoryStorage.getObservationalMemory(threadId ?? null, resourceId);
    if (!record) {
      return { hasRecord: false };
    }
    return {
      hasRecord: true,
      originType: record.originType,
      lastObservedAt: record.lastObservedAt ?? null,
      tokenCount: record.totalTokensObserved,
      observationTokenCount: record.observationTokenCount,
      isObserving: record.isObserving,
      isReflecting: record.isReflecting
    };
  } catch {
    return null;
  }
}
var GET_MEMORY_STATUS_ROUTE = createRoute({
  method: "GET",
  path: "/memory/status",
  responseType: "json",
  queryParamSchema: getMemoryStatusQuerySchema,
  responseSchema: memoryStatusResponseSchema,
  summary: "Get memory status",
  description: "Returns the current status of the memory system including configuration and health information",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, resourceId, threadId, requestContext }) => {
    try {
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (memory) {
        const agent = await getAgentFromContext({ mastra, agentId, requestContext });
        let omStatus;
        if (agent) {
          const omConfig = await getOMConfigFromAgent(agent, requestContext);
          if (omConfig?.enabled && resourceId) {
            const omThreadId = omConfig.scope === "resource" ? void 0 : threadId;
            try {
              const memoryStore = await memory.storage.getStore("memory");
              if (memoryStore) {
                const status = await getOMStatus(memoryStore, resourceId, omThreadId);
                if (status) {
                  omStatus = {
                    enabled: true,
                    ...status,
                    // Convert null to undefined for schema compatibility
                    lastObservedAt: status.lastObservedAt ?? void 0
                  };
                } else {
                  omStatus = { enabled: true, hasRecord: false };
                }
              }
            } catch {
              omStatus = { enabled: true };
            }
          } else if (omConfig?.enabled) {
            omStatus = { enabled: true };
          }
        }
        return { result: true, observationalMemory: omStatus };
      }
      if (!agentId) {
        const storage = getStorageFromContext({ mastra });
        if (storage) {
          return { result: true };
        }
      }
      return { result: false };
    } catch (error) {
      return handleError$1(error, "Error getting memory status");
    }
  }
});
var GET_MEMORY_CONFIG_ROUTE = createRoute({
  method: "GET",
  path: "/memory/config",
  responseType: "json",
  queryParamSchema: getMemoryConfigQuerySchema,
  responseSchema: memoryConfigResponseSchema,
  summary: "Get memory configuration",
  description: "Returns the memory configuration for a specific agent or the system default",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, requestContext }) => {
    try {
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new HTTPException$2(400, { message: "Memory is not initialized" });
      }
      const config = memory.getMergedThreadConfig({});
      const agent = await getAgentFromContext({ mastra, agentId, requestContext });
      let omConfig;
      if (agent) {
        omConfig = await getOMConfigFromAgent(agent, requestContext) ?? { enabled: false };
      }
      return {
        config: {
          ...config,
          observationalMemory: omConfig
        }
      };
    } catch (error) {
      return handleError$1(error, "Error getting memory configuration");
    }
  }
});
var GET_OBSERVATIONAL_MEMORY_ROUTE = createRoute({
  method: "GET",
  path: "/memory/observational-memory",
  responseType: "json",
  queryParamSchema: getObservationalMemoryQuerySchema,
  responseSchema: getObservationalMemoryResponseSchema,
  summary: "Get observational memory data",
  description: "Returns the current observational memory record and optional history for a resource/thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, resourceId, threadId, requestContext }) => {
    try {
      const agent = await getAgentFromContext({ mastra, agentId, requestContext });
      if (!agent) {
        throw new HTTPException$2(404, { message: "Agent not found" });
      }
      const omConfig = await getOMConfigFromAgent(agent, requestContext);
      if (!omConfig?.enabled) {
        throw new HTTPException$2(400, { message: "Observational Memory is not enabled for this agent" });
      }
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new HTTPException$2(400, { message: "Memory is not configured for this agent" });
      }
      let memoryStore;
      try {
        memoryStore = await memory.storage.getStore("memory");
      } catch {
        throw new HTTPException$2(400, { message: "Memory storage is not initialized" });
      }
      if (!memoryStore) {
        throw new HTTPException$2(400, { message: "Memory storage is not initialized" });
      }
      const effectiveResourceId = resourceId;
      if (!effectiveResourceId) {
        throw new HTTPException$2(400, { message: "resourceId is required for observational memory lookup" });
      }
      const omThreadId = omConfig.scope === "resource" ? null : threadId ?? null;
      const record = await memoryStore.getObservationalMemory(omThreadId, effectiveResourceId);
      const history = await memoryStore.getObservationalMemoryHistory(omThreadId, effectiveResourceId, 5);
      return {
        record: record ?? null,
        history: history.length > 0 ? history : void 0
      };
    } catch (error) {
      return handleError$1(error, "Error getting observational memory");
    }
  }
});
var AWAIT_BUFFER_STATUS_ROUTE = createRoute({
  method: "POST",
  path: "/memory/observational-memory/buffer-status",
  responseType: "json",
  bodySchema: awaitBufferStatusBodySchema,
  responseSchema: awaitBufferStatusResponseSchema,
  summary: "Await observational memory buffering completion",
  description: "Blocks until any in-flight buffering operations complete for the given thread/resource, then returns the updated record",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, resourceId, threadId, requestContext }) => {
    try {
      const agent = await getAgentFromContext({ mastra, agentId, requestContext });
      if (!agent) {
        throw new HTTPException$2(404, { message: "Agent not found" });
      }
      const omConfig = await getOMConfigFromAgent(agent, requestContext);
      if (!omConfig?.enabled) {
        throw new HTTPException$2(400, { message: "Observational Memory is not enabled for this agent" });
      }
      const omProcessor = await agent.resolveProcessorById("observational-memory", requestContext);
      if (!omProcessor || typeof omProcessor.waitForBuffering !== "function") {
        throw new HTTPException$2(400, { message: "Observational Memory processor not available" });
      }
      await omProcessor.waitForBuffering(threadId, resourceId);
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new HTTPException$2(400, { message: "Memory is not configured for this agent" });
      }
      let memoryStore;
      try {
        memoryStore = await memory.storage.getStore("memory");
      } catch {
        throw new HTTPException$2(400, { message: "Memory storage is not initialized" });
      }
      if (!memoryStore) {
        throw new HTTPException$2(400, { message: "Memory storage is not initialized" });
      }
      const effectiveResourceId = resourceId;
      if (!effectiveResourceId) {
        throw new HTTPException$2(400, { message: "resourceId is required" });
      }
      const omThreadId = omConfig.scope === "resource" ? null : threadId ?? null;
      const record = await memoryStore.getObservationalMemory(omThreadId, effectiveResourceId);
      return { record: record ?? null };
    } catch (error) {
      console.error("Error awaiting buffer status", error);
      return handleError$1(error, "Error awaiting buffer status");
    }
  }
});
var LIST_THREADS_ROUTE = createRoute({
  method: "GET",
  path: "/memory/threads",
  responseType: "json",
  queryParamSchema: listThreadsQuerySchema,
  responseSchema: listThreadsResponseSchema,
  summary: "List memory threads",
  description: "Returns a paginated list of conversation threads with optional filtering by resource ID and/or metadata",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, resourceId, metadata, requestContext, page, perPage, orderBy }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      const filter = effectiveResourceId || metadata ? {} : void 0;
      if (effectiveResourceId) {
        filter.resourceId = effectiveResourceId;
      }
      if (metadata) {
        filter.metadata = metadata;
      }
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (memory) {
        const result = await memory.listThreads({
          filter,
          page,
          perPage,
          orderBy
        });
        return result;
      }
      if (!agentId) {
        const storage = getStorageFromContext({ mastra });
        if (storage) {
          const memoryStore = await storage.getStore("memory");
          if (memoryStore) {
            const result = await memoryStore.listThreads({
              filter,
              page,
              perPage,
              orderBy
            });
            return result;
          }
        }
      }
      throw new HTTPException$2(400, { message: "Memory is not initialized" });
    } catch (error) {
      return handleError$1(error, "Error listing threads");
    }
  }
});
var GET_THREAD_BY_ID_ROUTE = createRoute({
  method: "GET",
  path: "/memory/threads/:threadId",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: getThreadByIdQuerySchema,
  responseSchema: getThreadByIdResponseSchema,
  summary: "Get thread by ID",
  description: "Returns details for a specific conversation thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, threadId, resourceId, requestContext }) => {
    try {
      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      validateBody({ threadId: effectiveThreadId });
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (memory) {
        const thread = await memory.getThreadById({ threadId: effectiveThreadId });
        if (!thread) {
          throw new HTTPException$2(404, { message: "Thread not found" });
        }
        await validateThreadOwnership(thread, effectiveResourceId);
        return thread;
      }
      if (!agentId) {
        const storage = getStorageFromContext({ mastra });
        if (storage) {
          const memoryStore = await storage.getStore("memory");
          if (memoryStore) {
            const thread = await memoryStore.getThreadById({ threadId: effectiveThreadId });
            if (!thread) {
              throw new HTTPException$2(404, { message: "Thread not found" });
            }
            await validateThreadOwnership(thread, effectiveResourceId);
            return thread;
          }
        }
      }
      throw new HTTPException$2(400, { message: "Memory is not initialized" });
    } catch (error) {
      return handleError$1(error, "Error getting thread");
    }
  }
});
var LIST_MESSAGES_ROUTE = createRoute({
  method: "GET",
  path: "/memory/threads/:threadId/messages",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: listMessagesQuerySchema,
  responseSchema: listMessagesResponseSchema,
  summary: "List thread messages",
  description: "Returns a paginated list of messages in a conversation thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({
    mastra,
    agentId,
    threadId,
    resourceId,
    perPage,
    page,
    orderBy,
    include,
    filter,
    requestContext
  }) => {
    try {
      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      validateBody({ threadId: effectiveThreadId });
      if (!effectiveThreadId) {
        throw new HTTPException$2(400, { message: "No threadId found" });
      }
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (memory) {
        const thread = await memory.getThreadById({ threadId: effectiveThreadId });
        if (!thread) {
          throw new HTTPException$2(404, { message: "Thread not found" });
        }
        await validateThreadOwnership(thread, effectiveResourceId);
        const result = await memory.recall({
          threadId: effectiveThreadId,
          resourceId: effectiveResourceId,
          perPage,
          page,
          orderBy,
          include,
          filter
        });
        return result;
      }
      if (!agentId) {
        const storage = getStorageFromContext({ mastra });
        if (storage) {
          const memoryStore = await storage.getStore("memory");
          if (memoryStore) {
            const thread = await memoryStore.getThreadById({ threadId: effectiveThreadId });
            if (!thread) {
              throw new HTTPException$2(404, { message: "Thread not found" });
            }
            await validateThreadOwnership(thread, effectiveResourceId);
            const result = await memoryStore.listMessages({
              threadId: effectiveThreadId,
              resourceId: effectiveResourceId,
              perPage,
              page,
              orderBy,
              include,
              filter
            });
            return result;
          }
        }
      }
      return { messages: [], uiMessages: [] };
    } catch (error) {
      return handleError$1(error, "Error getting messages");
    }
  }
});
var GET_WORKING_MEMORY_ROUTE = createRoute({
  method: "GET",
  path: "/memory/threads/:threadId/working-memory",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: getWorkingMemoryQuerySchema,
  responseSchema: getWorkingMemoryResponseSchema,
  summary: "Get working memory",
  description: "Returns the working memory state for a thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, threadId, resourceId, requestContext, memoryConfig }) => {
    try {
      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      validateBody({ threadId: effectiveThreadId });
      if (!memory) {
        throw new HTTPException$2(400, { message: "Memory is not initialized" });
      }
      const thread = await memory.getThreadById({ threadId: effectiveThreadId });
      if (thread) {
        await validateThreadOwnership(thread, effectiveResourceId);
      }
      const threadExists = !!thread;
      const template = await memory.getWorkingMemoryTemplate({ memoryConfig });
      const workingMemoryTemplate = template?.format === "json" ? { ...template, content: JSON.stringify(generateEmptyFromSchema(template.content)) } : template;
      const workingMemory = await memory.getWorkingMemory({
        threadId: effectiveThreadId,
        resourceId: effectiveResourceId,
        memoryConfig
      });
      const config = memory.getMergedThreadConfig(memoryConfig || {});
      const source = config.workingMemory?.scope !== "thread" && effectiveResourceId ? "resource" : "thread";
      return { workingMemory, source, workingMemoryTemplate, threadExists };
    } catch (error) {
      return handleError$1(error, "Error getting working memory");
    }
  }
});
var SAVE_MESSAGES_ROUTE = createRoute({
  method: "POST",
  path: "/memory/save-messages",
  responseType: "json",
  queryParamSchema: agentIdQuerySchema,
  bodySchema: saveMessagesBodySchema,
  responseSchema: saveMessagesResponseSchema,
  summary: "Save messages",
  description: "Saves new messages to memory",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, messages, requestContext }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new HTTPException$2(400, { message: "Memory is not initialized" });
      }
      if (!messages) {
        throw new HTTPException$2(400, { message: "Messages are required" });
      }
      if (!Array.isArray(messages)) {
        throw new HTTPException$2(400, { message: "Messages should be an array" });
      }
      const invalidMessages = messages.filter((message) => !message.threadId || !message.resourceId);
      if (invalidMessages.length > 0) {
        throw new HTTPException$2(400, {
          message: `All messages must have threadId and resourceId fields. Found ${invalidMessages.length} invalid message(s).`
        });
      }
      if (effectiveResourceId) {
        const unauthorizedMessages = messages.filter((message) => message.resourceId !== effectiveResourceId);
        if (unauthorizedMessages.length > 0) {
          throw new HTTPException$2(403, {
            message: "Access denied: cannot save messages for a different resource"
          });
        }
        const threadIds = [...new Set(messages.map((m) => m.threadId).filter(Boolean))];
        for (const threadId of threadIds) {
          const thread = await memory.getThreadById({ threadId });
          await validateThreadOwnership(thread, effectiveResourceId);
        }
      }
      const processedMessages = messages.map((message) => ({
        ...message,
        id: message.id || memory.generateId(),
        createdAt: message.createdAt ? new Date(message.createdAt) : /* @__PURE__ */ new Date()
      }));
      const result = await memory.saveMessages({ messages: processedMessages, memoryConfig: {} });
      return result;
    } catch (error) {
      return handleError$1(error, "Error saving messages");
    }
  }
});
var CREATE_THREAD_ROUTE = createRoute({
  method: "POST",
  path: "/memory/threads",
  responseType: "json",
  queryParamSchema: agentIdQuerySchema,
  bodySchema: createThreadBodySchema,
  responseSchema: getThreadByIdResponseSchema,
  summary: "Create thread",
  description: "Creates a new conversation thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, resourceId, title, metadata, threadId, requestContext }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new HTTPException$2(400, { message: "Memory is not initialized" });
      }
      validateBody({ resourceId: effectiveResourceId });
      const result = await memory.createThread({
        resourceId: effectiveResourceId,
        title,
        metadata,
        threadId
      });
      return result;
    } catch (error) {
      return handleError$1(error, "Error saving thread to memory");
    }
  }
});
var UPDATE_THREAD_ROUTE = createRoute({
  method: "PATCH",
  path: "/memory/threads/:threadId",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: agentIdQuerySchema,
  bodySchema: updateThreadBodySchema,
  responseSchema: getThreadByIdResponseSchema,
  summary: "Update thread",
  description: "Updates a conversation thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, threadId, title, metadata, resourceId, requestContext }) => {
    try {
      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      const updatedAt = /* @__PURE__ */ new Date();
      validateBody({ threadId: effectiveThreadId });
      if (!memory) {
        throw new HTTPException$2(400, { message: "Memory is not initialized" });
      }
      const thread = await memory.getThreadById({ threadId: effectiveThreadId });
      if (!thread) {
        throw new HTTPException$2(404, { message: "Thread not found" });
      }
      await validateThreadOwnership(thread, effectiveResourceId);
      const updatedThread = {
        ...thread,
        title: title || thread.title,
        metadata: metadata || thread.metadata,
        // Don't allow changing resourceId if effectiveResourceId is set (prevents reassigning threads)
        resourceId: effectiveResourceId || resourceId || thread.resourceId,
        createdAt: thread.createdAt,
        updatedAt
      };
      const result = await memory.saveThread({ thread: updatedThread });
      return {
        ...result,
        resourceId: result.resourceId ?? null
      };
    } catch (error) {
      return handleError$1(error, "Error updating thread");
    }
  }
});
var DELETE_THREAD_ROUTE = createRoute({
  method: "DELETE",
  path: "/memory/threads/:threadId",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: deleteThreadQuerySchema,
  responseSchema: deleteThreadResponseSchema,
  summary: "Delete thread",
  description: "Deletes a conversation thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, threadId, resourceId, requestContext }) => {
    try {
      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      validateBody({ threadId: effectiveThreadId });
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new HTTPException$2(400, { message: "Memory is not initialized" });
      }
      const thread = await memory.getThreadById({ threadId: effectiveThreadId });
      if (!thread) {
        throw new HTTPException$2(404, { message: "Thread not found" });
      }
      await validateThreadOwnership(thread, effectiveResourceId);
      await memory.deleteThread(effectiveThreadId);
      return { result: "Thread deleted" };
    } catch (error) {
      return handleError$1(error, "Error deleting thread");
    }
  }
});
var CLONE_THREAD_ROUTE = createRoute({
  method: "POST",
  path: "/memory/threads/:threadId/clone",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: agentIdQuerySchema,
  bodySchema: cloneThreadBodySchema,
  responseSchema: cloneThreadResponseSchema,
  summary: "Clone thread",
  description: "Creates a copy of a conversation thread with all its messages",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, threadId, newThreadId, resourceId, title, metadata, options, requestContext }) => {
    try {
      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      validateBody({ threadId: effectiveThreadId });
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new HTTPException$2(400, { message: "Memory is not initialized" });
      }
      const sourceThread = await memory.getThreadById({ threadId: effectiveThreadId });
      if (!sourceThread) {
        throw new HTTPException$2(404, { message: "Source thread not found" });
      }
      await validateThreadOwnership(sourceThread, effectiveResourceId);
      const result = await memory.cloneThread({
        sourceThreadId: effectiveThreadId,
        newThreadId,
        // Use effective resourceId for the cloned thread
        resourceId: effectiveResourceId,
        title,
        metadata,
        options
      });
      return result;
    } catch (error) {
      return handleError$1(error, "Error cloning thread");
    }
  }
});
var UPDATE_WORKING_MEMORY_ROUTE = createRoute({
  method: "POST",
  path: "/memory/threads/:threadId/working-memory",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: agentIdQuerySchema,
  bodySchema: updateWorkingMemoryBodySchema,
  responseSchema: updateWorkingMemoryResponseSchema,
  summary: "Update working memory",
  description: "Updates the working memory state for a thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, threadId, resourceId, memoryConfig, workingMemory, requestContext }) => {
    try {
      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      validateBody({ threadId: effectiveThreadId, workingMemory });
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new HTTPException$2(400, { message: "Memory is not initialized" });
      }
      const thread = await memory.getThreadById({ threadId: effectiveThreadId });
      if (!thread) {
        throw new HTTPException$2(404, { message: "Thread not found" });
      }
      await validateThreadOwnership(thread, effectiveResourceId);
      await memory.updateWorkingMemory({
        threadId: effectiveThreadId,
        resourceId: effectiveResourceId,
        workingMemory,
        memoryConfig
      });
      return { success: true };
    } catch (error) {
      return handleError$1(error, "Error updating working memory");
    }
  }
});
var DELETE_MESSAGES_ROUTE = createRoute({
  method: "POST",
  path: "/memory/messages/delete",
  responseType: "json",
  queryParamSchema: deleteMessagesQuerySchema,
  bodySchema: deleteMessagesBodySchema,
  responseSchema: deleteMessagesResponseSchema,
  summary: "Delete messages",
  description: "Deletes specific messages from memory",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, resourceId, messageIds, requestContext }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      if (messageIds === void 0 || messageIds === null) {
        throw new HTTPException$2(400, { message: "messageIds is required" });
      }
      let normalizedIds;
      if (Array.isArray(messageIds)) {
        normalizedIds = messageIds;
      } else if (typeof messageIds === "string") {
        normalizedIds = [messageIds];
      } else {
        normalizedIds = [messageIds];
      }
      const stringIds = normalizedIds.map((id) => typeof id === "string" ? id : id.id);
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (effectiveResourceId && stringIds.length > 0) {
        const storage = memory?.storage || getStorageFromContext({ mastra });
        if (!storage) {
          throw new HTTPException$2(403, { message: "Access denied: unable to verify message ownership" });
        }
        const memoryStore = await storage.getStore("memory");
        if (!memoryStore) {
          throw new HTTPException$2(400, { message: "Memory is not initialized" });
        }
        const { messages } = await memoryStore.listMessagesById({ messageIds: stringIds });
        const threadIds = [...new Set(messages.map((m) => m.threadId).filter(Boolean))];
        for (const threadId of threadIds) {
          const thread = await memoryStore.getThreadById({ threadId });
          if (thread && thread.resourceId && thread.resourceId !== effectiveResourceId) {
            throw new HTTPException$2(403, {
              message: "Access denied: message belongs to a thread owned by a different resource"
            });
          }
        }
      }
      if (memory) {
        await memory.deleteMessages(normalizedIds);
      } else if (!agentId) {
        const storage = getStorageFromContext({ mastra });
        if (storage) {
          const memoryStore = await storage.getStore("memory");
          if (memoryStore) {
            await memoryStore.deleteMessages(stringIds);
          } else {
            throw new HTTPException$2(400, { message: "Memory is not initialized" });
          }
        } else {
          throw new HTTPException$2(400, { message: "Memory is not initialized" });
        }
      } else {
        throw new HTTPException$2(400, { message: "Memory is not initialized" });
      }
      const count = Array.isArray(messageIds) ? messageIds.length : 1;
      return { success: true, message: `${count} message${count === 1 ? "" : "s"} deleted successfully` };
    } catch (error) {
      return handleError$1(error, "Error deleting messages");
    }
  }
});
var SEARCH_MEMORY_ROUTE = createRoute({
  method: "GET",
  path: "/memory/search",
  responseType: "json",
  queryParamSchema: searchMemoryQuerySchema,
  responseSchema: searchMemoryResponseSchema,
  summary: "Search memory",
  description: "Searches across memory using semantic or text search",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, searchQuery, resourceId, threadId, limit = 20, requestContext, memoryConfig }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);
      validateBody({ searchQuery, resourceId: effectiveResourceId });
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new HTTPException$2(400, { message: "Memory is not initialized" });
      }
      const config = memory.getMergedThreadConfig(memoryConfig || {});
      const hasSemanticRecall = !!config?.semanticRecall;
      const resourceScope = typeof config?.semanticRecall === "object" ? config?.semanticRecall?.scope !== "thread" : true;
      const searchResults = [];
      if (effectiveThreadId && !resourceScope) {
        const thread = await memory.getThreadById({ threadId: effectiveThreadId });
        if (!thread) {
          return {
            results: [],
            count: 0,
            query: searchQuery,
            searchScope: resourceScope ? "resource" : "thread",
            searchType: hasSemanticRecall ? "semantic" : "text"
          };
        }
        await validateThreadOwnership(thread, effectiveResourceId);
      }
      let searchThreadId = effectiveThreadId;
      if (!searchThreadId) {
        const { threads } = await memory.listThreads({
          filter: { resourceId: effectiveResourceId },
          page: 0,
          perPage: 1,
          orderBy: { field: "updatedAt", direction: "DESC" }
        });
        if (threads.length === 0) {
          return {
            results: [],
            count: 0,
            query: searchQuery,
            searchScope: resourceScope ? "resource" : "thread",
            searchType: hasSemanticRecall ? "semantic" : "text"
          };
        }
        searchThreadId = threads[0].id;
      }
      const beforeRange = typeof config.semanticRecall === `boolean` ? 2 : typeof config.semanticRecall?.messageRange === `number` ? config.semanticRecall.messageRange : config.semanticRecall?.messageRange.before || 2;
      const afterRange = typeof config.semanticRecall === `boolean` ? 2 : typeof config.semanticRecall?.messageRange === `number` ? config.semanticRecall.messageRange : config.semanticRecall?.messageRange.after || 2;
      if (resourceScope && config.semanticRecall) {
        config.semanticRecall = typeof config.semanticRecall === `boolean` ? (
          // make message range 0 so we can highlight the matches in search, message range will include other messages, not the matching ones
          // and we add prev/next messages in a special section on each message anyway
          { messageRange: 0, topK: 2, scope: "resource" }
        ) : { ...config.semanticRecall, messageRange: 0 };
      }
      const threadConfig = memory.getMergedThreadConfig(config || {});
      if (!threadConfig.lastMessages && !threadConfig.semanticRecall) {
        return { results: [], count: 0, query: searchQuery };
      }
      const result = await memory.recall({
        threadId: searchThreadId,
        resourceId: effectiveResourceId,
        perPage: threadConfig.lastMessages,
        threadConfig: config,
        vectorSearchString: threadConfig.semanticRecall && searchQuery ? searchQuery : void 0
      });
      const threadIds = Array.from(
        new Set(result.messages.map((m) => m.threadId || searchThreadId).filter(Boolean))
      );
      const fetched = await Promise.all(threadIds.map((id) => memory.getThreadById({ threadId: id })));
      const threadMap = new Map(fetched.filter(Boolean).map((t) => [t.id, t]));
      for (const msg of result.messages) {
        const content = getTextContent(msg);
        const msgThreadId = msg.threadId || searchThreadId;
        const thread = threadMap.get(msgThreadId);
        const threadMessages = (await memory.recall({ threadId: msgThreadId })).messages;
        const messageIndex = threadMessages.findIndex((m) => m.id === msg.id);
        const searchResult = {
          id: msg.id,
          role: msg.role,
          content,
          createdAt: msg.createdAt,
          threadId: msgThreadId,
          threadTitle: thread?.title || msgThreadId
        };
        if (messageIndex !== -1) {
          searchResult.context = {
            before: threadMessages.slice(Math.max(0, messageIndex - beforeRange), messageIndex).map((m) => ({
              id: m.id,
              role: m.role,
              content: getTextContent(m),
              createdAt: m.createdAt || /* @__PURE__ */ new Date()
            })),
            after: threadMessages.slice(messageIndex + 1, messageIndex + afterRange + 1).map((m) => ({
              id: m.id,
              role: m.role,
              content: getTextContent(m),
              createdAt: m.createdAt || /* @__PURE__ */ new Date()
            }))
          };
        }
        searchResults.push(searchResult);
      }
      const sortedResults = searchResults.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()).slice(0, limit);
      return {
        results: sortedResults,
        count: sortedResults.length,
        query: searchQuery,
        searchScope: resourceScope ? "resource" : "thread",
        searchType: hasSemanticRecall ? "semantic" : "text"
      };
    } catch (error) {
      return handleError$1(error, "Error searching memory");
    }
  }
});
var GET_MEMORY_STATUS_NETWORK_ROUTE = createRoute({
  method: "GET",
  path: "/memory/network/status",
  responseType: "json",
  queryParamSchema: getMemoryStatusNetworkQuerySchema,
  responseSchema: memoryStatusResponseSchema,
  summary: "Get memory status (network)",
  description: "Returns the current status of the memory system (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: GET_MEMORY_STATUS_ROUTE.handler
});
var LIST_THREADS_NETWORK_ROUTE = createRoute({
  method: "GET",
  path: "/memory/network/threads",
  responseType: "json",
  queryParamSchema: listThreadsNetworkQuerySchema,
  responseSchema: listThreadsResponseSchema,
  summary: "List memory threads (network)",
  description: "Returns a paginated list of conversation threads (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: LIST_THREADS_ROUTE.handler
});
var GET_THREAD_BY_ID_NETWORK_ROUTE = createRoute({
  method: "GET",
  path: "/memory/network/threads/:threadId",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: getThreadByIdNetworkQuerySchema,
  responseSchema: getThreadByIdResponseSchema,
  summary: "Get thread by ID (network)",
  description: "Returns details for a specific conversation thread (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: GET_THREAD_BY_ID_ROUTE.handler
});
var LIST_MESSAGES_NETWORK_ROUTE = createRoute({
  method: "GET",
  path: "/memory/network/threads/:threadId/messages",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: listMessagesNetworkQuerySchema,
  responseSchema: listMessagesResponseSchema,
  summary: "List thread messages (network)",
  description: "Returns a paginated list of messages in a conversation thread (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: LIST_MESSAGES_ROUTE.handler
});
var SAVE_MESSAGES_NETWORK_ROUTE = createRoute({
  method: "POST",
  path: "/memory/network/save-messages",
  responseType: "json",
  queryParamSchema: saveMessagesNetworkQuerySchema,
  bodySchema: saveMessagesBodySchema,
  responseSchema: saveMessagesResponseSchema,
  summary: "Save messages (network)",
  description: "Saves new messages to memory (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: SAVE_MESSAGES_ROUTE.handler
});
var CREATE_THREAD_NETWORK_ROUTE = createRoute({
  method: "POST",
  path: "/memory/network/threads",
  responseType: "json",
  queryParamSchema: createThreadNetworkQuerySchema,
  bodySchema: createThreadBodySchema,
  responseSchema: getThreadByIdResponseSchema,
  summary: "Create thread (network)",
  description: "Creates a new conversation thread (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: CREATE_THREAD_ROUTE.handler
});
var UPDATE_THREAD_NETWORK_ROUTE = createRoute({
  method: "PATCH",
  path: "/memory/network/threads/:threadId",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: updateThreadNetworkQuerySchema,
  bodySchema: updateThreadBodySchema,
  responseSchema: getThreadByIdResponseSchema,
  summary: "Update thread (network)",
  description: "Updates a conversation thread (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: UPDATE_THREAD_ROUTE.handler
});
var DELETE_THREAD_NETWORK_ROUTE = createRoute({
  method: "DELETE",
  path: "/memory/network/threads/:threadId",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: deleteThreadNetworkQuerySchema,
  responseSchema: deleteThreadResponseSchema,
  summary: "Delete thread (network)",
  description: "Deletes a conversation thread (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: DELETE_THREAD_ROUTE.handler
});
var DELETE_MESSAGES_NETWORK_ROUTE = createRoute({
  method: "POST",
  path: "/memory/network/messages/delete",
  responseType: "json",
  queryParamSchema: deleteMessagesNetworkQuerySchema,
  bodySchema: deleteMessagesBodySchema,
  responseSchema: deleteMessagesResponseSchema,
  summary: "Delete messages (network)",
  description: "Deletes specific messages from memory (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: DELETE_MESSAGES_ROUTE.handler
});

// src/server/handlers/observability.ts
var observability_exports = {};
__export(observability_exports, {
  GET_TRACE_ROUTE: () => GET_TRACE_ROUTE,
  LIST_SCORES_BY_SPAN_ROUTE: () => LIST_SCORES_BY_SPAN_ROUTE,
  LIST_TRACES_ROUTE: () => LIST_TRACES_ROUTE,
  SCORE_TRACES_ROUTE: () => SCORE_TRACES_ROUTE
});
var legacyQueryParamsSchema = z.object({
  // Old: dateRange was in pagination, now it's startedAt in filters
  dateRange: dateRangeSchema.optional(),
  // Old: name matched span names like "agent run: 'myAgent'"
  name: z.string().optional(),
  // entityType needs preprocessing to handle legacy 'workflow' value
  entityType: z.preprocess((val) => val === "workflow" ? "workflow_run" : val, z.string().optional())
});
function transformLegacyParams(params) {
  const result = { ...params };
  if (result.entityType === "workflow") {
    result.entityType = "workflow_run";
  }
  if (params.dateRange && !params.startedAt) {
    result.startedAt = params.dateRange;
    delete result.dateRange;
  }
  if (typeof params.name === "string" && !params.entityId) {
    const agentMatch = params.name.match(/^agent run: '([^']+)'$/);
    const workflowMatch = params.name.match(/^workflow run: '([^']+)'$/);
    if (agentMatch) {
      result.entityId = agentMatch[1];
      result.entityType = "agent";
    } else if (workflowMatch) {
      result.entityId = workflowMatch[1];
      result.entityType = "workflow_run";
    }
    delete result.name;
  }
  return result;
}
function getStorage(mastra) {
  const storage = mastra.getStorage();
  if (!storage) {
    throw new HTTPException$2(500, { message: "Storage is not available" });
  }
  return storage;
}
async function getObservabilityStore(mastra) {
  const storage = getStorage(mastra);
  const observability = await storage.getStore("observability");
  if (!observability) {
    throw new HTTPException$2(500, { message: "Observability storage domain is not available" });
  }
  return observability;
}
async function getScoresStore(mastra) {
  const storage = getStorage(mastra);
  const scores = await storage.getStore("scores");
  if (!scores) {
    throw new HTTPException$2(500, { message: "Scores storage domain is not available" });
  }
  return scores;
}
var LIST_TRACES_ROUTE = createRoute({
  method: "GET",
  path: "/observability/traces",
  responseType: "json",
  queryParamSchema: wrapSchemaForQueryParams(
    tracesFilterSchema.merge(paginationArgsSchema).merge(tracesOrderBySchema).merge(legacyQueryParamsSchema).partial()
  ),
  responseSchema: listTracesResponseSchema,
  summary: "List traces",
  description: "Returns a paginated list of traces with optional filtering and sorting",
  tags: ["Observability"],
  requiresAuth: true,
  handler: async ({ mastra, ...params }) => {
    try {
      const transformedParams = transformLegacyParams(params);
      const filters = pickParams(tracesFilterSchema, transformedParams);
      const pagination = pickParams(paginationArgsSchema, transformedParams);
      const orderBy = pickParams(tracesOrderBySchema, transformedParams);
      const observabilityStore = await getObservabilityStore(mastra);
      return await observabilityStore.listTraces({ filters, pagination, orderBy });
    } catch (error) {
      return handleError$1(error, "Error listing traces");
    }
  }
});
var GET_TRACE_ROUTE = createRoute({
  method: "GET",
  path: "/observability/traces/:traceId",
  responseType: "json",
  pathParamSchema: getTraceArgsSchema,
  responseSchema: getTraceResponseSchema,
  summary: "Get AI trace by ID",
  description: "Returns a complete AI trace with all spans by trace ID",
  tags: ["Observability"],
  requiresAuth: true,
  handler: async ({ mastra, traceId }) => {
    try {
      const observabilityStore = await getObservabilityStore(mastra);
      const trace = await observabilityStore.getTrace({ traceId });
      if (!trace) {
        throw new HTTPException$2(404, { message: `Trace with ID '${traceId}' not found` });
      }
      return trace;
    } catch (error) {
      return handleError$1(error, "Error getting trace");
    }
  }
});
var SCORE_TRACES_ROUTE = createRoute({
  method: "POST",
  path: "/observability/traces/score",
  responseType: "json",
  bodySchema: scoreTracesRequestSchema,
  responseSchema: scoreTracesResponseSchema,
  summary: "Score traces",
  description: "Scores one or more traces using a specified scorer (fire-and-forget)",
  tags: ["Observability"],
  requiresAuth: true,
  handler: async ({ mastra, ...params }) => {
    try {
      getStorage(mastra);
      const { scorerName, targets } = params;
      const scorer = mastra.getScorerById(scorerName);
      if (!scorer) {
        throw new HTTPException$2(404, { message: `Scorer '${scorerName}' not found` });
      }
      scoreTraces({
        scorerId: scorer.config.id || scorer.config.name,
        targets,
        mastra
      }).catch((error) => {
        const logger = mastra.getLogger();
        logger?.error(`Background trace scoring failed: ${error.message}`, error);
      });
      return {
        status: "success",
        message: `Scoring started for ${targets.length} ${targets.length === 1 ? "trace" : "traces"}`,
        traceCount: targets.length
      };
    } catch (error) {
      return handleError$1(error, "Error processing trace scoring");
    }
  }
});
var LIST_SCORES_BY_SPAN_ROUTE = createRoute({
  method: "GET",
  path: "/observability/traces/:traceId/:spanId/scores",
  responseType: "json",
  pathParamSchema: spanIdsSchema,
  queryParamSchema: paginationArgsSchema,
  responseSchema: listScoresResponseSchema,
  summary: "List scores by span",
  description: "Returns all scores for a specific span within a trace",
  tags: ["Observability"],
  requiresAuth: true,
  handler: async ({ mastra, ...params }) => {
    try {
      const pagination = pickParams(paginationArgsSchema, params);
      const spanIds = pickParams(spanIdsSchema, params);
      const scoresStore = await getScoresStore(mastra);
      return await scoresStore.listScoresBySpan({
        ...spanIds,
        pagination
      });
    } catch (error) {
      return handleError$1(error, "Error getting scores by span");
    }
  }
});

// src/server/handlers/scores.ts
var scores_exports = {};
__export(scores_exports, {
  GET_SCORER_ROUTE: () => GET_SCORER_ROUTE,
  LIST_SCORERS_ROUTE: () => LIST_SCORERS_ROUTE,
  LIST_SCORES_BY_ENTITY_ID_ROUTE: () => LIST_SCORES_BY_ENTITY_ID_ROUTE,
  LIST_SCORES_BY_RUN_ID_ROUTE: () => LIST_SCORES_BY_RUN_ID_ROUTE,
  LIST_SCORES_BY_SCORER_ID_ROUTE: () => LIST_SCORES_BY_SCORER_ID_ROUTE,
  SAVE_SCORE_ROUTE: () => SAVE_SCORE_ROUTE
});
var scoringSamplingConfigSchema = z$1.object({});
var mastraScorerConfigSchema = z$1.object({
  id: z$1.string(),
  name: z$1.string().optional(),
  description: z$1.string(),
  type: z$1.unknown().optional(),
  judge: z$1.unknown().optional()
});
var mastraScorerSchema = z$1.object({
  config: mastraScorerConfigSchema
});
var scorerEntrySchema = z$1.object({
  scorer: mastraScorerSchema,
  sampling: scoringSamplingConfigSchema.optional(),
  agentIds: z$1.array(z$1.string()),
  agentNames: z$1.array(z$1.string()),
  workflowIds: z$1.array(z$1.string()),
  isRegistered: z$1.boolean()
});
var listScorersResponseSchema = z$1.record(z$1.string(), scorerEntrySchema);
var scorerIdPathParams = z$1.object({
  scorerId: z$1.string().describe("Unique identifier for the scorer")
});
var entityPathParams = z$1.object({
  entityType: z$1.string().describe("Type of the entity (AGENT or WORKFLOW)"),
  entityId: z$1.string().describe("Unique identifier for the entity")
});
var listScoresByRunIdQuerySchema = z$1.object({
  page: z$1.coerce.number().optional().default(0),
  perPage: z$1.coerce.number().optional().default(10)
});
var listScoresByScorerIdQuerySchema = z$1.object({
  page: z$1.coerce.number().optional().default(0),
  perPage: z$1.coerce.number().optional().default(10),
  entityId: z$1.string().optional(),
  entityType: z$1.string().optional()
});
var listScoresByEntityIdQuerySchema = z$1.object({
  page: z$1.coerce.number().optional().default(0),
  perPage: z$1.coerce.number().optional().default(10)
});
var saveScoreBodySchema = z$1.object({
  score: z$1.unknown()
  // ScoreRowData - complex type
});
var scoresWithPaginationResponseSchema = z$1.object({
  pagination: paginationInfoSchema,
  scores: z$1.array(z$1.unknown())
  // Array of score records
});
var saveScoreResponseSchema = z$1.object({
  score: z$1.unknown()
  // ScoreRowData
});

// src/server/handlers/scores.ts
async function listScorersFromSystem({
  mastra,
  requestContext
}) {
  const agents = mastra.listAgents();
  const workflows = mastra.listWorkflows();
  const scorersMap = /* @__PURE__ */ new Map();
  const processAgentScorers = async (agent) => {
    const scorers = await agent.listScorers({
      requestContext
    }) || {};
    if (Object.keys(scorers).length > 0) {
      for (const [_scorerId, scorer] of Object.entries(scorers)) {
        const scorerId = scorer.scorer.id;
        if (scorersMap.has(scorerId)) {
          scorersMap.get(scorerId)?.agentIds.push(agent.id);
          scorersMap.get(scorerId)?.agentNames.push(agent.name);
        } else {
          scorersMap.set(scorerId, {
            workflowIds: [],
            ...scorer,
            agentNames: [agent.name],
            agentIds: [agent.id],
            isRegistered: false
          });
        }
      }
    }
  };
  for (const [_, agent] of Object.entries(agents)) {
    await processAgentScorers(agent);
  }
  try {
    const editor = mastra.getEditor();
    const storedAgentsResult = await editor?.agent.list();
    if (storedAgentsResult?.agents) {
      for (const storedAgentConfig of storedAgentsResult.agents) {
        try {
          const agent = await editor?.agent.getById(storedAgentConfig.id);
          if (agent) {
            await processAgentScorers(agent);
          }
        } catch {
        }
      }
    }
  } catch {
  }
  try {
    const editor = mastra.getEditor();
    const storedScorersResult = await editor?.scorer.list();
    if (storedScorersResult?.scorerDefinitions) {
      for (const storedScorerConfig of storedScorersResult.scorerDefinitions) {
        try {
          await editor?.scorer.getById(storedScorerConfig.id);
        } catch {
        }
      }
    }
  } catch {
  }
  for (const [workflowId, workflow] of Object.entries(workflows)) {
    const scorers = await workflow.listScorers({
      requestContext
    }) || {};
    if (Object.keys(scorers).length > 0) {
      for (const [_scorerId, scorer] of Object.entries(scorers)) {
        const scorerName = scorer.scorer.name;
        if (scorersMap.has(scorerName)) {
          scorersMap.get(scorerName)?.workflowIds.push(workflowId);
        } else {
          scorersMap.set(scorerName, {
            agentIds: [],
            agentNames: [],
            ...scorer,
            workflowIds: [workflowId],
            isRegistered: false
          });
        }
      }
    }
  }
  const registeredScorers = await mastra.listScorers();
  for (const [_scorerId, scorer] of Object.entries(registeredScorers || {})) {
    const scorerId = scorer.id;
    if (scorersMap.has(scorerId)) {
      scorersMap.get(scorerId).isRegistered = true;
    } else {
      scorersMap.set(scorerId, {
        scorer,
        agentIds: [],
        agentNames: [],
        workflowIds: [],
        isRegistered: true
      });
    }
  }
  return Object.fromEntries(scorersMap.entries());
}
function getTraceDetails(traceIdWithSpanId) {
  if (!traceIdWithSpanId) {
    return {};
  }
  const [traceId, spanId] = traceIdWithSpanId.split("-");
  return {
    ...traceId ? { traceId } : {},
    ...spanId ? { spanId } : {}
  };
}
var LIST_SCORERS_ROUTE = createRoute({
  method: "GET",
  path: "/scores/scorers",
  responseType: "json",
  responseSchema: listScorersResponseSchema,
  summary: "List all scorers",
  description: "Returns a list of all registered scorers with their configuration and associated agents and workflows",
  tags: ["Scoring"],
  requiresAuth: true,
  handler: async ({ mastra, requestContext }) => {
    const scorers = await listScorersFromSystem({
      mastra,
      requestContext
    });
    return scorers;
  }
});
var GET_SCORER_ROUTE = createRoute({
  method: "GET",
  path: "/scores/scorers/:scorerId",
  responseType: "json",
  pathParamSchema: scorerIdPathParams,
  responseSchema: scorerEntrySchema.nullable(),
  summary: "Get scorer by ID",
  description: "Returns details for a specific scorer including its configuration and associations",
  tags: ["Scoring"],
  requiresAuth: true,
  handler: async ({ mastra, scorerId, requestContext }) => {
    const scorers = await listScorersFromSystem({
      mastra,
      requestContext
    });
    const scorer = scorers[scorerId];
    if (!scorer) {
      return null;
    }
    return scorer;
  }
});
var LIST_SCORES_BY_RUN_ID_ROUTE = createRoute({
  method: "GET",
  path: "/scores/run/:runId",
  responseType: "json",
  pathParamSchema: runIdSchema,
  queryParamSchema: listScoresByRunIdQuerySchema,
  responseSchema: scoresWithPaginationResponseSchema,
  summary: "List scores by run ID",
  description: "Returns all scores for a specific execution run",
  tags: ["Scoring"],
  requiresAuth: true,
  handler: async ({ mastra, runId, ...params }) => {
    try {
      const { page, perPage } = params;
      const pagination = {
        page: page ?? 0,
        perPage: perPage ?? 10
      };
      const scores = await mastra.getStorage()?.getStore("scores");
      const scoreResults = await scores?.listScoresByRunId?.({
        runId,
        pagination
      }) || { pagination: { total: 0, page: 0, perPage: 0, hasMore: false }, scores: [] };
      return {
        pagination: scoreResults.pagination,
        scores: scoreResults.scores.map((score) => ({ ...score, ...getTraceDetails(score.traceId) }))
      };
    } catch (error) {
      return handleError$1(error, "Error getting scores by run id");
    }
  }
});
var LIST_SCORES_BY_SCORER_ID_ROUTE = createRoute({
  method: "GET",
  path: "/scores/scorer/:scorerId",
  responseType: "json",
  pathParamSchema: scorerIdPathParams,
  queryParamSchema: listScoresByScorerIdQuerySchema,
  responseSchema: scoresWithPaginationResponseSchema,
  summary: "List scores by scorer ID",
  description: "Returns all scores generated by a specific scorer",
  tags: ["Scoring"],
  requiresAuth: true,
  handler: async ({ mastra, scorerId, ...params }) => {
    try {
      const { page, perPage, entityId, entityType } = params;
      const filters = Object.fromEntries(Object.entries({ entityId, entityType }).filter(([_, v]) => v !== void 0));
      const scores = await mastra.getStorage()?.getStore("scores");
      const scoreResults = await scores?.listScoresByScorerId?.({
        scorerId,
        pagination: { page: page ?? 0, perPage: perPage ?? 10 },
        ...filters
      }) || { pagination: { total: 0, page: 0, perPage: 0, hasMore: false }, scores: [] };
      return {
        pagination: scoreResults.pagination,
        scores: scoreResults.scores.map((score) => ({ ...score, ...getTraceDetails(score.traceId) }))
      };
    } catch (error) {
      return handleError$1(error, "Error getting scores by scorer id");
    }
  }
});
var LIST_SCORES_BY_ENTITY_ID_ROUTE = createRoute({
  method: "GET",
  path: "/scores/entity/:entityType/:entityId",
  responseType: "json",
  pathParamSchema: entityPathParams,
  queryParamSchema: listScoresByEntityIdQuerySchema,
  responseSchema: scoresWithPaginationResponseSchema,
  summary: "List scores by entity ID",
  description: "Returns all scores for a specific entity (agent or workflow)",
  tags: ["Scoring"],
  requiresAuth: true,
  handler: async ({ mastra, entityId, entityType, ...params }) => {
    try {
      const { page, perPage } = params;
      let entityIdToUse = entityId;
      if (entityType === "AGENT") {
        const agent = await getAgentFromSystem({ mastra, agentId: entityId });
        entityIdToUse = agent.id;
      } else if (entityType === "WORKFLOW") {
        const workflow = mastra.getWorkflowById(entityId);
        entityIdToUse = workflow.id;
      }
      const pagination = {
        page: page ?? 0,
        perPage: perPage ?? 10
      };
      const scoresStore = await mastra.getStorage()?.getStore("scores");
      const scoreResults = await scoresStore?.listScoresByEntityId?.({
        entityId: entityIdToUse,
        entityType,
        pagination
      }) || { pagination: { total: 0, page: 0, perPage: 0, hasMore: false }, scores: [] };
      return {
        pagination: scoreResults.pagination,
        scores: scoreResults.scores.map((score) => ({ ...score, ...getTraceDetails(score.traceId) }))
      };
    } catch (error) {
      return handleError$1(error, "Error getting scores by entity id");
    }
  }
});
var SAVE_SCORE_ROUTE = createRoute({
  method: "POST",
  path: "/scores",
  responseType: "json",
  bodySchema: saveScoreBodySchema,
  responseSchema: saveScoreResponseSchema,
  summary: "Save score",
  description: "Saves a new score record to storage",
  tags: ["Scoring"],
  requiresAuth: true,
  handler: async ({ mastra, ...params }) => {
    try {
      const { score } = params;
      const scoresStore = await mastra.getStorage()?.getStore("scores");
      const result = await scoresStore?.saveScore?.(score);
      if (!result) {
        throw new HTTPException$2(500, { message: "Storage not configured" });
      }
      return result;
    } catch (error) {
      return handleError$1(error, "Error saving score");
    }
  }
});

// src/server/auth/defaults.ts
var defaultAuthConfig = {
  protected: ["/api/*"],
  public: ["/api"],
  // Simple rule system
  rules: [
    // Admin users can do anything
    {
      condition: (user) => {
        if (typeof user === "object" && user !== null) {
          if ("isAdmin" in user) {
            return !!user.isAdmin;
          }
          if ("role" in user) {
            return user.role === "admin";
          }
        }
        return false;
      },
      allow: true
    }
  ]
};

// src/server/auth/path-pattern.ts
function parse(input, loose) {
  if (input instanceof RegExp) return { keys: false, pattern: input };
  let c;
  let o;
  let tmp;
  let ext;
  const keys = [];
  let pattern = "";
  const arr = input.split("/");
  arr[0] || arr.shift();
  while (tmp = arr.shift()) {
    c = tmp[0];
    if (c === "*") {
      keys.push(c);
      pattern += tmp[1] === "?" ? "(?:/(.*))?" : "/(.*)";
    } else if (c === ":") {
      o = tmp.indexOf("?", 1);
      ext = tmp.indexOf(".", 1);
      keys.push(tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length));
      pattern += !!~o && !~ext ? "(?:/([^/]+?))?" : "/([^/]+?)";
      if (!!~ext) pattern += (!!~o ? "?" : "") + "\\" + tmp.substring(ext);
    } else {
      pattern += "/" + tmp;
    }
  }
  return {
    keys,
    pattern: new RegExp("^" + pattern + ("/?$"), "i")
  };
}

// src/server/auth/helpers.ts
var isProtectedCustomRoute = (path, method, customRouteAuthConfig) => {
  if (!customRouteAuthConfig) {
    return false;
  }
  const exactRouteKey = `${method}:${path}`;
  if (customRouteAuthConfig.has(exactRouteKey)) {
    return customRouteAuthConfig.get(exactRouteKey) === true;
  }
  const allRouteKey = `ALL:${path}`;
  if (customRouteAuthConfig.has(allRouteKey)) {
    return customRouteAuthConfig.get(allRouteKey) === true;
  }
  for (const [routeKey, requiresAuth] of customRouteAuthConfig.entries()) {
    const colonIndex = routeKey.indexOf(":");
    if (colonIndex === -1) {
      continue;
    }
    const routeMethod = routeKey.substring(0, colonIndex);
    const routePattern = routeKey.substring(colonIndex + 1);
    if (routeMethod !== method && routeMethod !== "ALL") {
      continue;
    }
    if (pathMatchesPattern(path, routePattern)) {
      return requiresAuth === true;
    }
  }
  return false;
};
var isDevPlaygroundRequest = (path, method, getHeader, authConfig, customRouteAuthConfig) => {
  const protectedAccess = [...defaultAuthConfig.protected || [], ...authConfig.protected || []];
  return process.env.MASTRA_DEV === "true" && // Allow if path doesn't match protected patterns AND is not a protected custom route
  (!isAnyMatch(path, method, protectedAccess) && !isProtectedCustomRoute(path, method, customRouteAuthConfig) || // Or if has playground header
  getHeader("x-mastra-dev-playground") === "true");
};
var isCustomRoutePublic = (path, method, customRouteAuthConfig) => {
  if (!customRouteAuthConfig) {
    return false;
  }
  const exactRouteKey = `${method}:${path}`;
  if (customRouteAuthConfig.has(exactRouteKey)) {
    return !customRouteAuthConfig.get(exactRouteKey);
  }
  const allRouteKey = `ALL:${path}`;
  if (customRouteAuthConfig.has(allRouteKey)) {
    return !customRouteAuthConfig.get(allRouteKey);
  }
  for (const [routeKey, requiresAuth] of customRouteAuthConfig.entries()) {
    const colonIndex = routeKey.indexOf(":");
    if (colonIndex === -1) {
      continue;
    }
    const routeMethod = routeKey.substring(0, colonIndex);
    const routePattern = routeKey.substring(colonIndex + 1);
    if (routeMethod !== method && routeMethod !== "ALL") {
      continue;
    }
    if (pathMatchesPattern(path, routePattern)) {
      return !requiresAuth;
    }
  }
  return false;
};
var isProtectedPath = (path, method, authConfig, customRouteAuthConfig) => {
  const protectedAccess = [...defaultAuthConfig.protected || [], ...authConfig.protected || []];
  return isAnyMatch(path, method, protectedAccess) || !isCustomRoutePublic(path, method, customRouteAuthConfig);
};
var canAccessPublicly = (path, method, authConfig) => {
  const publicAccess = [...defaultAuthConfig.public || [], ...authConfig.public || []];
  return isAnyMatch(path, method, publicAccess);
};
var isAnyMatch = (path, method, patterns) => {
  if (!patterns) {
    return false;
  }
  for (const patternPathOrMethod of patterns) {
    if (patternPathOrMethod instanceof RegExp) {
      if (patternPathOrMethod.test(path)) {
        return true;
      }
    }
    if (typeof patternPathOrMethod === "string" && pathMatchesPattern(path, patternPathOrMethod)) {
      return true;
    }
    if (Array.isArray(patternPathOrMethod) && patternPathOrMethod.length === 2) {
      const [pattern, methodOrMethods] = patternPathOrMethod;
      if (pathMatchesPattern(path, pattern) && matchesOrIncludes(methodOrMethods, method)) {
        return true;
      }
    }
  }
  return false;
};
var pathMatchesPattern = (path, pattern) => {
  const { pattern: regex } = parse(pattern);
  return regex.test(path);
};
var pathMatchesRule = (path, rulePath) => {
  if (!rulePath) return true;
  if (typeof rulePath === "string") {
    return pathMatchesPattern(path, rulePath);
  }
  if (rulePath instanceof RegExp) {
    return rulePath.test(path);
  }
  if (Array.isArray(rulePath)) {
    return rulePath.some((p) => pathMatchesPattern(path, p));
  }
  return false;
};
var matchesOrIncludes = (values, value) => {
  if (typeof values === "string") {
    return values === value;
  }
  if (Array.isArray(values)) {
    return values.includes(value);
  }
  return false;
};
var checkRules = async (rules, path, method, user) => {
  for (const i in rules || []) {
    const rule = rules?.[i];
    if (!pathMatchesRule(path, rule.path)) {
      continue;
    }
    if (rule.methods && !matchesOrIncludes(rule.methods, method)) {
      continue;
    }
    const condition = rule.condition;
    if (typeof condition === "function") {
      const allowed = await Promise.resolve().then(() => condition(user)).catch(() => false);
      if (allowed) {
        return true;
      }
    } else if (rule.allow) {
      return true;
    }
  }
  return false;
};

// src/server/handlers/a2a.ts
var a2a_exports = {};
__export(a2a_exports, {
  AGENT_EXECUTION_ROUTE: () => AGENT_EXECUTION_ROUTE,
  GET_AGENT_CARD_ROUTE: () => GET_AGENT_CARD_ROUTE,
  getAgentCardByIdHandler: () => getAgentCardByIdHandler,
  getAgentExecutionHandler: () => getAgentExecutionHandler,
  handleMessageSend: () => handleMessageSend,
  handleMessageStream: () => handleMessageStream,
  handleTaskCancel: () => handleTaskCancel,
  handleTaskGet: () => handleTaskGet
});
function normalizeError(error, reqId, taskId, logger) {
  let a2aError;
  if (error instanceof MastraA2AError) {
    a2aError = error;
  } else if (error instanceof Error) {
    a2aError = MastraA2AError.internalError(error.message, { stack: error.stack });
  } else {
    a2aError = MastraA2AError.internalError("An unknown error occurred.", error);
  }
  if (taskId && !a2aError.taskId) {
    a2aError.taskId = taskId;
  }
  logger?.error(`Error processing request (Task: ${a2aError.taskId ?? "N/A"}, ReqID: ${reqId ?? "N/A"}):`, a2aError);
  return createErrorResponse(reqId, a2aError.toJSONRPCError());
}
function createErrorResponse(id, error) {
  return {
    jsonrpc: "2.0",
    id,
    // Can be null if request ID was invalid/missing
    error
  };
}
function createSuccessResponse(id, result) {
  if (!id) {
    throw MastraA2AError.internalError("Cannot create success response for null ID.");
  }
  return {
    jsonrpc: "2.0",
    id,
    result
  };
}
function convertToCoreMessage(message) {
  return {
    role: message.role === "user" ? "user" : "assistant",
    content: message.parts.map((msg) => convertToCoreMessagePart(msg))
  };
}
function convertToCoreMessagePart(part) {
  switch (part.kind) {
    case "text":
      return {
        type: "text",
        text: part.text
      };
    case "file":
      return {
        type: "file",
        data: "uri" in part.file ? new URL(part.file.uri) : part.file.bytes,
        mimeType: part.file.mimeType
      };
    case "data":
      throw new Error("Data parts are not supported in core messages");
  }
}

// src/server/a2a/tasks.ts
function isTaskStatusUpdate(update) {
  return "state" in update && !("parts" in update);
}
function isArtifactUpdate(update) {
  return "kind" in update && update.kind === "artifact-update";
}
function applyUpdateToTask(current, update) {
  let newTask = structuredClone(current);
  if (isTaskStatusUpdate(update)) {
    newTask.status = {
      ...newTask.status,
      // Keep existing properties if not overwritten
      ...update,
      // Apply updates
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  } else if (isArtifactUpdate(update)) {
    if (!newTask.artifacts) {
      newTask.artifacts = [];
    } else {
      newTask.artifacts = [...newTask.artifacts];
    }
    const artifact = update.artifact;
    const existingIndex = newTask.artifacts.findIndex((a) => a.name === artifact.name);
    const existingArtifact = newTask.artifacts[existingIndex];
    if (existingArtifact) {
      if (update.append) {
        const appendedArtifact = JSON.parse(JSON.stringify(existingArtifact));
        appendedArtifact.parts.push(...artifact.parts);
        if (artifact.metadata) {
          appendedArtifact.metadata = {
            ...appendedArtifact.metadata || {},
            ...artifact.metadata
          };
        }
        if (artifact.description) appendedArtifact.description = artifact.description;
        newTask.artifacts[existingIndex] = appendedArtifact;
      } else {
        newTask.artifacts[existingIndex] = { ...artifact };
      }
    } else {
      newTask.artifacts.push({ ...artifact });
    }
  }
  return newTask;
}
async function loadOrCreateTask({
  agentId,
  taskId,
  taskStore,
  message,
  contextId,
  metadata,
  logger
}) {
  const data = await taskStore.load({ agentId, taskId });
  if (!data) {
    const initialTask = {
      id: taskId,
      contextId: contextId || crypto.randomUUID(),
      status: {
        state: "submitted",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        message: void 0
      },
      artifacts: [],
      history: [message],
      metadata,
      kind: "task"
    };
    logger?.info(`[Task ${taskId}] Created new task.`);
    await taskStore.save({ agentId, data: initialTask });
    return initialTask;
  }
  logger?.info(`[Task ${taskId}] Loaded existing task.`);
  let updatedData = data;
  updatedData.history = [...data.history || [], message];
  const { status } = data;
  const finalStates = ["completed", "failed", "canceled"];
  if (finalStates.includes(status.state)) {
    logger?.warn(`[Task ${taskId}] Received message for task in final state ${status.state}. Restarting.`);
    updatedData = applyUpdateToTask(updatedData, {
      state: "submitted",
      message: void 0
    });
  } else if (status.state === "input-required") {
    logger?.info(`[Task ${taskId}] Changing state from 'input-required' to 'working'.`);
    updatedData = applyUpdateToTask(updatedData, { state: "working" });
  } else if (status.state === "working") {
    logger?.warn(`[Task ${taskId}] Received message while already 'working'. Proceeding.`);
  }
  await taskStore.save({ agentId, data: updatedData });
  return updatedData;
}
function createTaskContext({
  task,
  userMessage,
  history,
  activeCancellations
}) {
  return {
    task: structuredClone(task),
    userMessage,
    history: structuredClone(history),
    isCancelled: () => activeCancellations.has(task.id)
  };
}
var a2aAgentIdPathParams = z$1.object({
  agentId: z$1.string().describe("Unique identifier for the agent")
});
a2aAgentIdPathParams.extend({
  taskId: z$1.string().describe("Unique identifier for the task")
});
var pushNotificationAuthenticationInfoSchema = z$1.object({
  schemes: z$1.array(z$1.string()).describe("Supported authentication schemes - e.g. Basic, Bearer"),
  credentials: z$1.string().optional().describe("Optional credentials")
});
var pushNotificationConfigSchema = z$1.object({
  url: z$1.string().describe("URL for sending the push notifications"),
  id: z$1.string().optional().describe("Push Notification ID - created by server to support multiple callbacks"),
  token: z$1.string().optional().describe("Token unique to this task/session"),
  authentication: pushNotificationAuthenticationInfoSchema.optional()
});
var messageSendConfigurationSchema = z$1.object({
  acceptedOutputModes: z$1.array(z$1.string()).describe("Accepted output modalities by the client"),
  blocking: z$1.boolean().optional().describe("If the server should treat the client as a blocking request"),
  historyLength: z$1.number().optional().describe("Number of recent messages to be retrieved"),
  pushNotificationConfig: pushNotificationConfigSchema.optional()
});
var textPartSchema$1 = z$1.object({
  kind: z$1.literal("text").describe("Part type - text for TextParts"),
  text: z$1.string().describe("Text content"),
  metadata: z$1.record(z$1.unknown()).optional().describe("Optional metadata associated with the part")
});
var fileWithBytesSchema = z$1.object({
  bytes: z$1.string().describe("base64 encoded content of the file"),
  mimeType: z$1.string().optional().describe("Optional mimeType for the file"),
  name: z$1.string().optional().describe("Optional name for the file")
});
var fileWithUriSchema = z$1.object({
  uri: z$1.string().describe("URL for the File content"),
  mimeType: z$1.string().optional().describe("Optional mimeType for the file"),
  name: z$1.string().optional().describe("Optional name for the file")
});
var filePartSchema$1 = z$1.object({
  kind: z$1.literal("file").describe("Part type - file for FileParts"),
  file: z$1.union([fileWithBytesSchema, fileWithUriSchema]).describe("File content either as url or bytes"),
  metadata: z$1.record(z$1.unknown()).optional().describe("Optional metadata associated with the part")
});
var dataPartSchema = z$1.object({
  kind: z$1.literal("data").describe("Part type - data for DataParts"),
  data: z$1.record(z$1.unknown()).describe("Structured data content"),
  metadata: z$1.record(z$1.unknown()).optional().describe("Optional metadata associated with the part")
});
var partSchema = z$1.union([textPartSchema$1, filePartSchema$1, dataPartSchema]);
var messageSchema = z$1.object({
  kind: z$1.literal("message").describe("Event type"),
  messageId: z$1.string().describe("Identifier created by the message creator"),
  role: z$1.enum(["user", "agent"]).describe("Message sender's role"),
  parts: z$1.array(partSchema).describe("Message content"),
  contextId: z$1.string().optional().describe("The context the message is associated with"),
  taskId: z$1.string().optional().describe("Identifier of task the message is related to"),
  referenceTaskIds: z$1.array(z$1.string()).optional().describe("List of tasks referenced as context by this message"),
  extensions: z$1.array(z$1.string()).optional().describe("The URIs of extensions that are present or contributed to this Message"),
  metadata: z$1.record(z$1.unknown()).optional().describe("Extension metadata")
});
var messageSendParamsSchema = z$1.object({
  message: messageSchema,
  configuration: messageSendConfigurationSchema.optional(),
  metadata: z$1.record(z$1.unknown()).optional().describe("Extension metadata")
});
var taskQueryParamsSchema = z$1.object({
  id: z$1.string().describe("Task id"),
  historyLength: z$1.number().optional().describe("Number of recent messages to be retrieved"),
  metadata: z$1.record(z$1.unknown()).optional()
});
var taskIdParamsSchema = z$1.object({
  id: z$1.string().describe("Task id"),
  metadata: z$1.record(z$1.unknown()).optional()
});
z$1.object({
  message: messageSchema,
  metadata: z$1.record(z$1.any()).optional()
});
z$1.object({
  id: z$1.string()
});
var agentExecutionParamsSchema = z$1.union([messageSendParamsSchema, taskQueryParamsSchema, taskIdParamsSchema]);
var agentExecutionBodySchema = z$1.object({
  jsonrpc: z$1.literal("2.0"),
  id: z$1.union([z$1.string(), z$1.number()]),
  method: z$1.enum(["message/send", "message/stream", "tasks/get", "tasks/cancel"]),
  params: agentExecutionParamsSchema
});
var agentCardResponseSchema = z$1.object({
  name: z$1.string(),
  description: z$1.string(),
  url: z$1.string(),
  provider: z$1.object({
    organization: z$1.string(),
    url: z$1.string()
  }).optional(),
  version: z$1.string(),
  capabilities: z$1.object({
    streaming: z$1.boolean().optional(),
    pushNotifications: z$1.boolean().optional(),
    stateTransitionHistory: z$1.boolean().optional()
  }),
  defaultInputModes: z$1.array(z$1.string()),
  defaultOutputModes: z$1.array(z$1.string()),
  skills: z$1.array(
    z$1.object({
      id: z$1.string(),
      name: z$1.string(),
      description: z$1.string(),
      tags: z$1.array(z$1.string()).optional()
    })
  )
});
z$1.unknown();
var agentExecutionResponseSchema = z$1.unknown();

// src/server/handlers/a2a.ts
var messageSendParamsSchema2 = z.object({
  message: z.object({
    role: z.enum(["user", "agent"]),
    parts: z.array(
      z.object({
        kind: z.enum(["text"]),
        text: z.string()
      })
    ),
    kind: z.literal("message"),
    messageId: z.string(),
    contextId: z.string().optional(),
    taskId: z.string().optional(),
    referenceTaskIds: z.array(z.string()).optional(),
    extensions: z.array(z.string()).optional(),
    metadata: z.record(z.any()).optional()
  })
});
async function getAgentCardByIdHandler({
  mastra,
  agentId,
  executionUrl = `/a2a/${agentId}`,
  provider = {
    organization: "Mastra",
    url: "https://mastra.ai"
  },
  version = "1.0",
  requestContext
}) {
  const agent = await getAgentFromSystem({ mastra, agentId });
  const [instructions, tools] = await Promise.all([agent.getInstructions({ requestContext }), agent.listTools({ requestContext })]);
  const agentCard = {
    name: agent.id || agentId,
    description: convertInstructionsToString(instructions),
    url: executionUrl,
    provider,
    version,
    capabilities: {
      streaming: true,
      // All agents support streaming
      pushNotifications: false,
      stateTransitionHistory: false
    },
    defaultInputModes: ["text"],
    defaultOutputModes: ["text"],
    // Convert agent tools to skills format for A2A protocol
    skills: Object.entries(tools).map(([toolId, tool]) => ({
      id: toolId,
      name: toolId,
      description: tool.description || `Tool: ${toolId}`,
      // Optional fields
      tags: ["tool"]
    }))
  };
  return agentCard;
}
function validateMessageSendParams(params) {
  try {
    messageSendParamsSchema2.parse(params);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw MastraA2AError.invalidParams(error.errors[0].message);
    }
    throw error;
  }
}
async function handleMessageSend({
  requestId,
  params,
  taskStore,
  agent,
  agentId,
  logger,
  requestContext
}) {
  validateMessageSendParams(params);
  const { message, metadata } = params;
  const { contextId } = message;
  const taskId = message.taskId || crypto.randomUUID();
  let currentData = await loadOrCreateTask({
    taskId,
    taskStore,
    agentId,
    message,
    contextId,
    metadata
  });
  createTaskContext({
    task: currentData,
    userMessage: message,
    history: currentData.history || [],
    activeCancellations: taskStore.activeCancellations
  });
  try {
    const resourceId = metadata?.resourceId ?? message.metadata?.resourceId ?? agentId;
    const result = await agent.generate([convertToCoreMessage(message)], {
      runId: taskId,
      requestContext,
      ...contextId ? { threadId: contextId, resourceId } : {}
    });
    currentData = applyUpdateToTask(currentData, {
      state: "completed",
      message: {
        messageId: crypto.randomUUID(),
        role: "agent",
        parts: [
          {
            kind: "text",
            text: result.text
          }
        ],
        kind: "message"
      }
    });
    currentData.metadata = {
      ...currentData.metadata,
      execution: {
        toolCalls: result.toolCalls,
        toolResults: result.toolResults,
        usage: result.usage,
        finishReason: result.finishReason
      }
    };
    await taskStore.save({ agentId, data: currentData });
  } catch (handlerError) {
    const failureStatusUpdate = {
      state: "failed",
      message: {
        messageId: crypto.randomUUID(),
        role: "agent",
        parts: [
          {
            kind: "text",
            text: `Handler failed: ${handlerError instanceof Error ? handlerError.message : String(handlerError)}`
          }
        ],
        kind: "message"
      }
    };
    currentData = applyUpdateToTask(currentData, failureStatusUpdate);
    try {
      await taskStore.save({ agentId, data: currentData });
    } catch (saveError) {
      logger?.error(`Failed to save task ${currentData.id} after handler error:`, saveError?.message);
    }
    return normalizeError(handlerError, requestId, currentData.id, logger);
  }
  return createSuccessResponse(requestId, currentData);
}
async function handleTaskGet({
  requestId,
  taskStore,
  agentId,
  taskId
}) {
  const task = await taskStore.load({ agentId, taskId });
  if (!task) {
    throw MastraA2AError.taskNotFound(taskId);
  }
  return createSuccessResponse(requestId, task);
}
async function* handleMessageStream({
  requestId,
  params,
  taskStore,
  agent,
  agentId,
  logger,
  requestContext
}) {
  yield createSuccessResponse(requestId, {
    state: "working",
    message: {
      messageId: crypto.randomUUID(),
      kind: "message",
      role: "agent",
      parts: [{ kind: "text", text: "Generating response..." }]
    }
  });
  let result;
  try {
    result = await handleMessageSend({
      requestId,
      params,
      taskStore,
      agent,
      agentId,
      requestContext,
      logger
    });
  } catch (err) {
    if (!(err instanceof MastraA2AError)) {
      throw err;
    }
    result = createErrorResponse(requestId, err.toJSONRPCError());
  }
  yield result;
}
async function handleTaskCancel({
  requestId,
  taskStore,
  agentId,
  taskId,
  logger
}) {
  let data = await taskStore.load({
    agentId,
    taskId
  });
  if (!data) {
    throw MastraA2AError.taskNotFound(taskId);
  }
  const finalStates = ["completed", "failed", "canceled"];
  if (finalStates.includes(data.status.state)) {
    logger?.info(`Task ${taskId} already in final state ${data.status.state}, cannot cancel.`);
    return createSuccessResponse(requestId, data);
  }
  taskStore.activeCancellations.add(taskId);
  const cancelUpdate = {
    state: "canceled",
    message: {
      role: "agent",
      parts: [{ kind: "text", text: "Task cancelled by request." }],
      kind: "message",
      messageId: crypto.randomUUID()
    }
  };
  data = applyUpdateToTask(data, cancelUpdate);
  await taskStore.save({ agentId, data });
  taskStore.activeCancellations.delete(taskId);
  return createSuccessResponse(requestId, data);
}
async function getAgentExecutionHandler({
  requestId,
  mastra,
  agentId,
  requestContext,
  method,
  params,
  taskStore,
  logger
}) {
  const agent = await getAgentFromSystem({ mastra, agentId });
  let taskId;
  try {
    taskId = "id" in params ? params.id : params.message?.taskId || "No task ID provided";
    switch (method) {
      case "message/send": {
        const result2 = await handleMessageSend({
          requestId,
          params,
          taskStore,
          agent,
          agentId,
          requestContext
        });
        return result2;
      }
      case "message/stream":
        const result = await handleMessageStream({
          requestId,
          taskStore,
          params,
          agent,
          agentId,
          requestContext
        });
        return result;
      case "tasks/get": {
        const result2 = await handleTaskGet({
          requestId,
          taskStore,
          agentId,
          taskId
        });
        return result2;
      }
      case "tasks/cancel": {
        const result2 = await handleTaskCancel({
          requestId,
          taskStore,
          agentId,
          taskId
        });
        return result2;
      }
      default:
        throw MastraA2AError.methodNotFound(method);
    }
  } catch (error) {
    if (error instanceof MastraA2AError && taskId && !error.taskId) {
      error.taskId = taskId;
    }
    return normalizeError(error, requestId, taskId, logger);
  }
}
var GET_AGENT_CARD_ROUTE = createRoute({
  method: "GET",
  path: "/.well-known/:agentId/agent-card.json",
  responseType: "json",
  pathParamSchema: a2aAgentIdPathParams,
  responseSchema: agentCardResponseSchema,
  summary: "Get agent card",
  description: "Returns the agent card information for A2A protocol discovery",
  tags: ["Agent-to-Agent"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, requestContext }) => {
    const executionUrl = `/a2a/${agentId}`;
    const provider = {
      organization: "Mastra",
      url: "https://mastra.ai"
    };
    const version = "1.0";
    const agent = await getAgentFromSystem({ mastra, agentId });
    const [instructions, tools] = await Promise.all([agent.getInstructions({ requestContext }), agent.listTools({ requestContext })]);
    const agentCard = {
      name: agent.id || agentId,
      description: convertInstructionsToString(instructions),
      url: executionUrl,
      provider,
      version,
      capabilities: {
        streaming: true,
        pushNotifications: false,
        stateTransitionHistory: false
      },
      defaultInputModes: ["text"],
      defaultOutputModes: ["text"],
      skills: Object.entries(tools).map(([toolId, tool]) => ({
        id: toolId,
        name: toolId,
        description: tool.description || `Tool: ${toolId}`,
        tags: ["tool"]
      }))
    };
    return agentCard;
  }
});
var AGENT_EXECUTION_ROUTE = createRoute({
  method: "POST",
  path: "/a2a/:agentId",
  responseType: "json",
  pathParamSchema: a2aAgentIdPathParams,
  bodySchema: agentExecutionBodySchema,
  responseSchema: agentExecutionResponseSchema,
  summary: "Execute agent",
  description: "Executes an agent action via JSON-RPC 2.0 over A2A protocol",
  tags: ["Agent-to-Agent"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, requestContext, taskStore, ...bodyParams }) => {
    const { id: requestId, method, params } = bodyParams;
    return await getAgentExecutionHandler({
      requestId: String(requestId),
      mastra,
      agentId,
      requestContext,
      method,
      params,
      taskStore
    });
  }
});

// ../../node_modules/.pnpm/xxhash-wasm@1.1.0/node_modules/xxhash-wasm/esm/xxhash-wasm.js
var t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 48, 8, 96, 3, 127, 127, 127, 1, 127, 96, 3, 127, 127, 127, 0, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 3, 127, 127, 126, 1, 126, 96, 3, 126, 127, 127, 1, 126, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 3, 11, 10, 0, 0, 2, 1, 3, 4, 5, 6, 1, 7, 5, 3, 1, 0, 1, 7, 85, 9, 3, 109, 101, 109, 2, 0, 5, 120, 120, 104, 51, 50, 0, 0, 6, 105, 110, 105, 116, 51, 50, 0, 2, 8, 117, 112, 100, 97, 116, 101, 51, 50, 0, 3, 8, 100, 105, 103, 101, 115, 116, 51, 50, 0, 4, 5, 120, 120, 104, 54, 52, 0, 5, 6, 105, 110, 105, 116, 54, 52, 0, 7, 8, 117, 112, 100, 97, 116, 101, 54, 52, 0, 8, 8, 100, 105, 103, 101, 115, 116, 54, 52, 0, 9, 10, 251, 22, 10, 242, 1, 1, 4, 127, 32, 0, 32, 1, 106, 33, 3, 32, 1, 65, 16, 79, 4, 127, 32, 3, 65, 16, 107, 33, 6, 32, 2, 65, 168, 136, 141, 161, 2, 106, 33, 3, 32, 2, 65, 137, 235, 208, 208, 7, 107, 33, 4, 32, 2, 65, 207, 140, 162, 142, 6, 106, 33, 5, 3, 64, 32, 3, 32, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 3, 32, 4, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 2, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 5, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 5, 32, 6, 32, 0, 65, 4, 106, 34, 0, 79, 13, 0, 11, 32, 2, 65, 12, 119, 32, 5, 65, 18, 119, 106, 32, 4, 65, 7, 119, 106, 32, 3, 65, 1, 119, 106, 5, 32, 2, 65, 177, 207, 217, 178, 1, 106, 11, 32, 1, 106, 32, 0, 32, 1, 65, 15, 113, 16, 1, 11, 146, 1, 0, 32, 1, 32, 2, 106, 33, 2, 3, 64, 32, 1, 65, 4, 106, 32, 2, 75, 69, 4, 64, 32, 0, 32, 1, 40, 2, 0, 65, 189, 220, 202, 149, 124, 108, 106, 65, 17, 119, 65, 175, 214, 211, 190, 2, 108, 33, 0, 32, 1, 65, 4, 106, 33, 1, 12, 1, 11, 11, 3, 64, 32, 1, 32, 2, 79, 69, 4, 64, 32, 0, 32, 1, 45, 0, 0, 65, 177, 207, 217, 178, 1, 108, 106, 65, 11, 119, 65, 177, 243, 221, 241, 121, 108, 33, 0, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 32, 0, 65, 15, 118, 115, 65, 247, 148, 175, 175, 120, 108, 34, 0, 65, 13, 118, 32, 0, 115, 65, 189, 220, 202, 149, 124, 108, 34, 0, 65, 16, 118, 32, 0, 115, 11, 63, 0, 32, 0, 65, 8, 106, 32, 1, 65, 168, 136, 141, 161, 2, 106, 54, 2, 0, 32, 0, 65, 12, 106, 32, 1, 65, 137, 235, 208, 208, 7, 107, 54, 2, 0, 32, 0, 65, 16, 106, 32, 1, 54, 2, 0, 32, 0, 65, 20, 106, 32, 1, 65, 207, 140, 162, 142, 6, 106, 54, 2, 0, 11, 195, 4, 1, 6, 127, 32, 1, 32, 2, 106, 33, 6, 32, 0, 65, 24, 106, 33, 4, 32, 0, 65, 40, 106, 40, 2, 0, 33, 3, 32, 0, 32, 0, 40, 2, 0, 32, 2, 106, 54, 2, 0, 32, 0, 65, 4, 106, 34, 5, 32, 5, 40, 2, 0, 32, 2, 65, 16, 79, 32, 0, 40, 2, 0, 65, 16, 79, 114, 114, 54, 2, 0, 32, 2, 32, 3, 106, 65, 16, 73, 4, 64, 32, 3, 32, 4, 106, 32, 1, 32, 2, 252, 10, 0, 0, 32, 0, 65, 40, 106, 32, 2, 32, 3, 106, 54, 2, 0, 15, 11, 32, 3, 4, 64, 32, 3, 32, 4, 106, 32, 1, 65, 16, 32, 3, 107, 34, 2, 252, 10, 0, 0, 32, 0, 65, 8, 106, 34, 3, 32, 3, 40, 2, 0, 32, 4, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 54, 2, 0, 32, 0, 65, 12, 106, 34, 3, 32, 3, 40, 2, 0, 32, 4, 65, 4, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 54, 2, 0, 32, 0, 65, 16, 106, 34, 3, 32, 3, 40, 2, 0, 32, 4, 65, 8, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 54, 2, 0, 32, 0, 65, 20, 106, 34, 3, 32, 3, 40, 2, 0, 32, 4, 65, 12, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 54, 2, 0, 32, 0, 65, 40, 106, 65, 0, 54, 2, 0, 32, 1, 32, 2, 106, 33, 1, 11, 32, 1, 32, 6, 65, 16, 107, 77, 4, 64, 32, 6, 65, 16, 107, 33, 8, 32, 0, 65, 8, 106, 40, 2, 0, 33, 2, 32, 0, 65, 12, 106, 40, 2, 0, 33, 3, 32, 0, 65, 16, 106, 40, 2, 0, 33, 5, 32, 0, 65, 20, 106, 40, 2, 0, 33, 7, 3, 64, 32, 2, 32, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 3, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 3, 32, 5, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 5, 32, 7, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 7, 32, 8, 32, 1, 65, 4, 106, 34, 1, 79, 13, 0, 11, 32, 0, 65, 8, 106, 32, 2, 54, 2, 0, 32, 0, 65, 12, 106, 32, 3, 54, 2, 0, 32, 0, 65, 16, 106, 32, 5, 54, 2, 0, 32, 0, 65, 20, 106, 32, 7, 54, 2, 0, 11, 32, 1, 32, 6, 73, 4, 64, 32, 4, 32, 1, 32, 6, 32, 1, 107, 34, 1, 252, 10, 0, 0, 32, 0, 65, 40, 106, 32, 1, 54, 2, 0, 11, 11, 97, 1, 1, 127, 32, 0, 65, 16, 106, 40, 2, 0, 33, 1, 32, 0, 65, 4, 106, 40, 2, 0, 4, 127, 32, 1, 65, 12, 119, 32, 0, 65, 20, 106, 40, 2, 0, 65, 18, 119, 106, 32, 0, 65, 12, 106, 40, 2, 0, 65, 7, 119, 106, 32, 0, 65, 8, 106, 40, 2, 0, 65, 1, 119, 106, 5, 32, 1, 65, 177, 207, 217, 178, 1, 106, 11, 32, 0, 40, 2, 0, 106, 32, 0, 65, 24, 106, 32, 0, 65, 40, 106, 40, 2, 0, 16, 1, 11, 255, 3, 2, 3, 126, 1, 127, 32, 0, 32, 1, 106, 33, 6, 32, 1, 65, 32, 79, 4, 126, 32, 6, 65, 32, 107, 33, 6, 32, 2, 66, 214, 235, 130, 238, 234, 253, 137, 245, 224, 0, 124, 33, 3, 32, 2, 66, 177, 169, 172, 193, 173, 184, 212, 166, 61, 125, 33, 4, 32, 2, 66, 249, 234, 208, 208, 231, 201, 161, 228, 225, 0, 124, 33, 5, 3, 64, 32, 3, 32, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 3, 32, 4, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 4, 32, 2, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 2, 32, 5, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 5, 32, 6, 32, 0, 65, 8, 106, 34, 0, 79, 13, 0, 11, 32, 2, 66, 12, 137, 32, 5, 66, 18, 137, 124, 32, 4, 66, 7, 137, 124, 32, 3, 66, 1, 137, 124, 32, 3, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 2, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 5, 32, 2, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 1, 173, 124, 32, 0, 32, 1, 65, 31, 113, 16, 6, 11, 134, 2, 0, 32, 1, 32, 2, 106, 33, 2, 3, 64, 32, 2, 32, 1, 65, 8, 106, 79, 4, 64, 32, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 32, 0, 133, 66, 27, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 33, 0, 32, 1, 65, 8, 106, 33, 1, 12, 1, 11, 11, 32, 1, 65, 4, 106, 32, 2, 77, 4, 64, 32, 0, 32, 1, 53, 2, 0, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 23, 137, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 124, 33, 0, 32, 1, 65, 4, 106, 33, 1, 11, 3, 64, 32, 1, 32, 2, 73, 4, 64, 32, 0, 32, 1, 49, 0, 0, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 126, 133, 66, 11, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 0, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 32, 0, 66, 33, 136, 133, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 34, 0, 32, 0, 66, 29, 136, 133, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 126, 34, 0, 32, 0, 66, 32, 136, 133, 11, 77, 0, 32, 0, 65, 8, 106, 32, 1, 66, 214, 235, 130, 238, 234, 253, 137, 245, 224, 0, 124, 55, 3, 0, 32, 0, 65, 16, 106, 32, 1, 66, 177, 169, 172, 193, 173, 184, 212, 166, 61, 125, 55, 3, 0, 32, 0, 65, 24, 106, 32, 1, 55, 3, 0, 32, 0, 65, 32, 106, 32, 1, 66, 249, 234, 208, 208, 231, 201, 161, 228, 225, 0, 124, 55, 3, 0, 11, 244, 4, 2, 3, 127, 4, 126, 32, 1, 32, 2, 106, 33, 5, 32, 0, 65, 40, 106, 33, 4, 32, 0, 65, 200, 0, 106, 40, 2, 0, 33, 3, 32, 0, 32, 0, 41, 3, 0, 32, 2, 173, 124, 55, 3, 0, 32, 2, 32, 3, 106, 65, 32, 73, 4, 64, 32, 3, 32, 4, 106, 32, 1, 32, 2, 252, 10, 0, 0, 32, 0, 65, 200, 0, 106, 32, 2, 32, 3, 106, 54, 2, 0, 15, 11, 32, 3, 4, 64, 32, 3, 32, 4, 106, 32, 1, 65, 32, 32, 3, 107, 34, 2, 252, 10, 0, 0, 32, 0, 65, 8, 106, 34, 3, 32, 3, 41, 3, 0, 32, 4, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 55, 3, 0, 32, 0, 65, 16, 106, 34, 3, 32, 3, 41, 3, 0, 32, 4, 65, 8, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 55, 3, 0, 32, 0, 65, 24, 106, 34, 3, 32, 3, 41, 3, 0, 32, 4, 65, 16, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 55, 3, 0, 32, 0, 65, 32, 106, 34, 3, 32, 3, 41, 3, 0, 32, 4, 65, 24, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 55, 3, 0, 32, 0, 65, 200, 0, 106, 65, 0, 54, 2, 0, 32, 1, 32, 2, 106, 33, 1, 11, 32, 1, 65, 32, 106, 32, 5, 77, 4, 64, 32, 5, 65, 32, 107, 33, 2, 32, 0, 65, 8, 106, 41, 3, 0, 33, 6, 32, 0, 65, 16, 106, 41, 3, 0, 33, 7, 32, 0, 65, 24, 106, 41, 3, 0, 33, 8, 32, 0, 65, 32, 106, 41, 3, 0, 33, 9, 3, 64, 32, 6, 32, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 7, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 7, 32, 8, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 8, 32, 9, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 9, 32, 2, 32, 1, 65, 8, 106, 34, 1, 79, 13, 0, 11, 32, 0, 65, 8, 106, 32, 6, 55, 3, 0, 32, 0, 65, 16, 106, 32, 7, 55, 3, 0, 32, 0, 65, 24, 106, 32, 8, 55, 3, 0, 32, 0, 65, 32, 106, 32, 9, 55, 3, 0, 11, 32, 1, 32, 5, 73, 4, 64, 32, 4, 32, 1, 32, 5, 32, 1, 107, 34, 1, 252, 10, 0, 0, 32, 0, 65, 200, 0, 106, 32, 1, 54, 2, 0, 11, 11, 188, 2, 1, 5, 126, 32, 0, 65, 24, 106, 41, 3, 0, 33, 1, 32, 0, 41, 3, 0, 34, 2, 66, 32, 90, 4, 126, 32, 0, 65, 8, 106, 41, 3, 0, 34, 3, 66, 1, 137, 32, 0, 65, 16, 106, 41, 3, 0, 34, 4, 66, 7, 137, 124, 32, 1, 66, 12, 137, 32, 0, 65, 32, 106, 41, 3, 0, 34, 5, 66, 18, 137, 124, 124, 32, 3, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 1, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 5, 32, 1, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 2, 124, 32, 0, 65, 40, 106, 32, 2, 66, 31, 131, 167, 16, 6, 11]);
async function e() {
  return (function(t2) {
    const { exports: { mem: e2, xxh32: n, xxh64: r, init32: i, update32: a, digest32: o, init64: s, update64: u, digest64: c } } = t2;
    let h = new Uint8Array(e2.buffer);
    function g(t3, n2) {
      if (e2.buffer.byteLength < t3 + n2) {
        const r2 = Math.ceil((t3 + n2 - e2.buffer.byteLength) / 65536);
        e2.grow(r2), h = new Uint8Array(e2.buffer);
      }
    }
    function f(t3, e3, n2, r2, i2, a2) {
      g(t3);
      const o2 = new Uint8Array(t3);
      return h.set(o2), n2(0, e3), o2.set(h.subarray(0, t3)), { update(e4) {
        let n3;
        return h.set(o2), "string" == typeof e4 ? (g(3 * e4.length, t3), n3 = w.encodeInto(e4, h.subarray(t3)).written) : (g(e4.byteLength, t3), h.set(e4, t3), n3 = e4.byteLength), r2(0, t3, n3), o2.set(h.subarray(0, t3)), this;
      }, digest: () => (h.set(o2), a2(i2(0))) };
    }
    function y(t3) {
      return t3 >>> 0;
    }
    const b = 2n ** 64n - 1n;
    function d(t3) {
      return t3 & b;
    }
    const w = new TextEncoder(), l = 0, p = 0n;
    function x(t3, e3 = l) {
      return g(3 * t3.length, 0), y(n(0, w.encodeInto(t3, h).written, e3));
    }
    function L(t3, e3 = p) {
      return g(3 * t3.length, 0), d(r(0, w.encodeInto(t3, h).written, e3));
    }
    return { h32: x, h32ToString: (t3, e3 = l) => x(t3, e3).toString(16).padStart(8, "0"), h32Raw: (t3, e3 = l) => (g(t3.byteLength, 0), h.set(t3), y(n(0, t3.byteLength, e3))), create32: (t3 = l) => f(48, t3, i, a, o, y), h64: L, h64ToString: (t3, e3 = p) => L(t3, e3).toString(16).padStart(16, "0"), h64Raw: (t3, e3 = p) => (g(t3.byteLength, 0), h.set(t3), d(r(0, t3.byteLength, e3))), create64: (t3 = p) => f(88, t3, s, u, c, d) };
  })((await WebAssembly.instantiate(t)).instance);
}

// ../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js
var require_secure_json_parse$1 = __commonJS$3({
  "../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js"(exports$1, module) {
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse(text, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text)) {
        text = text.toString();
      }
      if (text && text.charCodeAt(0) === 65279) {
        text = text.slice(1);
      }
      const obj = JSON.parse(text, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx.test(text) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx.test(text) === false) {
          return obj;
        }
      }
      return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse(text, reviver, options) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse(text, reviver) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, { safe: true });
      } catch (_e) {
        return null;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module.exports = parse;
    module.exports.default = parse;
    module.exports.parse = parse;
    module.exports.safeParse = safeParse;
    module.exports.scan = filter;
  }
});

// ../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/dist/index.mjs
var marker$1 = "vercel.ai.error";
var symbol$1 = Symbol.for(marker$1);
var _a$1;
var _AISDKError$1 = class _AISDKError2 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name14,
    message,
    cause
  }) {
    super(message);
    this[_a$1] = true;
    this.name = name14;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError2.hasMarker(error, marker$1);
  }
  static hasMarker(error, marker15) {
    const markerSymbol = Symbol.for(marker15);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a$1 = symbol$1;
var AISDKError$1 = _AISDKError$1;
var name$1 = "AI_APICallError";
var marker2$1 = `vercel.ai.error.${name$1}`;
var symbol2$1 = Symbol.for(marker2$1);
var _a2$1;
var APICallError$1 = class APICallError extends AISDKError$1 {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name: name$1, message, cause });
    this[_a2$1] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker2$1);
  }
};
_a2$1 = symbol2$1;
var name2$1 = "AI_EmptyResponseBodyError";
var marker3$1 = `vercel.ai.error.${name2$1}`;
var symbol3$1 = Symbol.for(marker3$1);
var _a3$1;
var EmptyResponseBodyError$1 = class EmptyResponseBodyError extends AISDKError$1 {
  // used in isInstance
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name2$1, message });
    this[_a3$1] = true;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker3$1);
  }
};
_a3$1 = symbol3$1;
function getErrorMessage$1(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name3$1 = "AI_InvalidArgumentError";
var marker4$1 = `vercel.ai.error.${name3$1}`;
var symbol4$1 = Symbol.for(marker4$1);
var _a4$1;
var InvalidArgumentError$1 = class InvalidArgumentError extends AISDKError$1 {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3$1, message, cause });
    this[_a4$1] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker4$1);
  }
};
_a4$1 = symbol4$1;
var name4 = "AI_InvalidPromptError";
var marker5 = `vercel.ai.error.${name4}`;
var symbol5 = Symbol.for(marker5);
var _a5;
var InvalidPromptError = class extends AISDKError$1 {
  constructor({
    prompt,
    message,
    cause
  }) {
    super({ name: name4, message: `Invalid prompt: ${message}`, cause });
    this[_a5] = true;
    this.prompt = prompt;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker5);
  }
};
_a5 = symbol5;
var name5 = "AI_InvalidResponseDataError";
var marker6 = `vercel.ai.error.${name5}`;
var symbol6 = Symbol.for(marker6);
var _a6;
var InvalidResponseDataError = class extends AISDKError$1 {
  constructor({
    data,
    message = `Invalid response data: ${JSON.stringify(data)}.`
  }) {
    super({ name: name5, message });
    this[_a6] = true;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker6);
  }
};
_a6 = symbol6;
var name6$1 = "AI_JSONParseError";
var marker7$1 = `vercel.ai.error.${name6$1}`;
var symbol7$1 = Symbol.for(marker7$1);
var _a7$1;
var JSONParseError$1 = class JSONParseError extends AISDKError$1 {
  constructor({ text, cause }) {
    super({
      name: name6$1,
      message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage$1(cause)}`,
      cause
    });
    this[_a7$1] = true;
    this.text = text;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker7$1);
  }
};
_a7$1 = symbol7$1;
var name7 = "AI_LoadAPIKeyError";
var marker8 = `vercel.ai.error.${name7}`;
var symbol8 = Symbol.for(marker8);
var _a8;
var LoadAPIKeyError = class extends AISDKError$1 {
  // used in isInstance
  constructor({ message }) {
    super({ name: name7, message });
    this[_a8] = true;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker8);
  }
};
_a8 = symbol8;
var name10 = "AI_NoSuchModelError";
var marker11 = `vercel.ai.error.${name10}`;
var symbol11 = Symbol.for(marker11);
var _a11;
var NoSuchModelError = class extends AISDKError$1 {
  constructor({
    errorName = name10,
    modelId,
    modelType,
    message = `No such ${modelType}: ${modelId}`
  }) {
    super({ name: errorName, message });
    this[_a11] = true;
    this.modelId = modelId;
    this.modelType = modelType;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker11);
  }
};
_a11 = symbol11;
var name11 = "AI_TooManyEmbeddingValuesForCallError";
var marker12 = `vercel.ai.error.${name11}`;
var symbol12 = Symbol.for(marker12);
var _a12;
var TooManyEmbeddingValuesForCallError = class extends AISDKError$1 {
  constructor(options) {
    super({
      name: name11,
      message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
    });
    this[_a12] = true;
    this.provider = options.provider;
    this.modelId = options.modelId;
    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
    this.values = options.values;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker12);
  }
};
_a12 = symbol12;
var name12$1 = "AI_TypeValidationError";
var marker13$1 = `vercel.ai.error.${name12$1}`;
var symbol13$1 = Symbol.for(marker13$1);
var _a13$1;
var _TypeValidationError$1 = class _TypeValidationError2 extends AISDKError$1 {
  constructor({ value, cause }) {
    super({
      name: name12$1,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage$1(cause)}`,
      cause
    });
    this[_a13$1] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker13$1);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });
  }
};
_a13$1 = symbol13$1;
var TypeValidationError$1 = _TypeValidationError$1;
var name13 = "AI_UnsupportedFunctionalityError";
var marker14 = `vercel.ai.error.${name13}`;
var symbol14 = Symbol.for(marker14);
var _a14;
var UnsupportedFunctionalityError = class extends AISDKError$1 {
  constructor({
    functionality,
    message = `'${functionality}' functionality not supported.`
  }) {
    super({ name: name13, message });
    this[_a14] = true;
    this.functionality = functionality;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker14);
  }
};
_a14 = symbol14;

// ../../node_modules/.pnpm/nanoid@3.3.11/node_modules/nanoid/non-secure/index.js
var customAlphabet$1 = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i = size | 0;
    while (i--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};

// ../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs
var import_secure_json_parse$1 = __toESM$3(require_secure_json_parse$1());
function combineHeaders$1(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
function createEventSourceParserStream() {
  let buffer = "";
  let event = void 0;
  let data = [];
  let lastEventId = void 0;
  let retry = void 0;
  function parseLine(line, controller) {
    if (line === "") {
      dispatchEvent(controller);
      return;
    }
    if (line.startsWith(":")) {
      return;
    }
    const colonIndex = line.indexOf(":");
    if (colonIndex === -1) {
      handleField(line, "");
      return;
    }
    const field = line.slice(0, colonIndex);
    const valueStart = colonIndex + 1;
    const value = valueStart < line.length && line[valueStart] === " " ? line.slice(valueStart + 1) : line.slice(valueStart);
    handleField(field, value);
  }
  function dispatchEvent(controller) {
    if (data.length > 0) {
      controller.enqueue({
        event,
        data: data.join("\n"),
        id: lastEventId,
        retry
      });
      data = [];
      event = void 0;
      retry = void 0;
    }
  }
  function handleField(field, value) {
    switch (field) {
      case "event":
        event = value;
        break;
      case "data":
        data.push(value);
        break;
      case "id":
        lastEventId = value;
        break;
      case "retry":
        const parsedRetry = parseInt(value, 10);
        if (!isNaN(parsedRetry)) {
          retry = parsedRetry;
        }
        break;
    }
  }
  return new TransformStream({
    transform(chunk, controller) {
      const { lines, incompleteLine } = splitLines$1(buffer, chunk);
      buffer = incompleteLine;
      for (let i = 0; i < lines.length; i++) {
        parseLine(lines[i], controller);
      }
    },
    flush(controller) {
      parseLine(buffer, controller);
      dispatchEvent(controller);
    }
  });
}
function splitLines$1(buffer, chunk) {
  const lines = [];
  let currentLine = buffer;
  for (let i = 0; i < chunk.length; ) {
    const char = chunk[i++];
    if (char === "\n") {
      lines.push(currentLine);
      currentLine = "";
    } else if (char === "\r") {
      lines.push(currentLine);
      currentLine = "";
      if (chunk[i] === "\n") {
        i++;
      }
    } else {
      currentLine += char;
    }
  }
  return { lines, incompleteLine: currentLine };
}
function extractResponseHeaders$1(response) {
  const headers = {};
  response.headers.forEach((value, key) => {
    headers[key] = value;
  });
  return headers;
}
var createIdGenerator$1 = ({
  prefix,
  size: defaultSize = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = customAlphabet$1(alphabet, defaultSize);
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError$1({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return (size) => `${prefix}${separator}${generator(size)}`;
};
var generateId = createIdGenerator$1();
function removeUndefinedEntries(record) {
  return Object.fromEntries(
    Object.entries(record).filter(([_key, value]) => value != null)
  );
}
function isAbortError$1(error) {
  return error instanceof Error && (error.name === "AbortError" || error.name === "TimeoutError");
}
function loadApiKey({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
var validatorSymbol$1 = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator$1(validate) {
  return { [validatorSymbol$1]: true, validate };
}
function isValidator$1(value) {
  return typeof value === "object" && value !== null && validatorSymbol$1 in value && value[validatorSymbol$1] === true && "validate" in value;
}
function asValidator$1(value) {
  return isValidator$1(value) ? value : zodValidator$1(value);
}
function zodValidator$1(zodSchema) {
  return validator$1((value) => {
    const result = zodSchema.safeParse(value);
    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
  });
}
function validateTypes$1({
  value,
  schema: inputSchema
}) {
  const result = safeValidateTypes$1({ value, schema: inputSchema });
  if (!result.success) {
    throw TypeValidationError$1.wrap({ value, cause: result.error });
  }
  return result.value;
}
function safeValidateTypes$1({
  value,
  schema
}) {
  const validator2 = asValidator$1(schema);
  try {
    if (validator2.validate == null) {
      return { success: true, value };
    }
    const result = validator2.validate(value);
    if (result.success) {
      return result;
    }
    return {
      success: false,
      error: TypeValidationError$1.wrap({ value, cause: result.error })
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError$1.wrap({ value, cause: error })
    };
  }
}
function parseJSON$1({
  text,
  schema
}) {
  try {
    const value = import_secure_json_parse$1.default.parse(text);
    if (schema == null) {
      return value;
    }
    return validateTypes$1({ value, schema });
  } catch (error) {
    if (JSONParseError$1.isInstance(error) || TypeValidationError$1.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError$1({ text, cause: error });
  }
}
function safeParseJSON$1({
  text,
  schema
}) {
  try {
    const value = import_secure_json_parse$1.default.parse(text);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    const validationResult = safeValidateTypes$1({ value, schema });
    return validationResult.success ? { ...validationResult, rawValue: value } : validationResult;
  } catch (error) {
    return {
      success: false,
      error: JSONParseError$1.isInstance(error) ? error : new JSONParseError$1({ text, cause: error })
    };
  }
}
function isParsableJson(input) {
  try {
    import_secure_json_parse$1.default.parse(input);
    return true;
  } catch (e) {
    return false;
  }
}
function parseProviderOptions({
  provider,
  providerOptions,
  schema
}) {
  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
    return void 0;
  }
  const parsedProviderOptions = safeValidateTypes$1({
    value: providerOptions[provider],
    schema
  });
  if (!parsedProviderOptions.success) {
    throw new InvalidArgumentError$1({
      argument: "providerOptions",
      message: `invalid ${provider} provider options`,
      cause: parsedProviderOptions.error
    });
  }
  return parsedProviderOptions.value;
}
var getOriginalFetch2$1 = () => globalThis.fetch;
var postJsonToApi$1 = async ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch
}) => postToApi$1({
  url,
  headers: {
    "Content-Type": "application/json",
    ...headers
  },
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch
});
var postFormDataToApi = async ({
  url,
  headers,
  formData,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch
}) => postToApi$1({
  url,
  headers,
  body: {
    content: formData,
    values: Object.fromEntries(formData.entries())
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch
});
var postToApi$1 = async ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch = getOriginalFetch2$1()
}) => {
  try {
    const response = await fetch(url, {
      method: "POST",
      headers: removeUndefinedEntries(headers),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders$1(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError$1(error) || APICallError$1.isInstance(error)) {
          throw error;
        }
        throw new APICallError$1({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError$1(error) || APICallError$1.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError$1({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    if (isAbortError$1(error)) {
      throw error;
    }
    if (error instanceof TypeError && error.message === "fetch failed") {
      const cause = error.cause;
      if (cause != null) {
        throw new APICallError$1({
          message: `Cannot connect to API: ${cause.message}`,
          cause,
          url,
          requestBodyValues: body.values,
          isRetryable: true
          // retry when network error
        });
      }
    }
    throw error;
  }
};
async function resolve$1(value) {
  if (typeof value === "function") {
    value = value();
  }
  return Promise.resolve(value);
}
var createJsonErrorResponseHandler$1 = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders$1(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError$1({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = parseJSON$1({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError$1({
        message: errorToMessage(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError$1({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler$1 = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders$1(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError$1({});
  }
  return {
    responseHeaders,
    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(createEventSourceParserStream()).pipeThrough(
      new TransformStream({
        transform({ data }, controller) {
          if (data === "[DONE]") {
            return;
          }
          controller.enqueue(
            safeParseJSON$1({
              text: data,
              schema: chunkSchema
            })
          );
        }
      })
    )
  };
};
var createJsonResponseHandler$1 = (responseSchema) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = safeParseJSON$1({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders$1(response);
  if (!parsedResult.success) {
    throw new APICallError$1({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
var createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {
  const responseHeaders = extractResponseHeaders$1(response);
  if (!response.body) {
    throw new APICallError$1({
      message: "Response body is empty",
      url,
      requestBodyValues,
      statusCode: response.status,
      responseHeaders,
      responseBody: void 0
    });
  }
  try {
    const buffer = await response.arrayBuffer();
    return {
      responseHeaders,
      value: new Uint8Array(buffer)
    };
  } catch (error) {
    throw new APICallError$1({
      message: "Failed to read response as array buffer",
      url,
      requestBodyValues,
      statusCode: response.status,
      responseHeaders,
      responseBody: void 0,
      cause: error
    });
  }
};
var { btoa, atob } = globalThis;
function convertBase64ToUint8Array(base64String) {
  const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
  const latin1string = atob(base64Url);
  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
}
function convertUint8ArrayToBase64(array) {
  let latin1string = "";
  for (let i = 0; i < array.length; i++) {
    latin1string += String.fromCodePoint(array[i]);
  }
  return btoa(latin1string);
}
function withoutTrailingSlash$1(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}

function convertToOpenAIChatMessages({
  prompt,
  useLegacyFunctionCalling = false,
  systemMessageMode = "system"
}) {
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part, index) => {
            var _a, _b, _c, _d;
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "image": {
                return {
                  type: "image_url",
                  image_url: {
                    url: part.image instanceof URL ? part.image.toString() : `data:${(_a = part.mimeType) != null ? _a : "image/jpeg"};base64,${convertUint8ArrayToBase64(part.image)}`,
                    // OpenAI specific extension: image detail
                    detail: (_c = (_b = part.providerMetadata) == null ? void 0 : _b.openai) == null ? void 0 : _c.imageDetail
                  }
                };
              }
              case "file": {
                if (part.data instanceof URL) {
                  throw new UnsupportedFunctionalityError({
                    functionality: "'File content parts with URL data' functionality not supported."
                  });
                }
                switch (part.mimeType) {
                  case "audio/wav": {
                    return {
                      type: "input_audio",
                      input_audio: { data: part.data, format: "wav" }
                    };
                  }
                  case "audio/mp3":
                  case "audio/mpeg": {
                    return {
                      type: "input_audio",
                      input_audio: { data: part.data, format: "mp3" }
                    };
                  }
                  case "application/pdf": {
                    return {
                      type: "file",
                      file: {
                        filename: (_d = part.filename) != null ? _d : `part-${index}.pdf`,
                        file_data: `data:application/pdf;base64,${part.data}`
                      }
                    };
                  }
                  default: {
                    throw new UnsupportedFunctionalityError({
                      functionality: `File content part type ${part.mimeType} in user messages`
                    });
                  }
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.args)
                }
              });
              break;
            }
          }
        }
        if (useLegacyFunctionCalling) {
          if (toolCalls.length > 1) {
            throw new UnsupportedFunctionalityError({
              functionality: "useLegacyFunctionCalling with multiple tool calls in one message"
            });
          }
          messages.push({
            role: "assistant",
            content: text,
            function_call: toolCalls.length > 0 ? toolCalls[0].function : void 0
          });
        } else {
          messages.push({
            role: "assistant",
            content: text,
            tool_calls: toolCalls.length > 0 ? toolCalls : void 0
          });
        }
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          if (useLegacyFunctionCalling) {
            messages.push({
              role: "function",
              name: toolResponse.toolName,
              content: JSON.stringify(toolResponse.result)
            });
          } else {
            messages.push({
              role: "tool",
              tool_call_id: toolResponse.toolCallId,
              content: JSON.stringify(toolResponse.result)
            });
          }
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}
function mapOpenAIChatLogProbsOutput(logprobs) {
  var _a, _b;
  return (_b = (_a = logprobs == null ? void 0 : logprobs.content) == null ? void 0 : _a.map(({ token, logprob, top_logprobs }) => ({
    token,
    logprob,
    topLogprobs: top_logprobs ? top_logprobs.map(({ token: token2, logprob: logprob2 }) => ({
      token: token2,
      logprob: logprob2
    })) : []
  }))) != null ? _b : void 0;
}
function mapOpenAIFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var openaiErrorDataSchema = z.object({
  error: z.object({
    message: z.string(),
    // The additional information below is handled loosely to support
    // OpenAI-compatible providers that have slightly different error
    // responses:
    type: z.string().nullish(),
    param: z.any().nullish(),
    code: z.union([z.string(), z.number()]).nullish()
  })
});
var openaiFailedResponseHandler = createJsonErrorResponseHandler$1({
  errorSchema: openaiErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
function getResponseMetadata({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function prepareTools({
  mode,
  useLegacyFunctionCalling = false,
  structuredOutputs
}) {
  var _a;
  const tools = ((_a = mode.tools) == null ? void 0 : _a.length) ? mode.tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, tool_choice: void 0, toolWarnings };
  }
  const toolChoice = mode.toolChoice;
  if (useLegacyFunctionCalling) {
    const openaiFunctions = [];
    for (const tool of tools) {
      if (tool.type === "provider-defined") {
        toolWarnings.push({ type: "unsupported-tool", tool });
      } else {
        openaiFunctions.push({
          name: tool.name,
          description: tool.description,
          parameters: tool.parameters
        });
      }
    }
    if (toolChoice == null) {
      return {
        functions: openaiFunctions,
        function_call: void 0,
        toolWarnings
      };
    }
    const type2 = toolChoice.type;
    switch (type2) {
      case "auto":
      case "none":
      case void 0:
        return {
          functions: openaiFunctions,
          function_call: void 0,
          toolWarnings
        };
      case "required":
        throw new UnsupportedFunctionalityError({
          functionality: "useLegacyFunctionCalling and toolChoice: required"
        });
      default:
        return {
          functions: openaiFunctions,
          function_call: { name: toolChoice.toolName },
          toolWarnings
        };
    }
  }
  const openaiTools2 = [];
  for (const tool of tools) {
    if (tool.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool });
    } else {
      openaiTools2.push({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.parameters,
          strict: structuredOutputs ? true : void 0
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: openaiTools2, tool_choice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiTools2, tool_choice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiTools2,
        tool_choice: {
          type: "function",
          function: {
            name: toolChoice.toolName
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError({
        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var OpenAIChatLanguageModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v1";
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  get supportsStructuredOutputs() {
    var _a;
    return (_a = this.settings.structuredOutputs) != null ? _a : isReasoningModel(this.modelId);
  }
  get defaultObjectGenerationMode() {
    if (isAudioModel(this.modelId)) {
      return "tool";
    }
    return this.supportsStructuredOutputs ? "json" : "tool";
  }
  get provider() {
    return this.config.provider;
  }
  get supportsImageUrls() {
    return !this.settings.downloadImages;
  }
  getArgs({
    mode,
    prompt,
    maxTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    providerMetadata
  }) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const type = mode.type;
    const warnings = [];
    if (topK != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "topK"
      });
    }
    if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !this.supportsStructuredOutputs) {
      warnings.push({
        type: "unsupported-setting",
        setting: "responseFormat",
        details: "JSON response format schema is only supported with structuredOutputs"
      });
    }
    const useLegacyFunctionCalling = this.settings.useLegacyFunctionCalling;
    if (useLegacyFunctionCalling && this.settings.parallelToolCalls === true) {
      throw new UnsupportedFunctionalityError({
        functionality: "useLegacyFunctionCalling with parallelToolCalls"
      });
    }
    if (useLegacyFunctionCalling && this.supportsStructuredOutputs) {
      throw new UnsupportedFunctionalityError({
        functionality: "structuredOutputs with useLegacyFunctionCalling"
      });
    }
    const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages(
      {
        prompt,
        useLegacyFunctionCalling,
        systemMessageMode: getSystemMessageMode(this.modelId)
      }
    );
    warnings.push(...messageWarnings);
    const baseArgs = {
      // model id:
      model: this.modelId,
      // model specific settings:
      logit_bias: this.settings.logitBias,
      logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === "number" ? true : void 0,
      top_logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
      user: this.settings.user,
      parallel_tool_calls: this.settings.parallelToolCalls,
      // standardized settings:
      max_tokens: maxTokens,
      temperature,
      top_p: topP,
      frequency_penalty: frequencyPenalty,
      presence_penalty: presencePenalty,
      response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? this.supportsStructuredOutputs && responseFormat.schema != null ? {
        type: "json_schema",
        json_schema: {
          schema: responseFormat.schema,
          strict: true,
          name: (_a = responseFormat.name) != null ? _a : "response",
          description: responseFormat.description
        }
      } : { type: "json_object" } : void 0,
      stop: stopSequences,
      seed,
      // openai specific settings:
      // TODO remove in next major version; we auto-map maxTokens now
      max_completion_tokens: (_b = providerMetadata == null ? void 0 : providerMetadata.openai) == null ? void 0 : _b.maxCompletionTokens,
      store: (_c = providerMetadata == null ? void 0 : providerMetadata.openai) == null ? void 0 : _c.store,
      metadata: (_d = providerMetadata == null ? void 0 : providerMetadata.openai) == null ? void 0 : _d.metadata,
      prediction: (_e = providerMetadata == null ? void 0 : providerMetadata.openai) == null ? void 0 : _e.prediction,
      reasoning_effort: (_g = (_f = providerMetadata == null ? void 0 : providerMetadata.openai) == null ? void 0 : _f.reasoningEffort) != null ? _g : this.settings.reasoningEffort,
      // messages:
      messages
    };
    if (isReasoningModel(this.modelId)) {
      if (baseArgs.temperature != null) {
        baseArgs.temperature = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "temperature",
          details: "temperature is not supported for reasoning models"
        });
      }
      if (baseArgs.top_p != null) {
        baseArgs.top_p = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "topP",
          details: "topP is not supported for reasoning models"
        });
      }
      if (baseArgs.frequency_penalty != null) {
        baseArgs.frequency_penalty = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "frequencyPenalty",
          details: "frequencyPenalty is not supported for reasoning models"
        });
      }
      if (baseArgs.presence_penalty != null) {
        baseArgs.presence_penalty = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "presencePenalty",
          details: "presencePenalty is not supported for reasoning models"
        });
      }
      if (baseArgs.logit_bias != null) {
        baseArgs.logit_bias = void 0;
        warnings.push({
          type: "other",
          message: "logitBias is not supported for reasoning models"
        });
      }
      if (baseArgs.logprobs != null) {
        baseArgs.logprobs = void 0;
        warnings.push({
          type: "other",
          message: "logprobs is not supported for reasoning models"
        });
      }
      if (baseArgs.top_logprobs != null) {
        baseArgs.top_logprobs = void 0;
        warnings.push({
          type: "other",
          message: "topLogprobs is not supported for reasoning models"
        });
      }
      if (baseArgs.max_tokens != null) {
        if (baseArgs.max_completion_tokens == null) {
          baseArgs.max_completion_tokens = baseArgs.max_tokens;
        }
        baseArgs.max_tokens = void 0;
      }
    } else if (this.modelId.startsWith("gpt-4o-search-preview") || this.modelId.startsWith("gpt-4o-mini-search-preview")) {
      if (baseArgs.temperature != null) {
        baseArgs.temperature = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "temperature",
          details: "temperature is not supported for the search preview models and has been removed."
        });
      }
    }
    switch (type) {
      case "regular": {
        const { tools, tool_choice, functions, function_call, toolWarnings } = prepareTools({
          mode,
          useLegacyFunctionCalling,
          structuredOutputs: this.supportsStructuredOutputs
        });
        return {
          args: {
            ...baseArgs,
            tools,
            tool_choice,
            functions,
            function_call
          },
          warnings: [...warnings, ...toolWarnings]
        };
      }
      case "object-json": {
        return {
          args: {
            ...baseArgs,
            response_format: this.supportsStructuredOutputs && mode.schema != null ? {
              type: "json_schema",
              json_schema: {
                schema: mode.schema,
                strict: true,
                name: (_h = mode.name) != null ? _h : "response",
                description: mode.description
              }
            } : { type: "json_object" }
          },
          warnings
        };
      }
      case "object-tool": {
        return {
          args: useLegacyFunctionCalling ? {
            ...baseArgs,
            function_call: {
              name: mode.tool.name
            },
            functions: [
              {
                name: mode.tool.name,
                description: mode.tool.description,
                parameters: mode.tool.parameters
              }
            ]
          } : {
            ...baseArgs,
            tool_choice: {
              type: "function",
              function: { name: mode.tool.name }
            },
            tools: [
              {
                type: "function",
                function: {
                  name: mode.tool.name,
                  description: mode.tool.description,
                  parameters: mode.tool.parameters,
                  strict: this.supportsStructuredOutputs ? true : void 0
                }
              }
            ]
          },
          warnings
        };
      }
      default: {
        const _exhaustiveCheck = type;
        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
      }
    }
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { args: body, warnings } = this.getArgs(options);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi$1({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiChatResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const { messages: rawPrompt, ...rawSettings } = body;
    const choice = response.choices[0];
    const completionTokenDetails = (_a = response.usage) == null ? void 0 : _a.completion_tokens_details;
    const promptTokenDetails = (_b = response.usage) == null ? void 0 : _b.prompt_tokens_details;
    const providerMetadata = { openai: {} };
    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens) != null) {
      providerMetadata.openai.reasoningTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens;
    }
    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
      providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
    }
    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
      providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
    }
    if ((promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens) != null) {
      providerMetadata.openai.cachedPromptTokens = promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens;
    }
    return {
      text: (_c = choice.message.content) != null ? _c : void 0,
      toolCalls: this.settings.useLegacyFunctionCalling && choice.message.function_call ? [
        {
          toolCallType: "function",
          toolCallId: generateId(),
          toolName: choice.message.function_call.name,
          args: choice.message.function_call.arguments
        }
      ] : (_d = choice.message.tool_calls) == null ? void 0 : _d.map((toolCall) => {
        var _a2;
        return {
          toolCallType: "function",
          toolCallId: (_a2 = toolCall.id) != null ? _a2 : generateId(),
          toolName: toolCall.function.name,
          args: toolCall.function.arguments
        };
      }),
      finishReason: mapOpenAIFinishReason(choice.finish_reason),
      usage: {
        promptTokens: (_f = (_e = response.usage) == null ? void 0 : _e.prompt_tokens) != null ? _f : NaN,
        completionTokens: (_h = (_g = response.usage) == null ? void 0 : _g.completion_tokens) != null ? _h : NaN
      },
      rawCall: { rawPrompt, rawSettings },
      rawResponse: { headers: responseHeaders, body: rawResponse },
      request: { body: JSON.stringify(body) },
      response: getResponseMetadata(response),
      warnings,
      logprobs: mapOpenAIChatLogProbsOutput(choice.logprobs),
      providerMetadata
    };
  }
  async doStream(options) {
    if (this.settings.simulateStreaming) {
      const result = await this.doGenerate(options);
      const simulatedStream = new ReadableStream({
        start(controller) {
          controller.enqueue({ type: "response-metadata", ...result.response });
          if (result.text) {
            controller.enqueue({
              type: "text-delta",
              textDelta: result.text
            });
          }
          if (result.toolCalls) {
            for (const toolCall of result.toolCalls) {
              controller.enqueue({
                type: "tool-call-delta",
                toolCallType: "function",
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                argsTextDelta: toolCall.args
              });
              controller.enqueue({
                type: "tool-call",
                ...toolCall
              });
            }
          }
          controller.enqueue({
            type: "finish",
            finishReason: result.finishReason,
            usage: result.usage,
            logprobs: result.logprobs,
            providerMetadata: result.providerMetadata
          });
          controller.close();
        }
      });
      return {
        stream: simulatedStream,
        rawCall: result.rawCall,
        rawResponse: result.rawResponse,
        warnings: result.warnings
      };
    }
    const { args, warnings } = this.getArgs(options);
    const body = {
      ...args,
      stream: true,
      // only include stream_options when in strict compatibility mode:
      stream_options: this.config.compatibility === "strict" ? { include_usage: true } : void 0
    };
    const { responseHeaders, value: response } = await postJsonToApi$1({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler$1(
        openaiChatChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const { messages: rawPrompt, ...rawSettings } = args;
    const toolCalls = [];
    let finishReason = "unknown";
    let usage = {
      promptTokens: void 0,
      completionTokens: void 0
    };
    let logprobs;
    let isFirstChunk = true;
    const { useLegacyFunctionCalling } = this.settings;
    const providerMetadata = { openai: {} };
    return {
      stream: response.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: value.error });
              return;
            }
            if (isFirstChunk) {
              isFirstChunk = false;
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata(value)
              });
            }
            if (value.usage != null) {
              const {
                prompt_tokens,
                completion_tokens,
                prompt_tokens_details,
                completion_tokens_details
              } = value.usage;
              usage = {
                promptTokens: prompt_tokens != null ? prompt_tokens : void 0,
                completionTokens: completion_tokens != null ? completion_tokens : void 0
              };
              if ((completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens) != null) {
                providerMetadata.openai.reasoningTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens;
              }
              if ((completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens) != null) {
                providerMetadata.openai.acceptedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens;
              }
              if ((completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens) != null) {
                providerMetadata.openai.rejectedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens;
              }
              if ((prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens) != null) {
                providerMetadata.openai.cachedPromptTokens = prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens;
              }
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapOpenAIFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.delta) == null) {
              return;
            }
            const delta = choice.delta;
            if (delta.content != null) {
              controller.enqueue({
                type: "text-delta",
                textDelta: delta.content
              });
            }
            const mappedLogprobs = mapOpenAIChatLogProbsOutput(
              choice == null ? void 0 : choice.logprobs
            );
            if (mappedLogprobs == null ? void 0 : mappedLogprobs.length) {
              if (logprobs === void 0) logprobs = [];
              logprobs.push(...mappedLogprobs);
            }
            const mappedToolCalls = useLegacyFunctionCalling && delta.function_call != null ? [
              {
                type: "function",
                id: generateId(),
                function: delta.function_call,
                index: 0
              }
            ] : delta.tool_calls;
            if (mappedToolCalls != null) {
              for (const toolCallDelta of mappedToolCalls) {
                const index = toolCallDelta.index;
                if (toolCalls[index] == null) {
                  if (toolCallDelta.type !== "function") {
                    throw new InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'function' type.`
                    });
                  }
                  if (toolCallDelta.id == null) {
                    throw new InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'id' to be a string.`
                    });
                  }
                  if (((_a = toolCallDelta.function) == null ? void 0 : _a.name) == null) {
                    throw new InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'function.name' to be a string.`
                    });
                  }
                  toolCalls[index] = {
                    id: toolCallDelta.id,
                    type: "function",
                    function: {
                      name: toolCallDelta.function.name,
                      arguments: (_b = toolCallDelta.function.arguments) != null ? _b : ""
                    },
                    hasFinished: false
                  };
                  const toolCall2 = toolCalls[index];
                  if (((_c = toolCall2.function) == null ? void 0 : _c.name) != null && ((_d = toolCall2.function) == null ? void 0 : _d.arguments) != null) {
                    if (toolCall2.function.arguments.length > 0) {
                      controller.enqueue({
                        type: "tool-call-delta",
                        toolCallType: "function",
                        toolCallId: toolCall2.id,
                        toolName: toolCall2.function.name,
                        argsTextDelta: toolCall2.function.arguments
                      });
                    }
                    if (isParsableJson(toolCall2.function.arguments)) {
                      controller.enqueue({
                        type: "tool-call",
                        toolCallType: "function",
                        toolCallId: (_e = toolCall2.id) != null ? _e : generateId(),
                        toolName: toolCall2.function.name,
                        args: toolCall2.function.arguments
                      });
                      toolCall2.hasFinished = true;
                    }
                  }
                  continue;
                }
                const toolCall = toolCalls[index];
                if (toolCall.hasFinished) {
                  continue;
                }
                if (((_f = toolCallDelta.function) == null ? void 0 : _f.arguments) != null) {
                  toolCall.function.arguments += (_h = (_g = toolCallDelta.function) == null ? void 0 : _g.arguments) != null ? _h : "";
                }
                controller.enqueue({
                  type: "tool-call-delta",
                  toolCallType: "function",
                  toolCallId: toolCall.id,
                  toolName: toolCall.function.name,
                  argsTextDelta: (_i = toolCallDelta.function.arguments) != null ? _i : ""
                });
                if (((_j = toolCall.function) == null ? void 0 : _j.name) != null && ((_k = toolCall.function) == null ? void 0 : _k.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                  controller.enqueue({
                    type: "tool-call",
                    toolCallType: "function",
                    toolCallId: (_l = toolCall.id) != null ? _l : generateId(),
                    toolName: toolCall.function.name,
                    args: toolCall.function.arguments
                  });
                  toolCall.hasFinished = true;
                }
              }
            }
          },
          flush(controller) {
            var _a, _b;
            controller.enqueue({
              type: "finish",
              finishReason,
              logprobs,
              usage: {
                promptTokens: (_a = usage.promptTokens) != null ? _a : NaN,
                completionTokens: (_b = usage.completionTokens) != null ? _b : NaN
              },
              ...providerMetadata != null ? { providerMetadata } : {}
            });
          }
        })
      ),
      rawCall: { rawPrompt, rawSettings },
      rawResponse: { headers: responseHeaders },
      request: { body: JSON.stringify(body) },
      warnings
    };
  }
};
var openaiTokenUsageSchema = z.object({
  prompt_tokens: z.number().nullish(),
  completion_tokens: z.number().nullish(),
  prompt_tokens_details: z.object({
    cached_tokens: z.number().nullish()
  }).nullish(),
  completion_tokens_details: z.object({
    reasoning_tokens: z.number().nullish(),
    accepted_prediction_tokens: z.number().nullish(),
    rejected_prediction_tokens: z.number().nullish()
  }).nullish()
}).nullish();
var openaiChatResponseSchema = z.object({
  id: z.string().nullish(),
  created: z.number().nullish(),
  model: z.string().nullish(),
  choices: z.array(
    z.object({
      message: z.object({
        role: z.literal("assistant").nullish(),
        content: z.string().nullish(),
        function_call: z.object({
          arguments: z.string(),
          name: z.string()
        }).nullish(),
        tool_calls: z.array(
          z.object({
            id: z.string().nullish(),
            type: z.literal("function"),
            function: z.object({
              name: z.string(),
              arguments: z.string()
            })
          })
        ).nullish()
      }),
      index: z.number(),
      logprobs: z.object({
        content: z.array(
          z.object({
            token: z.string(),
            logprob: z.number(),
            top_logprobs: z.array(
              z.object({
                token: z.string(),
                logprob: z.number()
              })
            )
          })
        ).nullable()
      }).nullish(),
      finish_reason: z.string().nullish()
    })
  ),
  usage: openaiTokenUsageSchema
});
var openaiChatChunkSchema = z.union([
  z.object({
    id: z.string().nullish(),
    created: z.number().nullish(),
    model: z.string().nullish(),
    choices: z.array(
      z.object({
        delta: z.object({
          role: z.enum(["assistant"]).nullish(),
          content: z.string().nullish(),
          function_call: z.object({
            name: z.string().optional(),
            arguments: z.string().optional()
          }).nullish(),
          tool_calls: z.array(
            z.object({
              index: z.number(),
              id: z.string().nullish(),
              type: z.literal("function").nullish(),
              function: z.object({
                name: z.string().nullish(),
                arguments: z.string().nullish()
              })
            })
          ).nullish()
        }).nullish(),
        logprobs: z.object({
          content: z.array(
            z.object({
              token: z.string(),
              logprob: z.number(),
              top_logprobs: z.array(
                z.object({
                  token: z.string(),
                  logprob: z.number()
                })
              )
            })
          ).nullable()
        }).nullish(),
        finish_reason: z.string().nullish(),
        index: z.number()
      })
    ),
    usage: openaiTokenUsageSchema
  }),
  openaiErrorDataSchema
]);
function isReasoningModel(modelId) {
  return modelId.startsWith("o") || modelId.startsWith("gpt-5");
}
function isAudioModel(modelId) {
  return modelId.startsWith("gpt-4o-audio-preview");
}
function getSystemMessageMode(modelId) {
  var _a, _b;
  if (!isReasoningModel(modelId)) {
    return "system";
  }
  return (_b = (_a = reasoningModels[modelId]) == null ? void 0 : _a.systemMessageMode) != null ? _b : "developer";
}
var reasoningModels = {
  "o1-mini": {
    systemMessageMode: "remove"
  },
  "o1-mini-2024-09-12": {
    systemMessageMode: "remove"
  },
  "o1-preview": {
    systemMessageMode: "remove"
  },
  "o1-preview-2024-09-12": {
    systemMessageMode: "remove"
  },
  o3: {
    systemMessageMode: "developer"
  },
  "o3-2025-04-16": {
    systemMessageMode: "developer"
  },
  "o3-mini": {
    systemMessageMode: "developer"
  },
  "o3-mini-2025-01-31": {
    systemMessageMode: "developer"
  },
  "o4-mini": {
    systemMessageMode: "developer"
  },
  "o4-mini-2025-04-16": {
    systemMessageMode: "developer"
  }
};
function convertToOpenAICompletionPrompt({
  prompt,
  inputFormat,
  user = "user",
  assistant = "assistant"
}) {
  if (inputFormat === "prompt" && prompt.length === 1 && prompt[0].role === "user" && prompt[0].content.length === 1 && prompt[0].content[0].type === "text") {
    return { prompt: prompt[0].content[0].text };
  }
  let text = "";
  if (prompt[0].role === "system") {
    text += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "image": {
              throw new UnsupportedFunctionalityError({
                functionality: "images"
              });
            }
          }
        }).join("");
        text += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new UnsupportedFunctionalityError({
                functionality: "tool-call messages"
              });
            }
          }
        }).join("");
        text += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  text += `${assistant}:
`;
  return {
    prompt: text,
    stopSequences: [`
${user}:`]
  };
}
function mapOpenAICompletionLogProbs(logprobs) {
  return logprobs == null ? void 0 : logprobs.tokens.map((token, index) => ({
    token,
    logprob: logprobs.token_logprobs[index],
    topLogprobs: logprobs.top_logprobs ? Object.entries(logprobs.top_logprobs[index]).map(
      ([token2, logprob]) => ({
        token: token2,
        logprob
      })
    ) : []
  }));
}
var OpenAICompletionLanguageModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v1";
    this.defaultObjectGenerationMode = void 0;
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs({
    mode,
    inputFormat,
    prompt,
    maxTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences: userStopSequences,
    responseFormat,
    seed
  }) {
    var _a;
    const type = mode.type;
    const warnings = [];
    if (topK != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "topK"
      });
    }
    if (responseFormat != null && responseFormat.type !== "text") {
      warnings.push({
        type: "unsupported-setting",
        setting: "responseFormat",
        details: "JSON response format is not supported."
      });
    }
    const { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt({ prompt, inputFormat });
    const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
    const baseArgs = {
      // model id:
      model: this.modelId,
      // model specific settings:
      echo: this.settings.echo,
      logit_bias: this.settings.logitBias,
      logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
      suffix: this.settings.suffix,
      user: this.settings.user,
      // standardized settings:
      max_tokens: maxTokens,
      temperature,
      top_p: topP,
      frequency_penalty: frequencyPenalty,
      presence_penalty: presencePenalty,
      seed,
      // prompt:
      prompt: completionPrompt,
      // stop sequences:
      stop: stop.length > 0 ? stop : void 0
    };
    switch (type) {
      case "regular": {
        if ((_a = mode.tools) == null ? void 0 : _a.length) {
          throw new UnsupportedFunctionalityError({
            functionality: "tools"
          });
        }
        if (mode.toolChoice) {
          throw new UnsupportedFunctionalityError({
            functionality: "toolChoice"
          });
        }
        return { args: baseArgs, warnings };
      }
      case "object-json": {
        throw new UnsupportedFunctionalityError({
          functionality: "object-json mode"
        });
      }
      case "object-tool": {
        throw new UnsupportedFunctionalityError({
          functionality: "object-tool mode"
        });
      }
      default: {
        const _exhaustiveCheck = type;
        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
      }
    }
  }
  async doGenerate(options) {
    const { args, warnings } = this.getArgs(options);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi$1({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiCompletionResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const { prompt: rawPrompt, ...rawSettings } = args;
    const choice = response.choices[0];
    return {
      text: choice.text,
      usage: {
        promptTokens: response.usage.prompt_tokens,
        completionTokens: response.usage.completion_tokens
      },
      finishReason: mapOpenAIFinishReason(choice.finish_reason),
      logprobs: mapOpenAICompletionLogProbs(choice.logprobs),
      rawCall: { rawPrompt, rawSettings },
      rawResponse: { headers: responseHeaders, body: rawResponse },
      response: getResponseMetadata(response),
      warnings,
      request: { body: JSON.stringify(args) }
    };
  }
  async doStream(options) {
    const { args, warnings } = this.getArgs(options);
    const body = {
      ...args,
      stream: true,
      // only include stream_options when in strict compatibility mode:
      stream_options: this.config.compatibility === "strict" ? { include_usage: true } : void 0
    };
    const { responseHeaders, value: response } = await postJsonToApi$1({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler$1(
        openaiCompletionChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const { prompt: rawPrompt, ...rawSettings } = args;
    let finishReason = "unknown";
    let usage = {
      promptTokens: Number.NaN,
      completionTokens: Number.NaN
    };
    let logprobs;
    let isFirstChunk = true;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: value.error });
              return;
            }
            if (isFirstChunk) {
              isFirstChunk = false;
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata(value)
              });
            }
            if (value.usage != null) {
              usage = {
                promptTokens: value.usage.prompt_tokens,
                completionTokens: value.usage.completion_tokens
              };
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapOpenAIFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.text) != null) {
              controller.enqueue({
                type: "text-delta",
                textDelta: choice.text
              });
            }
            const mappedLogprobs = mapOpenAICompletionLogProbs(
              choice == null ? void 0 : choice.logprobs
            );
            if (mappedLogprobs == null ? void 0 : mappedLogprobs.length) {
              if (logprobs === void 0) logprobs = [];
              logprobs.push(...mappedLogprobs);
            }
          },
          flush(controller) {
            controller.enqueue({
              type: "finish",
              finishReason,
              logprobs,
              usage
            });
          }
        })
      ),
      rawCall: { rawPrompt, rawSettings },
      rawResponse: { headers: responseHeaders },
      warnings,
      request: { body: JSON.stringify(body) }
    };
  }
};
var openaiCompletionResponseSchema = z.object({
  id: z.string().nullish(),
  created: z.number().nullish(),
  model: z.string().nullish(),
  choices: z.array(
    z.object({
      text: z.string(),
      finish_reason: z.string(),
      logprobs: z.object({
        tokens: z.array(z.string()),
        token_logprobs: z.array(z.number()),
        top_logprobs: z.array(z.record(z.string(), z.number())).nullable()
      }).nullish()
    })
  ),
  usage: z.object({
    prompt_tokens: z.number(),
    completion_tokens: z.number()
  })
});
var openaiCompletionChunkSchema = z.union([
  z.object({
    id: z.string().nullish(),
    created: z.number().nullish(),
    model: z.string().nullish(),
    choices: z.array(
      z.object({
        text: z.string(),
        finish_reason: z.string().nullish(),
        index: z.number(),
        logprobs: z.object({
          tokens: z.array(z.string()),
          token_logprobs: z.array(z.number()),
          top_logprobs: z.array(z.record(z.string(), z.number())).nullable()
        }).nullish()
      })
    ),
    usage: z.object({
      prompt_tokens: z.number(),
      completion_tokens: z.number()
    }).nullish()
  }),
  openaiErrorDataSchema
]);
var OpenAIEmbeddingModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v1";
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  get maxEmbeddingsPerCall() {
    var _a;
    return (_a = this.settings.maxEmbeddingsPerCall) != null ? _a : 2048;
  }
  get supportsParallelCalls() {
    var _a;
    return (_a = this.settings.supportsParallelCalls) != null ? _a : true;
  }
  async doEmbed({
    values,
    headers,
    abortSignal
  }) {
    if (values.length > this.maxEmbeddingsPerCall) {
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    }
    const { responseHeaders, value: response } = await postJsonToApi$1({
      url: this.config.url({
        path: "/embeddings",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), headers),
      body: {
        model: this.modelId,
        input: values,
        encoding_format: "float",
        dimensions: this.settings.dimensions,
        user: this.settings.user
      },
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiTextEmbeddingResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      embeddings: response.data.map((item) => item.embedding),
      usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
      rawResponse: { headers: responseHeaders }
    };
  }
};
var openaiTextEmbeddingResponseSchema = z.object({
  data: z.array(z.object({ embedding: z.array(z.number()) })),
  usage: z.object({ prompt_tokens: z.number() }).nullish()
});
var modelMaxImagesPerCall = {
  "dall-e-3": 1,
  "dall-e-2": 10,
  "gpt-image-1": 10
};
var hasDefaultResponseFormat = /* @__PURE__ */ new Set(["gpt-image-1"]);
var OpenAIImageModel = class {
  constructor(modelId, settings, config) {
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
    this.specificationVersion = "v1";
  }
  get maxImagesPerCall() {
    var _a, _b;
    return (_b = (_a = this.settings.maxImagesPerCall) != null ? _a : modelMaxImagesPerCall[this.modelId]) != null ? _b : 1;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a, _b, _c, _d;
    const warnings = [];
    if (aspectRatio != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "aspectRatio",
        details: "This model does not support aspect ratio. Use `size` instead."
      });
    }
    if (seed != null) {
      warnings.push({ type: "unsupported-setting", setting: "seed" });
    }
    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
    const { value: response, responseHeaders } = await postJsonToApi$1({
      url: this.config.url({
        path: "/images/generations",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), headers),
      body: {
        model: this.modelId,
        prompt,
        n,
        size,
        ...(_d = providerOptions.openai) != null ? _d : {},
        ...!hasDefaultResponseFormat.has(this.modelId) ? { response_format: "b64_json" } : {}
      },
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiImageResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      images: response.data.map((item) => item.b64_json),
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders
      }
    };
  }
};
var openaiImageResponseSchema = z.object({
  data: z.array(z.object({ b64_json: z.string() }))
});
var openAIProviderOptionsSchema = z.object({
  include: z.array(z.string()).nullish(),
  language: z.string().nullish(),
  prompt: z.string().nullish(),
  temperature: z.number().min(0).max(1).nullish().default(0),
  timestampGranularities: z.array(z.enum(["word", "segment"])).nullish().default(["segment"])
});
var languageMap = {
  afrikaans: "af",
  arabic: "ar",
  armenian: "hy",
  azerbaijani: "az",
  belarusian: "be",
  bosnian: "bs",
  bulgarian: "bg",
  catalan: "ca",
  chinese: "zh",
  croatian: "hr",
  czech: "cs",
  danish: "da",
  dutch: "nl",
  english: "en",
  estonian: "et",
  finnish: "fi",
  french: "fr",
  galician: "gl",
  german: "de",
  greek: "el",
  hebrew: "he",
  hindi: "hi",
  hungarian: "hu",
  icelandic: "is",
  indonesian: "id",
  italian: "it",
  japanese: "ja",
  kannada: "kn",
  kazakh: "kk",
  korean: "ko",
  latvian: "lv",
  lithuanian: "lt",
  macedonian: "mk",
  malay: "ms",
  marathi: "mr",
  maori: "mi",
  nepali: "ne",
  norwegian: "no",
  persian: "fa",
  polish: "pl",
  portuguese: "pt",
  romanian: "ro",
  russian: "ru",
  serbian: "sr",
  slovak: "sk",
  slovenian: "sl",
  spanish: "es",
  swahili: "sw",
  swedish: "sv",
  tagalog: "tl",
  tamil: "ta",
  thai: "th",
  turkish: "tr",
  ukrainian: "uk",
  urdu: "ur",
  vietnamese: "vi",
  welsh: "cy"
};
var OpenAITranscriptionModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v1";
  }
  get provider() {
    return this.config.provider;
  }
  getArgs({
    audio,
    mediaType,
    providerOptions
  }) {
    var _a, _b, _c, _d, _e;
    const warnings = [];
    const openAIOptions = parseProviderOptions({
      provider: "openai",
      providerOptions,
      schema: openAIProviderOptionsSchema
    });
    const formData = new FormData();
    const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([convertBase64ToUint8Array(audio)]);
    formData.append("model", this.modelId);
    formData.append("file", new File([blob], "audio", { type: mediaType }));
    if (openAIOptions) {
      const transcriptionModelOptions = {
        include: (_a = openAIOptions.include) != null ? _a : void 0,
        language: (_b = openAIOptions.language) != null ? _b : void 0,
        prompt: (_c = openAIOptions.prompt) != null ? _c : void 0,
        temperature: (_d = openAIOptions.temperature) != null ? _d : void 0,
        timestamp_granularities: (_e = openAIOptions.timestampGranularities) != null ? _e : void 0
      };
      for (const key in transcriptionModelOptions) {
        const value = transcriptionModelOptions[key];
        if (value !== void 0) {
          formData.append(key, String(value));
        }
      }
    }
    return {
      formData,
      warnings
    };
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f;
    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
    const { formData, warnings } = this.getArgs(options);
    const {
      value: response,
      responseHeaders,
      rawValue: rawResponse
    } = await postFormDataToApi({
      url: this.config.url({
        path: "/audio/transcriptions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      formData,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiTranscriptionResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const language = response.language != null && response.language in languageMap ? languageMap[response.language] : void 0;
    return {
      text: response.text,
      segments: (_e = (_d = response.words) == null ? void 0 : _d.map((word) => ({
        text: word.word,
        startSecond: word.start,
        endSecond: word.end
      }))) != null ? _e : [],
      language,
      durationInSeconds: (_f = response.duration) != null ? _f : void 0,
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders,
        body: rawResponse
      }
    };
  }
};
var openaiTranscriptionResponseSchema = z.object({
  text: z.string(),
  language: z.string().nullish(),
  duration: z.number().nullish(),
  words: z.array(
    z.object({
      word: z.string(),
      start: z.number(),
      end: z.number()
    })
  ).nullish()
});
function convertToOpenAIResponsesMessages({
  prompt,
  systemMessageMode
}) {
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        messages.push({
          role: "user",
          content: content.map((part, index) => {
            var _a, _b, _c, _d;
            switch (part.type) {
              case "text": {
                return { type: "input_text", text: part.text };
              }
              case "image": {
                return {
                  type: "input_image",
                  image_url: part.image instanceof URL ? part.image.toString() : `data:${(_a = part.mimeType) != null ? _a : "image/jpeg"};base64,${convertUint8ArrayToBase64(part.image)}`,
                  // OpenAI specific extension: image detail
                  detail: (_c = (_b = part.providerMetadata) == null ? void 0 : _b.openai) == null ? void 0 : _c.imageDetail
                };
              }
              case "file": {
                if (part.data instanceof URL) {
                  throw new UnsupportedFunctionalityError({
                    functionality: "File URLs in user messages"
                  });
                }
                switch (part.mimeType) {
                  case "application/pdf": {
                    return {
                      type: "input_file",
                      filename: (_d = part.filename) != null ? _d : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${part.data}`
                    };
                  }
                  default: {
                    throw new UnsupportedFunctionalityError({
                      functionality: "Only PDF files are supported in user messages"
                    });
                  }
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        for (const part of content) {
          switch (part.type) {
            case "text": {
              messages.push({
                role: "assistant",
                content: [{ type: "output_text", text: part.text }]
              });
              break;
            }
            case "tool-call": {
              messages.push({
                type: "function_call",
                call_id: part.toolCallId,
                name: part.toolName,
                arguments: JSON.stringify(part.args)
              });
              break;
            }
          }
        }
        break;
      }
      case "tool": {
        for (const part of content) {
          messages.push({
            type: "function_call_output",
            call_id: part.toolCallId,
            output: JSON.stringify(part.result)
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}
function mapOpenAIResponseFinishReason({
  finishReason,
  hasToolCalls
}) {
  switch (finishReason) {
    case void 0:
    case null:
      return hasToolCalls ? "tool-calls" : "stop";
    case "max_output_tokens":
      return "length";
    case "content_filter":
      return "content-filter";
    default:
      return hasToolCalls ? "tool-calls" : "unknown";
  }
}
function prepareResponsesTools({
  mode,
  strict
}) {
  var _a;
  const tools = ((_a = mode.tools) == null ? void 0 : _a.length) ? mode.tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, tool_choice: void 0, toolWarnings };
  }
  const toolChoice = mode.toolChoice;
  const openaiTools2 = [];
  for (const tool of tools) {
    switch (tool.type) {
      case "function":
        openaiTools2.push({
          type: "function",
          name: tool.name,
          description: tool.description,
          parameters: tool.parameters,
          strict: strict ? true : void 0
        });
        break;
      case "provider-defined":
        switch (tool.id) {
          case "openai.web_search_preview":
            openaiTools2.push({
              type: "web_search_preview",
              search_context_size: tool.args.searchContextSize,
              user_location: tool.args.userLocation
            });
            break;
          default:
            toolWarnings.push({ type: "unsupported-tool", tool });
            break;
        }
        break;
      default:
        toolWarnings.push({ type: "unsupported-tool", tool });
        break;
    }
  }
  if (toolChoice == null) {
    return { tools: openaiTools2, tool_choice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiTools2, tool_choice: type, toolWarnings };
    case "tool": {
      if (toolChoice.toolName === "web_search_preview") {
        return {
          tools: openaiTools2,
          tool_choice: {
            type: "web_search_preview"
          },
          toolWarnings
        };
      }
      return {
        tools: openaiTools2,
        tool_choice: {
          type: "function",
          name: toolChoice.toolName
        },
        toolWarnings
      };
    }
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError({
        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var OpenAIResponsesLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v1";
    this.defaultObjectGenerationMode = "json";
    this.supportsStructuredOutputs = true;
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs({
    mode,
    maxTokens,
    temperature,
    stopSequences,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    seed,
    prompt,
    providerMetadata,
    responseFormat
  }) {
    var _a, _b, _c;
    const warnings = [];
    const modelConfig = getResponsesModelConfig(this.modelId);
    const type = mode.type;
    if (topK != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "topK"
      });
    }
    if (seed != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "seed"
      });
    }
    if (presencePenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "presencePenalty"
      });
    }
    if (frequencyPenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "frequencyPenalty"
      });
    }
    if (stopSequences != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "stopSequences"
      });
    }
    const { messages, warnings: messageWarnings } = convertToOpenAIResponsesMessages({
      prompt,
      systemMessageMode: modelConfig.systemMessageMode
    });
    warnings.push(...messageWarnings);
    const openaiOptions = parseProviderOptions({
      provider: "openai",
      providerOptions: providerMetadata,
      schema: openaiResponsesProviderOptionsSchema
    });
    const isStrict = (_a = openaiOptions == null ? void 0 : openaiOptions.strictSchemas) != null ? _a : true;
    const baseArgs = {
      model: this.modelId,
      input: messages,
      temperature,
      top_p: topP,
      max_output_tokens: maxTokens,
      ...(responseFormat == null ? void 0 : responseFormat.type) === "json" && {
        text: {
          format: responseFormat.schema != null ? {
            type: "json_schema",
            strict: isStrict,
            name: (_b = responseFormat.name) != null ? _b : "response",
            description: responseFormat.description,
            schema: responseFormat.schema
          } : { type: "json_object" }
        }
      },
      // provider options:
      metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,
      parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,
      previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,
      store: openaiOptions == null ? void 0 : openaiOptions.store,
      user: openaiOptions == null ? void 0 : openaiOptions.user,
      instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,
      // model-specific settings:
      ...modelConfig.isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {
        reasoning: {
          ...(openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {
            effort: openaiOptions.reasoningEffort
          },
          ...(openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {
            summary: openaiOptions.reasoningSummary
          }
        }
      },
      ...modelConfig.requiredAutoTruncation && {
        truncation: "auto"
      }
    };
    if (modelConfig.isReasoningModel) {
      if (baseArgs.temperature != null) {
        baseArgs.temperature = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "temperature",
          details: "temperature is not supported for reasoning models"
        });
      }
      if (baseArgs.top_p != null) {
        baseArgs.top_p = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "topP",
          details: "topP is not supported for reasoning models"
        });
      }
    }
    switch (type) {
      case "regular": {
        const { tools, tool_choice, toolWarnings } = prepareResponsesTools({
          mode,
          strict: isStrict
          // TODO support provider options on tools
        });
        return {
          args: {
            ...baseArgs,
            tools,
            tool_choice
          },
          warnings: [...warnings, ...toolWarnings]
        };
      }
      case "object-json": {
        return {
          args: {
            ...baseArgs,
            text: {
              format: mode.schema != null ? {
                type: "json_schema",
                strict: isStrict,
                name: (_c = mode.name) != null ? _c : "response",
                description: mode.description,
                schema: mode.schema
              } : { type: "json_object" }
            }
          },
          warnings
        };
      }
      case "object-tool": {
        return {
          args: {
            ...baseArgs,
            tool_choice: { type: "function", name: mode.tool.name },
            tools: [
              {
                type: "function",
                name: mode.tool.name,
                description: mode.tool.description,
                parameters: mode.tool.parameters,
                strict: isStrict
              }
            ]
          },
          warnings
        };
      }
      default: {
        const _exhaustiveCheck = type;
        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
      }
    }
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { args: body, warnings } = this.getArgs(options);
    const url = this.config.url({
      path: "/responses",
      modelId: this.modelId
    });
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi$1({
      url,
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        z.object({
          id: z.string(),
          created_at: z.number(),
          error: z.object({
            message: z.string(),
            code: z.string()
          }).nullish(),
          model: z.string(),
          output: z.array(
            z.discriminatedUnion("type", [
              z.object({
                type: z.literal("message"),
                role: z.literal("assistant"),
                content: z.array(
                  z.object({
                    type: z.literal("output_text"),
                    text: z.string(),
                    annotations: z.array(
                      z.object({
                        type: z.literal("url_citation"),
                        start_index: z.number(),
                        end_index: z.number(),
                        url: z.string(),
                        title: z.string()
                      })
                    )
                  })
                )
              }),
              z.object({
                type: z.literal("function_call"),
                call_id: z.string(),
                name: z.string(),
                arguments: z.string()
              }),
              z.object({
                type: z.literal("web_search_call")
              }),
              z.object({
                type: z.literal("computer_call")
              }),
              z.object({
                type: z.literal("reasoning"),
                summary: z.array(
                  z.object({
                    type: z.literal("summary_text"),
                    text: z.string()
                  })
                )
              })
            ])
          ),
          incomplete_details: z.object({ reason: z.string() }).nullable(),
          usage: usageSchema
        })
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    if (response.error) {
      throw new APICallError$1({
        message: response.error.message,
        url,
        requestBodyValues: body,
        statusCode: 400,
        responseHeaders,
        responseBody: rawResponse,
        isRetryable: false
      });
    }
    const outputTextElements = response.output.filter((output) => output.type === "message").flatMap((output) => output.content).filter((content) => content.type === "output_text");
    const toolCalls = response.output.filter((output) => output.type === "function_call").map((output) => ({
      toolCallType: "function",
      toolCallId: output.call_id,
      toolName: output.name,
      args: output.arguments
    }));
    const reasoningSummary = (_b = (_a = response.output.find((item) => item.type === "reasoning")) == null ? void 0 : _a.summary) != null ? _b : null;
    return {
      text: outputTextElements.map((content) => content.text).join("\n"),
      sources: outputTextElements.flatMap(
        (content) => content.annotations.map((annotation) => {
          var _a2, _b2, _c2;
          return {
            sourceType: "url",
            id: (_c2 = (_b2 = (_a2 = this.config).generateId) == null ? void 0 : _b2.call(_a2)) != null ? _c2 : generateId(),
            url: annotation.url,
            title: annotation.title
          };
        })
      ),
      finishReason: mapOpenAIResponseFinishReason({
        finishReason: (_c = response.incomplete_details) == null ? void 0 : _c.reason,
        hasToolCalls: toolCalls.length > 0
      }),
      toolCalls: toolCalls.length > 0 ? toolCalls : void 0,
      reasoning: reasoningSummary ? reasoningSummary.map((summary) => ({
        type: "text",
        text: summary.text
      })) : void 0,
      usage: {
        promptTokens: response.usage.input_tokens,
        completionTokens: response.usage.output_tokens
      },
      rawCall: {
        rawPrompt: void 0,
        rawSettings: {}
      },
      rawResponse: {
        headers: responseHeaders,
        body: rawResponse
      },
      request: {
        body: JSON.stringify(body)
      },
      response: {
        id: response.id,
        timestamp: new Date(response.created_at * 1e3),
        modelId: response.model
      },
      providerMetadata: {
        openai: {
          responseId: response.id,
          cachedPromptTokens: (_e = (_d = response.usage.input_tokens_details) == null ? void 0 : _d.cached_tokens) != null ? _e : null,
          reasoningTokens: (_g = (_f = response.usage.output_tokens_details) == null ? void 0 : _f.reasoning_tokens) != null ? _g : null
        }
      },
      warnings
    };
  }
  async doStream(options) {
    const { args: body, warnings } = this.getArgs(options);
    const { responseHeaders, value: response } = await postJsonToApi$1({
      url: this.config.url({
        path: "/responses",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body: {
        ...body,
        stream: true
      },
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler$1(
        openaiResponsesChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const self = this;
    let finishReason = "unknown";
    let promptTokens = NaN;
    let completionTokens = NaN;
    let cachedPromptTokens = null;
    let reasoningTokens = null;
    let responseId = null;
    const ongoingToolCalls = {};
    let hasToolCalls = false;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if (isResponseOutputItemAddedChunk(value)) {
              if (value.item.type === "function_call") {
                ongoingToolCalls[value.output_index] = {
                  toolName: value.item.name,
                  toolCallId: value.item.call_id
                };
                controller.enqueue({
                  type: "tool-call-delta",
                  toolCallType: "function",
                  toolCallId: value.item.call_id,
                  toolName: value.item.name,
                  argsTextDelta: value.item.arguments
                });
              }
            } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {
              const toolCall = ongoingToolCalls[value.output_index];
              if (toolCall != null) {
                controller.enqueue({
                  type: "tool-call-delta",
                  toolCallType: "function",
                  toolCallId: toolCall.toolCallId,
                  toolName: toolCall.toolName,
                  argsTextDelta: value.delta
                });
              }
            } else if (isResponseCreatedChunk(value)) {
              responseId = value.response.id;
              controller.enqueue({
                type: "response-metadata",
                id: value.response.id,
                timestamp: new Date(value.response.created_at * 1e3),
                modelId: value.response.model
              });
            } else if (isTextDeltaChunk(value)) {
              controller.enqueue({
                type: "text-delta",
                textDelta: value.delta
              });
            } else if (isResponseReasoningSummaryTextDeltaChunk(value)) {
              controller.enqueue({
                type: "reasoning",
                textDelta: value.delta
              });
            } else if (isResponseOutputItemDoneChunk(value) && value.item.type === "function_call") {
              ongoingToolCalls[value.output_index] = void 0;
              hasToolCalls = true;
              controller.enqueue({
                type: "tool-call",
                toolCallType: "function",
                toolCallId: value.item.call_id,
                toolName: value.item.name,
                args: value.item.arguments
              });
            } else if (isResponseFinishedChunk(value)) {
              finishReason = mapOpenAIResponseFinishReason({
                finishReason: (_a = value.response.incomplete_details) == null ? void 0 : _a.reason,
                hasToolCalls
              });
              promptTokens = value.response.usage.input_tokens;
              completionTokens = value.response.usage.output_tokens;
              cachedPromptTokens = (_c = (_b = value.response.usage.input_tokens_details) == null ? void 0 : _b.cached_tokens) != null ? _c : cachedPromptTokens;
              reasoningTokens = (_e = (_d = value.response.usage.output_tokens_details) == null ? void 0 : _d.reasoning_tokens) != null ? _e : reasoningTokens;
            } else if (isResponseAnnotationAddedChunk(value)) {
              controller.enqueue({
                type: "source",
                source: {
                  sourceType: "url",
                  id: (_h = (_g = (_f = self.config).generateId) == null ? void 0 : _g.call(_f)) != null ? _h : generateId(),
                  url: value.annotation.url,
                  title: value.annotation.title
                }
              });
            } else if (isErrorChunk(value)) {
              controller.enqueue({ type: "error", error: value });
            }
          },
          flush(controller) {
            controller.enqueue({
              type: "finish",
              finishReason,
              usage: { promptTokens, completionTokens },
              ...(cachedPromptTokens != null || reasoningTokens != null) && {
                providerMetadata: {
                  openai: {
                    responseId,
                    cachedPromptTokens,
                    reasoningTokens
                  }
                }
              }
            });
          }
        })
      ),
      rawCall: {
        rawPrompt: void 0,
        rawSettings: {}
      },
      rawResponse: { headers: responseHeaders },
      request: { body: JSON.stringify(body) },
      warnings
    };
  }
};
var usageSchema = z.object({
  input_tokens: z.number(),
  input_tokens_details: z.object({ cached_tokens: z.number().nullish() }).nullish(),
  output_tokens: z.number(),
  output_tokens_details: z.object({ reasoning_tokens: z.number().nullish() }).nullish()
});
var textDeltaChunkSchema = z.object({
  type: z.literal("response.output_text.delta"),
  delta: z.string()
});
var responseFinishedChunkSchema = z.object({
  type: z.enum(["response.completed", "response.incomplete"]),
  response: z.object({
    incomplete_details: z.object({ reason: z.string() }).nullish(),
    usage: usageSchema
  })
});
var responseCreatedChunkSchema = z.object({
  type: z.literal("response.created"),
  response: z.object({
    id: z.string(),
    created_at: z.number(),
    model: z.string()
  })
});
var responseOutputItemDoneSchema = z.object({
  type: z.literal("response.output_item.done"),
  output_index: z.number(),
  item: z.discriminatedUnion("type", [
    z.object({
      type: z.literal("message")
    }),
    z.object({
      type: z.literal("function_call"),
      id: z.string(),
      call_id: z.string(),
      name: z.string(),
      arguments: z.string(),
      status: z.literal("completed")
    })
  ])
});
var responseFunctionCallArgumentsDeltaSchema = z.object({
  type: z.literal("response.function_call_arguments.delta"),
  item_id: z.string(),
  output_index: z.number(),
  delta: z.string()
});
var responseOutputItemAddedSchema = z.object({
  type: z.literal("response.output_item.added"),
  output_index: z.number(),
  item: z.discriminatedUnion("type", [
    z.object({
      type: z.literal("message")
    }),
    z.object({
      type: z.literal("function_call"),
      id: z.string(),
      call_id: z.string(),
      name: z.string(),
      arguments: z.string()
    })
  ])
});
var responseAnnotationAddedSchema = z.object({
  type: z.literal("response.output_text.annotation.added"),
  annotation: z.object({
    type: z.literal("url_citation"),
    url: z.string(),
    title: z.string()
  })
});
var responseReasoningSummaryTextDeltaSchema = z.object({
  type: z.literal("response.reasoning_summary_text.delta"),
  item_id: z.string(),
  output_index: z.number(),
  summary_index: z.number(),
  delta: z.string()
});
var errorChunkSchema = z.object({
  type: z.literal("error"),
  code: z.string(),
  message: z.string(),
  param: z.string().nullish(),
  sequence_number: z.number()
});
var openaiResponsesChunkSchema = z.union([
  textDeltaChunkSchema,
  responseFinishedChunkSchema,
  responseCreatedChunkSchema,
  responseOutputItemDoneSchema,
  responseFunctionCallArgumentsDeltaSchema,
  responseOutputItemAddedSchema,
  responseAnnotationAddedSchema,
  responseReasoningSummaryTextDeltaSchema,
  errorChunkSchema,
  z.object({ type: z.string() }).passthrough()
  // fallback for unknown chunks
]);
function isTextDeltaChunk(chunk) {
  return chunk.type === "response.output_text.delta";
}
function isResponseOutputItemDoneChunk(chunk) {
  return chunk.type === "response.output_item.done";
}
function isResponseFinishedChunk(chunk) {
  return chunk.type === "response.completed" || chunk.type === "response.incomplete";
}
function isResponseCreatedChunk(chunk) {
  return chunk.type === "response.created";
}
function isResponseFunctionCallArgumentsDeltaChunk(chunk) {
  return chunk.type === "response.function_call_arguments.delta";
}
function isResponseOutputItemAddedChunk(chunk) {
  return chunk.type === "response.output_item.added";
}
function isResponseAnnotationAddedChunk(chunk) {
  return chunk.type === "response.output_text.annotation.added";
}
function isResponseReasoningSummaryTextDeltaChunk(chunk) {
  return chunk.type === "response.reasoning_summary_text.delta";
}
function isErrorChunk(chunk) {
  return chunk.type === "error";
}
function getResponsesModelConfig(modelId) {
  if (modelId.startsWith("o") || modelId.startsWith("gpt-5")) {
    if (modelId.startsWith("o1-mini") || modelId.startsWith("o1-preview")) {
      return {
        isReasoningModel: true,
        systemMessageMode: "remove",
        requiredAutoTruncation: false
      };
    }
    return {
      isReasoningModel: true,
      systemMessageMode: "developer",
      requiredAutoTruncation: false
    };
  }
  return {
    isReasoningModel: false,
    systemMessageMode: "system",
    requiredAutoTruncation: false
  };
}
var openaiResponsesProviderOptionsSchema = z.object({
  metadata: z.any().nullish(),
  parallelToolCalls: z.boolean().nullish(),
  previousResponseId: z.string().nullish(),
  store: z.boolean().nullish(),
  user: z.string().nullish(),
  reasoningEffort: z.string().nullish(),
  strictSchemas: z.boolean().nullish(),
  instructions: z.string().nullish(),
  reasoningSummary: z.string().nullish()
});
var WebSearchPreviewParameters = z.object({});
function webSearchPreviewTool({
  searchContextSize,
  userLocation
} = {}) {
  return {
    type: "provider-defined",
    id: "openai.web_search_preview",
    args: {
      searchContextSize,
      userLocation
    },
    parameters: WebSearchPreviewParameters
  };
}
var openaiTools = {
  webSearchPreview: webSearchPreviewTool
};
var OpenAIProviderOptionsSchema = z.object({
  instructions: z.string().nullish(),
  speed: z.number().min(0.25).max(4).default(1).nullish()
});
var OpenAISpeechModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v1";
  }
  get provider() {
    return this.config.provider;
  }
  getArgs({
    text,
    voice = "alloy",
    outputFormat = "mp3",
    speed,
    instructions,
    providerOptions
  }) {
    const warnings = [];
    const openAIOptions = parseProviderOptions({
      provider: "openai",
      providerOptions,
      schema: OpenAIProviderOptionsSchema
    });
    const requestBody = {
      model: this.modelId,
      input: text,
      voice,
      response_format: "mp3",
      speed,
      instructions
    };
    if (outputFormat) {
      if (["mp3", "opus", "aac", "flac", "wav", "pcm"].includes(outputFormat)) {
        requestBody.response_format = outputFormat;
      } else {
        warnings.push({
          type: "unsupported-setting",
          setting: "outputFormat",
          details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`
        });
      }
    }
    if (openAIOptions) {
      const speechModelOptions = {};
      for (const key in speechModelOptions) {
        const value = speechModelOptions[key];
        if (value !== void 0) {
          requestBody[key] = value;
        }
      }
    }
    return {
      requestBody,
      warnings
    };
  }
  async doGenerate(options) {
    var _a, _b, _c;
    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
    const { requestBody, warnings } = this.getArgs(options);
    const {
      value: audio,
      responseHeaders,
      rawValue: rawResponse
    } = await postJsonToApi$1({
      url: this.config.url({
        path: "/audio/speech",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body: requestBody,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createBinaryResponseHandler(),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    return {
      audio,
      warnings,
      request: {
        body: JSON.stringify(requestBody)
      },
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders,
        body: rawResponse
      }
    };
  }
};
function createOpenAI(options = {}) {
  var _a, _b, _c;
  const baseURL = (_a = withoutTrailingSlash$1(options.baseURL)) != null ? _a : "https://api.openai.com/v1";
  const compatibility = (_b = options.compatibility) != null ? _b : "compatible";
  const providerName = (_c = options.name) != null ? _c : "openai";
  const getHeaders = () => ({
    Authorization: `Bearer ${loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "OPENAI_API_KEY",
      description: "OpenAI"
    })}`,
    "OpenAI-Organization": options.organization,
    "OpenAI-Project": options.project,
    ...options.headers
  });
  const createChatModel = (modelId, settings = {}) => new OpenAIChatLanguageModel(modelId, settings, {
    provider: `${providerName}.chat`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    compatibility,
    fetch: options.fetch
  });
  const createCompletionModel = (modelId, settings = {}) => new OpenAICompletionLanguageModel(modelId, settings, {
    provider: `${providerName}.completion`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    compatibility,
    fetch: options.fetch
  });
  const createEmbeddingModel = (modelId, settings = {}) => new OpenAIEmbeddingModel(modelId, settings, {
    provider: `${providerName}.embedding`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createImageModel = (modelId, settings = {}) => new OpenAIImageModel(modelId, settings, {
    provider: `${providerName}.image`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createTranscriptionModel = (modelId) => new OpenAITranscriptionModel(modelId, {
    provider: `${providerName}.transcription`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createSpeechModel = (modelId) => new OpenAISpeechModel(modelId, {
    provider: `${providerName}.speech`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createLanguageModel = (modelId, settings) => {
    if (new.target) {
      throw new Error(
        "The OpenAI model function cannot be called with the new keyword."
      );
    }
    if (modelId === "gpt-3.5-turbo-instruct") {
      return createCompletionModel(
        modelId,
        settings
      );
    }
    return createChatModel(modelId, settings);
  };
  const createResponsesModel = (modelId) => {
    return new OpenAIResponsesLanguageModel(modelId, {
      provider: `${providerName}.responses`,
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch
    });
  };
  const provider = function(modelId, settings) {
    return createLanguageModel(modelId, settings);
  };
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.completion = createCompletionModel;
  provider.responses = createResponsesModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.transcription = createTranscriptionModel;
  provider.transcriptionModel = createTranscriptionModel;
  provider.speech = createSpeechModel;
  provider.speechModel = createSpeechModel;
  provider.tools = openaiTools;
  return provider;
}
var openai = createOpenAI({
  compatibility: "strict"
  // strict for OpenAI API
});

// ../agent-builder/dist/chunk-RQJR2QYC.js
var __require2$3 = /* @__PURE__ */ ((x) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof __require !== "undefined" ? __require : a)[b]
}) : x)(function(x) {
  if (typeof __require !== "undefined") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __create$3 = Object.create;
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$3 = Object.getOwnPropertyNames;
var __getProtoOf$3 = Object.getPrototypeOf;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __require22 = /* @__PURE__ */ ((x) => typeof __require2$3 !== "undefined" ? __require2$3 : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof __require2$3 !== "undefined" ? __require2$3 : a)[b]
}) : x)(function(x) {
  if (typeof __require2$3 !== "undefined") return __require2$3.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS$2 = (cb, mod) => function __require222() {
  return mod || (0, cb[__getOwnPropNames$3(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$3 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames$3(from))
      if (!__hasOwnProp$3.call(to, key) && key !== except)
        __defProp$3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc$3(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM$2 = (mod, isNodeMode, target) => (target = mod != null ? __create$3(__getProtoOf$3(mod)) : {}, __copyProps$3(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp$3(target, "default", { value: mod, enumerable: true }) ,
  mod
));
var require_token_error$2 = __commonJS$2({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/token-error.js"(exports$1, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var token_error_exports = {};
    __export(token_error_exports, {
      VercelOidcTokenError: () => VercelOidcTokenError
    });
    module.exports = __toCommonJS(token_error_exports);
    var VercelOidcTokenError = class extends Error {
      constructor(message, cause) {
        super(message);
        this.name = "VercelOidcTokenError";
        this.cause = cause;
      }
      toString() {
        if (this.cause) {
          return `${this.name}: ${this.message}: ${this.cause}`;
        }
        return `${this.name}: ${this.message}`;
      }
    };
  }
});

// src/server/handlers/workflows.ts
var workflows_exports = {};
__export(workflows_exports, {
  CANCEL_WORKFLOW_RUN_ROUTE: () => CANCEL_WORKFLOW_RUN_ROUTE,
  CREATE_WORKFLOW_RUN_ROUTE: () => CREATE_WORKFLOW_RUN_ROUTE,
  DELETE_WORKFLOW_RUN_BY_ID_ROUTE: () => DELETE_WORKFLOW_RUN_BY_ID_ROUTE,
  GET_WORKFLOW_BY_ID_ROUTE: () => GET_WORKFLOW_BY_ID_ROUTE,
  GET_WORKFLOW_RUN_BY_ID_ROUTE: () => GET_WORKFLOW_RUN_BY_ID_ROUTE,
  LIST_WORKFLOWS_ROUTE: () => LIST_WORKFLOWS_ROUTE,
  LIST_WORKFLOW_RUNS_ROUTE: () => LIST_WORKFLOW_RUNS_ROUTE,
  OBSERVE_STREAM_LEGACY_WORKFLOW_ROUTE: () => OBSERVE_STREAM_LEGACY_WORKFLOW_ROUTE,
  OBSERVE_STREAM_WORKFLOW_ROUTE: () => OBSERVE_STREAM_WORKFLOW_ROUTE,
  RESTART_ALL_ACTIVE_WORKFLOW_RUNS_ASYNC_ROUTE: () => RESTART_ALL_ACTIVE_WORKFLOW_RUNS_ASYNC_ROUTE,
  RESTART_ALL_ACTIVE_WORKFLOW_RUNS_ROUTE: () => RESTART_ALL_ACTIVE_WORKFLOW_RUNS_ROUTE,
  RESTART_ASYNC_WORKFLOW_ROUTE: () => RESTART_ASYNC_WORKFLOW_ROUTE,
  RESTART_WORKFLOW_ROUTE: () => RESTART_WORKFLOW_ROUTE,
  RESUME_ASYNC_WORKFLOW_ROUTE: () => RESUME_ASYNC_WORKFLOW_ROUTE,
  RESUME_STREAM_WORKFLOW_ROUTE: () => RESUME_STREAM_WORKFLOW_ROUTE,
  RESUME_WORKFLOW_ROUTE: () => RESUME_WORKFLOW_ROUTE,
  START_ASYNC_WORKFLOW_ROUTE: () => START_ASYNC_WORKFLOW_ROUTE,
  START_WORKFLOW_RUN_ROUTE: () => START_WORKFLOW_RUN_ROUTE,
  STREAM_LEGACY_WORKFLOW_ROUTE: () => STREAM_LEGACY_WORKFLOW_ROUTE,
  STREAM_WORKFLOW_ROUTE: () => STREAM_WORKFLOW_ROUTE,
  TIME_TRAVEL_ASYNC_WORKFLOW_ROUTE: () => TIME_TRAVEL_ASYNC_WORKFLOW_ROUTE,
  TIME_TRAVEL_STREAM_WORKFLOW_ROUTE: () => TIME_TRAVEL_STREAM_WORKFLOW_ROUTE,
  TIME_TRAVEL_WORKFLOW_ROUTE: () => TIME_TRAVEL_WORKFLOW_ROUTE
});
var workflowRunStatusSchema = z$1.enum([
  "running",
  "waiting",
  "suspended",
  "success",
  "failed",
  "canceled",
  "pending",
  "bailed",
  "tripwire",
  "paused"
]);
var workflowIdPathParams = z$1.object({
  workflowId: z$1.string().describe("Unique identifier for the workflow")
});
var workflowRunPathParams = workflowIdPathParams.extend({
  runId: z$1.string().describe("Unique identifier for the workflow run")
});
var serializedStepSchema = z$1.object({
  id: z$1.string(),
  description: z$1.string().optional(),
  stateSchema: z$1.string().optional(),
  inputSchema: z$1.string().optional(),
  outputSchema: z$1.string().optional(),
  resumeSchema: z$1.string().optional(),
  suspendSchema: z$1.string().optional(),
  component: z$1.string().optional(),
  isWorkflow: z$1.boolean().optional(),
  metadata: z$1.record(z$1.string(), z$1.unknown()).optional()
});
var serializedStepFlowEntrySchema = z$1.object({
  type: z$1.enum(["step", "sleep", "sleepUntil", "waitForEvent", "parallel", "conditional", "loop", "foreach"])
});
var workflowInfoSchema = z$1.object({
  steps: z$1.record(z$1.string(), serializedStepSchema),
  allSteps: z$1.record(z$1.string(), serializedStepSchema),
  name: z$1.string().optional(),
  description: z$1.string().optional(),
  stepGraph: z$1.array(serializedStepFlowEntrySchema),
  inputSchema: z$1.string().optional(),
  outputSchema: z$1.string().optional(),
  stateSchema: z$1.string().optional(),
  options: z$1.object({}).optional(),
  isProcessorWorkflow: z$1.boolean().optional()
});
var listWorkflowsResponseSchema = z$1.record(z$1.string(), workflowInfoSchema);
var workflowRunSchema = z$1.object({
  workflowName: z$1.string(),
  runId: z$1.string(),
  snapshot: z$1.union([z$1.object({}), z$1.string()]),
  createdAt: z$1.date(),
  updatedAt: z$1.date(),
  resourceId: z$1.string().optional()
});
var workflowRunsResponseSchema = z$1.object({
  runs: z$1.array(workflowRunSchema),
  total: z$1.number()
});
var listWorkflowRunsQuerySchema = createCombinedPaginationSchema().extend({
  fromDate: z$1.coerce.date().optional(),
  toDate: z$1.coerce.date().optional(),
  resourceId: z$1.string().optional(),
  status: workflowRunStatusSchema.optional()
});
var workflowExecutionBodySchema = z$1.object({
  resourceId: z$1.string().optional(),
  inputData: z$1.unknown().optional(),
  initialState: z$1.unknown().optional(),
  requestContext: z$1.record(z$1.string(), z$1.unknown()).optional(),
  tracingOptions: tracingOptionsSchema.optional(),
  perStep: z$1.boolean().optional()
});
var streamLegacyWorkflowBodySchema = workflowExecutionBodySchema;
var streamWorkflowBodySchema = workflowExecutionBodySchema.extend({
  closeOnSuspend: z$1.boolean().optional()
});
var resumeBodySchema = z$1.object({
  step: z$1.union([z$1.string(), z$1.array(z$1.string())]).optional(),
  // Optional - workflow can auto-resume all suspended steps
  resumeData: z$1.unknown().optional(),
  requestContext: z$1.record(z$1.string(), z$1.unknown()).optional(),
  tracingOptions: tracingOptionsSchema.optional(),
  perStep: z$1.boolean().optional()
});
var restartBodySchema = z$1.object({
  requestContext: z$1.record(z$1.string(), z$1.unknown()).optional(),
  tracingOptions: tracingOptionsSchema.optional()
});
var timeTravelBodySchema = z$1.object({
  inputData: z$1.unknown().optional(),
  resumeData: z$1.unknown().optional(),
  initialState: z$1.unknown().optional(),
  step: z$1.union([z$1.string(), z$1.array(z$1.string())]),
  context: z$1.record(z$1.string(), z$1.any()).optional(),
  nestedStepsContext: z$1.record(z$1.string(), z$1.record(z$1.string(), z$1.any())).optional(),
  requestContext: z$1.record(z$1.string(), z$1.unknown()).optional(),
  tracingOptions: tracingOptionsSchema.optional(),
  perStep: z$1.boolean().optional()
});
var startAsyncWorkflowBodySchema = workflowExecutionBodySchema;
z$1.object({
  event: z$1.string(),
  data: z$1.unknown()
});
var VALID_WORKFLOW_RESULT_FIELDS = /* @__PURE__ */ new Set([
  "result",
  "error",
  "payload",
  "steps",
  "activeStepsPath",
  "serializedStepGraph"
]);
var WORKFLOW_RESULT_FIELDS_ERROR = "Invalid field name. Available fields: result, error, payload, steps, activeStepsPath, serializedStepGraph";
var createFieldsValidator = (description) => z$1.string().optional().refine(
  (value) => {
    if (!value) return true;
    const requestedFields = value.split(",").map((f) => f.trim());
    return requestedFields.every((field) => VALID_WORKFLOW_RESULT_FIELDS.has(field));
  },
  { message: WORKFLOW_RESULT_FIELDS_ERROR }
).describe(description);
var withNestedWorkflowsField = z$1.enum(["true", "false"]).optional().describe("Whether to include nested workflow data in steps. Defaults to true. Set to false for better performance.");
var workflowExecutionResultSchema = z$1.object({
  status: workflowRunStatusSchema.optional(),
  result: z$1.unknown().optional(),
  error: z$1.unknown().optional(),
  payload: z$1.unknown().optional(),
  initialState: z$1.unknown().optional(),
  steps: z$1.record(z$1.string(), z$1.any()).optional(),
  activeStepsPath: z$1.record(z$1.string(), z$1.array(z$1.number())).optional(),
  serializedStepGraph: z$1.array(serializedStepFlowEntrySchema).optional()
});
var workflowRunResultQuerySchema = z$1.object({
  fields: createFieldsValidator(
    "Comma-separated list of fields to return. Available fields: result, error, payload, steps, activeStepsPath, serializedStepGraph. Metadata fields (runId, workflowName, resourceId, createdAt, updatedAt) and status are always included."
  ),
  withNestedWorkflows: withNestedWorkflowsField
});
var workflowRunResultSchema = z$1.object({
  // Metadata - always present
  runId: z$1.string(),
  workflowName: z$1.string(),
  resourceId: z$1.string().optional(),
  createdAt: z$1.date(),
  updatedAt: z$1.date(),
  // Execution state
  status: workflowRunStatusSchema,
  initialState: z$1.record(z$1.string(), z$1.any()).optional(),
  result: z$1.unknown().optional(),
  error: z$1.unknown().optional(),
  payload: z$1.unknown().optional(),
  steps: z$1.record(z$1.string(), z$1.any()).optional(),
  // Optional detailed fields
  activeStepsPath: z$1.record(z$1.string(), z$1.array(z$1.number())).optional(),
  serializedStepGraph: z$1.array(serializedStepFlowEntrySchema).optional()
});
var workflowControlResponseSchema = messageResponseSchema;
var createWorkflowRunResponseSchema = z$1.object({
  runId: z$1.string()
});
var createWorkflowRunBodySchema = z$1.object({
  resourceId: z$1.string().optional(),
  disableScorers: z$1.boolean().optional()
});

// src/server/handlers/workflows.ts
async function listWorkflowsFromSystem({ mastra, workflowId }) {
  const logger = mastra.getLogger();
  if (!workflowId) {
    throw new HTTPException$2(400, { message: "Workflow ID is required" });
  }
  let workflow;
  workflow = WorkflowRegistry.getWorkflow(workflowId);
  if (!workflow) {
    try {
      workflow = mastra.getWorkflowById(workflowId);
    } catch (error) {
      logger.debug("Error getting workflow, searching agents for workflow", error);
    }
  }
  if (!workflow) {
    logger.debug("Workflow not found, searching agents for workflow", { workflowId });
    const agents = mastra.listAgents();
    if (Object.keys(agents || {}).length) {
      for (const [_, agent] of Object.entries(agents)) {
        try {
          const workflows = await agent.listWorkflows();
          if (workflows[workflowId]) {
            workflow = workflows[workflowId];
            break;
          }
        } catch (error) {
          logger.debug("Error getting workflow from agent", error);
        }
      }
    }
  }
  if (!workflow) {
    throw new HTTPException$2(404, { message: "Workflow not found" });
  }
  return { workflow };
}
var LIST_WORKFLOWS_ROUTE = createRoute({
  method: "GET",
  path: "/workflows",
  responseType: "json",
  queryParamSchema: z.object({
    partial: z.string().optional()
  }),
  responseSchema: listWorkflowsResponseSchema,
  summary: "List all workflows",
  description: "Returns a list of all available workflows in the system",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, partial }) => {
    try {
      const workflows = mastra.listWorkflows({ serialized: false });
      const isPartial = partial === "true";
      const _workflows = Object.entries(workflows).reduce((acc, [key, workflow]) => {
        acc[key] = getWorkflowInfo(workflow, isPartial);
        return acc;
      }, {});
      return _workflows;
    } catch (error) {
      return handleError$1(error, "Error getting workflows");
    }
  }
});
var GET_WORKFLOW_BY_ID_ROUTE = createRoute({
  method: "GET",
  path: "/workflows/:workflowId",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  responseSchema: workflowInfoSchema,
  summary: "Get workflow by ID",
  description: "Returns details for a specific workflow",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId }) => {
    try {
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      return getWorkflowInfo(workflow);
    } catch (error) {
      return handleError$1(error, "Error getting workflow");
    }
  }
});
var LIST_WORKFLOW_RUNS_ROUTE = createRoute({
  method: "GET",
  path: "/workflows/:workflowId/runs",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: listWorkflowRunsQuerySchema,
  responseSchema: workflowRunsResponseSchema,
  summary: "List workflow runs",
  description: "Returns a paginated list of execution runs for the specified workflow",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({
    mastra,
    workflowId,
    fromDate,
    toDate,
    page,
    perPage,
    limit,
    offset,
    resourceId,
    status,
    requestContext
  }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      let finalPage = page;
      let finalPerPage = perPage;
      if (finalPerPage === void 0 && limit !== void 0) {
        finalPerPage = limit;
      }
      if (finalPage === void 0 && offset !== void 0 && finalPerPage !== void 0 && finalPerPage > 0) {
        finalPage = Math.floor(offset / finalPerPage);
      }
      if (finalPerPage !== void 0 && (typeof finalPerPage !== "number" || !Number.isInteger(finalPerPage) || finalPerPage <= 0)) {
        throw new HTTPException$2(400, { message: "perPage must be a positive integer" });
      }
      if (finalPage !== void 0 && (!Number.isInteger(finalPage) || finalPage < 0)) {
        throw new HTTPException$2(400, { message: "page must be a non-negative integer" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const workflowRuns = await workflow.listWorkflowRuns({
        fromDate: fromDate ? typeof fromDate === "string" ? new Date(fromDate) : fromDate : void 0,
        toDate: toDate ? typeof toDate === "string" ? new Date(toDate) : toDate : void 0,
        perPage: finalPerPage,
        page: finalPage,
        resourceId: effectiveResourceId,
        status
      }) || {
        runs: [],
        total: 0
      };
      return workflowRuns;
    } catch (error) {
      return handleError$1(error, "Error getting workflow runs");
    }
  }
});
var GET_WORKFLOW_RUN_BY_ID_ROUTE = createRoute({
  method: "GET",
  path: "/workflows/:workflowId/runs/:runId",
  responseType: "json",
  pathParamSchema: workflowRunPathParams,
  queryParamSchema: workflowRunResultQuerySchema,
  responseSchema: workflowRunResultSchema,
  summary: "Get workflow run by ID",
  description: "Returns a workflow run with metadata and processed execution state. Use the fields query parameter to reduce payload size by requesting only specific fields (e.g., ?fields=status,result,metadata)",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, fields, withNestedWorkflows, requestContext }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "Run ID is required" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const fieldList = fields ? fields.split(",").map((f) => f.trim()) : void 0;
      const run = await workflow.getWorkflowRunById(runId, {
        withNestedWorkflows: withNestedWorkflows !== "false",
        // Default to true unless explicitly 'false'
        fields: fieldList
      });
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      return run;
    } catch (error) {
      return handleError$1(error, "Error getting workflow run");
    }
  }
});
var DELETE_WORKFLOW_RUN_BY_ID_ROUTE = createRoute({
  method: "DELETE",
  path: "/workflows/:workflowId/runs/:runId",
  responseType: "json",
  pathParamSchema: workflowRunPathParams,
  responseSchema: workflowControlResponseSchema,
  summary: "Delete workflow run by ID",
  description: "Deletes a specific workflow run by ID",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "Run ID is required" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.getWorkflowRunById(runId);
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      await workflow.deleteWorkflowRunById(runId);
      return { message: "Workflow run deleted" };
    } catch (error) {
      return handleError$1(error, "Error deleting workflow run");
    }
  }
});
var CREATE_WORKFLOW_RUN_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/create-run",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: optionalRunIdSchema,
  bodySchema: createWorkflowRunBodySchema,
  responseSchema: createWorkflowRunResponseSchema,
  summary: "Create workflow run",
  description: "Creates a new workflow execution instance with an optional custom run ID",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, resourceId, disableScorers, requestContext }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.createRun({ runId, resourceId: effectiveResourceId, disableScorers });
      return { runId: run.runId };
    } catch (error) {
      return handleError$1(error, "Error creating workflow run");
    }
  }
});
var STREAM_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/stream",
  responseType: "stream",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: streamWorkflowBodySchema,
  summary: "Stream workflow execution",
  description: "Executes a workflow and streams the results in real-time",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, resourceId, requestContext, ...params }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to stream workflow" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const serverCache = mastra.getServerCache();
      const run = await workflow.createRun({ runId, resourceId: effectiveResourceId });
      const result = run.stream({ ...params, requestContext });
      return result.fullStream.pipeThrough(
        new TransformStream$1({
          transform(chunk, controller) {
            if (serverCache) {
              const cacheKey = runId;
              serverCache.listPush(cacheKey, chunk).catch(() => {
              });
            }
            controller.enqueue(chunk);
          }
        })
      );
    } catch (error) {
      return handleError$1(error, "Error streaming workflow");
    }
  }
});
var RESUME_STREAM_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/resume-stream",
  responseType: "stream",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: resumeBodySchema,
  responseSchema: streamResponseSchema,
  summary: "Resume workflow stream",
  description: "Resumes a suspended workflow execution and continues streaming results",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext, ...params }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to resume workflow" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.getWorkflowRunById(runId);
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      const _run = await workflow.createRun({ runId, resourceId: run.resourceId });
      const serverCache = mastra.getServerCache();
      const stream = _run.resumeStream({ ...params, requestContext }).fullStream.pipeThrough(
        new TransformStream$1({
          transform(chunk, controller) {
            if (serverCache) {
              const cacheKey = runId;
              serverCache.listPush(cacheKey, chunk).catch(() => {
              });
            }
            controller.enqueue(chunk);
          }
        })
      );
      return stream;
    } catch (error) {
      return handleError$1(error, "Error resuming workflow");
    }
  }
});
var START_ASYNC_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/start-async",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: optionalRunIdSchema,
  bodySchema: startAsyncWorkflowBodySchema,
  responseSchema: workflowExecutionResultSchema,
  summary: "Start workflow asynchronously",
  description: "Starts a workflow execution asynchronously without streaming results",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, resourceId, requestContext, ...params }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const _run = await workflow.createRun({ runId, resourceId: effectiveResourceId });
      const result = await _run.start({ ...params, requestContext });
      return result;
    } catch (error) {
      return handleError$1(error, "Error starting async workflow");
    }
  }
});
var START_WORKFLOW_RUN_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/start",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: startAsyncWorkflowBodySchema,
  responseSchema: workflowControlResponseSchema,
  summary: "Start specific workflow run",
  description: "Starts execution of a specific workflow run by ID",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext, ...params }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to start run" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.getWorkflowRunById(runId);
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      const _run = await workflow.createRun({ runId, resourceId: run.resourceId });
      void _run.start({
        ...params,
        requestContext
      });
      return { message: "Workflow run started" };
    } catch (e) {
      return handleError$1(e, "Error starting workflow run");
    }
  }
});
var OBSERVE_STREAM_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/observe",
  responseType: "stream",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  responseSchema: streamResponseSchema,
  summary: "Observe workflow stream",
  description: "Observes and streams updates from an already running workflow execution",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to observe workflow stream" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.getWorkflowRunById(runId);
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      const _run = await workflow.createRun({ runId, resourceId: run.resourceId });
      const serverCache = mastra.getServerCache();
      if (!serverCache) {
        throw new HTTPException$2(500, { message: "Server cache not found" });
      }
      const cachedRunChunks = await serverCache.listFromTo(runId, 0);
      const combinedStream = new ReadableStream$1({
        start(controller) {
          const emitCachedChunks = async () => {
            for (const chunk of cachedRunChunks) {
              controller.enqueue(chunk);
            }
          };
          const liveStream = _run.observeStream();
          const reader = liveStream.getReader();
          const pump = async () => {
            try {
              while (true) {
                const { done, value } = await reader.read();
                if (done) {
                  controller.close();
                  break;
                }
                controller.enqueue(value);
              }
            } catch (error) {
              controller.error(error);
            } finally {
              reader.releaseLock();
            }
          };
          void emitCachedChunks().then(() => {
            void pump();
          }).catch((error) => {
            controller.error(error);
          });
        }
      });
      return combinedStream;
    } catch (error) {
      return handleError$1(error, "Error observing workflow stream");
    }
  }
});
var RESUME_ASYNC_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/resume-async",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: resumeBodySchema,
  responseSchema: workflowExecutionResultSchema,
  summary: "Resume workflow asynchronously",
  description: "Resumes a suspended workflow execution asynchronously without streaming",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext, ...params }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to resume workflow" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.getWorkflowRunById(runId);
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      const _run = await workflow.createRun({ runId, resourceId: run.resourceId });
      const result = await _run.resume({ ...params, requestContext });
      return result;
    } catch (error) {
      return handleError$1(error, "Error resuming workflow step");
    }
  }
});
var RESUME_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/resume",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: resumeBodySchema,
  responseSchema: workflowControlResponseSchema,
  summary: "Resume workflow",
  description: "Resumes a suspended workflow execution from a specific step",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext, ...params }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to resume workflow" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.getWorkflowRunById(runId);
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      const _run = await workflow.createRun({ runId, resourceId: run.resourceId });
      void _run.resume({ ...params, requestContext });
      return { message: "Workflow run resumed" };
    } catch (error) {
      return handleError$1(error, "Error resuming workflow");
    }
  }
});
var RESTART_ASYNC_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/restart-async",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: restartBodySchema,
  responseSchema: workflowExecutionResultSchema,
  summary: "Restart workflow asynchronously",
  description: "Restarts an active workflow execution asynchronously",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext, ...params }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to restart workflow" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.getWorkflowRunById(runId);
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      const _run = await workflow.createRun({ runId, resourceId: run.resourceId });
      const result = await _run.restart({ ...params, requestContext });
      return result;
    } catch (error) {
      return handleError$1(error, "Error restarting workflow");
    }
  }
});
var RESTART_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/restart",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: restartBodySchema,
  responseSchema: workflowControlResponseSchema,
  summary: "Restart workflow",
  description: "Restarts an active workflow execution",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext, ...params }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to restart workflow" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.getWorkflowRunById(runId);
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      const _run = await workflow.createRun({ runId, resourceId: run.resourceId });
      void _run.restart({ ...params, requestContext });
      return { message: "Workflow run restarted" };
    } catch (error) {
      return handleError$1(error, "Error restarting workflow");
    }
  }
});
var RESTART_ALL_ACTIVE_WORKFLOW_RUNS_ASYNC_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/restart-all-active-workflow-runs-async",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  responseSchema: workflowControlResponseSchema,
  summary: "Restart all active workflow runs asynchronously",
  description: "Restarts all active workflow runs asynchronously",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId }) => {
    try {
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      await workflow.restartAllActiveWorkflowRuns();
      return { message: "All active workflow runs restarted" };
    } catch (error) {
      return handleError$1(error, "Error restarting workflow");
    }
  }
});
var RESTART_ALL_ACTIVE_WORKFLOW_RUNS_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/restart-all-active-workflow-runs",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  responseSchema: workflowControlResponseSchema,
  summary: "Restart all active workflow runs",
  description: "Restarts all active workflow runs",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId }) => {
    try {
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      void workflow.restartAllActiveWorkflowRuns();
      return { message: "All active workflow runs restarted" };
    } catch (error) {
      return handleError$1(error, "Error restarting workflow");
    }
  }
});
var TIME_TRAVEL_ASYNC_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/time-travel-async",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: timeTravelBodySchema,
  responseSchema: workflowExecutionResultSchema,
  summary: "Time travel workflow asynchronously",
  description: "Time travels a workflow run asynchronously without streaming",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext, ...params }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to time travel workflow" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.getWorkflowRunById(runId);
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      const _run = await workflow.createRun({ runId, resourceId: run.resourceId });
      const result = await _run.timeTravel({ ...params, requestContext });
      return result;
    } catch (error) {
      return handleError$1(error, "Error time traveling workflow");
    }
  }
});
var TIME_TRAVEL_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/time-travel",
  responseType: "json",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: timeTravelBodySchema,
  responseSchema: workflowControlResponseSchema,
  summary: "Time travel workflow",
  description: "Time travels a workflow run, starting from a specific step",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext, ...params }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to time travel workflow" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.getWorkflowRunById(runId);
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      const _run = await workflow.createRun({ runId, resourceId: run.resourceId });
      void _run.timeTravel({ ...params, requestContext });
      return { message: "Workflow run time travel started" };
    } catch (error) {
      return handleError$1(error, "Error time traveling workflow");
    }
  }
});
var TIME_TRAVEL_STREAM_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/time-travel-stream",
  responseType: "stream",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: timeTravelBodySchema,
  summary: "Time travel workflow stream",
  description: "Time travels a workflow run, starting from a specific step, and streams the results in real-time",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext, ...params }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to time travel workflow stream" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const existingRun = await workflow.getWorkflowRunById(runId);
      if (!existingRun) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(existingRun, effectiveResourceId);
      const serverCache = mastra.getServerCache();
      const run = await workflow.createRun({ runId, resourceId: existingRun.resourceId });
      const result = run.timeTravelStream({ ...params, requestContext });
      return result.fullStream.pipeThrough(
        new TransformStream$1({
          transform(chunk, controller) {
            if (serverCache) {
              const cacheKey = runId;
              serverCache.listPush(cacheKey, chunk).catch(() => {
              });
            }
            controller.enqueue(chunk);
          }
        })
      );
    } catch (error) {
      return handleError$1(error, "Error time traveling workflow stream");
    }
  }
});
var CANCEL_WORKFLOW_RUN_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/runs/:runId/cancel",
  responseType: "json",
  pathParamSchema: workflowRunPathParams,
  responseSchema: workflowControlResponseSchema,
  summary: "Cancel workflow run",
  description: "Cancels an in-progress workflow execution",
  tags: ["Workflows"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to cancel workflow run" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.getWorkflowRunById(runId);
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      const _run = await workflow.createRun({ runId, resourceId: run.resourceId });
      await _run.cancel();
      return { message: "Workflow run cancelled" };
    } catch (error) {
      return handleError$1(error, "Error canceling workflow run");
    }
  }
});
var STREAM_LEGACY_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/stream-legacy",
  responseType: "stream",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: streamWorkflowBodySchema,
  responseSchema: streamResponseSchema,
  summary: "[DEPRECATED] Stream workflow with legacy format",
  description: "Legacy endpoint for streaming workflow execution. Use /workflows/:workflowId/stream instead.",
  tags: ["Workflows", "Legacy"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, resourceId, requestContext, ...params }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to resume workflow" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const serverCache = mastra.getServerCache();
      const run = await workflow.createRun({ runId, resourceId: effectiveResourceId });
      const result = run.streamLegacy({
        ...params,
        requestContext,
        onChunk: async (chunk) => {
          if (serverCache) {
            const cacheKey = runId;
            await serverCache.listPush(cacheKey, chunk);
          }
        }
      });
      return result.stream;
    } catch (error) {
      return handleError$1(error, "Error executing workflow");
    }
  }
});
var OBSERVE_STREAM_LEGACY_WORKFLOW_ROUTE = createRoute({
  method: "POST",
  path: "/workflows/:workflowId/observe-stream-legacy",
  responseType: "stream",
  pathParamSchema: workflowIdPathParams,
  queryParamSchema: runIdSchema,
  responseSchema: streamResponseSchema,
  summary: "[DEPRECATED] Observe workflow stream with legacy format",
  description: "Legacy endpoint for observing workflow stream. Use /workflows/:workflowId/observe instead.",
  tags: ["Workflows", "Legacy"],
  requiresAuth: true,
  handler: async ({ mastra, workflowId, runId, requestContext }) => {
    try {
      const effectiveResourceId = getEffectiveResourceId(requestContext, void 0);
      if (!workflowId) {
        throw new HTTPException$2(400, { message: "Workflow ID is required" });
      }
      if (!runId) {
        throw new HTTPException$2(400, { message: "runId required to observe workflow stream" });
      }
      const { workflow } = await listWorkflowsFromSystem({ mastra, workflowId });
      if (!workflow) {
        throw new HTTPException$2(404, { message: "Workflow not found" });
      }
      const run = await workflow.getWorkflowRunById(runId);
      if (!run) {
        throw new HTTPException$2(404, { message: "Workflow run not found" });
      }
      await validateRunOwnership(run, effectiveResourceId);
      const _run = await workflow.createRun({ runId, resourceId: run.resourceId });
      const serverCache = mastra.getServerCache();
      if (!serverCache) {
        throw new HTTPException$2(500, { message: "Server cache not found" });
      }
      const transformStream = new TransformStream$1();
      const writer = transformStream.writable.getWriter();
      const cachedRunChunks = await serverCache.listFromTo(runId, 0);
      for (const chunk of cachedRunChunks) {
        await writer.write(chunk);
      }
      writer.releaseLock();
      const result = _run.observeStreamLegacy();
      return result.stream?.pipeThrough(transformStream);
    } catch (error) {
      return handleError$1(error, "Error observing workflow stream");
    }
  }
});

// ../memory/dist/chunk-DGUM43GV.js
var __require2$2 = /* @__PURE__ */ ((x) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof __require !== "undefined" ? __require : a)[b]
}) : x)(function(x) {
  if (typeof __require !== "undefined") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// ../memory/dist/chunk-BSDWQEU3.js
var __create$2 = Object.create;
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$2 = Object.getOwnPropertyNames;
var __getProtoOf$2 = Object.getPrototypeOf;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __require2$1 = /* @__PURE__ */ ((x) => typeof __require2$2 !== "undefined" ? __require2$2 : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof __require2$2 !== "undefined" ? __require2$2 : a)[b]
}) : x)(function(x) {
  if (typeof __require2$2 !== "undefined") return __require2$2.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS$1 = (cb, mod) => function __require22() {
  return mod || (0, cb[__getOwnPropNames$2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames$2(from))
      if (!__hasOwnProp$2.call(to, key) && key !== except)
        __defProp$2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc$2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM$1 = (mod, isNodeMode, target) => (target = mod != null ? __create$2(__getProtoOf$2(mod)) : {}, __copyProps$2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp$2(target, "default", { value: mod, enumerable: true }) ,
  mod
));
var require_token_error$1 = __commonJS$1({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/token-error.js"(exports$1, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var token_error_exports = {};
    __export(token_error_exports, {
      VercelOidcTokenError: () => VercelOidcTokenError
    });
    module.exports = __toCommonJS(token_error_exports);
    var VercelOidcTokenError = class extends Error {
      constructor(message, cause) {
        super(message);
        this.name = "VercelOidcTokenError";
        this.cause = cause;
      }
      toString() {
        if (this.cause) {
          return `${this.name}: ${this.message}: ${this.cause}`;
        }
        return `${this.name}: ${this.message}`;
      }
    };
  }
});

// ../memory/dist/chunk-RC6RZVYE.js
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __require2 = /* @__PURE__ */ ((x) => typeof __require2$2 !== "undefined" ? __require2$2 : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof __require2$2 !== "undefined" ? __require2$2 : a)[b]
}) : x)(function(x) {
  if (typeof __require2$2 !== "undefined") return __require2$2.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require22() {
  return mod || (0, cb[__getOwnPropNames$1(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$1 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames$1(from))
      if (!__hasOwnProp$1.call(to, key) && key !== except)
        __defProp$1(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$1(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp$1(target, "default", { value: mod, enumerable: true }) ,
  mod
));
var require_token_error = __commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.1.0/node_modules/@vercel/oidc/dist/token-error.js"(exports$1, module) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var token_error_exports = {};
    __export(token_error_exports, {
      VercelOidcTokenError: () => VercelOidcTokenError
    });
    module.exports = __toCommonJS(token_error_exports);
    var VercelOidcTokenError = class extends Error {
      constructor(message, cause) {
        super(message);
        this.name = "VercelOidcTokenError";
        this.cause = cause;
      }
      toString() {
        if (this.cause) {
          return `${this.name}: ${this.message}: ${this.cause}`;
        }
        return `${this.name}: ${this.message}`;
      }
    };
  }
});

// ../../node_modules/.pnpm/ignore@7.0.5/node_modules/ignore/index.js
var require_ignore = __commonJS$3({
  "../../node_modules/.pnpm/ignore@7.0.5/node_modules/ignore/index.js"(exports$1, module) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var UNDEFINED = void 0;
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.{0,2}\/|^\.{1,2}$/;
    var REGEX_TEST_TRAILING_SLASH = /\/$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = /* @__PURE__ */ Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define = (object5, key, value) => {
      Object.defineProperty(object5, key, { value });
      return value;
    };
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        // Remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        () => EMPTY
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a ) -> (a)
        // (a \ ) -> (a  )
        /((?:\\\\)*?)(\\?\s+)$/,
        (_, m1, m2) => m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY)
      ],
      // Replace (\ ) with ' '
      // (\ ) -> ' '
      // (\\ ) -> '\\ '
      // (\\\ ) -> '\\ '
      [
        /(\\+?)\s/g,
        (_, m1) => {
          const { length } = m1;
          return m1.slice(0, length - length % 2) + SPACE;
        }
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ]
    ];
    var REGEX_REPLACE_TRAILING_WILDCARD = /(^|\\\/)?\\\*$/;
    var MODE_IGNORE = "regex";
    var MODE_CHECK_IGNORE = "checkRegex";
    var UNDERSCORE = "_";
    var TRAILING_WILD_CARD_REPLACERS = {
      [MODE_IGNORE](_, p1) {
        const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      },
      [MODE_CHECK_IGNORE](_, p1) {
        const prefix = p1 ? `${p1}[^/]*` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      }
    };
    var makeRegexPrefix = (pattern) => REPLACERS.reduce(
      (prev, [matcher, replacer]) => prev.replace(matcher, replacer.bind(pattern)),
      pattern
    );
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF).filter(Boolean);
    var IgnoreRule = class {
      constructor(pattern, mark, body, ignoreCase, negative, prefix) {
        this.pattern = pattern;
        this.mark = mark;
        this.negative = negative;
        define(this, "body", body);
        define(this, "ignoreCase", ignoreCase);
        define(this, "regexPrefix", prefix);
      }
      get regex() {
        const key = UNDERSCORE + MODE_IGNORE;
        if (this[key]) {
          return this[key];
        }
        return this._make(MODE_IGNORE, key);
      }
      get checkRegex() {
        const key = UNDERSCORE + MODE_CHECK_IGNORE;
        if (this[key]) {
          return this[key];
        }
        return this._make(MODE_CHECK_IGNORE, key);
      }
      _make(mode, key) {
        const str = this.regexPrefix.replace(
          REGEX_REPLACE_TRAILING_WILDCARD,
          // It does not need to bind pattern
          TRAILING_WILD_CARD_REPLACERS[mode]
        );
        const regex = this.ignoreCase ? new RegExp(str, "i") : new RegExp(str);
        return define(this, key, regex);
      }
    };
    var createRule = ({
      pattern,
      mark
    }, ignoreCase) => {
      let negative = false;
      let body = pattern;
      if (body.indexOf("!") === 0) {
        negative = true;
        body = body.substr(1);
      }
      body = body.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regexPrefix = makeRegexPrefix(body);
      return new IgnoreRule(
        pattern,
        mark,
        body,
        ignoreCase,
        negative,
        regexPrefix
      );
    };
    var RuleManager = class {
      constructor(ignoreCase) {
        this._ignoreCase = ignoreCase;
        this._rules = [];
      }
      _add(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules._rules);
          this._added = true;
          return;
        }
        if (isString(pattern)) {
          pattern = {
            pattern
          };
        }
        if (checkPattern(pattern.pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._add, this);
        return this._added;
      }
      // Test one single path without recursively checking parent directories
      //
      // - checkUnignored `boolean` whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // - check `string` either `MODE_IGNORE` or `MODE_CHECK_IGNORE`
      // @returns {TestResult} true if a file is ignored
      test(path, checkUnignored, mode) {
        let ignored = false;
        let unignored = false;
        let matchedRule;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule[mode].test(path);
          if (!matched) {
            return;
          }
          ignored = !negative;
          unignored = negative;
          matchedRule = negative ? UNDEFINED : rule;
        });
        const ret = {
          ignored,
          unignored
        };
        if (matchedRule) {
          ret.rule = matchedRule;
        }
        return ret;
      }
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path, originalPath, doThrow) => {
      if (!isString(path)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define(this, KEY_IGNORE, true);
        this._rules = new RuleManager(ignoreCase);
        this._strictPathCheck = !allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      add(pattern) {
        if (this._rules.add(pattern)) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(
          path,
          originalPath,
          this._strictPathCheck ? throwError : RETURN_FALSE
        );
        return this._t(path, cache, checkUnignored, slices);
      }
      checkIgnore(path) {
        if (!REGEX_TEST_TRAILING_SLASH.test(path)) {
          return this.test(path);
        }
        const slices = path.split(SLASH).filter(Boolean);
        slices.pop();
        if (slices.length) {
          const parent = this._t(
            slices.join(SLASH) + SLASH,
            this._testCache,
            true,
            slices
          );
          if (parent.ignored) {
            return parent;
          }
        }
        return this._rules.test(path, false, MODE_CHECK_IGNORE);
      }
      _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
          return cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH).filter(Boolean);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path] = this._rules.test(path, checkUnignored, MODE_IGNORE);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path] = parent.ignored ? parent : this._rules.test(path, checkUnignored, MODE_IGNORE);
      }
      ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path) => !this.ignores(path);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path) {
        return this._test(path, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
    var setupWindows = () => {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGEX_TEST_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path) => REGEX_TEST_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
    };
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && process.platform === "win32"
    ) {
      setupWindows();
    }
    module.exports = factory;
    factory.default = factory;
    module.exports.isPathValid = isPathValid;
    define(module.exports, /* @__PURE__ */ Symbol.for("setupWindows"), setupWindows);
  }
});

// src/server/handlers/agent-builder.ts
var agent_builder_exports = {};
__export(agent_builder_exports, {
  CANCEL_AGENT_BUILDER_ACTION_RUN_ROUTE: () => CANCEL_AGENT_BUILDER_ACTION_RUN_ROUTE,
  CREATE_AGENT_BUILDER_ACTION_RUN_ROUTE: () => CREATE_AGENT_BUILDER_ACTION_RUN_ROUTE,
  GET_AGENT_BUILDER_ACTION_BY_ID_ROUTE: () => GET_AGENT_BUILDER_ACTION_BY_ID_ROUTE,
  GET_AGENT_BUILDER_ACTION_RUN_BY_ID_ROUTE: () => GET_AGENT_BUILDER_ACTION_RUN_BY_ID_ROUTE,
  LIST_AGENT_BUILDER_ACTIONS_ROUTE: () => LIST_AGENT_BUILDER_ACTIONS_ROUTE,
  LIST_AGENT_BUILDER_ACTION_RUNS_ROUTE: () => LIST_AGENT_BUILDER_ACTION_RUNS_ROUTE,
  OBSERVE_STREAM_AGENT_BUILDER_ACTION_ROUTE: () => OBSERVE_STREAM_AGENT_BUILDER_ACTION_ROUTE,
  OBSERVE_STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE: () => OBSERVE_STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE,
  RESUME_AGENT_BUILDER_ACTION_ROUTE: () => RESUME_AGENT_BUILDER_ACTION_ROUTE,
  RESUME_ASYNC_AGENT_BUILDER_ACTION_ROUTE: () => RESUME_ASYNC_AGENT_BUILDER_ACTION_ROUTE,
  RESUME_STREAM_AGENT_BUILDER_ACTION_ROUTE: () => RESUME_STREAM_AGENT_BUILDER_ACTION_ROUTE,
  START_AGENT_BUILDER_ACTION_RUN_ROUTE: () => START_AGENT_BUILDER_ACTION_RUN_ROUTE,
  START_ASYNC_AGENT_BUILDER_ACTION_ROUTE: () => START_ASYNC_AGENT_BUILDER_ACTION_ROUTE,
  STREAM_AGENT_BUILDER_ACTION_ROUTE: () => STREAM_AGENT_BUILDER_ACTION_ROUTE,
  STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE: () => STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name4, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name4],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/getRelativePath.js
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var emojiRegex = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex === void 0) {
      emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
}
function addPattern(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  return pattern;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef(refs);
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object5 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object5[object5[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object5[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef(refs)
      },
      innerSchema
    ]
  } : parseAnyDef(refs);
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef(refs) {
  return {
    not: parseAnyDef(refs)
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef(refs) {
  return parseAnyDef(refs);
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema5 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema5) {
    addMeta(def, refs, jsonSchema5);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema5, def, refs);
    newItem.jsonSchema = jsonSchema5;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema5;
  return jsonSchema5;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef(refs) : void 0;
    }
  }
};
var addMeta = (def, refs, jsonSchema5) => {
  if (def.description) {
    jsonSchema5.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema5.markdownDescription = def.description;
    }
  }
  return jsonSchema5;
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name5, schema2]) => ({
    ...acc,
    [name5]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name5]
    }, true) ?? parseAnyDef(refs)
  }), {}) : void 0;
  const name4 = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main = parseDef(schema._def, name4 === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name4]
  }, false) ?? parseAnyDef(refs);
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name4 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name4
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name4]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.25.1_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/index.js
var esm_default = zodToJsonSchema;

// ../schema-compat/dist/chunk-BXZCXMXO.js
var PATCHED = /* @__PURE__ */ Symbol("__mastra_patched__");
function patchRecordSchemas(schema) {
  if (!schema || typeof schema !== "object") return schema;
  if (schema[PATCHED]) return schema;
  schema[PATCHED] = true;
  const def = schema._zod?.def;
  if (def?.type === "record" && def.keyType && !def.valueType) {
    def.valueType = def.keyType;
    def.keyType = z.string();
  }
  if (!def) return schema;
  if (def.type === "object" && def.shape) {
    const shape = typeof def.shape === "function" ? def.shape() : def.shape;
    for (const key of Object.keys(shape)) {
      patchRecordSchemas(shape[key]);
    }
  }
  if (def.type === "array" && def.element) {
    patchRecordSchemas(def.element);
  }
  if (def.type === "union" && def.options) {
    def.options.forEach(patchRecordSchemas);
  }
  if (def.type === "record") {
    if (def.keyType) patchRecordSchemas(def.keyType);
    if (def.valueType) patchRecordSchemas(def.valueType);
  }
  if (def.type === "intersection") {
    if (def.left) patchRecordSchemas(def.left);
    if (def.right) patchRecordSchemas(def.right);
  }
  if (def.type === "lazy") {
    if (def.getter && typeof def.getter === "function") {
      const originalGetter = def.getter;
      def.getter = function() {
        const innerSchema = originalGetter();
        if (innerSchema) {
          patchRecordSchemas(innerSchema);
        }
        return innerSchema;
      };
    }
  }
  if (def.innerType) {
    patchRecordSchemas(def.innerType);
  }
  return schema;
}
function fixAnyOfNullable(schema) {
  if (typeof schema !== "object" || schema === null) {
    return schema;
  }
  const result = { ...schema };
  if (result.anyOf && Array.isArray(result.anyOf) && result.anyOf.length === 2) {
    const nullSchema = result.anyOf.find((s) => typeof s === "object" && s !== null && s.type === "null");
    const otherSchema = result.anyOf.find((s) => typeof s === "object" && s !== null && s.type !== "null");
    if (nullSchema && otherSchema && typeof otherSchema === "object" && otherSchema.type) {
      const { anyOf, ...rest } = result;
      const fixedRest = fixAnyOfNullable(rest);
      const fixedOther = fixAnyOfNullable(otherSchema);
      return {
        ...fixedRest,
        ...fixedOther,
        type: Array.isArray(fixedOther.type) ? [...fixedOther.type, "null"] : [fixedOther.type, "null"]
      };
    }
  }
  if (result.properties && typeof result.properties === "object" && !Array.isArray(result.properties)) {
    result.properties = Object.fromEntries(
      Object.entries(result.properties).map(([key, value]) => {
        const propSchema = value;
        if (typeof propSchema === "object" && propSchema !== null && !Array.isArray(propSchema) && Object.keys(propSchema).length === 0) {
          return [key, { type: ["string", "number", "boolean", "null"] }];
        }
        return [key, fixAnyOfNullable(propSchema)];
      })
    );
  }
  if (result.items) {
    if (Array.isArray(result.items)) {
      result.items = result.items.map((item) => fixAnyOfNullable(item));
    } else {
      result.items = fixAnyOfNullable(result.items);
    }
  }
  if (result.anyOf && Array.isArray(result.anyOf)) {
    result.anyOf = result.anyOf.map((s) => fixAnyOfNullable(s));
  }
  if (result.oneOf && Array.isArray(result.oneOf)) {
    result.oneOf = result.oneOf.map((s) => fixAnyOfNullable(s));
  }
  if (result.allOf && Array.isArray(result.allOf)) {
    result.allOf = result.allOf.map((s) => fixAnyOfNullable(s));
  }
  return result;
}
function zodToJsonSchema2(zodSchema5, target = "jsonSchema7", strategy = "relative") {
  const fn = "toJSONSchema";
  if (fn in z) {
    patchRecordSchemas(zodSchema5);
    const jsonSchema5 = z[fn](zodSchema5, {
      unrepresentable: "any",
      override: (ctx) => {
        const def = ctx.zodSchema?._def || ctx.zodSchema?._zod?.def;
        if (def && (def.typeName === "ZodDate" || def.type === "date")) {
          ctx.jsonSchema.type = "string";
          ctx.jsonSchema.format = "date-time";
        }
      }
    });
    return fixAnyOfNullable(jsonSchema5);
  } else {
    return esm_default(zodSchema5, {
      $refStrategy: strategy,
      target
    });
  }
}
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P || (P = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve5, reject) => {
      const task = { resolve: resolve5, reject, weight, priority };
      const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
      if (i === -1 && weight <= this._value) {
        this._dispatchItem(task);
      } else {
        this._queue.splice(i + 1, 0, task);
      }
    });
  }
  runExclusive(callback_1) {
    return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
      const [value, release] = yield this.acquire(weight, priority);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise((resolve5) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        insertSorted(this._weightedWaiters[weight - 1], { resolve: resolve5, priority });
      });
    }
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatchQueue();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((entry) => entry.reject(this._cancelError));
    this._queue = [];
  }
  _dispatchQueue() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  }
  _dispatchItem(item) {
    const previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0) {
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach((waiter) => waiter.resolve());
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      const queuedPriority = this._queue[0].priority;
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
        (i === -1 ? waiters : waiters.splice(0, i)).forEach(((waiter) => waiter.resolve()));
      }
    }
  }
  _couldLockImmediately(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  }
};
function insertSorted(a, v) {
  const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
  a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
  for (let i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P || (P = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
      const [, releaser] = yield this._semaphore.acquire(1, priority);
      return releaser;
    });
  }
  runExclusive(callback, priority = 0) {
    return this._semaphore.runExclusive(() => callback(), 1, priority);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(priority = 0) {
    return this._semaphore.waitForUnlock(1, priority);
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// ../schema-compat/dist/chunk-5WRI5ZAA.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS5 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM5 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp(target, "default", { value: mod, enumerable: true }) ,
  mod
));
var require_code = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.regexpCode = exports$1.getEsmExportName = exports$1.getProperty = exports$1.safeStringify = exports$1.stringify = exports$1.strConcat = exports$1.addCodeArg = exports$1.str = exports$1._ = exports$1.nil = exports$1._Code = exports$1.Name = exports$1.IDENTIFIER = exports$1._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports$1._CodeOrName = _CodeOrName;
    exports$1.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports$1.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports$1.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a5;
        return (_a5 = this._str) !== null && _a5 !== void 0 ? _a5 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a5;
        return (_a5 = this._names) !== null && _a5 !== void 0 ? _a5 : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports$1._Code = _Code;
    exports$1.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports$1._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports$1.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports$1.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports$1.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports$1.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports$1.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports$1.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports$1.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports$1.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports$1.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports$1.regexpCode = regexpCode;
  }
});
var require_scope = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ValueScope = exports$1.ValueScopeName = exports$1.Scope = exports$1.varKinds = exports$1.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name4) {
        super(`CodeGen: "code" for ${name4} not defined`);
        this.value = name4.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports$1.UsedValueState = UsedValueState = {}));
    exports$1.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a5, _b10;
        if (((_b10 = (_a5 = this._parent) === null || _a5 === void 0 ? void 0 : _a5._prefixes) === null || _b10 === void 0 ? void 0 : _b10.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports$1.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports$1.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a5;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name4 = this.toName(nameOrPrefix);
        const { prefix } = name4;
        const valueKey = (_a5 = value.key) !== null && _a5 !== void 0 ? _a5 : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name4);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name4.setValue(value, { property: prefix, itemIndex });
        return name4;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name4) => {
          if (name4.scopePath === void 0)
            throw new Error(`CodeGen: name "${name4}" has no value`);
          return (0, code_1._)`${scopeName}${name4.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name4) => {
          if (name4.value === void 0)
            throw new Error(`CodeGen: name "${name4}" has no value`);
          return name4.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name4) => {
            if (nameSet.has(name4))
              return;
            nameSet.set(name4, UsedValueState.Started);
            let c = valueCode(name4);
            if (c) {
              const def = this.opts.es5 ? exports$1.varKinds.var : exports$1.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name4} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name4)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name4);
            }
            nameSet.set(name4, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports$1.ValueScope = ValueScope;
  }
});
var require_codegen = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.or = exports$1.and = exports$1.not = exports$1.CodeGen = exports$1.operators = exports$1.varKinds = exports$1.ValueScopeName = exports$1.ValueScope = exports$1.Scope = exports$1.Name = exports$1.regexpCode = exports$1.stringify = exports$1.getProperty = exports$1.nil = exports$1.strConcat = exports$1.str = exports$1._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports$1, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports$1, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports$1, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports$1, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports$1, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports$1, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports$1, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports$1.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name4, rhs) {
        super();
        this.varKind = varKind;
        this.name = name4;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e2 = this.else;
        if (e2) {
          const ns = e2.optimizeNodes();
          e2 = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e2) {
          if (cond === false)
            return e2 instanceof _If ? e2 : e2.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e2 instanceof _If ? [e2] : e2.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a5;
        this.else = (_a5 = this.else) === null || _a5 === void 0 ? void 0 : _a5.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name4, from, to) {
        super();
        this.varKind = varKind;
        this.name = name4;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name: name4, from, to } = this;
        return `for(${varKind} ${name4}=${from}; ${name4}<${to}; ${name4}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name4, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name4;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name4, args, async) {
        super();
        this.name = name4;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a5, _b10;
        super.optimizeNodes();
        (_a5 = this.catch) === null || _a5 === void 0 ? void 0 : _a5.optimizeNodes();
        (_b10 = this.finally) === null || _b10 === void 0 ? void 0 : _b10.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a5, _b10;
        super.optimizeNames(names, constants);
        (_a5 = this.catch) === null || _a5 === void 0 ? void 0 : _a5.optimizeNames(names, constants);
        (_b10 = this.finally) === null || _b10 === void 0 ? void 0 : _b10.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name4 = this._extScope.value(prefixOrName, value);
        const vs = this._values[name4.prefix] || (this._values[name4.prefix] = /* @__PURE__ */ new Set());
        vs.add(name4);
        return name4;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name4 = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name4.str] = rhs;
        this._leafNode(new Def(varKind, name4, rhs));
        return name4;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports$1.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name4 = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name4, from, to), () => forBody(name4));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name4 = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name4, (0, code_1._)`${arr}[${i}]`);
            forBody(name4);
          });
        }
        return this._for(new ForIter("of", varKind, name4, iterable), () => forBody(name4));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name4 = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name4, obj), () => forBody(name4));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name4, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name4, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports$1.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e2) {
        return e2 instanceof code_1._Code && e2._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports$1.not = not;
    var andCode = mappend(exports$1.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports$1.and = and;
    var orCode = mappend(exports$1.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports$1.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});
var require_util = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.checkStrictMode = exports$1.getErrorPath = exports$1.Type = exports$1.useFunc = exports$1.setEvaluated = exports$1.evaluatedPropsToName = exports$1.mergeEvaluated = exports$1.eachItem = exports$1.unescapeJsonPointer = exports$1.escapeJsonPointer = exports$1.escapeFragment = exports$1.unescapeFragment = exports$1.schemaRefOrVal = exports$1.schemaHasRulesButRef = exports$1.schemaHasRules = exports$1.checkUnknownRules = exports$1.alwaysValidSchema = exports$1.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports$1.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports$1.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports$1.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports$1.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports$1.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports$1.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports$1.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports$1.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports$1.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports$1.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports$1.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports$1.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports$1.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports$1.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports$1.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports$1.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports$1.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports$1.checkStrictMode = checkStrictMode;
  }
});
var require_names = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports$1.default = names;
  }
});
var require_errors = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.extendErrors = exports$1.resetErrorsCount = exports$1.reportExtraError = exports$1.reportError = exports$1.keyword$DataError = exports$1.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports$1.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports$1.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports$1.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports$1.reportError = reportError;
    function reportExtraError(cxt, error = exports$1.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports$1.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports$1.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports$1.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});
var require_boolSchema = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.boolOrEmptySchema = exports$1.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports$1.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports$1.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});
var require_rules = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.getRules = exports$1.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports$1.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports$1.getRules = getRules;
  }
});
var require_applicability = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.shouldUseRule = exports$1.shouldUseGroup = exports$1.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      const group = self.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports$1.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports$1.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a5;
      return schema[rule.keyword] !== void 0 || ((_a5 = rule.definition.implements) === null || _a5 === void 0 ? void 0 : _a5.some((kwd) => schema[kwd] !== void 0));
    }
    exports$1.shouldUseRule = shouldUseRule;
  }
});
var require_dataType = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.reportTypeError = exports$1.checkDataTypes = exports$1.checkDataType = exports$1.coerceAndCheckDataType = exports$1.getJSONTypes = exports$1.getSchemaTypes = exports$1.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports$1.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports$1.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports$1.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports$1.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports$1.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports$1.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports$1.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});
var require_defaults = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports$1.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});
var require_code2 = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateUnion = exports$1.validateArray = exports$1.usePattern = exports$1.callValidateCode = exports$1.schemaProperties = exports$1.allSchemaProperties = exports$1.noPropertyInData = exports$1.propertyInData = exports$1.isOwnProperty = exports$1.hasPropFunc = exports$1.reportMissingProp = exports$1.checkMissingProp = exports$1.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports$1.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports$1.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports$1.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports$1.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports$1.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports$1.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports$1.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports$1.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports$1.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context2, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context2 !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context2}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports$1.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports$1.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports$1.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports$1.validateUnion = validateUnion;
  }
});
var require_keyword = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateKeywordUsage = exports$1.validSchemaType = exports$1.funcKeywordCode = exports$1.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports$1.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a5;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a5 = def.valid) !== null && _a5 !== void 0 ? _a5 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e2) => gen.assign(valid, false).if((0, codegen_1._)`${e2} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e2}.errors`), () => gen.throw(e2)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a28;
        gen.if((0, codegen_1.not)((_a28 = def.valid) !== null && _a28 !== void 0 ? _a28 : valid), errors);
      }
    }
    exports$1.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports$1.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports$1.validateKeywordUsage = validateKeywordUsage;
  }
});
var require_subschema = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.extendSubschemaMode = exports$1.extendSubschemaData = exports$1.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports$1.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports$1.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports$1.extendSubschemaMode = extendSubschemaMode;
  }
});
var require_fast_deep_equal = __commonJS5({
  "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports$1, module) {
    module.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});
var require_json_schema_traverse = __commonJS5({
  "../../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js"(exports$1, module) {
    var traverse2 = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse2.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse2.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse2.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse2.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse2.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse2.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse2.keywords || opts.allKeys && !(key in traverse2.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});
var require_resolve = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.getSchemaRefs = exports$1.resolveUrl = exports$1.normalizeId = exports$1._getFullPath = exports$1.getFullPath = exports$1.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse2 = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports$1.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports$1.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports$1._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports$1.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports$1.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse2(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports$1.getSchemaRefs = getSchemaRefs;
  }
});
var require_validate = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.getData = exports$1.KeywordCxt = exports$1.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports$1.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self } = it;
      const { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports$1.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports$1.getData = getData;
  }
});
var require_validation_error = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports$1.default = ValidationError;
  }
});
var require_ref_error = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports$1.default = MissingRefError;
  }
});
var require_compile = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.resolveSchema = exports$1.getCompilingSchema = exports$1.resolveRef = exports$1.compileSchema = exports$1.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a5;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a5 = env.baseId) !== null && _a5 !== void 0 ? _a5 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports$1.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e2) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e2;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports$1.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a5;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve5.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a5 = root.localRefs) === null || _a5 === void 0 ? void 0 : _a5[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports$1.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports$1.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve5(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports$1.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a5;
      if (((_a5 = parsedRef.fragment) === null || _a5 === void 0 ? void 0 : _a5[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});
var require_data = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json"(exports$1, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});
var require_utils = __commonJS5({
  "../../node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/utils.js"(exports$1, module) {
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
    var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "";
      let code = 0;
      let i = 0;
      for (i = 0; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (code === 48) {
          continue;
        }
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
        break;
      }
      for (i += 1; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      buffer.length = 0;
      return true;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== "") {
          address.push(hex);
        } else {
          output.error = true;
          return false;
        }
        buffer.length = 0;
      }
      return true;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let endipv6Encountered = false;
      let endIpv6 = false;
      let consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume(buffer, address, output)) {
            break;
          }
          if (++tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i > 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          address.push(":");
          continue;
        } else if (cursor === "%") {
          if (!consume(buffer, address, output)) {
            break;
          }
          consume = consumeIsZone;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (consume === consumeIsZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, isIPV6: true, escapedHost };
      } else {
        return { host, isIPV6: false };
      }
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    function removeDotSegments(path) {
      let input = path;
      const output = [];
      let nextSlash = -1;
      let len = 0;
      while (len = input.length) {
        if (len === 1) {
          if (input === ".") {
            break;
          } else if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".") {
              break;
            } else if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/") {
            if (input[1] === "." || input[1] === "/") {
              output.push("/");
              break;
            }
          }
        } else if (len === 3) {
          if (input === "/..") {
            if (output.length !== 0) {
              output.pop();
            }
            output.push("/");
            break;
          }
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(2);
              continue;
            } else if (input[2] === ".") {
              if (input[3] === "/") {
                input = input.slice(3);
                if (output.length !== 0) {
                  output.pop();
                }
                continue;
              }
            }
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else {
          output.push(input.slice(0, nextSlash));
          input = input.slice(nextSlash);
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc) {
      const func = esc !== true ? escape : unescape;
      if (component.scheme !== void 0) {
        component.scheme = func(component.scheme);
      }
      if (component.userinfo !== void 0) {
        component.userinfo = func(component.userinfo);
      }
      if (component.host !== void 0) {
        component.host = func(component.host);
      }
      if (component.path !== void 0) {
        component.path = func(component.path);
      }
      if (component.query !== void 0) {
        component.query = func(component.query);
      }
      if (component.fragment !== void 0) {
        component.fragment = func(component.fragment);
      }
      return component;
    }
    function recomposeAuthority(component) {
      const uriTokens = [];
      if (component.userinfo !== void 0) {
        uriTokens.push(component.userinfo);
        uriTokens.push("@");
      }
      if (component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          const ipV6res = normalizeIPv6(host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = component.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof component.port === "number" || typeof component.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(component.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});
var require_schemes = __commonJS5({
  "../../node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/schemes.js"(exports$1, module) {
    var { isUUID } = require_utils();
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    var supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name4) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name4
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      if (wsComponent.secure === true) {
        return true;
      } else if (wsComponent.secure === false) {
        return false;
      } else if (wsComponent.scheme) {
        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
      } else {
        return false;
      }
    }
    function httpParse(component) {
      if (!component.host) {
        component.error = component.error || "HTTP URIs must have a host.";
      }
      return component;
    }
    function httpSerialize(component) {
      const secure = String(component.scheme).toLowerCase() === "https";
      if (component.port === (secure ? 443 : 80) || component.port === "") {
        component.port = void 0;
      }
      if (!component.path) {
        component.path = "/";
      }
      return component;
    }
    function wsParse(wsComponent) {
      wsComponent.secure = wsIsSecure(wsComponent);
      wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
      wsComponent.path = void 0;
      wsComponent.query = void 0;
      return wsComponent;
    }
    function wsSerialize(wsComponent) {
      if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
        wsComponent.port = void 0;
      }
      if (typeof wsComponent.secure === "boolean") {
        wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
        wsComponent.secure = void 0;
      }
      if (wsComponent.resourceName) {
        const [path, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path && path !== "/" ? path : void 0;
        wsComponent.query = query;
        wsComponent.resourceName = void 0;
      }
      wsComponent.fragment = void 0;
      return wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path) {
        urnComponent.error = "URN can not be parsed";
        return urnComponent;
      }
      const matches = urnComponent.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase();
        urnComponent.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
        const schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0;
        if (schemeHandler) {
          urnComponent = schemeHandler.parse(urnComponent, options);
        }
      } else {
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      }
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0) {
        throw new Error("URN without nid cannot be serialized");
      }
      const scheme = options.scheme || urnComponent.scheme || "urn";
      const nid = urnComponent.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      if (schemeHandler) {
        urnComponent = schemeHandler.serialize(urnComponent, options);
      }
      const uriComponent = urnComponent;
      const nss = urnComponent.nss;
      uriComponent.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      const uuidComponent = urnComponent;
      uuidComponent.uuid = uuidComponent.nss;
      uuidComponent.nss = void 0;
      if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
        uuidComponent.error = uuidComponent.error || "UUID is not valid.";
      }
      return uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      const urnComponent = uuidComponent;
      urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
      return urnComponent;
    }
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      }
    );
    var wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    );
    var urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      }
    );
    var urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      }
    );
    var SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});
var require_fast_uri = __commonJS5({
  "../../node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/index.js"(exports$1, module) {
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
    var { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = /** @type {T} */
        serialize(parse(uri, options), options);
      } else if (typeof uri === "object") {
        uri = /** @type {T} */
        parse(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve5(baseURI, relativeURI, options) {
      const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
      const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      schemelessOptions.skipEscape = true;
      return serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative2, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative2 = parse(serialize(relative2, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative2.scheme) {
        target.scheme = relative2.scheme;
        target.userinfo = relative2.userinfo;
        target.host = relative2.host;
        target.port = relative2.port;
        target.path = removeDotSegments(relative2.path || "");
        target.query = relative2.query;
      } else {
        if (relative2.userinfo !== void 0 || relative2.host !== void 0 || relative2.port !== void 0) {
          target.userinfo = relative2.userinfo;
          target.host = relative2.host;
          target.port = relative2.port;
          target.path = removeDotSegments(relative2.path || "");
          target.query = relative2.query;
        } else {
          if (!relative2.path) {
            target.path = base.path;
            if (relative2.query !== void 0) {
              target.query = relative2.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative2.path[0] === "/") {
              target.path = removeDotSegments(relative2.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative2.path;
              } else if (!base.path) {
                target.path = relative2.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative2.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative2.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative2.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
      if (component.path !== void 0) {
        if (!options.skipEscape) {
          component.path = escape(component.path);
          if (component.scheme !== void 0) {
            component.path = component.path.split("%3A").join(":");
          }
        } else {
          component.path = unescape(component.path);
        }
      }
      if (options.reference !== "suffix" && component.scheme) {
        uriTokens.push(component.scheme, ":");
      }
      const authority = recomposeAuthority(component);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (component.path && component.path[0] !== "/") {
          uriTokens.push("/");
        }
      }
      if (component.path !== void 0) {
        let s = component.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0 && s[0] === "/" && s[1] === "/") {
          s = "/%2F" + s.slice(2);
        }
        uriTokens.push(s);
      }
      if (component.query !== void 0) {
        uriTokens.push("?", component.query);
      }
      if (component.fragment !== void 0) {
        uriTokens.push("#", component.fragment);
      }
      return uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let isIP = false;
      if (options.reference === "suffix") {
        if (options.scheme) {
          uri = options.scheme + ":" + uri;
        } else {
          uri = "//" + uri;
        }
      }
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = isIPv4(parsed.host);
          if (ipv4result === false) {
            const ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e2) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e2;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (uri.indexOf("%") !== -1) {
            if (parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve: resolve5,
      resolveComponent,
      equal,
      serialize,
      parse
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});
var require_uri = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports$1.default = uri;
  }
});
var require_core = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a5, _b10, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a5 = o.code) === null || _a5 === void 0 ? void 0 : _a5.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b10 = o.code) === null || _b10 === void 0 ? void 0 : _b10.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e2) {
            if (!(e2 instanceof ref_error_1.default))
              throw e2;
            checkLoaded.call(this, e2);
            await loadMissingSchema.call(this, e2.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name4, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name4] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text5, msg) => text5 + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports$1.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name4 in this.opts.formats) {
        const format = this.opts.formats[name4];
        if (format)
          this.addFormat(name4, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a5;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a5 = definition.implements) === null || _a5 === void 0 ? void 0 : _a5.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});
var require_id = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports$1.default = def;
  }
});
var require_ref = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.callRef = exports$1.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports$1.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e2) => {
          gen.if((0, codegen_1._)`!(${e2} instanceof ${it.ValidationError})`, () => gen.throw(e2));
          addErrorsFrom(e2);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a5;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a5 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a5 === void 0 ? void 0 : _a5.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports$1.callRef = callRef;
    exports$1.default = def;
  }
});
var require_core2 = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports$1.default = core;
  }
});
var require_limitNumber = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports$1.default = def;
  }
});
var require_multipleOf = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports$1.default = def;
  }
});
var require_ucs2length = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports$1.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});
var require_limitLength = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports$1.default = def;
  }
});
var require_pattern = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports$1.default = def;
  }
});
var require_limitProperties = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports$1.default = def;
  }
});
var require_required = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports$1.default = def;
  }
});
var require_limitItems = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports$1.default = def;
  }
});
var require_equal = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports$1.default = equal;
  }
});
var require_uniqueItems = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports$1.default = def;
  }
});
var require_const = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports$1.default = def;
  }
});
var require_enum = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports$1.default = def;
  }
});
var require_validation = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports$1.default = validation;
  }
});
var require_additionalItems = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports$1.validateAdditionalItems = validateAdditionalItems;
    exports$1.default = def;
  }
});
var require_items = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports$1.validateTuple = validateTuple;
    exports$1.default = def;
  }
});
var require_prefixItems = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports$1.default = def;
  }
});
var require_items2020 = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports$1.default = def;
  }
});
var require_contains = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports$1.default = def;
  }
});
var require_dependencies = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateSchemaDeps = exports$1.validatePropertyDeps = exports$1.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports$1.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports$1.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports$1.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports$1.validateSchemaDeps = validateSchemaDeps;
    exports$1.default = def;
  }
});
var require_propertyNames = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports$1.default = def;
  }
});
var require_additionalProperties = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports$1.default = def;
  }
});
var require_properties = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports$1.default = def;
  }
});
var require_patternProperties = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports$1.default = def;
  }
});
var require_not = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports$1.default = def;
  }
});
var require_anyOf = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports$1.default = def;
  }
});
var require_oneOf = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports$1.default = def;
  }
});
var require_allOf = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports$1.default = def;
  }
});
var require_if = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports$1.default = def;
  }
});
var require_thenElse = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports$1.default = def;
  }
});
var require_applicator = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports$1.default = getApplicator;
  }
});
var require_format = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports$1.default = def;
  }
});
var require_format2 = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports$1.default = format;
  }
});
var require_metadata = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.contentVocabulary = exports$1.metadataVocabulary = void 0;
    exports$1.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports$1.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});
var require_draft7 = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports$1.default = draft7Vocabularies;
  }
});
var require_types = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports$1.DiscrError = DiscrError = {}));
  }
});
var require_discriminator = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a5;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a5 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a5 === void 0 ? void 0 : _a5[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports$1.default = def;
  }
});
var require_json_schema_draft_07 = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports$1, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});
var require_ajv = __commonJS5({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js"(exports$1, module) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MissingRefError = exports$1.ValidationError = exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = exports$1.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports$1.Ajv = Ajv2;
    module.exports = exports$1 = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports$1, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});
__toESM5(require_ajv());
__toESM5(require_json_schema_traverse());
var TypeHandler = class {
  apply(types, schema) {
    if (!schema.type) return;
    const allowedTypes = Array.isArray(schema.type) ? schema.type : [schema.type];
    const typeSet = new Set(allowedTypes);
    if (!typeSet.has("string")) {
      types.string = false;
    }
    if (!typeSet.has("number") && !typeSet.has("integer")) {
      types.number = false;
    }
    if (!typeSet.has("boolean")) {
      types.boolean = false;
    }
    if (!typeSet.has("null")) {
      types.null = false;
    }
    if (!typeSet.has("array")) {
      types.array = false;
    }
    if (!typeSet.has("object")) {
      types.object = false;
    }
    if (typeSet.has("integer") && types.number !== false) {
      const currentNumber = types.number || z$2.number();
      if (currentNumber instanceof z$2.ZodNumber) {
        types.number = currentNumber.int();
      }
    }
  }
};
var ConstHandler = class {
  apply(types, schema) {
    if (schema.const === void 0) return;
    const constValue = schema.const;
    types.string = false;
    types.number = false;
    types.boolean = false;
    types.null = false;
    types.array = false;
    types.object = false;
    if (typeof constValue === "string") {
      types.string = z$2.literal(constValue);
    } else if (typeof constValue === "number") {
      types.number = z$2.literal(constValue);
    } else if (typeof constValue === "boolean") {
      types.boolean = z$2.literal(constValue);
    } else if (constValue === null) {
      types.null = z$2.null();
    } else if (Array.isArray(constValue)) {
      types.array = void 0;
    } else if (typeof constValue === "object") {
      types.object = void 0;
    }
  }
};
var EnumHandler = class {
  apply(types, schema) {
    if (!schema.enum) return;
    if (schema.enum.length === 0) {
      if (!schema.type) {
        types.string = false;
        types.number = false;
        types.boolean = false;
        types.null = false;
        types.array = false;
        types.object = false;
      }
      return;
    }
    const valuesByType = {
      string: schema.enum.filter((v) => typeof v === "string"),
      number: schema.enum.filter((v) => typeof v === "number"),
      boolean: schema.enum.filter((v) => typeof v === "boolean"),
      null: schema.enum.filter((v) => v === null),
      array: schema.enum.filter((v) => Array.isArray(v)),
      object: schema.enum.filter((v) => typeof v === "object" && v !== null && !Array.isArray(v))
    };
    types.string = this.createTypeSchema(valuesByType.string, "string");
    types.number = this.createTypeSchema(valuesByType.number, "number");
    types.boolean = this.createTypeSchema(valuesByType.boolean, "boolean");
    types.null = valuesByType.null.length > 0 ? z$2.null() : false;
    types.array = valuesByType.array.length > 0 ? void 0 : false;
    types.object = valuesByType.object.length > 0 ? void 0 : false;
  }
  createTypeSchema(values, type) {
    if (values.length === 0) return false;
    if (values.length === 1) {
      return z$2.literal(values[0]);
    }
    if (type === "string") {
      return z$2.enum(values);
    }
    if (type === "number") {
      const [first, second, ...rest] = values;
      return z$2.union([z$2.literal(first), z$2.literal(second), ...rest.map((v) => z$2.literal(v))]);
    }
    if (type === "boolean") {
      return z$2.union([z$2.literal(true), z$2.literal(false)]);
    }
    return false;
  }
};
var ImplicitStringHandler = class {
  apply(types, schema) {
    const stringSchema = schema;
    if (schema.type === void 0 && (stringSchema.minLength !== void 0 || stringSchema.maxLength !== void 0 || stringSchema.pattern !== void 0)) {
      if (types.string === void 0) {
        types.string = z$2.string();
      }
    }
  }
};
var MinLengthHandler = class {
  apply(types, schema) {
    const stringSchema = schema;
    if (stringSchema.minLength === void 0) return;
    if (types.string !== false) {
      const currentString = types.string || z$2.string();
      if (currentString instanceof z$2.ZodString) {
        types.string = currentString.refine(
          (value) => {
            const graphemeLength = Array.from(value).length;
            return graphemeLength >= stringSchema.minLength;
          },
          { message: `String must be at least ${stringSchema.minLength} characters long` }
        );
      }
    }
  }
};
var MaxLengthHandler = class {
  apply(types, schema) {
    const stringSchema = schema;
    if (stringSchema.maxLength === void 0) return;
    if (types.string !== false) {
      const currentString = types.string || z$2.string();
      if (currentString instanceof z$2.ZodString) {
        types.string = currentString.refine(
          (value) => {
            const graphemeLength = Array.from(value).length;
            return graphemeLength <= stringSchema.maxLength;
          },
          { message: `String must be at most ${stringSchema.maxLength} characters long` }
        );
      }
    }
  }
};
var PatternHandler = class {
  apply(types, schema) {
    const stringSchema = schema;
    if (!stringSchema.pattern) return;
    if (types.string !== false) {
      const currentString = types.string || z$2.string();
      if (currentString instanceof z$2.ZodString) {
        const regex = new RegExp(stringSchema.pattern);
        types.string = currentString.regex(regex);
      }
    }
  }
};
var MinimumHandler = class {
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.minimum === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || z$2.number();
      if (currentNumber instanceof z$2.ZodNumber) {
        types.number = currentNumber.min(numberSchema.minimum);
      }
    }
  }
};
var MaximumHandler = class {
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.maximum === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || z$2.number();
      if (currentNumber instanceof z$2.ZodNumber) {
        types.number = currentNumber.max(numberSchema.maximum);
      }
    }
  }
};
var ExclusiveMinimumHandler = class {
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.exclusiveMinimum === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || z$2.number();
      if (currentNumber instanceof z$2.ZodNumber) {
        if (typeof numberSchema.exclusiveMinimum === "number") {
          types.number = currentNumber.gt(numberSchema.exclusiveMinimum);
        } else {
          types.number = false;
        }
      }
    }
  }
};
var ExclusiveMaximumHandler = class {
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.exclusiveMaximum === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || z$2.number();
      if (currentNumber instanceof z$2.ZodNumber) {
        if (typeof numberSchema.exclusiveMaximum === "number") {
          types.number = currentNumber.lt(numberSchema.exclusiveMaximum);
        } else {
          types.number = false;
        }
      }
    }
  }
};
var MultipleOfHandler = class {
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.multipleOf === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || z$2.number();
      if (currentNumber instanceof z$2.ZodNumber) {
        types.number = currentNumber.refine(
          (value) => {
            if (numberSchema.multipleOf === 0) return false;
            const quotient = value / numberSchema.multipleOf;
            const rounded = Math.round(quotient);
            const tolerance = Math.min(
              Math.abs(value) * Number.EPSILON * 10,
              Math.abs(numberSchema.multipleOf) * Number.EPSILON * 10
            );
            return Math.abs(quotient - rounded) <= tolerance / Math.abs(numberSchema.multipleOf);
          },
          { message: `Must be a multiple of ${numberSchema.multipleOf}` }
        );
      }
    }
  }
};
var ImplicitArrayHandler = class {
  apply(types, schema) {
    const arraySchema = schema;
    if (schema.type === void 0 && (arraySchema.minItems !== void 0 || arraySchema.maxItems !== void 0 || arraySchema.items !== void 0 || arraySchema.prefixItems !== void 0)) {
      if (types.array === void 0) {
        types.array = z$2.array(z$2.any());
      }
    }
  }
};
var MinItemsHandler = class {
  apply(types, schema) {
    const arraySchema = schema;
    if (arraySchema.minItems === void 0) return;
    if (types.array !== false) {
      types.array = (types.array || z$2.array(z$2.any())).min(arraySchema.minItems);
    }
  }
};
var MaxItemsHandler = class {
  apply(types, schema) {
    const arraySchema = schema;
    if (arraySchema.maxItems === void 0) return;
    if (types.array !== false) {
      types.array = (types.array || z$2.array(z$2.any())).max(arraySchema.maxItems);
    }
  }
};
var ItemsHandler = class {
  apply(types, schema) {
    const arraySchema = schema;
    if (types.array === false) return;
    if (Array.isArray(arraySchema.items)) {
      types.array = types.array || z$2.array(z$2.any());
    } else if (arraySchema.items && typeof arraySchema.items !== "boolean" && !arraySchema.prefixItems) {
      const itemSchema = convertJsonSchemaToZod(arraySchema.items);
      let newArray = z$2.array(itemSchema);
      if (types.array && types.array instanceof z$2.ZodArray) {
        const existingDef = types.array._def;
        if (existingDef.checks) {
          existingDef.checks.forEach((check) => {
            if (check._zod && check._zod.def) {
              const def = check._zod.def;
              if (def.check === "min_length" && def.minimum !== void 0) {
                newArray = newArray.min(def.minimum);
              } else if (def.check === "max_length" && def.maximum !== void 0) {
                newArray = newArray.max(def.maximum);
              }
            }
          });
        }
      }
      types.array = newArray;
    } else if (typeof arraySchema.items === "boolean" && arraySchema.items === false) {
      if (!arraySchema.prefixItems) {
        types.array = z$2.array(z$2.any()).max(0);
      } else {
        types.array = types.array || z$2.array(z$2.any());
      }
    } else if (typeof arraySchema.items === "boolean" && arraySchema.items === true) {
      types.array = types.array || z$2.array(z$2.any());
    } else if (arraySchema.prefixItems) {
      types.array = types.array || z$2.array(z$2.any());
    }
  }
};
var TupleHandler = class {
  apply(types, schema) {
    if (schema.type !== "array") return;
    const arraySchema = schema;
    if (!Array.isArray(arraySchema.items)) return;
    if (types.array === false) return;
    const itemSchemas = arraySchema.items.map((itemSchema) => convertJsonSchemaToZod(itemSchema));
    let tuple;
    if (itemSchemas.length === 0) {
      tuple = z$2.tuple([]);
    } else {
      tuple = z$2.tuple(itemSchemas);
    }
    if (arraySchema.minItems !== void 0 && arraySchema.minItems > itemSchemas.length) {
      tuple = false;
    }
    if (arraySchema.maxItems !== void 0 && arraySchema.maxItems < itemSchemas.length) {
      tuple = false;
    }
    types.tuple = tuple;
    types.array = false;
  }
};
var PropertiesHandler = class {
  apply(types, schema) {
    const objectSchema = schema;
    if (types.object === false) return;
    if (objectSchema.properties || objectSchema.required || objectSchema.additionalProperties !== void 0) {
      types.object = types.object || z$2.object({}).passthrough();
    }
  }
};
var ImplicitObjectHandler = class {
  apply(types, schema) {
    const objectSchema = schema;
    if (schema.type === void 0 && (objectSchema.maxProperties !== void 0 || objectSchema.minProperties !== void 0)) {
      if (types.object === void 0) {
        types.object = z$2.object({}).passthrough();
      }
    }
  }
};
var MaxPropertiesHandler = class {
  apply(types, schema) {
    const objectSchema = schema;
    if (objectSchema.maxProperties === void 0) return;
    if (types.object !== false) {
      const baseObject = types.object || z$2.object({}).passthrough();
      types.object = baseObject.refine(
        (obj) => Object.keys(obj).length <= objectSchema.maxProperties,
        { message: `Object must have at most ${objectSchema.maxProperties} properties` }
      );
    }
  }
};
var MinPropertiesHandler = class {
  apply(types, schema) {
    const objectSchema = schema;
    if (objectSchema.minProperties === void 0) return;
    if (types.object !== false) {
      const baseObject = types.object || z$2.object({}).passthrough();
      types.object = baseObject.refine(
        (obj) => Object.keys(obj).length >= objectSchema.minProperties,
        { message: `Object must have at least ${objectSchema.minProperties} properties` }
      );
    }
  }
};
function deepEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return a === b;
  if (typeof a !== typeof b) return false;
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    return a.every((item, index) => deepEqual(item, b[index]));
  }
  if (typeof a === "object" && typeof b === "object") {
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) return false;
    return keysA.every((key) => keysB.includes(key) && deepEqual(a[key], b[key]));
  }
  return false;
}
function createUniqueItemsValidator() {
  return (value) => {
    if (!Array.isArray(value)) {
      return true;
    }
    const seen = [];
    return value.every((item) => {
      const isDuplicate = seen.some((seenItem) => deepEqual(item, seenItem));
      if (isDuplicate) {
        return false;
      }
      seen.push(item);
      return true;
    });
  };
}
function isValidWithSchema(schema, value) {
  return schema.safeParse(value).success;
}
var NotHandler = class {
  apply(zodSchema5, schema) {
    if (!schema.not) return zodSchema5;
    const notSchema = convertJsonSchemaToZod(schema.not);
    return zodSchema5.refine(
      (value) => !isValidWithSchema(notSchema, value),
      { message: "Value must not match the 'not' schema" }
    );
  }
};
var UniqueItemsHandler = class {
  apply(zodSchema5, schema) {
    const arraySchema = schema;
    if (arraySchema.uniqueItems !== true) return zodSchema5;
    return zodSchema5.refine(createUniqueItemsValidator(), {
      message: "Array items must be unique"
    });
  }
};
var AllOfHandler = class {
  apply(zodSchema5, schema) {
    if (!schema.allOf || schema.allOf.length === 0) return zodSchema5;
    const allOfSchemas = schema.allOf.map((s) => convertJsonSchemaToZod(s));
    return allOfSchemas.reduce(
      (acc, s) => z$2.intersection(acc, s),
      zodSchema5
    );
  }
};
var AnyOfHandler = class {
  apply(zodSchema5, schema) {
    if (!schema.anyOf || schema.anyOf.length === 0) return zodSchema5;
    const anyOfSchema = schema.anyOf.length === 1 ? convertJsonSchemaToZod(schema.anyOf[0]) : z$2.union([
      convertJsonSchemaToZod(schema.anyOf[0]),
      convertJsonSchemaToZod(schema.anyOf[1]),
      ...schema.anyOf.slice(2).map((s) => convertJsonSchemaToZod(s))
    ]);
    return z$2.intersection(zodSchema5, anyOfSchema);
  }
};
var OneOfHandler = class {
  apply(zodSchema5, schema) {
    if (!schema.oneOf || schema.oneOf.length === 0) return zodSchema5;
    const oneOfSchemas = schema.oneOf.map((s) => convertJsonSchemaToZod(s));
    return zodSchema5.refine(
      (value) => {
        let validCount = 0;
        for (const oneOfSchema of oneOfSchemas) {
          const result = oneOfSchema.safeParse(value);
          if (result.success) {
            validCount++;
            if (validCount > 1) return false;
          }
        }
        return validCount === 1;
      },
      { message: "Value must match exactly one of the oneOf schemas" }
    );
  }
};
var PrefixItemsHandler = class {
  apply(zodSchema5, schema) {
    const arraySchema = schema;
    if (arraySchema.prefixItems && Array.isArray(arraySchema.prefixItems)) {
      const prefixItems = arraySchema.prefixItems;
      const prefixSchemas = prefixItems.map((itemSchema) => convertJsonSchemaToZod(itemSchema));
      return zodSchema5.refine(
        (value) => {
          if (!Array.isArray(value)) return true;
          for (let i = 0; i < Math.min(value.length, prefixSchemas.length); i++) {
            if (!isValidWithSchema(prefixSchemas[i], value[i])) {
              return false;
            }
          }
          if (value.length > prefixSchemas.length) {
            if (typeof arraySchema.items === "boolean" && arraySchema.items === false) {
              return false;
            } else if (arraySchema.items && typeof arraySchema.items === "object" && !Array.isArray(arraySchema.items)) {
              const additionalItemSchema = convertJsonSchemaToZod(arraySchema.items);
              for (let i = prefixSchemas.length; i < value.length; i++) {
                if (!isValidWithSchema(additionalItemSchema, value[i])) {
                  return false;
                }
              }
            }
          }
          return true;
        },
        { message: "Array does not match prefixItems schema" }
      );
    }
    return zodSchema5;
  }
};
var ObjectPropertiesHandler = class {
  apply(zodSchema5, schema) {
    const objectSchema = schema;
    if (!objectSchema.properties && !objectSchema.required && objectSchema.additionalProperties !== false) {
      return zodSchema5;
    }
    if (zodSchema5 instanceof z$2.ZodObject || zodSchema5 instanceof z$2.ZodRecord) {
      const shape = {};
      if (objectSchema.properties) {
        for (const [key, propSchema] of Object.entries(objectSchema.properties)) {
          if (propSchema !== void 0) {
            shape[key] = convertJsonSchemaToZod(propSchema);
          }
        }
      }
      if (objectSchema.required && Array.isArray(objectSchema.required)) {
        const required = new Set(objectSchema.required);
        for (const key of Object.keys(shape)) {
          if (!required.has(key)) {
            shape[key] = shape[key].optional();
          }
        }
      } else {
        for (const key of Object.keys(shape)) {
          shape[key] = shape[key].optional();
        }
      }
      if (objectSchema.additionalProperties === false) {
        return z$2.object(shape);
      } else {
        return z$2.object(shape).passthrough();
      }
    }
    return zodSchema5.refine(
      (value) => {
        if (typeof value !== "object" || value === null || Array.isArray(value)) {
          return true;
        }
        if (objectSchema.properties) {
          for (const [propName, propSchema] of Object.entries(objectSchema.properties)) {
            if (propSchema !== void 0) {
              const propExists = Object.getOwnPropertyDescriptor(value, propName) !== void 0;
              if (propExists) {
                const zodPropSchema = convertJsonSchemaToZod(propSchema);
                const propResult = zodPropSchema.safeParse(value[propName]);
                if (!propResult.success) {
                  return false;
                }
              }
            }
          }
        }
        if (objectSchema.required && Array.isArray(objectSchema.required)) {
          for (const requiredProp of objectSchema.required) {
            const propExists = Object.getOwnPropertyDescriptor(value, requiredProp) !== void 0;
            if (!propExists) {
              return false;
            }
          }
        }
        if (objectSchema.additionalProperties === false && objectSchema.properties) {
          const allowedProps = new Set(Object.keys(objectSchema.properties));
          for (const prop in value) {
            if (!allowedProps.has(prop)) {
              return false;
            }
          }
        }
        return true;
      },
      { message: "Object constraints validation failed" }
    );
  }
};
var EnumComplexHandler = class {
  apply(zodSchema5, schema) {
    if (!schema.enum || schema.enum.length === 0) return zodSchema5;
    const complexValues = schema.enum.filter(
      (v) => Array.isArray(v) || typeof v === "object" && v !== null
    );
    if (complexValues.length === 0) return zodSchema5;
    return zodSchema5.refine(
      (value) => {
        if (typeof value !== "object" || value === null) return true;
        return complexValues.some(
          (enumValue) => deepEqual(value, enumValue)
        );
      },
      { message: "Value must match one of the enum values" }
    );
  }
};
var ConstComplexHandler = class {
  apply(zodSchema5, schema) {
    if (schema.const === void 0) return zodSchema5;
    const constValue = schema.const;
    if (typeof constValue !== "object" || constValue === null) {
      return zodSchema5;
    }
    return zodSchema5.refine(
      (value) => deepEqual(value, constValue),
      { message: "Value must equal the const value" }
    );
  }
};
var MetadataHandler = class {
  apply(zodSchema5, schema) {
    if (schema.description) {
      zodSchema5 = zodSchema5.describe(schema.description);
    }
    return zodSchema5;
  }
};
var ProtoRequiredHandler = class {
  apply(zodSchema5, schema) {
    var _a5;
    const objectSchema = schema;
    if (!((_a5 = objectSchema.required) == null ? void 0 : _a5.includes("__proto__")) || schema.type !== void 0) {
      return zodSchema5;
    }
    return z$2.any().refine(
      (value) => this.validateRequired(value, objectSchema.required),
      { message: "Missing required properties" }
    );
  }
  validateRequired(value, required) {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      return true;
    }
    return required.every(
      (prop) => Object.prototype.hasOwnProperty.call(value, prop)
    );
  }
};
var ContainsHandler = class {
  apply(zodSchema5, schema) {
    var _a5;
    const arraySchema = schema;
    if (arraySchema.contains === void 0) return zodSchema5;
    const containsSchema = convertJsonSchemaToZod(arraySchema.contains);
    const minContains = (_a5 = arraySchema.minContains) != null ? _a5 : 1;
    const maxContains = arraySchema.maxContains;
    return zodSchema5.refine(
      (value) => {
        if (!Array.isArray(value)) {
          return true;
        }
        let matchCount = 0;
        for (const item of value) {
          if (isValidWithSchema(containsSchema, item)) {
            matchCount++;
          }
        }
        if (matchCount < minContains) {
          return false;
        }
        if (maxContains !== void 0 && matchCount > maxContains) {
          return false;
        }
        return true;
      },
      { message: "Array must contain required items matching the schema" }
    );
  }
};
var primitiveHandlers = [
  // Type constraints - should run first
  new ConstHandler(),
  new EnumHandler(),
  new TypeHandler(),
  // Implicit type detection - must run before other constraints
  new ImplicitStringHandler(),
  new ImplicitArrayHandler(),
  new ImplicitObjectHandler(),
  // String constraints
  new MinLengthHandler(),
  new MaxLengthHandler(),
  new PatternHandler(),
  // Number constraints
  new MinimumHandler(),
  new MaximumHandler(),
  new ExclusiveMinimumHandler(),
  new ExclusiveMaximumHandler(),
  new MultipleOfHandler(),
  // Array constraints - TupleHandler must run before ItemsHandler
  new TupleHandler(),
  new MinItemsHandler(),
  new MaxItemsHandler(),
  new ItemsHandler(),
  // Object constraints
  new MaxPropertiesHandler(),
  new MinPropertiesHandler(),
  new PropertiesHandler()
];
var refinementHandlers = [
  // Handle special cases first
  new ProtoRequiredHandler(),
  new EnumComplexHandler(),
  new ConstComplexHandler(),
  // Logical combinations
  new AllOfHandler(),
  new AnyOfHandler(),
  new OneOfHandler(),
  // Type-specific refinements
  new PrefixItemsHandler(),
  new ObjectPropertiesHandler(),
  // Array refinements
  new ContainsHandler(),
  // Other refinements
  new NotHandler(),
  new UniqueItemsHandler(),
  // Metadata last
  new MetadataHandler()
];
function convertJsonSchemaToZod(schema) {
  if (typeof schema === "boolean") {
    return schema ? z$2.any() : z$2.never();
  }
  const types = {};
  for (const handler of primitiveHandlers) {
    handler.apply(types, schema);
  }
  const allowedSchemas = [];
  if (types.string !== false) {
    allowedSchemas.push(types.string || z$2.string());
  }
  if (types.number !== false) {
    allowedSchemas.push(types.number || z$2.number());
  }
  if (types.boolean !== false) {
    allowedSchemas.push(types.boolean || z$2.boolean());
  }
  if (types.null !== false) {
    allowedSchemas.push(types.null || z$2.null());
  }
  if (types.array !== false) {
    allowedSchemas.push(types.array || z$2.array(z$2.any()));
  }
  if (types.tuple !== false && types.tuple !== void 0) {
    allowedSchemas.push(types.tuple);
  }
  if (types.object !== false) {
    if (types.object) {
      allowedSchemas.push(types.object);
    } else {
      const objectSchema = z$2.custom((val) => {
        return typeof val === "object" && val !== null && !Array.isArray(val);
      }, "Must be an object, not an array");
      allowedSchemas.push(objectSchema);
    }
  }
  let zodSchema5;
  if (allowedSchemas.length === 0) {
    zodSchema5 = z$2.never();
  } else if (allowedSchemas.length === 1) {
    zodSchema5 = allowedSchemas[0];
  } else {
    const hasConstraints = Object.keys(schema).some(
      (key) => key !== "$schema" && key !== "title" && key !== "description"
    );
    if (!hasConstraints) {
      zodSchema5 = z$2.any();
    } else {
      zodSchema5 = z$2.union(allowedSchemas);
    }
  }
  for (const handler of refinementHandlers) {
    zodSchema5 = handler.apply(zodSchema5, schema);
  }
  return zodSchema5;
}
function convertJsonSchemaToZod2(schema) {
  function addMetadata(zodSchema5, jsonSchema5) {
    if (jsonSchema5.description) {
      zodSchema5 = zodSchema5.describe(jsonSchema5.description);
    }
    return zodSchema5;
  }
  if (schema.const !== void 0) {
    if (typeof schema.const === "string") {
      return addMetadata(z.literal(schema.const), schema);
    } else if (typeof schema.const === "number") {
      return addMetadata(z.literal(schema.const), schema);
    } else if (typeof schema.const === "boolean") {
      return addMetadata(z.literal(schema.const), schema);
    } else if (schema.const === null) {
      return addMetadata(z.null(), schema);
    }
    return addMetadata(z.literal(schema.const), schema);
  }
  if (schema.type) {
    switch (schema.type) {
      case "string": {
        if (schema.enum) {
          if (schema.enum.length === 0) {
            return addMetadata(z.string(), schema);
          }
          return addMetadata(z.enum(schema.enum), schema);
        }
        let stringSchema = z.string();
        if (schema.minLength !== void 0) {
          stringSchema = stringSchema.min(schema.minLength);
        }
        if (schema.maxLength !== void 0) {
          stringSchema = stringSchema.max(schema.maxLength);
        }
        if (schema.pattern !== void 0) {
          const regex = new RegExp(schema.pattern);
          stringSchema = stringSchema.regex(regex);
        }
        return addMetadata(stringSchema, schema);
      }
      case "number":
      case "integer": {
        if (schema.enum) {
          if (schema.enum.length === 0) {
            return addMetadata(z.number(), schema);
          }
          const options = schema.enum.map((val) => z.literal(val));
          if (options.length === 1) {
            return addMetadata(options[0], schema);
          }
          if (options.length >= 2) {
            const unionSchema = z.union([options[0], options[1], ...options.slice(2)]);
            return addMetadata(unionSchema, schema);
          }
        }
        let numberSchema = schema.type === "integer" ? z.number().int() : z.number();
        if (schema.minimum !== void 0) {
          numberSchema = numberSchema.min(schema.minimum);
        }
        if (schema.maximum !== void 0) {
          numberSchema = numberSchema.max(schema.maximum);
        }
        if (schema.exclusiveMinimum !== void 0) {
          numberSchema = numberSchema.gt(schema.exclusiveMinimum);
        }
        if (schema.exclusiveMaximum !== void 0) {
          numberSchema = numberSchema.lt(schema.exclusiveMaximum);
        }
        if (schema.multipleOf !== void 0) {
          numberSchema = numberSchema.multipleOf(schema.multipleOf);
        }
        return addMetadata(numberSchema, schema);
      }
      case "boolean":
        if (schema.enum) {
          if (schema.enum.length === 0) {
            return addMetadata(z.boolean(), schema);
          }
          const options = schema.enum.map((val) => z.literal(val));
          if (options.length === 1) {
            return addMetadata(options[0], schema);
          }
          if (options.length >= 2) {
            const unionSchema = z.union([options[0], options[1], ...options.slice(2)]);
            return addMetadata(unionSchema, schema);
          }
        }
        return addMetadata(z.boolean(), schema);
      case "null":
        return addMetadata(z.null(), schema);
      case "object":
        if (schema.properties) {
          const shape = {};
          for (const [key, propSchema] of Object.entries(
            schema.properties
          )) {
            shape[key] = convertJsonSchemaToZod2(propSchema);
          }
          if (schema.required && Array.isArray(schema.required)) {
            const required = new Set(schema.required);
            for (const key of Object.keys(shape)) {
              if (!required.has(key)) {
                shape[key] = shape[key].optional();
              }
            }
          } else {
            for (const key of Object.keys(shape)) {
              shape[key] = shape[key].optional();
            }
          }
          let zodSchema5;
          if (schema.additionalProperties !== false) {
            zodSchema5 = z.object(shape).passthrough();
          } else {
            zodSchema5 = z.object(shape);
          }
          return addMetadata(zodSchema5, schema);
        }
        return addMetadata(z.object({}), schema);
      case "array": {
        let arraySchema;
        if (schema.items) {
          arraySchema = z.array(convertJsonSchemaToZod2(schema.items));
        } else {
          arraySchema = z.array(z.any());
        }
        if (schema.minItems !== void 0) {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (schema.maxItems !== void 0) {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        if (schema.uniqueItems === true) {
          arraySchema = arraySchema.refine(
            (items) => {
              const seen = /* @__PURE__ */ new Set();
              return items.every((item) => {
                if (typeof item === "string" || typeof item === "number" || typeof item === "boolean") {
                  if (seen.has(item)) return false;
                  seen.add(item);
                  return true;
                }
                const serialized = JSON.stringify(item);
                if (seen.has(serialized)) return false;
                seen.add(serialized);
                return true;
              });
            },
            { message: "Array items must be unique" }
          );
        }
        return addMetadata(arraySchema, schema);
      }
    }
  }
  if (schema.enum) {
    if (schema.enum.length === 0) {
      return addMetadata(z.never(), schema);
    }
    const allStrings = schema.enum.every((val) => typeof val === "string");
    if (allStrings) {
      return addMetadata(z.enum(schema.enum), schema);
    } else {
      const options = schema.enum.map((val) => z.literal(val));
      if (options.length === 1) {
        return addMetadata(options[0], schema);
      }
      if (options.length >= 2) {
        const unionSchema = z.union([options[0], options[1], ...options.slice(2)]);
        return addMetadata(unionSchema, schema);
      }
    }
  }
  if (schema.anyOf && schema.anyOf.length >= 2) {
    const schemas = schema.anyOf.map(convertJsonSchemaToZod2);
    return addMetadata(
      z.union([schemas[0], schemas[1], ...schemas.slice(2)]),
      schema
    );
  }
  if (schema.allOf) {
    return addMetadata(
      schema.allOf.reduce(
        (acc, s) => z.intersection(acc, convertJsonSchemaToZod2(s)),
        z.object({})
      ),
      schema
    );
  }
  if (schema.oneOf && schema.oneOf.length >= 2) {
    const schemas = schema.oneOf.map(convertJsonSchemaToZod2);
    return addMetadata(
      z.union([schemas[0], schemas[1], ...schemas.slice(2)]),
      schema
    );
  }
  return addMetadata(z.any(), schema);
}
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS6 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM22 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp2(target, "default", { value: mod, enumerable: true }),
  mod
));
var require_secure_json_parse = __commonJS6({
  "../../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js"(exports$1, module) {
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx4 = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx4 = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse4(text23, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text23)) {
        text23 = text23.toString();
      }
      if (text23 && text23.charCodeAt(0) === 65279) {
        text23 = text23.slice(1);
      }
      const obj = JSON.parse(text23, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx4.test(text23) === false && suspectConstructorRx4.test(text23) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx4.test(text23) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx4.test(text23) === false) {
          return obj;
        }
      }
      return filter4(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter4(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse(text23, reviver, options) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse4(text23, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse(text23, reviver) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse4(text23, reviver, { safe: true });
      } catch (_e) {
        return null;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module.exports = parse;
    module.exports.default = parse;
    module.exports.parse = parse;
    module.exports.safeParse = safeParse;
    module.exports.scan = filter4;
  }
});
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError2 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name1422,
    message,
    cause
  }) {
    super(message);
    this[_a] = true;
    this.name = name1422;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError2.hasMarker(error, marker);
  }
  static hasMarker(error, marker152) {
    const markerSymbol = Symbol.for(marker152);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a = symbol;
var AISDKError = _AISDKError;
function getErrorMessage(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3, message, cause });
    this[_a4] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker4);
  }
};
_a4 = symbol4;
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
  constructor({ text: text23, cause }) {
    super({
      name: name6,
      message: `JSON parsing failed: Text: ${text23}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a7] = true;
    this.text = text23;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker7);
  }
};
_a7 = symbol7;
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
  constructor({ value, cause }) {
    super({
      name: name12,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a13] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker13);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });
  }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;
var customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i = size | 0;
    while (i--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
var import_secure_json_parse = __toESM22(require_secure_json_parse());
function convertAsyncIteratorToReadableStream(iterator) {
  return new ReadableStream({
    /**
     * Called when the consumer wants to pull more data from the stream.
     *
     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.
     * @returns {Promise<void>}
     */
    async pull(controller) {
      try {
        const { value, done } = await iterator.next();
        if (done) {
          controller.close();
        } else {
          controller.enqueue(value);
        }
      } catch (error) {
        controller.error(error);
      }
    },
    /**
     * Called when the consumer cancels the stream.
     */
    cancel() {
    }
  });
}
var createIdGenerator = ({
  prefix,
  size: defaultSize = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = customAlphabet(alphabet, defaultSize);
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return (size) => `${prefix}${separator}${generator(size)}`;
};
createIdGenerator();
var validatorSymbol = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator(validate) {
  return { [validatorSymbol]: true, validate };
}
function isValidator(value) {
  return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
function asValidator(value) {
  return isValidator(value) ? value : zodValidator(value);
}
function zodValidator(zodSchema23) {
  return validator((value) => {
    const result = zodSchema23.safeParse(value);
    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
  });
}
function safeValidateTypes({
  value,
  schema
}) {
  const validator23 = asValidator(schema);
  try {
    if (validator23.validate == null) {
      return { success: true, value };
    }
    const result = validator23.validate(value);
    if (result.success) {
      return result;
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: result.error })
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: error })
    };
  }
}
function safeParseJSON({
  text: text23,
  schema
}) {
  try {
    const value = import_secure_json_parse.default.parse(text23);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    const validationResult = safeValidateTypes({ value, schema });
    return validationResult.success ? { ...validationResult, rawValue: value } : validationResult;
  } catch (error) {
    return {
      success: false,
      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text: text23, cause: error })
    };
  }
}
var ignoreOverride2 = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions2 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions2 = (options) => typeof options === "string" ? {
  ...defaultOptions2,
  name: options
} : {
  ...defaultOptions2,
  ...options
};
var getRefs2 = (options) => {
  const _options = getDefaultOptions2(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name172, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name172],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function addErrorMessage2(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors2(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage2(res, key, errorMessage, refs);
}
var getRelativePath2 = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
function parseAnyDef2(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath2(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}
function parseArrayDef2(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef2(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors2(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors2(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors2(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors2(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
function parseBigintDef2(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors2(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors2(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors2(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors2(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors2(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors2(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors2(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function parseBooleanDef2() {
  return {
    type: "boolean"
  };
}
function parseBrandedDef2(_def, refs) {
  return parseDef2(_def.type._def, refs);
}
var parseCatchDef2 = (def, refs) => {
  return parseDef2(def.innerType._def, refs);
};
function parseDateDef2(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef2(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser2(def, refs);
  }
}
var integerDateParser2 = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors2(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors2(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};
function parseDefaultDef2(_def, refs) {
  return {
    ...parseDef2(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef2(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef2(_def.schema._def, refs) : parseAnyDef2(refs);
}
function parseEnumDef2(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType2 = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef2(def, refs) {
  const allOf = [
    parseDef2(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef2(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType2(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
function parseLiteralDef2(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex2 = void 0;
var zodPatterns2 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex2 === void 0) {
      emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex2;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef2(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors2(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors2(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat2(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat2(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern2(res, zodPatterns2.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat2(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat2(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern2(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern2(res, zodPatterns2.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern2(res, zodPatterns2.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern2(res, RegExp(`^${escapeLiteralCheckValue2(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern2(res, RegExp(`${escapeLiteralCheckValue2(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat2(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat2(res, "date", check.message, refs);
          break;
        case "time":
          addFormat2(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat2(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors2(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors2(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern2(res, RegExp(escapeLiteralCheckValue2(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat2(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat2(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern2(res, zodPatterns2.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern2(res, zodPatterns2.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern2(res, zodPatterns2.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern2(res, zodPatterns2.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern2(res, zodPatterns2.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern2(res, zodPatterns2.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat2(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors2(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern2(res, zodPatterns2.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern2(res, zodPatterns2.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue2(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric2(literal) : literal;
}
var ALPHA_NUMERIC2 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric2(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC2.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat2(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors2(schema, "format", value, message, refs);
  }
}
function addPattern2(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags2(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors2(schema, "pattern", stringifyRegExpWithFlags2(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags2(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  return pattern;
}
function parseRecordDef2(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef2(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef2(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef2(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef2(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef2(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef2(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef2(def, refs);
  }
  const keys = parseDef2(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef2(refs);
  const values = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef2(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef2(def) {
  const object23 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object23[object23[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object23[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef2(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef2({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}
function parseNullDef2(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
var primitiveMappings2 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef2(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf2(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings2 && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings2[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf2(def, refs);
}
var asAnyOf2 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef2(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef2(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings2[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings2[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef2(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef2(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef2(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage2(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors2(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors2(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors2(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors2(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors2(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors2(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors2(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function parseObjectDef2(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional2(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef2(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties2(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties2(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef2(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional2(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}
var parseOptionalDef2 = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef2(def.innerType._def, refs);
  }
  const innerSchema = parseDef2(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef2(refs)
      },
      innerSchema
    ]
  } : parseAnyDef2(refs);
};
var parsePipelineDef2 = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef2(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef2(def.out._def, refs);
  }
  const a = parseDef2(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef2(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef2(def, refs) {
  return parseDef2(def.type._def, refs);
}
function parseSetDef2(def, refs) {
  const items = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors2(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors2(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
function parseTupleDef2(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef2(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef2(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef2(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
function parseUndefinedDef2(refs) {
  return {
    not: parseAnyDef2(refs)
  };
}
function parseUnknownDef2(refs) {
  return parseAnyDef2(refs);
}
var parseReadonlyDef2 = (def, refs) => {
  return parseDef2(def.innerType._def, refs);
};
var selectParser2 = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef2();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef2(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef2(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef2(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef2(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef2(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef2(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef2(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
function parseDef2(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride2) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref2(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser2(def, def.typeName, refs);
  const jsonSchema23 = typeof jsonSchemaOrGetter === "function" ? parseDef2(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema23) {
    addMeta2(def, refs, jsonSchema23);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema23, def, refs);
    newItem.jsonSchema = jsonSchema23;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema23;
  return jsonSchema23;
}
var get$ref2 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath2(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef2(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef2(refs) : void 0;
    }
  }
};
var addMeta2 = (def, refs, jsonSchema23) => {
  if (def.description) {
    jsonSchema23.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema23.markdownDescription = def.description;
    }
  }
  return jsonSchema23;
};
var zodToJsonSchema22 = (schema, options) => {
  const refs = getRefs2(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name182, schema2]) => ({
    ...acc,
    [name182]: parseDef2(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name182]
    }, true) ?? parseAnyDef2(refs)
  }), {}) : void 0;
  const name172 = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main = parseDef2(schema._def, name172 === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name172]
  }, false) ?? parseAnyDef2(refs);
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name172 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name172
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name172]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};
var esm_default2 = zodToJsonSchema22;
function fixJson(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
function parsePartialJson(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = safeParseJSON({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = safeParseJSON({ text: fixJson(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
var textStreamPart2 = {
  code: "0",
  name: "text",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"text" parts expect a string value.');
    }
    return { type: "text", value };
  }
};
var dataStreamPart = {
  code: "2",
  name: "data",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"data" parts expect an array value.');
    }
    return { type: "data", value };
  }
};
var errorStreamPart2 = {
  code: "3",
  name: "error",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"error" parts expect a string value.');
    }
    return { type: "error", value };
  }
};
var messageAnnotationsStreamPart = {
  code: "8",
  name: "message_annotations",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"message_annotations" parts expect an array value.');
    }
    return { type: "message_annotations", value };
  }
};
var toolCallStreamPart = {
  code: "9",
  name: "tool_call",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string" || !("args" in value) || typeof value.args !== "object") {
      throw new Error(
        '"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.'
      );
    }
    return {
      type: "tool_call",
      value
    };
  }
};
var toolResultStreamPart = {
  code: "a",
  name: "tool_result",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("result" in value)) {
      throw new Error(
        '"tool_result" parts expect an object with a "toolCallId" and a "result" property.'
      );
    }
    return {
      type: "tool_result",
      value
    };
  }
};
var toolCallStreamingStartStreamPart = {
  code: "b",
  name: "tool_call_streaming_start",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string") {
      throw new Error(
        '"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.'
      );
    }
    return {
      type: "tool_call_streaming_start",
      value
    };
  }
};
var toolCallDeltaStreamPart = {
  code: "c",
  name: "tool_call_delta",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("argsTextDelta" in value) || typeof value.argsTextDelta !== "string") {
      throw new Error(
        '"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.'
      );
    }
    return {
      type: "tool_call_delta",
      value
    };
  }
};
var finishMessageStreamPart = {
  code: "d",
  name: "finish_message",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_message" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    return {
      type: "finish_message",
      value: result
    };
  }
};
var finishStepStreamPart = {
  code: "e",
  name: "finish_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_step" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason,
      isContinued: false
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    if ("isContinued" in value && typeof value.isContinued === "boolean") {
      result.isContinued = value.isContinued;
    }
    return {
      type: "finish_step",
      value: result
    };
  }
};
var startStepStreamPart = {
  code: "f",
  name: "start_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("messageId" in value) || typeof value.messageId !== "string") {
      throw new Error(
        '"start_step" parts expect an object with an "id" property.'
      );
    }
    return {
      type: "start_step",
      value: {
        messageId: value.messageId
      }
    };
  }
};
var reasoningStreamPart = {
  code: "g",
  name: "reasoning",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"reasoning" parts expect a string value.');
    }
    return { type: "reasoning", value };
  }
};
var sourcePart = {
  code: "h",
  name: "source",
  parse: (value) => {
    if (value == null || typeof value !== "object") {
      throw new Error('"source" parts expect a Source object.');
    }
    return {
      type: "source",
      value
    };
  }
};
var redactedReasoningStreamPart = {
  code: "i",
  name: "redacted_reasoning",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string") {
      throw new Error(
        '"redacted_reasoning" parts expect an object with a "data" property.'
      );
    }
    return { type: "redacted_reasoning", value: { data: value.data } };
  }
};
var reasoningSignatureStreamPart = {
  code: "j",
  name: "reasoning_signature",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("signature" in value) || typeof value.signature !== "string") {
      throw new Error(
        '"reasoning_signature" parts expect an object with a "signature" property.'
      );
    }
    return {
      type: "reasoning_signature",
      value: { signature: value.signature }
    };
  }
};
var fileStreamPart = {
  code: "k",
  name: "file",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string" || !("mimeType" in value) || typeof value.mimeType !== "string") {
      throw new Error(
        '"file" parts expect an object with a "data" and "mimeType" property.'
      );
    }
    return { type: "file", value };
  }
};
var dataStreamParts = [
  textStreamPart2,
  dataStreamPart,
  errorStreamPart2,
  messageAnnotationsStreamPart,
  toolCallStreamPart,
  toolResultStreamPart,
  toolCallStreamingStartStreamPart,
  toolCallDeltaStreamPart,
  finishMessageStreamPart,
  finishStepStreamPart,
  startStepStreamPart,
  reasoningStreamPart,
  sourcePart,
  redactedReasoningStreamPart,
  reasoningSignatureStreamPart,
  fileStreamPart
];
Object.fromEntries(
  dataStreamParts.map((part) => [part.code, part])
);
Object.fromEntries(
  dataStreamParts.map((part) => [part.name, part.code])
);
function formatDataStreamPart(type, value) {
  const streamPart = dataStreamParts.find((part) => part.name === type);
  if (!streamPart) {
    throw new Error(`Invalid stream part type: ${type}`);
  }
  return `${streamPart.code}:${JSON.stringify(value)}
`;
}
function zodSchema(zodSchema23, options) {
  var _a172;
  const useReferences = (_a172 = void 0) != null ? _a172 : false;
  return jsonSchema(
    esm_default2(zodSchema23, {
      $refStrategy: useReferences ? "root" : "none",
      target: "jsonSchema7"
      // note: openai mode breaks various gemini conversions
    }),
    {
      validate: (value) => {
        const result = zodSchema23.safeParse(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
var schemaSymbol = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema23, {
  validate
} = {}) {
  return {
    [schemaSymbol]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol]: true,
    jsonSchema: jsonSchema23,
    validate
  };
}
function isSchema(value) {
  return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema(schema) {
  return isSchema(schema) ? schema : zodSchema(schema);
}
var _globalThis = typeof globalThis === "object" ? globalThis : global;
var VERSION = "1.9.0";
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible23(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible = _makeCompatibilityCheck(VERSION);
var major = VERSION.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis;
function registerGlobal(type, instance, diag, allowOverride) {
  var _a172;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a172 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a172 !== void 0 ? _a172 : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a172, _b10;
  var globalVersion = (_a172 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a172 === void 0 ? void 0 : _a172.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b10 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b10 === void 0 ? void 0 : _b10[type];
}
function unregisterGlobal(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger = (
  /** @class */
  (function() {
    function DiagComponentLogger23(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger23.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("debug", this._namespace, args);
    };
    DiagComponentLogger23.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("error", this._namespace, args);
    };
    DiagComponentLogger23.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("info", this._namespace, args);
    };
    DiagComponentLogger23.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("warn", this._namespace, args);
    };
    DiagComponentLogger23.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("verbose", this._namespace, args);
    };
    return DiagComponentLogger23;
  })()
);
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}
var DiagLogLevel;
(function(DiagLogLevel23) {
  DiagLogLevel23[DiagLogLevel23["NONE"] = 0] = "NONE";
  DiagLogLevel23[DiagLogLevel23["ERROR"] = 30] = "ERROR";
  DiagLogLevel23[DiagLogLevel23["WARN"] = 50] = "WARN";
  DiagLogLevel23[DiagLogLevel23["INFO"] = 60] = "INFO";
  DiagLogLevel23[DiagLogLevel23["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel23[DiagLogLevel23["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel23[DiagLogLevel23["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME = "diag";
var DiagAPI = (
  /** @class */
  (function() {
    function DiagAPI23() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger = getGlobal("diag");
          if (!logger)
            return;
          return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
        };
      }
      var self = this;
      var setLogger = function(logger, optionsOrLogLevel) {
        var _a172, _b10, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
        }
        if (logger === self) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a172 = err.stack) !== null && _a172 !== void 0 ? _a172 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal("diag");
        var newLogger = createLogLevelDiagLogger((_b10 = optionsOrLogLevel.logLevel) !== null && _b10 !== void 0 ? _b10 : DiagLogLevel.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = function() {
        unregisterGlobal(API_NAME, self);
      };
      self.createComponentLogger = function(options) {
        return new DiagComponentLogger(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    DiagAPI23.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI23();
      }
      return this._instance;
    };
    return DiagAPI23;
  })()
);
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BaseContext23(parentContext) {
      var self = this;
      self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self.getValue = function(key) {
        return self._currentContext.get(key);
      };
      self.setValue = function(key, value) {
        var context2 = new BaseContext23(self._currentContext);
        context2._currentContext.set(key, value);
        return context2;
      };
      self.deleteValue = function(key) {
        var context2 = new BaseContext23(self._currentContext);
        context2._currentContext.delete(key);
        return context2;
      };
    }
    return BaseContext23;
  })()
);
var ROOT_CONTEXT = new BaseContext();
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = (
  /** @class */
  (function() {
    function NoopContextManager23() {
    }
    NoopContextManager23.prototype.active = function() {
      return ROOT_CONTEXT;
    };
    NoopContextManager23.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray3([thisArg], __read3(args), false));
    };
    NoopContextManager23.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager23.prototype.enable = function() {
      return this;
    };
    NoopContextManager23.prototype.disable = function() {
      return this;
    };
    return NoopContextManager23;
  })()
);
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME2 = "context";
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
var ContextAPI = (
  /** @class */
  (function() {
    function ContextAPI23() {
    }
    ContextAPI23.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI23();
      }
      return this._instance;
    };
    ContextAPI23.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
    };
    ContextAPI23.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI23.prototype.with = function(context2, fn, thisArg) {
      var _a172;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a172 = this._getContextManager()).with.apply(_a172, __spreadArray4([context2, fn, thisArg], __read4(args), false));
    };
    ContextAPI23.prototype.bind = function(context2, target) {
      return this._getContextManager().bind(context2, target);
    };
    ContextAPI23.prototype._getContextManager = function() {
      return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
    };
    ContextAPI23.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal(API_NAME2, DiagAPI.instance());
    };
    return ContextAPI23;
  })()
);
var TraceFlags;
(function(TraceFlags23) {
  TraceFlags23[TraceFlags23["NONE"] = 0] = "NONE";
  TraceFlags23[TraceFlags23["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));
var INVALID_SPANID = "0000000000000000";
var INVALID_TRACEID = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT = {
  traceId: INVALID_TRACEID,
  spanId: INVALID_SPANID,
  traceFlags: TraceFlags.NONE
};
var NonRecordingSpan = (
  /** @class */
  (function() {
    function NonRecordingSpan23(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan23.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan23.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan23.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan23.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan23.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan23.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan23.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan23.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan23.prototype.end = function(_endTime) {
    };
    NonRecordingSpan23.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan23.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan23;
  })()
);
var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a172;
  return (_a172 = getSpan(context2)) === null || _a172 === void 0 ? void 0 : _a172.spanContext();
}
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var contextApi = ContextAPI.getInstance();
var NoopTracer = (
  /** @class */
  (function() {
    function NoopTracer23() {
    }
    NoopTracer23.prototype.startSpan = function(name172, options, context2) {
      if (context2 === void 0) {
        context2 = contextApi.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan();
      }
      var parentFromContext = context2 && getSpanContext(context2);
      if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
        return new NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan();
      }
    };
    NoopTracer23.prototype.startActiveSpan = function(name172, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
      var span = this.startSpan(name172, opts, parentContext);
      var contextWithSpanSet = setSpan(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer23;
  })()
);
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER = new NoopTracer();
var ProxyTracer = (
  /** @class */
  (function() {
    function ProxyTracer23(_provider, name172, version, options) {
      this._provider = _provider;
      this.name = name172;
      this.version = version;
      this.options = options;
    }
    ProxyTracer23.prototype.startSpan = function(name172, options, context2) {
      return this._getTracer().startSpan(name172, options, context2);
    };
    ProxyTracer23.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer23.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer23;
  })()
);
var NoopTracerProvider = (
  /** @class */
  (function() {
    function NoopTracerProvider23() {
    }
    NoopTracerProvider23.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer();
    };
    return NoopTracerProvider23;
  })()
);
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
var ProxyTracerProvider = (
  /** @class */
  (function() {
    function ProxyTracerProvider23() {
    }
    ProxyTracerProvider23.prototype.getTracer = function(name172, version, options) {
      var _a172;
      return (_a172 = this.getDelegateTracer(name172, version, options)) !== null && _a172 !== void 0 ? _a172 : new ProxyTracer(this, name172, version, options);
    };
    ProxyTracerProvider23.prototype.getDelegate = function() {
      var _a172;
      return (_a172 = this._delegate) !== null && _a172 !== void 0 ? _a172 : NOOP_TRACER_PROVIDER;
    };
    ProxyTracerProvider23.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider23.prototype.getDelegateTracer = function(name172, version, options) {
      var _a172;
      return (_a172 = this._delegate) === null || _a172 === void 0 ? void 0 : _a172.getTracer(name172, version, options);
    };
    return ProxyTracerProvider23;
  })()
);
var SpanStatusCode;
(function(SpanStatusCode23) {
  SpanStatusCode23[SpanStatusCode23["UNSET"] = 0] = "UNSET";
  SpanStatusCode23[SpanStatusCode23["OK"] = 1] = "OK";
  SpanStatusCode23[SpanStatusCode23["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));
var API_NAME3 = "trace";
var TraceAPI = (
  /** @class */
  (function() {
    function TraceAPI23() {
      this._proxyTracerProvider = new ProxyTracerProvider();
      this.wrapSpanContext = wrapSpanContext;
      this.isSpanContextValid = isSpanContextValid;
      this.deleteSpan = deleteSpan;
      this.getSpan = getSpan;
      this.getActiveSpan = getActiveSpan;
      this.getSpanContext = getSpanContext;
      this.setSpan = setSpan;
      this.setSpanContext = setSpanContext;
    }
    TraceAPI23.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI23();
      }
      return this._instance;
    };
    TraceAPI23.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI23.prototype.getTracerProvider = function() {
      return getGlobal(API_NAME3) || this._proxyTracerProvider;
    };
    TraceAPI23.prototype.getTracer = function(name172, version) {
      return this.getTracerProvider().getTracer(name172, version);
    };
    TraceAPI23.prototype.disable = function() {
      unregisterGlobal(API_NAME3, DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI23;
  })()
);
TraceAPI.getInstance();
var __defProp22 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name172 in all)
    __defProp22(target, name172, { get: all[name172], enumerable: true });
};
function prepareResponseHeaders(headers, {
  contentType,
  dataStreamVersion
}) {
  const responseHeaders = new Headers(headers != null ? headers : {});
  if (!responseHeaders.has("Content-Type")) {
    responseHeaders.set("Content-Type", contentType);
  }
  {
    responseHeaders.set("X-Vercel-AI-Data-Stream", dataStreamVersion);
  }
  return responseHeaders;
}
var name42 = "AI_NoObjectGeneratedError";
var marker42 = `vercel.ai.error.${name42}`;
var symbol42 = Symbol.for(marker42);
var _a42;
var NoObjectGeneratedError = class extends AISDKError {
  constructor({
    message = "No object generated.",
    cause,
    text: text23,
    response,
    usage,
    finishReason
  }) {
    super({ name: name42, message, cause });
    this[_a42] = true;
    this.text = text23;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker42);
  }
};
_a42 = symbol42;
var dataContentSchema = z.union([
  z.string(),
  z.instanceof(Uint8Array),
  z.instanceof(ArrayBuffer),
  z.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a172, _b10;
      return (_b10 = (_a172 = globalThis.Buffer) == null ? void 0 : _a172.isBuffer(value)) != null ? _b10 : false;
    },
    { message: "Must be a Buffer" }
  )
]);
var jsonValueSchema = z.lazy(
  () => z.union([
    z.null(),
    z.string(),
    z.number(),
    z.boolean(),
    z.record(z.string(), jsonValueSchema),
    z.array(jsonValueSchema)
  ])
);
var providerMetadataSchema = z.record(
  z.string(),
  z.record(z.string(), jsonValueSchema)
);
var toolResultContentSchema = z.array(
  z.union([
    z.object({ type: z.literal("text"), text: z.string() }),
    z.object({
      type: z.literal("image"),
      data: z.string(),
      mimeType: z.string().optional()
    })
  ])
);
var textPartSchema = z.object({
  type: z.literal("text"),
  text: z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var imagePartSchema = z.object({
  type: z.literal("image"),
  image: z.union([dataContentSchema, z.instanceof(URL)]),
  mimeType: z.string().optional(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var filePartSchema = z.object({
  type: z.literal("file"),
  data: z.union([dataContentSchema, z.instanceof(URL)]),
  filename: z.string().optional(),
  mimeType: z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var reasoningPartSchema = z.object({
  type: z.literal("reasoning"),
  text: z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var redactedReasoningPartSchema = z.object({
  type: z.literal("redacted-reasoning"),
  data: z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var toolCallPartSchema = z.object({
  type: z.literal("tool-call"),
  toolCallId: z.string(),
  toolName: z.string(),
  args: z.unknown(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var toolResultPartSchema = z.object({
  type: z.literal("tool-result"),
  toolCallId: z.string(),
  toolName: z.string(),
  result: z.unknown(),
  content: toolResultContentSchema.optional(),
  isError: z.boolean().optional(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreSystemMessageSchema = z.object({
  role: z.literal("system"),
  content: z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreUserMessageSchema = z.object({
  role: z.literal("user"),
  content: z.union([
    z.string(),
    z.array(z.union([textPartSchema, imagePartSchema, filePartSchema]))
  ]),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreAssistantMessageSchema = z.object({
  role: z.literal("assistant"),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        textPartSchema,
        filePartSchema,
        reasoningPartSchema,
        redactedReasoningPartSchema,
        toolCallPartSchema
      ])
    )
  ]),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreToolMessageSchema = z.object({
  role: z.literal("tool"),
  content: z.array(toolResultPartSchema),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
z.union([
  coreSystemMessageSchema,
  coreUserMessageSchema,
  coreAssistantMessageSchema,
  coreToolMessageSchema
]);
var DEFAULT_SCHEMA_PREFIX = "JSON schema:";
var DEFAULT_SCHEMA_SUFFIX = "You MUST answer with a JSON object that matches the JSON schema above.";
var DEFAULT_GENERIC_SUFFIX = "You MUST answer with JSON.";
function injectJsonInstruction({
  prompt,
  schema,
  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,
  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX
}) {
  return [
    prompt != null && prompt.length > 0 ? prompt : void 0,
    prompt != null && prompt.length > 0 ? "" : void 0,
    // add a newline if prompt is not null
    schemaPrefix,
    schema != null ? JSON.stringify(schema) : void 0,
    schemaSuffix
  ].filter((line) => line != null).join("\n");
}
createIdGenerator({ prefix: "aiobj", size: 24 });
createIdGenerator({ prefix: "aiobj", size: 24 });
createIdGenerator({
  prefix: "aitxt",
  size: 24
});
createIdGenerator({
  prefix: "msg",
  size: 24
});
var output_exports = {};
__export2(output_exports, {
  object: () => object,
  text: () => text
});
var text = () => ({
  type: "text",
  responseFormat: () => ({ type: "text" }),
  injectIntoSystemPrompt({ system }) {
    return system;
  },
  parsePartial({ text: text23 }) {
    return { partial: text23 };
  },
  parseOutput({ text: text23 }) {
    return text23;
  }
});
var object = ({
  schema: inputSchema
}) => {
  const schema = asSchema(inputSchema);
  return {
    type: "object",
    responseFormat: ({ model }) => ({
      type: "json",
      schema: model.supportsStructuredOutputs ? schema.jsonSchema : void 0
    }),
    injectIntoSystemPrompt({ system, model }) {
      return model.supportsStructuredOutputs ? system : injectJsonInstruction({
        prompt: system,
        schema: schema.jsonSchema
      });
    },
    parsePartial({ text: text23 }) {
      const result = parsePartialJson(text23);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    parseOutput({ text: text23 }, context2) {
      const parseResult = safeParseJSON({ text: text23 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text23,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      const validationResult = safeValidateTypes({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text23,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      return validationResult.value;
    }
  };
};
function mergeStreams(stream1, stream2) {
  const reader1 = stream1.getReader();
  const reader2 = stream2.getReader();
  let lastRead1 = void 0;
  let lastRead2 = void 0;
  let stream1Done = false;
  let stream2Done = false;
  async function readStream1(controller) {
    try {
      if (lastRead1 == null) {
        lastRead1 = reader1.read();
      }
      const result = await lastRead1;
      lastRead1 = void 0;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error) {
      controller.error(error);
    }
  }
  async function readStream2(controller) {
    try {
      if (lastRead2 == null) {
        lastRead2 = reader2.read();
      }
      const result = await lastRead2;
      lastRead2 = void 0;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error) {
      controller.error(error);
    }
  }
  return new ReadableStream({
    async pull(controller) {
      try {
        if (stream1Done) {
          await readStream2(controller);
          return;
        }
        if (stream2Done) {
          await readStream1(controller);
          return;
        }
        if (lastRead1 == null) {
          lastRead1 = reader1.read();
        }
        if (lastRead2 == null) {
          lastRead2 = reader2.read();
        }
        const { result, reader } = await Promise.race([
          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),
          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))
        ]);
        if (!result.done) {
          controller.enqueue(result.value);
        }
        if (reader === reader1) {
          lastRead1 = void 0;
          if (result.done) {
            await readStream2(controller);
            stream1Done = true;
          }
        } else {
          lastRead2 = void 0;
          if (result.done) {
            stream2Done = true;
            await readStream1(controller);
          }
        }
      } catch (error) {
        controller.error(error);
      }
    },
    cancel() {
      reader1.cancel();
      reader2.cancel();
    }
  });
}
createIdGenerator({
  prefix: "aitxt",
  size: 24
});
createIdGenerator({
  prefix: "msg",
  size: 24
});
var ClientOrServerImplementationSchema = z.object({
  name: z.string(),
  version: z.string()
}).passthrough();
var BaseParamsSchema = z.object({
  _meta: z.optional(z.object({}).passthrough())
}).passthrough();
var ResultSchema = BaseParamsSchema;
var RequestSchema = z.object({
  method: z.string(),
  params: z.optional(BaseParamsSchema)
});
var ServerCapabilitiesSchema = z.object({
  experimental: z.optional(z.object({}).passthrough()),
  logging: z.optional(z.object({}).passthrough()),
  prompts: z.optional(
    z.object({
      listChanged: z.optional(z.boolean())
    }).passthrough()
  ),
  resources: z.optional(
    z.object({
      subscribe: z.optional(z.boolean()),
      listChanged: z.optional(z.boolean())
    }).passthrough()
  ),
  tools: z.optional(
    z.object({
      listChanged: z.optional(z.boolean())
    }).passthrough()
  )
}).passthrough();
ResultSchema.extend({
  protocolVersion: z.string(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ClientOrServerImplementationSchema,
  instructions: z.optional(z.string())
});
var PaginatedResultSchema = ResultSchema.extend({
  nextCursor: z.optional(z.string())
});
var ToolSchema = z.object({
  name: z.string(),
  description: z.optional(z.string()),
  inputSchema: z.object({
    type: z.literal("object"),
    properties: z.optional(z.object({}).passthrough())
  }).passthrough()
}).passthrough();
PaginatedResultSchema.extend({
  tools: z.array(ToolSchema)
});
var TextContentSchema = z.object({
  type: z.literal("text"),
  text: z.string()
}).passthrough();
var ImageContentSchema = z.object({
  type: z.literal("image"),
  data: z.string().base64(),
  mimeType: z.string()
}).passthrough();
var ResourceContentsSchema = z.object({
  /**
   * The URI of this resource.
   */
  uri: z.string(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: z.optional(z.string())
}).passthrough();
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  text: z.string()
});
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  blob: z.string().base64()
});
var EmbeddedResourceSchema = z.object({
  type: z.literal("resource"),
  resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema])
}).passthrough();
ResultSchema.extend({
  content: z.array(
    z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])
  ),
  isError: z.boolean().default(false).optional()
}).or(
  ResultSchema.extend({
    toolResult: z.unknown()
  })
);
var JSONRPC_VERSION = "2.0";
var JSONRPCRequestSchema = z.object({
  jsonrpc: z.literal(JSONRPC_VERSION),
  id: z.union([z.string(), z.number().int()])
}).merge(RequestSchema).strict();
var JSONRPCResponseSchema = z.object({
  jsonrpc: z.literal(JSONRPC_VERSION),
  id: z.union([z.string(), z.number().int()]),
  result: ResultSchema
}).strict();
var JSONRPCErrorSchema = z.object({
  jsonrpc: z.literal(JSONRPC_VERSION),
  id: z.union([z.string(), z.number().int()]),
  error: z.object({
    code: z.number().int(),
    message: z.string(),
    data: z.optional(z.unknown())
  })
}).strict();
var JSONRPCNotificationSchema = z.object({
  jsonrpc: z.literal(JSONRPC_VERSION)
}).merge(
  z.object({
    method: z.string(),
    params: z.optional(BaseParamsSchema)
  })
).strict();
z.union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResponseSchema,
  JSONRPCErrorSchema
]);
var langchain_adapter_exports = {};
__export2(langchain_adapter_exports, {
  mergeIntoDataStream: () => mergeIntoDataStream,
  toDataStream: () => toDataStream,
  toDataStreamResponse: () => toDataStreamResponse
});
function createCallbacksTransformer(callbacks = {}) {
  const textEncoder = new TextEncoder();
  let aggregatedResponse = "";
  return new TransformStream({
    async start() {
      if (callbacks.onStart)
        await callbacks.onStart();
    },
    async transform(message, controller) {
      controller.enqueue(textEncoder.encode(message));
      aggregatedResponse += message;
      if (callbacks.onToken)
        await callbacks.onToken(message);
      if (callbacks.onText && typeof message === "string") {
        await callbacks.onText(message);
      }
    },
    async flush() {
      if (callbacks.onCompletion) {
        await callbacks.onCompletion(aggregatedResponse);
      }
      if (callbacks.onFinal) {
        await callbacks.onFinal(aggregatedResponse);
      }
    }
  });
}
function toDataStreamInternal(stream, callbacks) {
  return stream.pipeThrough(
    new TransformStream({
      transform: async (value, controller) => {
        var _a172;
        if (typeof value === "string") {
          controller.enqueue(value);
          return;
        }
        if ("event" in value) {
          if (value.event === "on_chat_model_stream") {
            forwardAIMessageChunk(
              (_a172 = value.data) == null ? void 0 : _a172.chunk,
              controller
            );
          }
          return;
        }
        forwardAIMessageChunk(value, controller);
      }
    })
  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(
    new TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(formatDataStreamPart("text", chunk));
      }
    })
  );
}
function toDataStream(stream, callbacks) {
  return toDataStreamInternal(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
}
function toDataStreamResponse(stream, options) {
  var _a172;
  const dataStream = toDataStreamInternal(
    stream,
    options == null ? void 0 : options.callbacks
  ).pipeThrough(new TextEncoderStream());
  const data = options == null ? void 0 : options.data;
  const init = options == null ? void 0 : options.init;
  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
    statusText: init == null ? void 0 : init.statusText,
    headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
function mergeIntoDataStream(stream, options) {
  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));
}
function forwardAIMessageChunk(chunk, controller) {
  if (typeof chunk.content === "string") {
    controller.enqueue(chunk.content);
  } else {
    const content = chunk.content;
    for (const item of content) {
      if (item.type === "text") {
        controller.enqueue(item.text);
      }
    }
  }
}
var llamaindex_adapter_exports = {};
__export2(llamaindex_adapter_exports, {
  mergeIntoDataStream: () => mergeIntoDataStream2,
  toDataStream: () => toDataStream2,
  toDataStreamResponse: () => toDataStreamResponse2
});
function toDataStreamInternal2(stream, callbacks) {
  const trimStart = trimStartOfStream();
  return convertAsyncIteratorToReadableStream(stream[Symbol.asyncIterator]()).pipeThrough(
    new TransformStream({
      async transform(message, controller) {
        controller.enqueue(trimStart(message.delta));
      }
    })
  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(
    new TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(formatDataStreamPart("text", chunk));
      }
    })
  );
}
function toDataStream2(stream, callbacks) {
  return toDataStreamInternal2(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
}
function toDataStreamResponse2(stream, options = {}) {
  var _a172;
  const { init, data, callbacks } = options;
  const dataStream = toDataStreamInternal2(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
    statusText: init == null ? void 0 : init.statusText,
    headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
function mergeIntoDataStream2(stream, options) {
  options.dataStream.merge(toDataStreamInternal2(stream, options.callbacks));
}
function trimStartOfStream() {
  let isStreamStart = true;
  return (text23) => {
    if (isStreamStart) {
      text23 = text23.trimStart();
      if (text23)
        isStreamStart = false;
    }
    return text23;
  };
}
function isZodType(value) {
  return typeof value === "object" && value !== null && ("_def" in value || "_zod" in value) && "parse" in value && typeof value.parse === "function" && "safeParse" in value && typeof value.safeParse === "function";
}
function convertSchemaToZod(schema) {
  if (isZodType(schema)) {
    return schema;
  } else {
    const jsonSchemaToConvert = "jsonSchema" in schema ? schema.jsonSchema : schema;
    try {
      if ("toJSONSchema" in z) {
        return convertJsonSchemaToZod(jsonSchemaToConvert);
      } else {
        return convertJsonSchemaToZod2(jsonSchemaToConvert);
      }
    } catch (e2) {
      const errorMessage = `[Schema Builder] Failed to convert schema parameters to Zod. Original schema: ${JSON.stringify(jsonSchemaToConvert)}`;
      console.error(errorMessage, e2);
      throw new Error(errorMessage + (e2 instanceof Error ? `
${e2.stack}` : "\nUnknown error object"));
    }
  }
}
__toESM5(require_json_schema_traverse());
var __create3 = Object.create;
var __defProp3 = Object.defineProperty;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames3 = Object.getOwnPropertyNames;
var __getProtoOf3 = Object.getPrototypeOf;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __commonJS32 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames3(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps3 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames3(from))
      if (!__hasOwnProp3.call(to, key) && key !== except)
        __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM32 = (mod, isNodeMode, target) => (target = mod != null ? __create3(__getProtoOf3(mod)) : {}, __copyProps3(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp3(target, "default", { value: mod, enumerable: true }),
  mod
));
var require_secure_json_parse2 = __commonJS32({
  "../../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js"(exports$1, module) {
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx32 = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx32 = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse32(text42, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text42)) {
        text42 = text42.toString();
      }
      if (text42 && text42.charCodeAt(0) === 65279) {
        text42 = text42.slice(1);
      }
      const obj = JSON.parse(text42, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx32.test(text42) === false && suspectConstructorRx32.test(text42) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx32.test(text42) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx32.test(text42) === false) {
          return obj;
        }
      }
      return filter32(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter32(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse(text42, reviver, options) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse32(text42, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse(text42, reviver) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse32(text42, reviver, { safe: true });
      } catch (_e) {
        return null;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module.exports = parse;
    module.exports.default = parse;
    module.exports.parse = parse;
    module.exports.safeParse = safeParse;
    module.exports.scan = filter32;
  }
});
var marker2 = "vercel.ai.error";
var symbol2 = Symbol.for(marker2);
var _a2;
var _AISDKError3 = class _AISDKError22 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name145,
    message,
    cause
  }) {
    super(message);
    this[_a2] = true;
    this.name = name145;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError22.hasMarker(error, marker2);
  }
  static hasMarker(error, marker155) {
    const markerSymbol = Symbol.for(marker155);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a2 = symbol2;
var AISDKError2 = _AISDKError3;
var name = "AI_APICallError";
var marker22 = `vercel.ai.error.${name}`;
var symbol22 = Symbol.for(marker22);
var _a22;
var APICallError = class extends AISDKError2 {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name, message, cause });
    this[_a22] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker22);
  }
};
_a22 = symbol22;
function getErrorMessage2(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name32 = "AI_InvalidArgumentError";
var marker43 = `vercel.ai.error.${name32}`;
var symbol43 = Symbol.for(marker43);
var _a43;
var InvalidArgumentError2 = class extends AISDKError2 {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name32, message, cause });
    this[_a43] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker43);
  }
};
_a43 = symbol43;
var name62 = "AI_JSONParseError";
var marker72 = `vercel.ai.error.${name62}`;
var symbol72 = Symbol.for(marker72);
var _a72;
var JSONParseError2 = class extends AISDKError2 {
  constructor({ text: text42, cause }) {
    super({
      name: name62,
      message: `JSON parsing failed: Text: ${text42}.
Error message: ${getErrorMessage2(cause)}`,
      cause
    });
    this[_a72] = true;
    this.text = text42;
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker72);
  }
};
_a72 = symbol72;
var name122 = "AI_TypeValidationError";
var marker132 = `vercel.ai.error.${name122}`;
var symbol132 = Symbol.for(marker132);
var _a132;
var _TypeValidationError3 = class _TypeValidationError22 extends AISDKError2 {
  constructor({ value, cause }) {
    super({
      name: name122,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage2(cause)}`,
      cause
    });
    this[_a132] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker132);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError22.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError22({ value, cause });
  }
};
_a132 = symbol132;
var TypeValidationError2 = _TypeValidationError3;
var customAlphabet2 = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i = size | 0;
    while (i--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
var import_secure_json_parse2 = __toESM32(require_secure_json_parse2());
function convertAsyncIteratorToReadableStream2(iterator) {
  return new ReadableStream({
    /**
     * Called when the consumer wants to pull more data from the stream.
     *
     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.
     * @returns {Promise<void>}
     */
    async pull(controller) {
      try {
        const { value, done } = await iterator.next();
        if (done) {
          controller.close();
        } else {
          controller.enqueue(value);
        }
      } catch (error) {
        controller.error(error);
      }
    },
    /**
     * Called when the consumer cancels the stream.
     */
    cancel() {
    }
  });
}
async function delay(delayInMs) {
  return delayInMs == null ? Promise.resolve() : new Promise((resolve22) => setTimeout(resolve22, delayInMs));
}
var createIdGenerator2 = ({
  prefix,
  size: defaultSize = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = customAlphabet2(alphabet, defaultSize);
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError2({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return (size) => `${prefix}${separator}${generator(size)}`;
};
createIdGenerator2();
function getErrorMessage22(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
function isAbortError(error) {
  return error instanceof Error && (error.name === "AbortError" || error.name === "TimeoutError");
}
var validatorSymbol2 = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator2(validate) {
  return { [validatorSymbol2]: true, validate };
}
function isValidator2(value) {
  return typeof value === "object" && value !== null && validatorSymbol2 in value && value[validatorSymbol2] === true && "validate" in value;
}
function asValidator2(value) {
  return isValidator2(value) ? value : zodValidator2(value);
}
function zodValidator2(zodSchema42) {
  return validator2((value) => {
    const result = zodSchema42.safeParse(value);
    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
  });
}
function safeValidateTypes2({
  value,
  schema
}) {
  const validator222 = asValidator2(schema);
  try {
    if (validator222.validate == null) {
      return { success: true, value };
    }
    const result = validator222.validate(value);
    if (result.success) {
      return result;
    }
    return {
      success: false,
      error: TypeValidationError2.wrap({ value, cause: result.error })
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError2.wrap({ value, cause: error })
    };
  }
}
function safeParseJSON2({
  text: text42,
  schema
}) {
  try {
    const value = import_secure_json_parse2.default.parse(text42);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    const validationResult = safeValidateTypes2({ value, schema });
    return validationResult.success ? { ...validationResult, rawValue: value } : validationResult;
  } catch (error) {
    return {
      success: false,
      error: JSONParseError2.isInstance(error) ? error : new JSONParseError2({ text: text42, cause: error })
    };
  }
}
var ignoreOverride3 = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions3 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions3 = (options) => typeof options === "string" ? {
  ...defaultOptions3,
  name: options
} : {
  ...defaultOptions3,
  ...options
};
var getRefs3 = (options) => {
  const _options = getDefaultOptions3(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name173, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name173],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function addErrorMessage3(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors3(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage3(res, key, errorMessage, refs);
}
var getRelativePath3 = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
function parseAnyDef3(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath3(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}
function parseArrayDef3(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef3(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors3(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors3(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors3(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors3(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
function parseBigintDef3(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors3(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors3(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors3(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors3(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors3(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors3(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors3(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function parseBooleanDef3() {
  return {
    type: "boolean"
  };
}
function parseBrandedDef3(_def, refs) {
  return parseDef3(_def.type._def, refs);
}
var parseCatchDef3 = (def, refs) => {
  return parseDef3(def.innerType._def, refs);
};
function parseDateDef3(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef3(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser3(def, refs);
  }
}
var integerDateParser3 = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors3(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors3(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};
function parseDefaultDef3(_def, refs) {
  return {
    ...parseDef3(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef3(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef3(_def.schema._def, refs) : parseAnyDef3(refs);
}
function parseEnumDef3(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType3 = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef3(def, refs) {
  const allOf = [
    parseDef3(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef3(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType3(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
function parseLiteralDef3(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex3 = void 0;
var zodPatterns3 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex3 === void 0) {
      emojiRegex3 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex3;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef3(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors3(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors3(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat3(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat3(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern3(res, zodPatterns3.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat3(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat3(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern3(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern3(res, zodPatterns3.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern3(res, zodPatterns3.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern3(res, RegExp(`^${escapeLiteralCheckValue3(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern3(res, RegExp(`${escapeLiteralCheckValue3(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat3(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat3(res, "date", check.message, refs);
          break;
        case "time":
          addFormat3(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat3(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors3(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors3(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern3(res, RegExp(escapeLiteralCheckValue3(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat3(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat3(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern3(res, zodPatterns3.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern3(res, zodPatterns3.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern3(res, zodPatterns3.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern3(res, zodPatterns3.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern3(res, zodPatterns3.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern3(res, zodPatterns3.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat3(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors3(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern3(res, zodPatterns3.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern3(res, zodPatterns3.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue3(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric3(literal) : literal;
}
var ALPHA_NUMERIC3 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric3(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC3.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat3(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors3(schema, "format", value, message, refs);
  }
}
function addPattern3(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags3(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors3(schema, "pattern", stringifyRegExpWithFlags3(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags3(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  return pattern;
}
function parseRecordDef3(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef3(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef3(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef3(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef3(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef3(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef3(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef3(def, refs);
  }
  const keys = parseDef3(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef3(refs);
  const values = parseDef3(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef3(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef3(def) {
  const object222 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object222[object222[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object222[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef3(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef3({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}
function parseNullDef3(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
var primitiveMappings3 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef3(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf3(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings3 && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings3[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf3(def, refs);
}
var asAnyOf3 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef3(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef3(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings3[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings3[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef3(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef3(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef3(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage3(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors3(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors3(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors3(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors3(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors3(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors3(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors3(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function parseObjectDef3(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional3(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef3(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties3(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties3(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef3(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional3(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}
var parseOptionalDef3 = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef3(def.innerType._def, refs);
  }
  const innerSchema = parseDef3(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef3(refs)
      },
      innerSchema
    ]
  } : parseAnyDef3(refs);
};
var parsePipelineDef3 = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef3(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef3(def.out._def, refs);
  }
  const a = parseDef3(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef3(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef3(def, refs) {
  return parseDef3(def.type._def, refs);
}
function parseSetDef3(def, refs) {
  const items = parseDef3(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors3(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors3(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
function parseTupleDef3(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef3(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef3(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef3(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
function parseUndefinedDef3(refs) {
  return {
    not: parseAnyDef3(refs)
  };
}
function parseUnknownDef3(refs) {
  return parseAnyDef3(refs);
}
var parseReadonlyDef3 = (def, refs) => {
  return parseDef3(def.innerType._def, refs);
};
var selectParser3 = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef3();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef3(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef3(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef3(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef3(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef3(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef3(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef3(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
function parseDef3(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride3) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref3(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser3(def, def.typeName, refs);
  const jsonSchema222 = typeof jsonSchemaOrGetter === "function" ? parseDef3(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema222) {
    addMeta3(def, refs, jsonSchema222);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema222, def, refs);
    newItem.jsonSchema = jsonSchema222;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema222;
  return jsonSchema222;
}
var get$ref3 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath3(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef3(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef3(refs) : void 0;
    }
  }
};
var addMeta3 = (def, refs, jsonSchema222) => {
  if (def.description) {
    jsonSchema222.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema222.markdownDescription = def.description;
    }
  }
  return jsonSchema222;
};
var zodToJsonSchema3 = (schema, options) => {
  const refs = getRefs3(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name183, schema2]) => ({
    ...acc,
    [name183]: parseDef3(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name183]
    }, true) ?? parseAnyDef3(refs)
  }), {}) : void 0;
  const name173 = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main = parseDef3(schema._def, name173 === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name173]
  }, false) ?? parseAnyDef3(refs);
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name173 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name173
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name173]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};
var esm_default3 = zodToJsonSchema3;
function fixJson2(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
function parsePartialJson2(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = safeParseJSON2({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = safeParseJSON2({ text: fixJson2(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
var textStreamPart22 = {
  code: "0",
  name: "text",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"text" parts expect a string value.');
    }
    return { type: "text", value };
  }
};
var dataStreamPart2 = {
  code: "2",
  name: "data",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"data" parts expect an array value.');
    }
    return { type: "data", value };
  }
};
var errorStreamPart22 = {
  code: "3",
  name: "error",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"error" parts expect a string value.');
    }
    return { type: "error", value };
  }
};
var messageAnnotationsStreamPart2 = {
  code: "8",
  name: "message_annotations",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"message_annotations" parts expect an array value.');
    }
    return { type: "message_annotations", value };
  }
};
var toolCallStreamPart2 = {
  code: "9",
  name: "tool_call",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string" || !("args" in value) || typeof value.args !== "object") {
      throw new Error(
        '"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.'
      );
    }
    return {
      type: "tool_call",
      value
    };
  }
};
var toolResultStreamPart2 = {
  code: "a",
  name: "tool_result",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("result" in value)) {
      throw new Error(
        '"tool_result" parts expect an object with a "toolCallId" and a "result" property.'
      );
    }
    return {
      type: "tool_result",
      value
    };
  }
};
var toolCallStreamingStartStreamPart2 = {
  code: "b",
  name: "tool_call_streaming_start",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string") {
      throw new Error(
        '"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.'
      );
    }
    return {
      type: "tool_call_streaming_start",
      value
    };
  }
};
var toolCallDeltaStreamPart2 = {
  code: "c",
  name: "tool_call_delta",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("argsTextDelta" in value) || typeof value.argsTextDelta !== "string") {
      throw new Error(
        '"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.'
      );
    }
    return {
      type: "tool_call_delta",
      value
    };
  }
};
var finishMessageStreamPart2 = {
  code: "d",
  name: "finish_message",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_message" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    return {
      type: "finish_message",
      value: result
    };
  }
};
var finishStepStreamPart2 = {
  code: "e",
  name: "finish_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_step" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason,
      isContinued: false
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    if ("isContinued" in value && typeof value.isContinued === "boolean") {
      result.isContinued = value.isContinued;
    }
    return {
      type: "finish_step",
      value: result
    };
  }
};
var startStepStreamPart2 = {
  code: "f",
  name: "start_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("messageId" in value) || typeof value.messageId !== "string") {
      throw new Error(
        '"start_step" parts expect an object with an "id" property.'
      );
    }
    return {
      type: "start_step",
      value: {
        messageId: value.messageId
      }
    };
  }
};
var reasoningStreamPart2 = {
  code: "g",
  name: "reasoning",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"reasoning" parts expect a string value.');
    }
    return { type: "reasoning", value };
  }
};
var sourcePart2 = {
  code: "h",
  name: "source",
  parse: (value) => {
    if (value == null || typeof value !== "object") {
      throw new Error('"source" parts expect a Source object.');
    }
    return {
      type: "source",
      value
    };
  }
};
var redactedReasoningStreamPart2 = {
  code: "i",
  name: "redacted_reasoning",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string") {
      throw new Error(
        '"redacted_reasoning" parts expect an object with a "data" property.'
      );
    }
    return { type: "redacted_reasoning", value: { data: value.data } };
  }
};
var reasoningSignatureStreamPart2 = {
  code: "j",
  name: "reasoning_signature",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("signature" in value) || typeof value.signature !== "string") {
      throw new Error(
        '"reasoning_signature" parts expect an object with a "signature" property.'
      );
    }
    return {
      type: "reasoning_signature",
      value: { signature: value.signature }
    };
  }
};
var fileStreamPart2 = {
  code: "k",
  name: "file",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string" || !("mimeType" in value) || typeof value.mimeType !== "string") {
      throw new Error(
        '"file" parts expect an object with a "data" and "mimeType" property.'
      );
    }
    return { type: "file", value };
  }
};
var dataStreamParts2 = [
  textStreamPart22,
  dataStreamPart2,
  errorStreamPart22,
  messageAnnotationsStreamPart2,
  toolCallStreamPart2,
  toolResultStreamPart2,
  toolCallStreamingStartStreamPart2,
  toolCallDeltaStreamPart2,
  finishMessageStreamPart2,
  finishStepStreamPart2,
  startStepStreamPart2,
  reasoningStreamPart2,
  sourcePart2,
  redactedReasoningStreamPart2,
  reasoningSignatureStreamPart2,
  fileStreamPart2
];
Object.fromEntries(
  dataStreamParts2.map((part) => [part.code, part])
);
Object.fromEntries(
  dataStreamParts2.map((part) => [part.name, part.code])
);
function formatDataStreamPart2(type, value) {
  const streamPart = dataStreamParts2.find((part) => part.name === type);
  if (!streamPart) {
    throw new Error(`Invalid stream part type: ${type}`);
  }
  return `${streamPart.code}:${JSON.stringify(value)}
`;
}
function zodSchema2(zodSchema222, options) {
  var _a173;
  const useReferences = (_a173 = void 0) != null ? _a173 : false;
  return jsonSchema2(
    esm_default3(zodSchema222, {
      $refStrategy: useReferences ? "root" : "none",
      target: "jsonSchema7"
      // note: openai mode breaks various gemini conversions
    }),
    {
      validate: (value) => {
        const result = zodSchema222.safeParse(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
var schemaSymbol2 = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function jsonSchema2(jsonSchema222, {
  validate
} = {}) {
  return {
    [schemaSymbol2]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol2]: true,
    jsonSchema: jsonSchema222,
    validate
  };
}
function isSchema2(value) {
  return typeof value === "object" && value !== null && schemaSymbol2 in value && value[schemaSymbol2] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema2(schema) {
  return isSchema2(schema) ? schema : zodSchema2(schema);
}
var _globalThis2 = typeof globalThis === "object" ? globalThis : global;
var VERSION2 = "1.9.0";
var re2 = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck2(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re2);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible222(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re2);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible2 = _makeCompatibilityCheck2(VERSION2);
var major2 = VERSION2.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY2 = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major2);
var _global2 = _globalThis2;
function registerGlobal2(type, instance, diag, allowOverride) {
  var _a173;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global2[GLOBAL_OPENTELEMETRY_API_KEY2] = (_a173 = _global2[GLOBAL_OPENTELEMETRY_API_KEY2]) !== null && _a173 !== void 0 ? _a173 : {
    version: VERSION2
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION2) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION2);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION2 + ".");
  return true;
}
function getGlobal2(type) {
  var _a173, _b17;
  var globalVersion = (_a173 = _global2[GLOBAL_OPENTELEMETRY_API_KEY2]) === null || _a173 === void 0 ? void 0 : _a173.version;
  if (!globalVersion || !isCompatible2(globalVersion)) {
    return;
  }
  return (_b17 = _global2[GLOBAL_OPENTELEMETRY_API_KEY2]) === null || _b17 === void 0 ? void 0 : _b17[type];
}
function unregisterGlobal2(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION2 + ".");
  var api = _global2[GLOBAL_OPENTELEMETRY_API_KEY2];
  if (api) {
    delete api[type];
  }
}
var __read5 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray5 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger2 = (
  /** @class */
  (function() {
    function DiagComponentLogger222(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger222.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy2("debug", this._namespace, args);
    };
    DiagComponentLogger222.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy2("error", this._namespace, args);
    };
    DiagComponentLogger222.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy2("info", this._namespace, args);
    };
    DiagComponentLogger222.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy2("warn", this._namespace, args);
    };
    DiagComponentLogger222.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy2("verbose", this._namespace, args);
    };
    return DiagComponentLogger222;
  })()
);
function logProxy2(funcName, namespace, args) {
  var logger = getGlobal2("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray5([], __read5(args), false));
}
var DiagLogLevel2;
(function(DiagLogLevel222) {
  DiagLogLevel222[DiagLogLevel222["NONE"] = 0] = "NONE";
  DiagLogLevel222[DiagLogLevel222["ERROR"] = 30] = "ERROR";
  DiagLogLevel222[DiagLogLevel222["WARN"] = 50] = "WARN";
  DiagLogLevel222[DiagLogLevel222["INFO"] = 60] = "INFO";
  DiagLogLevel222[DiagLogLevel222["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel222[DiagLogLevel222["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel222[DiagLogLevel222["ALL"] = 9999] = "ALL";
})(DiagLogLevel2 || (DiagLogLevel2 = {}));
function createLogLevelDiagLogger2(maxLevel, logger) {
  if (maxLevel < DiagLogLevel2.NONE) {
    maxLevel = DiagLogLevel2.NONE;
  } else if (maxLevel > DiagLogLevel2.ALL) {
    maxLevel = DiagLogLevel2.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel2.ERROR),
    warn: _filterFunc("warn", DiagLogLevel2.WARN),
    info: _filterFunc("info", DiagLogLevel2.INFO),
    debug: _filterFunc("debug", DiagLogLevel2.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel2.VERBOSE)
  };
}
var __read22 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray22 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME4 = "diag";
var DiagAPI2 = (
  /** @class */
  (function() {
    function DiagAPI222() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger = getGlobal2("diag");
          if (!logger)
            return;
          return logger[funcName].apply(logger, __spreadArray22([], __read22(args), false));
        };
      }
      var self = this;
      var setLogger = function(logger, optionsOrLogLevel) {
        var _a173, _b17, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel2.INFO };
        }
        if (logger === self) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a173 = err.stack) !== null && _a173 !== void 0 ? _a173 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal2("diag");
        var newLogger = createLogLevelDiagLogger2((_b17 = optionsOrLogLevel.logLevel) !== null && _b17 !== void 0 ? _b17 : DiagLogLevel2.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal2("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = function() {
        unregisterGlobal2(API_NAME4, self);
      };
      self.createComponentLogger = function(options) {
        return new DiagComponentLogger2(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    DiagAPI222.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI222();
      }
      return this._instance;
    };
    return DiagAPI222;
  })()
);
function createContextKey2(description) {
  return Symbol.for(description);
}
var BaseContext2 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BaseContext222(parentContext) {
      var self = this;
      self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self.getValue = function(key) {
        return self._currentContext.get(key);
      };
      self.setValue = function(key, value) {
        var context2 = new BaseContext222(self._currentContext);
        context2._currentContext.set(key, value);
        return context2;
      };
      self.deleteValue = function(key) {
        var context2 = new BaseContext222(self._currentContext);
        context2._currentContext.delete(key);
        return context2;
      };
    }
    return BaseContext222;
  })()
);
var ROOT_CONTEXT2 = new BaseContext2();
var __read32 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray32 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager2 = (
  /** @class */
  (function() {
    function NoopContextManager222() {
    }
    NoopContextManager222.prototype.active = function() {
      return ROOT_CONTEXT2;
    };
    NoopContextManager222.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray32([thisArg], __read32(args), false));
    };
    NoopContextManager222.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager222.prototype.enable = function() {
      return this;
    };
    NoopContextManager222.prototype.disable = function() {
      return this;
    };
    return NoopContextManager222;
  })()
);
var __read42 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray42 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME22 = "context";
var NOOP_CONTEXT_MANAGER2 = new NoopContextManager2();
var ContextAPI2 = (
  /** @class */
  (function() {
    function ContextAPI222() {
    }
    ContextAPI222.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI222();
      }
      return this._instance;
    };
    ContextAPI222.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal2(API_NAME22, contextManager, DiagAPI2.instance());
    };
    ContextAPI222.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI222.prototype.with = function(context2, fn, thisArg) {
      var _a173;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a173 = this._getContextManager()).with.apply(_a173, __spreadArray42([context2, fn, thisArg], __read42(args), false));
    };
    ContextAPI222.prototype.bind = function(context2, target) {
      return this._getContextManager().bind(context2, target);
    };
    ContextAPI222.prototype._getContextManager = function() {
      return getGlobal2(API_NAME22) || NOOP_CONTEXT_MANAGER2;
    };
    ContextAPI222.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal2(API_NAME22, DiagAPI2.instance());
    };
    return ContextAPI222;
  })()
);
var TraceFlags2;
(function(TraceFlags222) {
  TraceFlags222[TraceFlags222["NONE"] = 0] = "NONE";
  TraceFlags222[TraceFlags222["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags2 || (TraceFlags2 = {}));
var INVALID_SPANID2 = "0000000000000000";
var INVALID_TRACEID2 = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT2 = {
  traceId: INVALID_TRACEID2,
  spanId: INVALID_SPANID2,
  traceFlags: TraceFlags2.NONE
};
var NonRecordingSpan2 = (
  /** @class */
  (function() {
    function NonRecordingSpan222(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT2;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan222.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan222.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan222.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan222.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan222.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan222.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan222.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan222.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan222.prototype.end = function(_endTime) {
    };
    NonRecordingSpan222.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan222.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan222;
  })()
);
var SPAN_KEY2 = createContextKey2("OpenTelemetry Context Key SPAN");
function getSpan2(context2) {
  return context2.getValue(SPAN_KEY2) || void 0;
}
function getActiveSpan2() {
  return getSpan2(ContextAPI2.getInstance().active());
}
function setSpan2(context2, span) {
  return context2.setValue(SPAN_KEY2, span);
}
function deleteSpan2(context2) {
  return context2.deleteValue(SPAN_KEY2);
}
function setSpanContext2(context2, spanContext) {
  return setSpan2(context2, new NonRecordingSpan2(spanContext));
}
function getSpanContext2(context2) {
  var _a173;
  return (_a173 = getSpan2(context2)) === null || _a173 === void 0 ? void 0 : _a173.spanContext();
}
var VALID_TRACEID_REGEX2 = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX2 = /^[0-9a-f]{16}$/i;
function isValidTraceId2(traceId) {
  return VALID_TRACEID_REGEX2.test(traceId) && traceId !== INVALID_TRACEID2;
}
function isValidSpanId2(spanId) {
  return VALID_SPANID_REGEX2.test(spanId) && spanId !== INVALID_SPANID2;
}
function isSpanContextValid2(spanContext) {
  return isValidTraceId2(spanContext.traceId) && isValidSpanId2(spanContext.spanId);
}
function wrapSpanContext2(spanContext) {
  return new NonRecordingSpan2(spanContext);
}
var contextApi2 = ContextAPI2.getInstance();
var NoopTracer2 = (
  /** @class */
  (function() {
    function NoopTracer222() {
    }
    NoopTracer222.prototype.startSpan = function(name173, options, context2) {
      if (context2 === void 0) {
        context2 = contextApi2.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan2();
      }
      var parentFromContext = context2 && getSpanContext2(context2);
      if (isSpanContext2(parentFromContext) && isSpanContextValid2(parentFromContext)) {
        return new NonRecordingSpan2(parentFromContext);
      } else {
        return new NonRecordingSpan2();
      }
    };
    NoopTracer222.prototype.startActiveSpan = function(name173, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi2.active();
      var span = this.startSpan(name173, opts, parentContext);
      var contextWithSpanSet = setSpan2(parentContext, span);
      return contextApi2.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer222;
  })()
);
function isSpanContext2(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER2 = new NoopTracer2();
var ProxyTracer2 = (
  /** @class */
  (function() {
    function ProxyTracer222(_provider, name173, version, options) {
      this._provider = _provider;
      this.name = name173;
      this.version = version;
      this.options = options;
    }
    ProxyTracer222.prototype.startSpan = function(name173, options, context2) {
      return this._getTracer().startSpan(name173, options, context2);
    };
    ProxyTracer222.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer222.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER2;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer222;
  })()
);
var NoopTracerProvider2 = (
  /** @class */
  (function() {
    function NoopTracerProvider222() {
    }
    NoopTracerProvider222.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer2();
    };
    return NoopTracerProvider222;
  })()
);
var NOOP_TRACER_PROVIDER2 = new NoopTracerProvider2();
var ProxyTracerProvider2 = (
  /** @class */
  (function() {
    function ProxyTracerProvider222() {
    }
    ProxyTracerProvider222.prototype.getTracer = function(name173, version, options) {
      var _a173;
      return (_a173 = this.getDelegateTracer(name173, version, options)) !== null && _a173 !== void 0 ? _a173 : new ProxyTracer2(this, name173, version, options);
    };
    ProxyTracerProvider222.prototype.getDelegate = function() {
      var _a173;
      return (_a173 = this._delegate) !== null && _a173 !== void 0 ? _a173 : NOOP_TRACER_PROVIDER2;
    };
    ProxyTracerProvider222.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider222.prototype.getDelegateTracer = function(name173, version, options) {
      var _a173;
      return (_a173 = this._delegate) === null || _a173 === void 0 ? void 0 : _a173.getTracer(name173, version, options);
    };
    return ProxyTracerProvider222;
  })()
);
var SpanStatusCode2;
(function(SpanStatusCode222) {
  SpanStatusCode222[SpanStatusCode222["UNSET"] = 0] = "UNSET";
  SpanStatusCode222[SpanStatusCode222["OK"] = 1] = "OK";
  SpanStatusCode222[SpanStatusCode222["ERROR"] = 2] = "ERROR";
})(SpanStatusCode2 || (SpanStatusCode2 = {}));
var API_NAME32 = "trace";
var TraceAPI2 = (
  /** @class */
  (function() {
    function TraceAPI222() {
      this._proxyTracerProvider = new ProxyTracerProvider2();
      this.wrapSpanContext = wrapSpanContext2;
      this.isSpanContextValid = isSpanContextValid2;
      this.deleteSpan = deleteSpan2;
      this.getSpan = getSpan2;
      this.getActiveSpan = getActiveSpan2;
      this.getSpanContext = getSpanContext2;
      this.setSpan = setSpan2;
      this.setSpanContext = setSpanContext2;
    }
    TraceAPI222.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI222();
      }
      return this._instance;
    };
    TraceAPI222.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal2(API_NAME32, this._proxyTracerProvider, DiagAPI2.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI222.prototype.getTracerProvider = function() {
      return getGlobal2(API_NAME32) || this._proxyTracerProvider;
    };
    TraceAPI222.prototype.getTracer = function(name173, version) {
      return this.getTracerProvider().getTracer(name173, version);
    };
    TraceAPI222.prototype.disable = function() {
      unregisterGlobal2(API_NAME32, DiagAPI2.instance());
      this._proxyTracerProvider = new ProxyTracerProvider2();
    };
    return TraceAPI222;
  })()
);
var trace = TraceAPI2.getInstance();
var __defProp23 = Object.defineProperty;
var __export3 = (target, all) => {
  for (var name173 in all)
    __defProp23(target, name173, { get: all[name173], enumerable: true });
};
function prepareResponseHeaders2(headers, {
  contentType,
  dataStreamVersion
}) {
  const responseHeaders = new Headers(headers != null ? headers : {});
  if (!responseHeaders.has("Content-Type")) {
    responseHeaders.set("Content-Type", contentType);
  }
  {
    responseHeaders.set("X-Vercel-AI-Data-Stream", dataStreamVersion);
  }
  return responseHeaders;
}
var UnsupportedModelVersionError = class extends AISDKError2 {
  constructor() {
    super({
      name: "AI_UnsupportedModelVersionError",
      message: `Unsupported model version. AI SDK 4 only supports models that implement specification version "v1". Please upgrade to AI SDK 5 to use this model.`
    });
  }
};
var name8 = "AI_InvalidArgumentError";
var marker9 = `vercel.ai.error.${name8}`;
var symbol9 = Symbol.for(marker9);
var _a9;
var InvalidArgumentError22 = class extends AISDKError2 {
  constructor({
    parameter,
    value,
    message
  }) {
    super({
      name: name8,
      message: `Invalid argument for parameter ${parameter}: ${message}`
    });
    this[_a9] = true;
    this.parameter = parameter;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker9);
  }
};
_a9 = symbol9;
var name22 = "AI_RetryError";
var marker222 = `vercel.ai.error.${name22}`;
var symbol222 = Symbol.for(marker222);
var _a222;
var RetryError = class extends AISDKError2 {
  constructor({
    message,
    reason,
    errors
  }) {
    super({ name: name22, message });
    this[_a222] = true;
    this.reason = reason;
    this.errors = errors;
    this.lastError = errors[errors.length - 1];
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker222);
  }
};
_a222 = symbol222;
var retryWithExponentialBackoff = ({
  maxRetries = 2,
  initialDelayInMs = 2e3,
  backoffFactor = 2
} = {}) => async (f) => _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs: initialDelayInMs,
  backoffFactor
});
async function _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs,
  backoffFactor
}, errors = []) {
  try {
    return await f();
  } catch (error) {
    if (isAbortError(error)) {
      throw error;
    }
    if (maxRetries === 0) {
      throw error;
    }
    const errorMessage = getErrorMessage22(error);
    const newErrors = [...errors, error];
    const tryNumber = newErrors.length;
    if (tryNumber > maxRetries) {
      throw new RetryError({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors
      });
    }
    if (error instanceof Error && APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
      await delay(delayInMs);
      return _retryWithExponentialBackoff(
        f,
        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },
        newErrors
      );
    }
    if (tryNumber === 1) {
      throw error;
    }
    throw new RetryError({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors
    });
  }
}
function prepareRetries({
  maxRetries
}) {
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries)) {
      throw new InvalidArgumentError22({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer"
      });
    }
    if (maxRetries < 0) {
      throw new InvalidArgumentError22({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0"
      });
    }
  }
  const maxRetriesResult = maxRetries != null ? maxRetries : 2;
  return {
    maxRetries: maxRetriesResult,
    retry: retryWithExponentialBackoff({ maxRetries: maxRetriesResult })
  };
}
function assembleOperationName({
  operationId,
  telemetry
}) {
  return {
    // standardized operation and resource name:
    "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
    "resource.name": telemetry == null ? void 0 : telemetry.functionId,
    // detailed, AI SDK specific data:
    "ai.operationId": operationId,
    "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
  };
}
function getBaseTelemetryAttributes({
  model,
  settings,
  telemetry,
  headers
}) {
  var _a173;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    // settings:
    ...Object.entries(settings).reduce((attributes, [key, value]) => {
      attributes[`ai.settings.${key}`] = value;
      return attributes;
    }, {}),
    // add metadata as attributes:
    ...Object.entries((_a173 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a173 : {}).reduce(
      (attributes, [key, value]) => {
        attributes[`ai.telemetry.metadata.${key}`] = value;
        return attributes;
      },
      {}
    ),
    // request headers
    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {
      if (value !== void 0) {
        attributes[`ai.request.headers.${key}`] = value;
      }
      return attributes;
    }, {})
  };
}
var noopTracer = {
  startSpan() {
    return noopSpan;
  },
  startActiveSpan(name173, arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
      return arg1(noopSpan);
    }
    if (typeof arg2 === "function") {
      return arg2(noopSpan);
    }
    if (typeof arg3 === "function") {
      return arg3(noopSpan);
    }
  }
};
var noopSpan = {
  spanContext() {
    return noopSpanContext;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  }
};
var noopSpanContext = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
function getTracer({
  isEnabled = false,
  tracer
} = {}) {
  if (!isEnabled) {
    return noopTracer;
  }
  if (tracer) {
    return tracer;
  }
  return trace.getTracer("ai");
}
function recordSpan({
  name: name173,
  tracer,
  attributes,
  fn,
  endWhenDone = true
}) {
  return tracer.startActiveSpan(name173, { attributes }, async (span) => {
    try {
      const result = await fn(span);
      if (endWhenDone) {
        span.end();
      }
      return result;
    } catch (error) {
      try {
        recordErrorOnSpan(span, error);
      } finally {
        span.end();
      }
      throw error;
    }
  });
}
function recordErrorOnSpan(span, error) {
  if (error instanceof Error) {
    span.recordException({
      name: error.name,
      message: error.message,
      stack: error.stack
    });
    span.setStatus({
      code: SpanStatusCode2.ERROR,
      message: error.message
    });
  } else {
    span.setStatus({ code: SpanStatusCode2.ERROR });
  }
}
function selectTelemetryAttributes({
  telemetry,
  attributes
}) {
  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
    return {};
  }
  return Object.entries(attributes).reduce((attributes2, [key, value]) => {
    if (value === void 0) {
      return attributes2;
    }
    if (typeof value === "object" && "input" in value && typeof value.input === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
        return attributes2;
      }
      const result = value.input();
      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };
    }
    if (typeof value === "object" && "output" in value && typeof value.output === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
        return attributes2;
      }
      const result = value.output();
      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };
    }
    return { ...attributes2, [key]: value };
  }, {});
}
function splitArray(array2, chunkSize) {
  if (chunkSize <= 0) {
    throw new Error("chunkSize must be greater than 0");
  }
  const result = [];
  for (let i = 0; i < array2.length; i += chunkSize) {
    result.push(array2.slice(i, i + chunkSize));
  }
  return result;
}
async function embedMany({
  model,
  values,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  experimental_telemetry: telemetry
}) {
  if (typeof model === "string" || model.specificationVersion !== "v1") {
    throw new UnsupportedModelVersionError();
  }
  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry,
    headers,
    settings: { maxRetries }
  });
  const tracer = getTracer(telemetry);
  return recordSpan({
    name: "ai.embedMany",
    attributes: selectTelemetryAttributes({
      telemetry,
      attributes: {
        ...assembleOperationName({ operationId: "ai.embedMany", telemetry }),
        ...baseTelemetryAttributes,
        // specific settings that only make sense on the outer level:
        "ai.values": {
          input: () => values.map((value) => JSON.stringify(value))
        }
      }
    }),
    tracer,
    fn: async (span) => {
      const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;
      if (maxEmbeddingsPerCall == null) {
        const { embeddings: embeddings2, usage } = await retry(() => {
          return recordSpan({
            name: "ai.embedMany.doEmbed",
            attributes: selectTelemetryAttributes({
              telemetry,
              attributes: {
                ...assembleOperationName({
                  operationId: "ai.embedMany.doEmbed",
                  telemetry
                }),
                ...baseTelemetryAttributes,
                // specific settings that only make sense on the outer level:
                "ai.values": {
                  input: () => values.map((value) => JSON.stringify(value))
                }
              }
            }),
            tracer,
            fn: async (doEmbedSpan) => {
              var _a173;
              const modelResponse = await model.doEmbed({
                values,
                abortSignal,
                headers
              });
              const embeddings3 = modelResponse.embeddings;
              const usage2 = (_a173 = modelResponse.usage) != null ? _a173 : { tokens: NaN };
              doEmbedSpan.setAttributes(
                selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    "ai.embeddings": {
                      output: () => embeddings3.map((embedding) => JSON.stringify(embedding))
                    },
                    "ai.usage.tokens": usage2.tokens
                  }
                })
              );
              return { embeddings: embeddings3, usage: usage2 };
            }
          });
        });
        span.setAttributes(
          selectTelemetryAttributes({
            telemetry,
            attributes: {
              "ai.embeddings": {
                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))
              },
              "ai.usage.tokens": usage.tokens
            }
          })
        );
        return new DefaultEmbedManyResult({ values, embeddings: embeddings2, usage });
      }
      const valueChunks = splitArray(values, maxEmbeddingsPerCall);
      const embeddings = [];
      let tokens = 0;
      for (const chunk of valueChunks) {
        const { embeddings: responseEmbeddings, usage } = await retry(() => {
          return recordSpan({
            name: "ai.embedMany.doEmbed",
            attributes: selectTelemetryAttributes({
              telemetry,
              attributes: {
                ...assembleOperationName({
                  operationId: "ai.embedMany.doEmbed",
                  telemetry
                }),
                ...baseTelemetryAttributes,
                // specific settings that only make sense on the outer level:
                "ai.values": {
                  input: () => chunk.map((value) => JSON.stringify(value))
                }
              }
            }),
            tracer,
            fn: async (doEmbedSpan) => {
              var _a173;
              const modelResponse = await model.doEmbed({
                values: chunk,
                abortSignal,
                headers
              });
              const embeddings2 = modelResponse.embeddings;
              const usage2 = (_a173 = modelResponse.usage) != null ? _a173 : { tokens: NaN };
              doEmbedSpan.setAttributes(
                selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    "ai.embeddings": {
                      output: () => embeddings2.map((embedding) => JSON.stringify(embedding))
                    },
                    "ai.usage.tokens": usage2.tokens
                  }
                })
              );
              return { embeddings: embeddings2, usage: usage2 };
            }
          });
        });
        embeddings.push(...responseEmbeddings);
        tokens += usage.tokens;
      }
      span.setAttributes(
        selectTelemetryAttributes({
          telemetry,
          attributes: {
            "ai.embeddings": {
              output: () => embeddings.map((embedding) => JSON.stringify(embedding))
            },
            "ai.usage.tokens": tokens
          }
        })
      );
      return new DefaultEmbedManyResult({
        values,
        embeddings,
        usage: { tokens }
      });
    }
  });
}
var DefaultEmbedManyResult = class {
  constructor(options) {
    this.values = options.values;
    this.embeddings = options.embeddings;
    this.usage = options.usage;
  }
};
var name422 = "AI_NoObjectGeneratedError";
var marker422 = `vercel.ai.error.${name422}`;
var symbol422 = Symbol.for(marker422);
var _a422;
var NoObjectGeneratedError2 = class extends AISDKError2 {
  constructor({
    message = "No object generated.",
    cause,
    text: text222,
    response,
    usage,
    finishReason
  }) {
    super({ name: name422, message, cause });
    this[_a422] = true;
    this.text = text222;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker422);
  }
};
_a422 = symbol422;
var dataContentSchema2 = z.union([
  z.string(),
  z.instanceof(Uint8Array),
  z.instanceof(ArrayBuffer),
  z.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a173, _b17;
      return (_b17 = (_a173 = globalThis.Buffer) == null ? void 0 : _a173.isBuffer(value)) != null ? _b17 : false;
    },
    { message: "Must be a Buffer" }
  )
]);
var jsonValueSchema2 = z.lazy(
  () => z.union([
    z.null(),
    z.string(),
    z.number(),
    z.boolean(),
    z.record(z.string(), jsonValueSchema2),
    z.array(jsonValueSchema2)
  ])
);
var providerMetadataSchema2 = z.record(
  z.string(),
  z.record(z.string(), jsonValueSchema2)
);
var toolResultContentSchema2 = z.array(
  z.union([
    z.object({ type: z.literal("text"), text: z.string() }),
    z.object({
      type: z.literal("image"),
      data: z.string(),
      mimeType: z.string().optional()
    })
  ])
);
var textPartSchema2 = z.object({
  type: z.literal("text"),
  text: z.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var imagePartSchema2 = z.object({
  type: z.literal("image"),
  image: z.union([dataContentSchema2, z.instanceof(URL)]),
  mimeType: z.string().optional(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var filePartSchema2 = z.object({
  type: z.literal("file"),
  data: z.union([dataContentSchema2, z.instanceof(URL)]),
  filename: z.string().optional(),
  mimeType: z.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var reasoningPartSchema2 = z.object({
  type: z.literal("reasoning"),
  text: z.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var redactedReasoningPartSchema2 = z.object({
  type: z.literal("redacted-reasoning"),
  data: z.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var toolCallPartSchema2 = z.object({
  type: z.literal("tool-call"),
  toolCallId: z.string(),
  toolName: z.string(),
  args: z.unknown(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var toolResultPartSchema2 = z.object({
  type: z.literal("tool-result"),
  toolCallId: z.string(),
  toolName: z.string(),
  result: z.unknown(),
  content: toolResultContentSchema2.optional(),
  isError: z.boolean().optional(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreSystemMessageSchema2 = z.object({
  role: z.literal("system"),
  content: z.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreUserMessageSchema2 = z.object({
  role: z.literal("user"),
  content: z.union([
    z.string(),
    z.array(z.union([textPartSchema2, imagePartSchema2, filePartSchema2]))
  ]),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreAssistantMessageSchema2 = z.object({
  role: z.literal("assistant"),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        textPartSchema2,
        filePartSchema2,
        reasoningPartSchema2,
        redactedReasoningPartSchema2,
        toolCallPartSchema2
      ])
    )
  ]),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreToolMessageSchema2 = z.object({
  role: z.literal("tool"),
  content: z.array(toolResultPartSchema2),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
z.union([
  coreSystemMessageSchema2,
  coreUserMessageSchema2,
  coreAssistantMessageSchema2,
  coreToolMessageSchema2
]);
var DEFAULT_SCHEMA_PREFIX2 = "JSON schema:";
var DEFAULT_SCHEMA_SUFFIX2 = "You MUST answer with a JSON object that matches the JSON schema above.";
var DEFAULT_GENERIC_SUFFIX2 = "You MUST answer with JSON.";
function injectJsonInstruction2({
  prompt,
  schema,
  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX2 : void 0,
  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX2 : DEFAULT_GENERIC_SUFFIX2
}) {
  return [
    prompt != null && prompt.length > 0 ? prompt : void 0,
    prompt != null && prompt.length > 0 ? "" : void 0,
    // add a newline if prompt is not null
    schemaPrefix,
    schema != null ? JSON.stringify(schema) : void 0,
    schemaSuffix
  ].filter((line) => line != null).join("\n");
}
createIdGenerator2({ prefix: "aiobj", size: 24 });
createIdGenerator2({ prefix: "aiobj", size: 24 });
createIdGenerator2({
  prefix: "aitxt",
  size: 24
});
createIdGenerator2({
  prefix: "msg",
  size: 24
});
var output_exports2 = {};
__export3(output_exports2, {
  object: () => object2,
  text: () => text2
});
var text2 = () => ({
  type: "text",
  responseFormat: () => ({ type: "text" }),
  injectIntoSystemPrompt({ system }) {
    return system;
  },
  parsePartial({ text: text222 }) {
    return { partial: text222 };
  },
  parseOutput({ text: text222 }) {
    return text222;
  }
});
var object2 = ({
  schema: inputSchema
}) => {
  const schema = asSchema2(inputSchema);
  return {
    type: "object",
    responseFormat: ({ model }) => ({
      type: "json",
      schema: model.supportsStructuredOutputs ? schema.jsonSchema : void 0
    }),
    injectIntoSystemPrompt({ system, model }) {
      return model.supportsStructuredOutputs ? system : injectJsonInstruction2({
        prompt: system,
        schema: schema.jsonSchema
      });
    },
    parsePartial({ text: text222 }) {
      const result = parsePartialJson2(text222);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    parseOutput({ text: text222 }, context2) {
      const parseResult = safeParseJSON2({ text: text222 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError2({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text222,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      const validationResult = safeValidateTypes2({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError2({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text222,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      return validationResult.value;
    }
  };
};
function mergeStreams2(stream1, stream2) {
  const reader1 = stream1.getReader();
  const reader2 = stream2.getReader();
  let lastRead1 = void 0;
  let lastRead2 = void 0;
  let stream1Done = false;
  let stream2Done = false;
  async function readStream1(controller) {
    try {
      if (lastRead1 == null) {
        lastRead1 = reader1.read();
      }
      const result = await lastRead1;
      lastRead1 = void 0;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error) {
      controller.error(error);
    }
  }
  async function readStream2(controller) {
    try {
      if (lastRead2 == null) {
        lastRead2 = reader2.read();
      }
      const result = await lastRead2;
      lastRead2 = void 0;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error) {
      controller.error(error);
    }
  }
  return new ReadableStream({
    async pull(controller) {
      try {
        if (stream1Done) {
          await readStream2(controller);
          return;
        }
        if (stream2Done) {
          await readStream1(controller);
          return;
        }
        if (lastRead1 == null) {
          lastRead1 = reader1.read();
        }
        if (lastRead2 == null) {
          lastRead2 = reader2.read();
        }
        const { result, reader } = await Promise.race([
          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),
          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))
        ]);
        if (!result.done) {
          controller.enqueue(result.value);
        }
        if (reader === reader1) {
          lastRead1 = void 0;
          if (result.done) {
            await readStream2(controller);
            stream1Done = true;
          }
        } else {
          lastRead2 = void 0;
          if (result.done) {
            stream2Done = true;
            await readStream1(controller);
          }
        }
      } catch (error) {
        controller.error(error);
      }
    },
    cancel() {
      reader1.cancel();
      reader2.cancel();
    }
  });
}
createIdGenerator2({
  prefix: "aitxt",
  size: 24
});
createIdGenerator2({
  prefix: "msg",
  size: 24
});
var ClientOrServerImplementationSchema2 = z.object({
  name: z.string(),
  version: z.string()
}).passthrough();
var BaseParamsSchema2 = z.object({
  _meta: z.optional(z.object({}).passthrough())
}).passthrough();
var ResultSchema2 = BaseParamsSchema2;
var RequestSchema2 = z.object({
  method: z.string(),
  params: z.optional(BaseParamsSchema2)
});
var ServerCapabilitiesSchema2 = z.object({
  experimental: z.optional(z.object({}).passthrough()),
  logging: z.optional(z.object({}).passthrough()),
  prompts: z.optional(
    z.object({
      listChanged: z.optional(z.boolean())
    }).passthrough()
  ),
  resources: z.optional(
    z.object({
      subscribe: z.optional(z.boolean()),
      listChanged: z.optional(z.boolean())
    }).passthrough()
  ),
  tools: z.optional(
    z.object({
      listChanged: z.optional(z.boolean())
    }).passthrough()
  )
}).passthrough();
ResultSchema2.extend({
  protocolVersion: z.string(),
  capabilities: ServerCapabilitiesSchema2,
  serverInfo: ClientOrServerImplementationSchema2,
  instructions: z.optional(z.string())
});
var PaginatedResultSchema2 = ResultSchema2.extend({
  nextCursor: z.optional(z.string())
});
var ToolSchema2 = z.object({
  name: z.string(),
  description: z.optional(z.string()),
  inputSchema: z.object({
    type: z.literal("object"),
    properties: z.optional(z.object({}).passthrough())
  }).passthrough()
}).passthrough();
PaginatedResultSchema2.extend({
  tools: z.array(ToolSchema2)
});
var TextContentSchema2 = z.object({
  type: z.literal("text"),
  text: z.string()
}).passthrough();
var ImageContentSchema2 = z.object({
  type: z.literal("image"),
  data: z.string().base64(),
  mimeType: z.string()
}).passthrough();
var ResourceContentsSchema2 = z.object({
  /**
   * The URI of this resource.
   */
  uri: z.string(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: z.optional(z.string())
}).passthrough();
var TextResourceContentsSchema2 = ResourceContentsSchema2.extend({
  text: z.string()
});
var BlobResourceContentsSchema2 = ResourceContentsSchema2.extend({
  blob: z.string().base64()
});
var EmbeddedResourceSchema2 = z.object({
  type: z.literal("resource"),
  resource: z.union([TextResourceContentsSchema2, BlobResourceContentsSchema2])
}).passthrough();
ResultSchema2.extend({
  content: z.array(
    z.union([TextContentSchema2, ImageContentSchema2, EmbeddedResourceSchema2])
  ),
  isError: z.boolean().default(false).optional()
}).or(
  ResultSchema2.extend({
    toolResult: z.unknown()
  })
);
var JSONRPC_VERSION2 = "2.0";
var JSONRPCRequestSchema2 = z.object({
  jsonrpc: z.literal(JSONRPC_VERSION2),
  id: z.union([z.string(), z.number().int()])
}).merge(RequestSchema2).strict();
var JSONRPCResponseSchema2 = z.object({
  jsonrpc: z.literal(JSONRPC_VERSION2),
  id: z.union([z.string(), z.number().int()]),
  result: ResultSchema2
}).strict();
var JSONRPCErrorSchema2 = z.object({
  jsonrpc: z.literal(JSONRPC_VERSION2),
  id: z.union([z.string(), z.number().int()]),
  error: z.object({
    code: z.number().int(),
    message: z.string(),
    data: z.optional(z.unknown())
  })
}).strict();
var JSONRPCNotificationSchema2 = z.object({
  jsonrpc: z.literal(JSONRPC_VERSION2)
}).merge(
  z.object({
    method: z.string(),
    params: z.optional(BaseParamsSchema2)
  })
).strict();
z.union([
  JSONRPCRequestSchema2,
  JSONRPCNotificationSchema2,
  JSONRPCResponseSchema2,
  JSONRPCErrorSchema2
]);
var langchain_adapter_exports2 = {};
__export3(langchain_adapter_exports2, {
  mergeIntoDataStream: () => mergeIntoDataStream3,
  toDataStream: () => toDataStream3,
  toDataStreamResponse: () => toDataStreamResponse3
});
function createCallbacksTransformer2(callbacks = {}) {
  const textEncoder = new TextEncoder();
  let aggregatedResponse = "";
  return new TransformStream({
    async start() {
      if (callbacks.onStart)
        await callbacks.onStart();
    },
    async transform(message, controller) {
      controller.enqueue(textEncoder.encode(message));
      aggregatedResponse += message;
      if (callbacks.onToken)
        await callbacks.onToken(message);
      if (callbacks.onText && typeof message === "string") {
        await callbacks.onText(message);
      }
    },
    async flush() {
      if (callbacks.onCompletion) {
        await callbacks.onCompletion(aggregatedResponse);
      }
      if (callbacks.onFinal) {
        await callbacks.onFinal(aggregatedResponse);
      }
    }
  });
}
function toDataStreamInternal3(stream, callbacks) {
  return stream.pipeThrough(
    new TransformStream({
      transform: async (value, controller) => {
        var _a173;
        if (typeof value === "string") {
          controller.enqueue(value);
          return;
        }
        if ("event" in value) {
          if (value.event === "on_chat_model_stream") {
            forwardAIMessageChunk2(
              (_a173 = value.data) == null ? void 0 : _a173.chunk,
              controller
            );
          }
          return;
        }
        forwardAIMessageChunk2(value, controller);
      }
    })
  ).pipeThrough(createCallbacksTransformer2(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(
    new TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(formatDataStreamPart2("text", chunk));
      }
    })
  );
}
function toDataStream3(stream, callbacks) {
  return toDataStreamInternal3(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
}
function toDataStreamResponse3(stream, options) {
  var _a173;
  const dataStream = toDataStreamInternal3(
    stream,
    options == null ? void 0 : options.callbacks
  ).pipeThrough(new TextEncoderStream());
  const data = options == null ? void 0 : options.data;
  const init = options == null ? void 0 : options.init;
  const responseStream = data ? mergeStreams2(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a173 = init == null ? void 0 : init.status) != null ? _a173 : 200,
    statusText: init == null ? void 0 : init.statusText,
    headers: prepareResponseHeaders2(init == null ? void 0 : init.headers, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
function mergeIntoDataStream3(stream, options) {
  options.dataStream.merge(toDataStreamInternal3(stream, options.callbacks));
}
function forwardAIMessageChunk2(chunk, controller) {
  if (typeof chunk.content === "string") {
    controller.enqueue(chunk.content);
  } else {
    const content = chunk.content;
    for (const item of content) {
      if (item.type === "text") {
        controller.enqueue(item.text);
      }
    }
  }
}
var llamaindex_adapter_exports2 = {};
__export3(llamaindex_adapter_exports2, {
  mergeIntoDataStream: () => mergeIntoDataStream22,
  toDataStream: () => toDataStream22,
  toDataStreamResponse: () => toDataStreamResponse22
});
function toDataStreamInternal22(stream, callbacks) {
  const trimStart = trimStartOfStream2();
  return convertAsyncIteratorToReadableStream2(stream[Symbol.asyncIterator]()).pipeThrough(
    new TransformStream({
      async transform(message, controller) {
        controller.enqueue(trimStart(message.delta));
      }
    })
  ).pipeThrough(createCallbacksTransformer2(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(
    new TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(formatDataStreamPart2("text", chunk));
      }
    })
  );
}
function toDataStream22(stream, callbacks) {
  return toDataStreamInternal22(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
}
function toDataStreamResponse22(stream, options = {}) {
  var _a173;
  const { init, data, callbacks } = options;
  const dataStream = toDataStreamInternal22(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
  const responseStream = data ? mergeStreams2(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a173 = init == null ? void 0 : init.status) != null ? _a173 : 200,
    statusText: init == null ? void 0 : init.statusText,
    headers: prepareResponseHeaders2(init == null ? void 0 : init.headers, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
function mergeIntoDataStream22(stream, options) {
  options.dataStream.merge(toDataStreamInternal22(stream, options.callbacks));
}
function trimStartOfStream2() {
  let isStreamStart = true;
  return (text222) => {
    if (isStreamStart) {
      text222 = text222.trimStart();
      if (text222)
        isStreamStart = false;
    }
    return text222;
  };
}
var marker17 = "vercel.ai.error";
var symbol17 = Symbol.for(marker17);
var _a17;
var _AISDKError32 = class _AISDKError222 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name145,
    message,
    cause
  }) {
    super(message);
    this[_a17] = true;
    this.name = name145;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError222.hasMarker(error, marker17);
  }
  static hasMarker(error, marker155) {
    const markerSymbol = Symbol.for(marker155);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a17 = symbol17;
var AISDKError22 = _AISDKError32;
var name17 = "AI_APICallError";
var marker23 = `vercel.ai.error.${name17}`;
var symbol23 = Symbol.for(marker23);
var _a23;
var APICallError2 = class extends AISDKError22 {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name: name17, message, cause });
    this[_a23] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker23);
  }
};
_a23 = symbol23;
var name23 = "AI_EmptyResponseBodyError";
var marker33 = `vercel.ai.error.${name23}`;
var symbol33 = Symbol.for(marker33);
var _a33;
var EmptyResponseBodyError = class extends AISDKError22 {
  // used in isInstance
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name23, message });
    this[_a33] = true;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker33);
  }
};
_a33 = symbol33;
function getErrorMessage3(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name33 = "AI_InvalidArgumentError";
var marker432 = `vercel.ai.error.${name33}`;
var symbol432 = Symbol.for(marker432);
var _a432;
var InvalidArgumentError3 = class extends AISDKError22 {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name33, message, cause });
    this[_a432] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker432);
  }
};
_a432 = symbol432;
var name63 = "AI_JSONParseError";
var marker73 = `vercel.ai.error.${name63}`;
var symbol73 = Symbol.for(marker73);
var _a73;
var JSONParseError22 = class extends AISDKError22 {
  constructor({ text: text42, cause }) {
    super({
      name: name63,
      message: `JSON parsing failed: Text: ${text42}.
Error message: ${getErrorMessage3(cause)}`,
      cause
    });
    this[_a73] = true;
    this.text = text42;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker73);
  }
};
_a73 = symbol73;
var name123 = "AI_TypeValidationError";
var marker133 = `vercel.ai.error.${name123}`;
var symbol133 = Symbol.for(marker133);
var _a133;
var _TypeValidationError32 = class _TypeValidationError222 extends AISDKError22 {
  constructor({ value, cause }) {
    super({
      name: name123,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage3(cause)}`,
      cause
    });
    this[_a133] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker133);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError222.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError222({ value, cause });
  }
};
_a133 = symbol133;
var TypeValidationError22 = _TypeValidationError32;
var ParseError = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
var EventSourceParserStream = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};
function combineHeaders(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
async function delay2(delayInMs, options) {
  if (delayInMs == null) {
    return Promise.resolve();
  }
  const signal = options == null ? void 0 : options.abortSignal;
  return new Promise((resolve22, reject) => {
    if (signal == null ? void 0 : signal.aborted) {
      reject(createAbortError());
      return;
    }
    const timeoutId = setTimeout(() => {
      cleanup();
      resolve22();
    }, delayInMs);
    const cleanup = () => {
      clearTimeout(timeoutId);
      signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
    };
    const onAbort = () => {
      cleanup();
      reject(createAbortError());
    };
    signal == null ? void 0 : signal.addEventListener("abort", onAbort);
  });
}
function createAbortError() {
  return new DOMException("Delay was aborted", "AbortError");
}
function extractResponseHeaders(response) {
  return Object.fromEntries([...response.headers]);
}
var createIdGenerator22 = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0; i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError3({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
createIdGenerator22();
function getErrorMessage222(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
function isAbortError2(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
function handleFetchError$1({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError2(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new APICallError2({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error;
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
  var _a155, _b17, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a155 = globalThisAny.navigator) == null ? void 0 : _a155.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b17 = globalThisAny.process) == null ? void 0 : _b17.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function normalizeHeaders(headers) {
  if (headers == null) {
    return {};
  }
  const normalized = {};
  if (headers instanceof Headers) {
    headers.forEach((value, key) => {
      normalized[key.toLowerCase()] = value;
    });
  } else {
    if (!Array.isArray(headers)) {
      headers = Object.entries(headers);
    }
    for (const [key, value] of headers) {
      if (value != null) {
        normalized[key.toLowerCase()] = value;
      }
    }
  }
  return normalized;
}
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = new Headers(normalizeHeaders(headers));
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders.entries());
}
var VERSION22 = "3.0.17";
var getOriginalFetch = () => globalThis.fetch;
var getFromApi = async ({
  url,
  headers = {},
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch()
}) => {
  try {
    const response = await fetch2(url, {
      method: "GET",
      headers: withUserAgentSuffix(
        headers,
        `ai-sdk/provider-utils/${VERSION22}`,
        getRuntimeEnvironmentUserAgent()
      ),
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: {}
        });
      } catch (error) {
        if (isAbortError2(error) || APICallError2.isInstance(error)) {
          throw error;
        }
        throw new APICallError2({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: {}
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: {}
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError2(error) || APICallError2.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError2({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: {}
      });
    }
  } catch (error) {
    throw handleFetchError$1({ error, url, requestBodyValues: {} });
  }
};
function loadOptionalSetting({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return void 0;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return void 0;
  }
  return settingValue;
}
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse(text42) {
  const obj = JSON.parse(text42);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx.test(text42) === false && suspectConstructorRx.test(text42) === false) {
    return obj;
  }
  return filter(obj);
}
function filter(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse(text42) {
  const { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e2) {
    return _parse(text42);
  }
  try {
    return _parse(text42);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
var validatorSymbol22 = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator22(validate) {
  return { [validatorSymbol22]: true, validate };
}
function isValidator22(value) {
  return typeof value === "object" && value !== null && validatorSymbol22 in value && value[validatorSymbol22] === true && "validate" in value;
}
function lazyValidator(createValidator) {
  let validator222;
  return () => {
    if (validator222 == null) {
      validator222 = createValidator();
    }
    return validator222;
  };
}
function asValidator22(value) {
  return isValidator22(value) ? value : typeof value === "function" ? value() : standardSchemaValidator(value);
}
function standardSchemaValidator(standardSchema2) {
  return validator22(async (value) => {
    const result = await standardSchema2["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError22({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes({
  value,
  schema
}) {
  const result = await safeValidateTypes22({ value, schema });
  if (!result.success) {
    throw TypeValidationError22.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes22({
  value,
  schema
}) {
  const validator222 = asValidator22(schema);
  try {
    if (validator222.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator222.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError22.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError22.wrap({ value, cause: error }),
      rawValue: value
    };
  }
}
async function parseJSON({
  text: text42,
  schema
}) {
  try {
    const value = secureJsonParse(text42);
    if (schema == null) {
      return value;
    }
    return validateTypes({ value, schema });
  } catch (error) {
    if (JSONParseError22.isInstance(error) || TypeValidationError22.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError22({ text: text42, cause: error });
  }
}
async function safeParseJSON22({
  text: text42,
  schema
}) {
  try {
    const value = secureJsonParse(text42);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes22({ value, schema });
  } catch (error) {
    return {
      success: false,
      error: JSONParseError22.isInstance(error) ? error : new JSONParseError22({ text: text42, cause: error }),
      rawValue: void 0
    };
  }
}
function parseJsonEventStream({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON22({ text: data, schema }));
      }
    })
  );
}
var getOriginalFetch2 = () => globalThis.fetch;
var postJsonToApi = async ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi({
  url,
  headers: {
    "Content-Type": "application/json",
    ...headers
  },
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
});
var postToApi = async ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch2()
}) => {
  try {
    const response = await fetch2(url, {
      method: "POST",
      headers: withUserAgentSuffix(
        headers,
        `ai-sdk/provider-utils/${VERSION22}`,
        getRuntimeEnvironmentUserAgent()
      ),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError2(error) || APICallError2.isInstance(error)) {
          throw error;
        }
        throw new APICallError2({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError2(error) || APICallError2.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError2({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    throw handleFetchError$1({ error, url, requestBodyValues: body.values });
  }
};
async function resolve(value) {
  if (typeof value === "function") {
    value = value();
  }
  return Promise.resolve(value);
}
var createJsonErrorResponseHandler = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError2({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = await parseJSON({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError2({
        message: errorToMessage(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError2({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream({
      stream: response.body,
      schema: chunkSchema
    })
  };
};
var createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = await safeParseJSON22({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders(response);
  if (!parsedResult.success) {
    throw new APICallError2({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
var getRelativePath22 = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i]) break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
var ignoreOverride22 = /* @__PURE__ */ Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var defaultOptions22 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions22 = (options) => typeof options === "string" ? {
  ...defaultOptions22,
  name: options
} : {
  ...defaultOptions22,
  ...options
};
function parseAnyDef22() {
  return {};
}
function parseArrayDef22(def, refs) {
  var _a155, _b17, _c;
  const res = {
    type: "array"
  };
  if (((_a155 = def.type) == null ? void 0 : _a155._def) && ((_c = (_b17 = def.type) == null ? void 0 : _b17._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef22(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef22(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef22() {
  return { type: "boolean" };
}
function parseBrandedDef22(_def, refs) {
  return parseDef22(_def.type._def, refs);
}
var parseCatchDef22 = (def, refs) => {
  return parseDef22(def.innerType._def, refs);
};
function parseDateDef22(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef22(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser22(def);
  }
}
var integerDateParser22 = (def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        res.minimum = check.value;
        break;
      case "max":
        res.maximum = check.value;
        break;
    }
  }
  return res;
};
function parseDefaultDef22(_def, refs) {
  return {
    ...parseDef22(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef22(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef22(_def.schema._def, refs) : parseAnyDef22();
}
function parseEnumDef22(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType22 = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef22(def, refs) {
  const allOf = [
    parseDef22(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef22(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType22(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef22(def) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex22 = void 0;
var zodPatterns22 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex22 === void 0) {
      emojiRegex22 = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u"
      );
    }
    return emojiRegex22;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef22(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat22(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat22(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern22(res, zodPatterns22.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat22(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat22(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern22(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern22(res, zodPatterns22.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern22(res, zodPatterns22.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern22(
            res,
            RegExp(`^${escapeLiteralCheckValue22(check.value, refs)}`),
            check.message,
            refs
          );
          break;
        case "endsWith":
          addPattern22(
            res,
            RegExp(`${escapeLiteralCheckValue22(check.value, refs)}$`),
            check.message,
            refs
          );
          break;
        case "datetime":
          addFormat22(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat22(res, "date", check.message, refs);
          break;
        case "time":
          addFormat22(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat22(res, "duration", check.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "includes": {
          addPattern22(
            res,
            RegExp(escapeLiteralCheckValue22(check.value, refs)),
            check.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat22(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat22(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern22(res, zodPatterns22.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern22(res, zodPatterns22.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern22(res, zodPatterns22.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern22(res, zodPatterns22.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern22(res, zodPatterns22.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern22(res, zodPatterns22.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat22(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern22(res, zodPatterns22.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern22(res, zodPatterns22.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue22(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric22(literal) : literal;
}
var ALPHA_NUMERIC22 = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function escapeNonAlphaNumeric22(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC22.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat22(schema, value, message, refs) {
  var _a155;
  if (schema.format || ((_a155 = schema.anyOf) == null ? void 0 : _a155.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value;
  }
}
function addPattern22(schema, regex, message, refs) {
  var _a155;
  if (schema.pattern || ((_a155 = schema.allOf) == null ? void 0 : _a155.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags22(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags22(regex, refs);
  }
}
function stringifyRegExpWithFlags22(regex, refs) {
  var _a155;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a155 = source[i + 2]) == null ? void 0 : _a155.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  return pattern;
}
function parseRecordDef22(def, refs) {
  var _a155, _b17, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a155 = parseDef22(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a155 : refs.allowedAdditionalProperties
  };
  if (((_b17 = def.keyType) == null ? void 0 : _b17._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef22(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef22(
      def.keyType._def,
      refs
    );
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef22(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef22(def, refs);
  }
  const keys = parseDef22(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef22();
  const values = parseDef22(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef22();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef22(def) {
  const object42 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object42[object42[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object42[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef22() {
  return { not: parseAnyDef22() };
}
function parseNullDef22() {
  return {
    type: "null"
  };
}
var primitiveMappings22 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef22(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings22 && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings22[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf22(def, refs);
}
var asAnyOf22 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef22(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i}`]
    })
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef22(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings22[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef22(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef22(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseObjectDef22(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional22(propDef);
    const parsedDef = parseDef22(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties22(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties22(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef22(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional22(schema) {
  try {
    return schema.isOptional();
  } catch (e2) {
    return true;
  }
}
var parseOptionalDef22 = (def, refs) => {
  var _a155;
  if (refs.currentPath.toString() === ((_a155 = refs.propertyPath) == null ? void 0 : _a155.toString())) {
    return parseDef22(def.innerType._def, refs);
  }
  const innerSchema = parseDef22(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef22() }, innerSchema] } : parseAnyDef22();
};
var parsePipelineDef22 = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef22(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef22(def.out._def, refs);
  }
  const a = parseDef22(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef22(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef22(def, refs) {
  return parseDef22(def.type._def, refs);
}
function parseSetDef22(def, refs) {
  const items = parseDef22(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef22(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef22(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef22(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef22(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
function parseUndefinedDef22() {
  return {
    not: parseAnyDef22()
  };
}
function parseUnknownDef22() {
  return parseAnyDef22();
}
var parseReadonlyDef22 = (def, refs) => {
  return parseDef22(def.innerType._def, refs);
};
var selectParser22 = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef22(def);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef22(def);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef22();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef22();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef22();
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef22(def);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef22(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef22(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef22();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef22();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef22();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef22(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
function parseDef22(def, refs, forceResolution = false) {
  var _a155;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a155 = refs.override) == null ? void 0 : _a155.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride22) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref22(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser22(def, def.typeName, refs);
  const jsonSchema222 = typeof jsonSchemaOrGetter === "function" ? parseDef22(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema222) {
    addMeta22(def, refs, jsonSchema222);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema222, def, refs);
    newItem.jsonSchema = jsonSchema222;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema222;
  return jsonSchema222;
}
var get$ref22 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath22(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
        );
        return parseAnyDef22();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef22() : void 0;
    }
  }
};
var addMeta22 = (def, refs, jsonSchema222) => {
  if (def.description) {
    jsonSchema222.description = def.description;
  }
  return jsonSchema222;
};
var getRefs22 = (options) => {
  const _options = getDefaultOptions22(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name145, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name145],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
};
var zodToJsonSchema23 = (schema, options) => {
  var _a155;
  const refs = getRefs22(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name224, schema2]) => {
      var _a224;
      return {
        ...acc,
        [name224]: (_a224 = parseDef22(
          schema2._def,
          {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name224]
          },
          true
        )) != null ? _a224 : parseAnyDef22()
      };
    },
    {}
  ) : void 0;
  const name145 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a155 = parseDef22(
    schema._def,
    name145 === void 0 ? refs : {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name145]
    },
    false
  )) != null ? _a155 : parseAnyDef22();
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined = name145 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name145
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name145]: main
    }
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
};
var zod_to_json_schema_default = zodToJsonSchema23;
function zod3Schema(zodSchema222, options) {
  var _a155;
  const useReferences = (_a155 = void 0) != null ? _a155 : false;
  return jsonSchema22(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod_to_json_schema_default(zodSchema222, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: async (value) => {
        const result = await zodSchema222.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function zod4Schema(zodSchema222, options) {
  var _a155;
  const useReferences = (_a155 = void 0) != null ? _a155 : false;
  return jsonSchema22(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => z42.toJSONSchema(zodSchema222, {
      target: "draft-7",
      io: "output",
      reused: useReferences ? "ref" : "inline"
    }),
    {
      validate: async (value) => {
        const result = await z42.safeParseAsync(zodSchema222, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function isZod4Schema(zodSchema222) {
  return "_zod" in zodSchema222;
}
function zodSchema22(zodSchema222, options) {
  if (isZod4Schema(zodSchema222)) {
    return zod4Schema(zodSchema222);
  } else {
    return zod3Schema(zodSchema222);
  }
}
var schemaSymbol22 = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function jsonSchema22(jsonSchema222, {
  validate
} = {}) {
  return {
    [schemaSymbol22]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol22]: true,
    get jsonSchema() {
      if (typeof jsonSchema222 === "function") {
        jsonSchema222 = jsonSchema222();
      }
      return jsonSchema222;
    },
    validate
  };
}
function isSchema22(value) {
  return typeof value === "object" && value !== null && schemaSymbol22 in value && value[schemaSymbol22] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema22(schema) {
  return schema == null ? jsonSchema22({
    properties: {},
    additionalProperties: false
  }) : isSchema22(schema) ? schema : typeof schema === "function" ? schema() : zodSchema22(schema);
}
function withoutTrailingSlash(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}
var require_get_context = __commonJS$1({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-context.js"(exports$1, module) {
    var __defProp222 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __export222 = (target, all) => {
      for (var name163 in all)
        __defProp222(target, name163, { get: all[name163], enumerable: true });
    };
    var __copyProps22 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames22(from))
          if (!__hasOwnProp22.call(to, key) && key !== except)
            __defProp222(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps22(__defProp222({}, "__esModule", { value: true }), mod);
    var get_context_exports = {};
    __export222(get_context_exports, {
      SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,
      getContext: () => getContext3
    });
    module.exports = __toCommonJS(get_context_exports);
    var SYMBOL_FOR_REQ_CONTEXT = /* @__PURE__ */ Symbol.for("@vercel/request-context");
    function getContext3() {
      const fromSymbol = globalThis;
      return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
    }
  }
});
var require_get_vercel_oidc_token = __commonJS$1({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js"(exports$1, module) {
    var __defProp222 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __export222 = (target, all) => {
      for (var name163 in all)
        __defProp222(target, name163, { get: all[name163], enumerable: true });
    };
    var __copyProps22 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames22(from))
          if (!__hasOwnProp22.call(to, key) && key !== except)
            __defProp222(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps22(__defProp222({}, "__esModule", { value: true }), mod);
    var get_vercel_oidc_token_exports = {};
    __export222(get_vercel_oidc_token_exports, {
      getVercelOidcToken: () => getVercelOidcToken3,
      getVercelOidcTokenSync: () => getVercelOidcTokenSync2
    });
    module.exports = __toCommonJS(get_vercel_oidc_token_exports);
    var import_get_context = require_get_context();
    var import_token_error = require_token_error$1();
    async function getVercelOidcToken3() {
      let token = "";
      let err;
      try {
        token = getVercelOidcTokenSync2();
      } catch (error) {
        err = error;
      }
      try {
        const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
          await import('./token-util-NEHG7TUY-XQP3QSPX-YCJRRNXO.mjs'),
          await import('./token-6GSAFR2W-ABXTQD64-Z6U2TA2C.mjs')
        ]);
        if (!token || isExpired(getTokenPayload(token))) {
          await refreshToken();
          token = getVercelOidcTokenSync2();
        }
      } catch (error) {
        if (err?.message && error instanceof Error) {
          error.message = `${err.message}
${error.message}`;
        }
        throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, error);
      }
      return token;
    }
    function getVercelOidcTokenSync2() {
      const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
      if (!token) {
        throw new Error(
          `The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`
        );
      }
      return token;
    }
  }
});
var require_dist = __commonJS$1({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/index.js"(exports$1, module) {
    var __defProp222 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __export222 = (target, all) => {
      for (var name163 in all)
        __defProp222(target, name163, { get: all[name163], enumerable: true });
    };
    var __copyProps22 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames22(from))
          if (!__hasOwnProp22.call(to, key) && key !== except)
            __defProp222(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps22(__defProp222({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export222(src_exports, {
      getContext: () => import_get_context.getContext,
      getVercelOidcToken: () => import_get_vercel_oidc_token.getVercelOidcToken,
      getVercelOidcTokenSync: () => import_get_vercel_oidc_token.getVercelOidcTokenSync
    });
    module.exports = __toCommonJS(src_exports);
    var import_get_vercel_oidc_token = require_get_vercel_oidc_token();
    var import_get_context = require_get_context();
  }
});
var import_oidc = __toESM$1(require_dist());
var import_oidc2 = __toESM$1(require_dist());
var marker18 = "vercel.ai.gateway.error";
var symbol18 = Symbol.for(marker18);
var _a18;
var _b;
var GatewayError = class _GatewayError extends (_b = Error, _a18 = symbol18, _b) {
  constructor({
    message,
    statusCode = 500,
    cause
  }) {
    super(message);
    this[_a18] = true;
    this.statusCode = statusCode;
    this.cause = cause;
  }
  /**
   * Checks if the given error is a Gateway Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is a Gateway Error, false otherwise.
   */
  static isInstance(error) {
    return _GatewayError.hasMarker(error);
  }
  static hasMarker(error) {
    return typeof error === "object" && error !== null && symbol18 in error && error[symbol18] === true;
  }
};
var name18 = "GatewayAuthenticationError";
var marker24 = `vercel.ai.gateway.error.${name18}`;
var symbol24 = Symbol.for(marker24);
var _a24;
var _b2;
var GatewayAuthenticationError = class _GatewayAuthenticationError extends (_b2 = GatewayError, _a24 = symbol24, _b2) {
  constructor({
    message = "Authentication failed",
    statusCode = 401,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a24] = true;
    this.name = name18;
    this.type = "authentication_error";
  }
  static isInstance(error) {
    return GatewayError.hasMarker(error) && symbol24 in error;
  }
  /**
   * Creates a contextual error message when authentication fails
   */
  static createContextualError({
    apiKeyProvided,
    oidcTokenProvided,
    message = "Authentication failed",
    statusCode = 401,
    cause
  }) {
    let contextualMessage;
    if (apiKeyProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid API key.

Create a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys

Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
    } else if (oidcTokenProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.

Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.

Alternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;
    } else {
      contextualMessage = `AI Gateway authentication failed: No authentication provided.

Option 1 - API key:
Create an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys
Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

Option 2 - OIDC token:
Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;
    }
    return new _GatewayAuthenticationError({
      message: contextualMessage,
      statusCode,
      cause
    });
  }
};
var name24 = "GatewayInvalidRequestError";
var marker34 = `vercel.ai.gateway.error.${name24}`;
var symbol34 = Symbol.for(marker34);
var _a34;
var _b3;
var GatewayInvalidRequestError = class extends (_b3 = GatewayError, _a34 = symbol34, _b3) {
  constructor({
    message = "Invalid request",
    statusCode = 400,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a34] = true;
    this.name = name24;
    this.type = "invalid_request_error";
  }
  static isInstance(error) {
    return GatewayError.hasMarker(error) && symbol34 in error;
  }
};
var name34 = "GatewayRateLimitError";
var marker44 = `vercel.ai.gateway.error.${name34}`;
var symbol44 = Symbol.for(marker44);
var _a44;
var _b4;
var GatewayRateLimitError = class extends (_b4 = GatewayError, _a44 = symbol44, _b4) {
  constructor({
    message = "Rate limit exceeded",
    statusCode = 429,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a44] = true;
    this.name = name34;
    this.type = "rate_limit_exceeded";
  }
  static isInstance(error) {
    return GatewayError.hasMarker(error) && symbol44 in error;
  }
};
var name44 = "GatewayModelNotFoundError";
var marker54 = `vercel.ai.gateway.error.${name44}`;
var symbol54 = Symbol.for(marker54);
var modelNotFoundParamSchema = lazyValidator(
  () => zodSchema22(
    z$2.object({
      modelId: z$2.string()
    })
  )
);
var _a54;
var _b5;
var GatewayModelNotFoundError = class extends (_b5 = GatewayError, _a54 = symbol54, _b5) {
  constructor({
    message = "Model not found",
    statusCode = 404,
    modelId,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a54] = true;
    this.name = name44;
    this.type = "model_not_found";
    this.modelId = modelId;
  }
  static isInstance(error) {
    return GatewayError.hasMarker(error) && symbol54 in error;
  }
};
var name54 = "GatewayInternalServerError";
var marker64 = `vercel.ai.gateway.error.${name54}`;
var symbol64 = Symbol.for(marker64);
var _a64;
var _b6;
var GatewayInternalServerError = class extends (_b6 = GatewayError, _a64 = symbol64, _b6) {
  constructor({
    message = "Internal server error",
    statusCode = 500,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a64] = true;
    this.name = name54;
    this.type = "internal_server_error";
  }
  static isInstance(error) {
    return GatewayError.hasMarker(error) && symbol64 in error;
  }
};
var name64 = "GatewayResponseError";
var marker74 = `vercel.ai.gateway.error.${name64}`;
var symbol74 = Symbol.for(marker74);
var _a74;
var _b7;
var GatewayResponseError = class extends (_b7 = GatewayError, _a74 = symbol74, _b7) {
  constructor({
    message = "Invalid response from Gateway",
    statusCode = 502,
    response,
    validationError,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a74] = true;
    this.name = name64;
    this.type = "response_error";
    this.response = response;
    this.validationError = validationError;
  }
  static isInstance(error) {
    return GatewayError.hasMarker(error) && symbol74 in error;
  }
};
async function createGatewayErrorFromResponse({
  response,
  statusCode,
  defaultMessage = "Gateway request failed",
  cause,
  authMethod
}) {
  const parseResult = await safeValidateTypes22({
    value: response,
    schema: gatewayErrorResponseSchema
  });
  if (!parseResult.success) {
    return new GatewayResponseError({
      message: `Invalid error response format: ${defaultMessage}`,
      statusCode,
      response,
      validationError: parseResult.error,
      cause
    });
  }
  const validatedResponse = parseResult.value;
  const errorType = validatedResponse.error.type;
  const message = validatedResponse.error.message;
  switch (errorType) {
    case "authentication_error":
      return GatewayAuthenticationError.createContextualError({
        apiKeyProvided: authMethod === "api-key",
        oidcTokenProvided: authMethod === "oidc",
        statusCode,
        cause
      });
    case "invalid_request_error":
      return new GatewayInvalidRequestError({ message, statusCode, cause });
    case "rate_limit_exceeded":
      return new GatewayRateLimitError({ message, statusCode, cause });
    case "model_not_found": {
      const modelResult = await safeValidateTypes22({
        value: validatedResponse.error.param,
        schema: modelNotFoundParamSchema
      });
      return new GatewayModelNotFoundError({
        message,
        statusCode,
        modelId: modelResult.success ? modelResult.value.modelId : void 0,
        cause
      });
    }
    case "internal_server_error":
      return new GatewayInternalServerError({ message, statusCode, cause });
    default:
      return new GatewayInternalServerError({ message, statusCode, cause });
  }
}
var gatewayErrorResponseSchema = lazyValidator(
  () => zodSchema22(
    z$2.object({
      error: z$2.object({
        message: z$2.string(),
        type: z$2.string().nullish(),
        param: z$2.unknown().nullish(),
        code: z$2.union([z$2.string(), z$2.number()]).nullish()
      })
    })
  )
);
function asGatewayError(error, authMethod) {
  var _a832;
  if (GatewayError.isInstance(error)) {
    return error;
  }
  if (APICallError2.isInstance(error)) {
    return createGatewayErrorFromResponse({
      response: extractApiCallResponse(error),
      statusCode: (_a832 = error.statusCode) != null ? _a832 : 500,
      defaultMessage: "Gateway request failed",
      cause: error,
      authMethod
    });
  }
  return createGatewayErrorFromResponse({
    response: {},
    statusCode: 500,
    defaultMessage: error instanceof Error ? `Gateway request failed: ${error.message}` : "Unknown Gateway error",
    cause: error,
    authMethod
  });
}
function extractApiCallResponse(error) {
  if (error.data !== void 0) {
    return error.data;
  }
  if (error.responseBody != null) {
    try {
      return JSON.parse(error.responseBody);
    } catch (e2) {
      return error.responseBody;
    }
  }
  return {};
}
var GATEWAY_AUTH_METHOD_HEADER = "ai-gateway-auth-method";
async function parseAuthMethod(headers) {
  const result = await safeValidateTypes22({
    value: headers[GATEWAY_AUTH_METHOD_HEADER],
    schema: gatewayAuthMethodSchema
  });
  return result.success ? result.value : void 0;
}
var gatewayAuthMethodSchema = lazyValidator(
  () => zodSchema22(z$2.union([z$2.literal("api-key"), z$2.literal("oidc")]))
);
var GatewayFetchMetadata = class {
  constructor(config) {
    this.config = config;
  }
  async getAvailableModels() {
    try {
      const { value } = await getFromApi({
        url: `${this.config.baseURL}/config`,
        headers: await resolve(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler(
          gatewayAvailableModelsResponseSchema
        ),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error) {
      throw await asGatewayError(error);
    }
  }
  async getCredits() {
    try {
      const baseUrl = new URL(this.config.baseURL);
      const { value } = await getFromApi({
        url: `${baseUrl.origin}/v1/credits`,
        headers: await resolve(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler(
          gatewayCreditsResponseSchema
        ),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error) {
      throw await asGatewayError(error);
    }
  }
};
var gatewayAvailableModelsResponseSchema = lazyValidator(
  () => zodSchema22(
    z$2.object({
      models: z$2.array(
        z$2.object({
          id: z$2.string(),
          name: z$2.string(),
          description: z$2.string().nullish(),
          pricing: z$2.object({
            input: z$2.string(),
            output: z$2.string(),
            input_cache_read: z$2.string().nullish(),
            input_cache_write: z$2.string().nullish()
          }).transform(
            ({ input, output, input_cache_read, input_cache_write }) => ({
              input,
              output,
              ...input_cache_read ? { cachedInputTokens: input_cache_read } : {},
              ...input_cache_write ? { cacheCreationInputTokens: input_cache_write } : {}
            })
          ).nullish(),
          specification: z$2.object({
            specificationVersion: z$2.literal("v2"),
            provider: z$2.string(),
            modelId: z$2.string()
          }),
          modelType: z$2.enum(["language", "embedding", "image"]).nullish()
        })
      )
    })
  )
);
var gatewayCreditsResponseSchema = lazyValidator(
  () => zodSchema22(
    z$2.object({
      balance: z$2.string(),
      total_used: z$2.string()
    }).transform(({ balance, total_used }) => ({
      balance,
      totalUsed: total_used
    }))
  )
);
var GatewayLanguageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.supportedUrls = { "*/*": [/.*/] };
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs(options) {
    const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
    return {
      args: this.maybeEncodeFileParts(optionsWithoutSignal),
      warnings: []
    };
  }
  async doGenerate(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue: rawResponse
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, false),
          await resolve(this.config.o11yHeaders)
        ),
        body: args,
        successfulResponseHandler: createJsonResponseHandler(z$2.any()),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        ...responseBody,
        request: { body: args },
        response: { headers: responseHeaders, body: rawResponse },
        warnings
      };
    } catch (error) {
      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
    }
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const { value: response, responseHeaders } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, true),
          await resolve(this.config.o11yHeaders)
        ),
        body: args,
        successfulResponseHandler: createEventSourceResponseHandler(z$2.any()),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              if (warnings.length > 0) {
                controller.enqueue({ type: "stream-start", warnings });
              }
            },
            transform(chunk, controller) {
              if (chunk.success) {
                const streamPart = chunk.value;
                if (streamPart.type === "raw" && !options.includeRawChunks) {
                  return;
                }
                if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                  streamPart.timestamp = new Date(streamPart.timestamp);
                }
                controller.enqueue(streamPart);
              } else {
                controller.error(
                  chunk.error
                );
              }
            }
          })
        ),
        request: { body: args },
        response: { headers: responseHeaders }
      };
    } catch (error) {
      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
    }
  }
  isFilePart(part) {
    return part && typeof part === "object" && "type" in part && part.type === "file";
  }
  /**
   * Encodes file parts in the prompt to base64. Mutates the passed options
   * instance directly to avoid copying the file data.
   * @param options - The options to encode.
   * @returns The options with the file parts encoded.
   */
  maybeEncodeFileParts(options) {
    for (const message of options.prompt) {
      for (const part of message.content) {
        if (this.isFilePart(part)) {
          const filePart = part;
          if (filePart.data instanceof Uint8Array) {
            const buffer = Uint8Array.from(filePart.data);
            const base64Data = Buffer.from(buffer).toString("base64");
            filePart.data = new URL(
              `data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`
            );
          }
        }
      }
    }
    return options;
  }
  getUrl() {
    return `${this.config.baseURL}/language-model`;
  }
  getModelConfigHeaders(modelId, streaming) {
    return {
      "ai-language-model-specification-version": "2",
      "ai-language-model-id": modelId,
      "ai-language-model-streaming": String(streaming)
    };
  }
};
var GatewayEmbeddingModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a832;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve(this.config.o11yHeaders)
        ),
        body: {
          input: values.length === 1 ? values[0] : values,
          ...providerOptions ? { providerOptions } : {}
        },
        successfulResponseHandler: createJsonResponseHandler(
          gatewayEmbeddingResponseSchema
        ),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        embeddings: responseBody.embeddings,
        usage: (_a832 = responseBody.usage) != null ? _a832 : void 0,
        providerMetadata: responseBody.providerMetadata,
        response: { headers: responseHeaders, body: rawValue }
      };
    } catch (error) {
      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/embedding-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-embedding-model-specification-version": "2",
      "ai-model-id": this.modelId
    };
  }
};
var gatewayEmbeddingResponseSchema = lazyValidator(
  () => zodSchema22(
    z$2.object({
      embeddings: z$2.array(z$2.array(z$2.number())),
      usage: z$2.object({ tokens: z$2.number() }).nullish(),
      providerMetadata: z$2.record(z$2.string(), z$2.record(z$2.string(), z$2.unknown())).optional()
    })
  )
);
var GatewayImageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxImagesPerCall = Number.MAX_SAFE_INTEGER;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a832;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve(this.config.o11yHeaders)
        ),
        body: {
          prompt,
          n,
          ...size && { size },
          ...aspectRatio && { aspectRatio },
          ...seed && { seed },
          ...providerOptions && { providerOptions }
        },
        successfulResponseHandler: createJsonResponseHandler(
          gatewayImageResponseSchema
        ),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        images: responseBody.images,
        // Always base64 strings from server
        warnings: (_a832 = responseBody.warnings) != null ? _a832 : [],
        providerMetadata: responseBody.providerMetadata,
        response: {
          timestamp: /* @__PURE__ */ new Date(),
          modelId: this.modelId,
          headers: responseHeaders
        }
      };
    } catch (error) {
      throw asGatewayError(error, await parseAuthMethod(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/image-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-image-model-specification-version": "2",
      "ai-model-id": this.modelId
    };
  }
};
var providerMetadataEntrySchema = z$2.object({
  images: z$2.array(z$2.unknown()).optional()
}).catchall(z$2.unknown());
var gatewayImageResponseSchema = z$2.object({
  images: z$2.array(z$2.string()),
  // Always base64 strings over the wire
  warnings: z$2.array(
    z$2.object({
      type: z$2.literal("other"),
      message: z$2.string()
    })
  ).optional(),
  providerMetadata: z$2.record(z$2.string(), providerMetadataEntrySchema).optional()
});
async function getVercelRequestId() {
  var _a832;
  return (_a832 = (0, import_oidc.getContext)().headers) == null ? void 0 : _a832["x-vercel-id"];
}
var VERSION3 = "2.0.15";
var AI_GATEWAY_PROTOCOL_VERSION = "0.0.1";
function createGatewayProvider(options = {}) {
  var _a832, _b83;
  let pendingMetadata = null;
  let metadataCache = null;
  const cacheRefreshMillis = (_a832 = options.metadataCacheRefreshMillis) != null ? _a832 : 1e3 * 60 * 5;
  let lastFetchTime = 0;
  const baseURL = (_b83 = withoutTrailingSlash(options.baseURL)) != null ? _b83 : "https://ai-gateway.vercel.sh/v1/ai";
  const getHeaders = async () => {
    const auth = await getGatewayAuthToken(options);
    if (auth) {
      return withUserAgentSuffix(
        {
          Authorization: `Bearer ${auth.token}`,
          "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION,
          [GATEWAY_AUTH_METHOD_HEADER]: auth.authMethod,
          ...options.headers
        },
        `ai-sdk/gateway/${VERSION3}`
      );
    }
    throw GatewayAuthenticationError.createContextualError({
      apiKeyProvided: false,
      oidcTokenProvided: false,
      statusCode: 401
    });
  };
  const createO11yHeaders = () => {
    const deploymentId = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_DEPLOYMENT_ID"
    });
    const environment = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_ENV"
    });
    const region = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_REGION"
    });
    return async () => {
      const requestId = await getVercelRequestId();
      return {
        ...deploymentId && { "ai-o11y-deployment-id": deploymentId },
        ...environment && { "ai-o11y-environment": environment },
        ...region && { "ai-o11y-region": region },
        ...requestId && { "ai-o11y-request-id": requestId }
      };
    };
  };
  const createLanguageModel = (modelId) => {
    return new GatewayLanguageModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  const getAvailableModels = async () => {
    var _a922, _b92, _c;
    const now2 = (_c = (_b92 = (_a922 = options._internal) == null ? void 0 : _a922.currentDate) == null ? void 0 : _b92.call(_a922).getTime()) != null ? _c : Date.now();
    if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {
      lastFetchTime = now2;
      pendingMetadata = new GatewayFetchMetadata({
        baseURL,
        headers: getHeaders,
        fetch: options.fetch
      }).getAvailableModels().then((metadata) => {
        metadataCache = metadata;
        return metadata;
      }).catch(async (error) => {
        throw await asGatewayError(
          error,
          await parseAuthMethod(await getHeaders())
        );
      });
    }
    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
  };
  const getCredits = async () => {
    return new GatewayFetchMetadata({
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    }).getCredits().catch(async (error) => {
      throw await asGatewayError(
        error,
        await parseAuthMethod(await getHeaders())
      );
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Gateway Provider model function cannot be called with the new keyword."
      );
    }
    return createLanguageModel(modelId);
  };
  provider.getAvailableModels = getAvailableModels;
  provider.getCredits = getCredits;
  provider.imageModel = (modelId) => {
    return new GatewayImageModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  provider.languageModel = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    return new GatewayEmbeddingModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  return provider;
}
var gateway = createGatewayProvider();
async function getGatewayAuthToken(options) {
  const apiKey = loadOptionalSetting({
    settingValue: options.apiKey,
    environmentVariableName: "AI_GATEWAY_API_KEY"
  });
  if (apiKey) {
    return {
      token: apiKey,
      authMethod: "api-key"
    };
  }
  try {
    const oidcToken = await (0, import_oidc2.getVercelOidcToken)();
    return {
      token: oidcToken,
      authMethod: "oidc"
    };
  } catch (e2) {
    return null;
  }
}
var _globalThis22 = typeof globalThis === "object" ? globalThis : global;
var VERSION222 = "1.9.0";
var re22 = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck22(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re22);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible222(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re22);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible22 = _makeCompatibilityCheck22(VERSION222);
var major22 = VERSION222.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY22 = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major22);
var _global22 = _globalThis22;
function registerGlobal22(type, instance, diag, allowOverride) {
  var _a163;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global22[GLOBAL_OPENTELEMETRY_API_KEY22] = (_a163 = _global22[GLOBAL_OPENTELEMETRY_API_KEY22]) !== null && _a163 !== void 0 ? _a163 : {
    version: VERSION222
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION222) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION222);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION222 + ".");
  return true;
}
function getGlobal22(type) {
  var _a163, _b83;
  var globalVersion = (_a163 = _global22[GLOBAL_OPENTELEMETRY_API_KEY22]) === null || _a163 === void 0 ? void 0 : _a163.version;
  if (!globalVersion || !isCompatible22(globalVersion)) {
    return;
  }
  return (_b83 = _global22[GLOBAL_OPENTELEMETRY_API_KEY22]) === null || _b83 === void 0 ? void 0 : _b83[type];
}
function unregisterGlobal22(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION222 + ".");
  var api = _global22[GLOBAL_OPENTELEMETRY_API_KEY22];
  if (api) {
    delete api[type];
  }
}
var __read52 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray52 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger22 = (
  /** @class */
  (function() {
    function DiagComponentLogger222(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger222.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy22("debug", this._namespace, args);
    };
    DiagComponentLogger222.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy22("error", this._namespace, args);
    };
    DiagComponentLogger222.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy22("info", this._namespace, args);
    };
    DiagComponentLogger222.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy22("warn", this._namespace, args);
    };
    DiagComponentLogger222.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy22("verbose", this._namespace, args);
    };
    return DiagComponentLogger222;
  })()
);
function logProxy22(funcName, namespace, args) {
  var logger = getGlobal22("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray52([], __read52(args), false));
}
var DiagLogLevel22;
(function(DiagLogLevel222) {
  DiagLogLevel222[DiagLogLevel222["NONE"] = 0] = "NONE";
  DiagLogLevel222[DiagLogLevel222["ERROR"] = 30] = "ERROR";
  DiagLogLevel222[DiagLogLevel222["WARN"] = 50] = "WARN";
  DiagLogLevel222[DiagLogLevel222["INFO"] = 60] = "INFO";
  DiagLogLevel222[DiagLogLevel222["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel222[DiagLogLevel222["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel222[DiagLogLevel222["ALL"] = 9999] = "ALL";
})(DiagLogLevel22 || (DiagLogLevel22 = {}));
function createLogLevelDiagLogger22(maxLevel, logger) {
  if (maxLevel < DiagLogLevel22.NONE) {
    maxLevel = DiagLogLevel22.NONE;
  } else if (maxLevel > DiagLogLevel22.ALL) {
    maxLevel = DiagLogLevel22.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel22.ERROR),
    warn: _filterFunc("warn", DiagLogLevel22.WARN),
    info: _filterFunc("info", DiagLogLevel22.INFO),
    debug: _filterFunc("debug", DiagLogLevel22.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel22.VERBOSE)
  };
}
var __read222 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray222 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME42 = "diag";
var DiagAPI22 = (
  /** @class */
  (function() {
    function DiagAPI222() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger = getGlobal22("diag");
          if (!logger)
            return;
          return logger[funcName].apply(logger, __spreadArray222([], __read222(args), false));
        };
      }
      var self = this;
      var setLogger = function(logger, optionsOrLogLevel) {
        var _a163, _b83, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel22.INFO };
        }
        if (logger === self) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a163 = err.stack) !== null && _a163 !== void 0 ? _a163 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal22("diag");
        var newLogger = createLogLevelDiagLogger22((_b83 = optionsOrLogLevel.logLevel) !== null && _b83 !== void 0 ? _b83 : DiagLogLevel22.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal22("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = function() {
        unregisterGlobal22(API_NAME42, self);
      };
      self.createComponentLogger = function(options) {
        return new DiagComponentLogger22(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    DiagAPI222.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI222();
      }
      return this._instance;
    };
    return DiagAPI222;
  })()
);
function createContextKey22(description) {
  return Symbol.for(description);
}
var BaseContext22 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BaseContext222(parentContext) {
      var self = this;
      self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self.getValue = function(key) {
        return self._currentContext.get(key);
      };
      self.setValue = function(key, value) {
        var context2 = new BaseContext222(self._currentContext);
        context2._currentContext.set(key, value);
        return context2;
      };
      self.deleteValue = function(key) {
        var context2 = new BaseContext222(self._currentContext);
        context2._currentContext.delete(key);
        return context2;
      };
    }
    return BaseContext222;
  })()
);
var ROOT_CONTEXT22 = new BaseContext22();
var __read322 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray322 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager22 = (
  /** @class */
  (function() {
    function NoopContextManager222() {
    }
    NoopContextManager222.prototype.active = function() {
      return ROOT_CONTEXT22;
    };
    NoopContextManager222.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray322([thisArg], __read322(args), false));
    };
    NoopContextManager222.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager222.prototype.enable = function() {
      return this;
    };
    NoopContextManager222.prototype.disable = function() {
      return this;
    };
    return NoopContextManager222;
  })()
);
var __read422 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray422 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME222 = "context";
var NOOP_CONTEXT_MANAGER22 = new NoopContextManager22();
var ContextAPI22 = (
  /** @class */
  (function() {
    function ContextAPI222() {
    }
    ContextAPI222.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI222();
      }
      return this._instance;
    };
    ContextAPI222.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal22(API_NAME222, contextManager, DiagAPI22.instance());
    };
    ContextAPI222.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI222.prototype.with = function(context2, fn, thisArg) {
      var _a163;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a163 = this._getContextManager()).with.apply(_a163, __spreadArray422([context2, fn, thisArg], __read422(args), false));
    };
    ContextAPI222.prototype.bind = function(context2, target) {
      return this._getContextManager().bind(context2, target);
    };
    ContextAPI222.prototype._getContextManager = function() {
      return getGlobal22(API_NAME222) || NOOP_CONTEXT_MANAGER22;
    };
    ContextAPI222.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal22(API_NAME222, DiagAPI22.instance());
    };
    return ContextAPI222;
  })()
);
var TraceFlags22;
(function(TraceFlags222) {
  TraceFlags222[TraceFlags222["NONE"] = 0] = "NONE";
  TraceFlags222[TraceFlags222["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags22 || (TraceFlags22 = {}));
var INVALID_SPANID22 = "0000000000000000";
var INVALID_TRACEID22 = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT22 = {
  traceId: INVALID_TRACEID22,
  spanId: INVALID_SPANID22,
  traceFlags: TraceFlags22.NONE
};
var NonRecordingSpan22 = (
  /** @class */
  (function() {
    function NonRecordingSpan222(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT22;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan222.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan222.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan222.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan222.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan222.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan222.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan222.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan222.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan222.prototype.end = function(_endTime) {
    };
    NonRecordingSpan222.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan222.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan222;
  })()
);
var SPAN_KEY22 = createContextKey22("OpenTelemetry Context Key SPAN");
function getSpan22(context2) {
  return context2.getValue(SPAN_KEY22) || void 0;
}
function getActiveSpan22() {
  return getSpan22(ContextAPI22.getInstance().active());
}
function setSpan22(context2, span) {
  return context2.setValue(SPAN_KEY22, span);
}
function deleteSpan22(context2) {
  return context2.deleteValue(SPAN_KEY22);
}
function setSpanContext22(context2, spanContext) {
  return setSpan22(context2, new NonRecordingSpan22(spanContext));
}
function getSpanContext22(context2) {
  var _a163;
  return (_a163 = getSpan22(context2)) === null || _a163 === void 0 ? void 0 : _a163.spanContext();
}
var VALID_TRACEID_REGEX22 = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX22 = /^[0-9a-f]{16}$/i;
function isValidTraceId22(traceId) {
  return VALID_TRACEID_REGEX22.test(traceId) && traceId !== INVALID_TRACEID22;
}
function isValidSpanId22(spanId) {
  return VALID_SPANID_REGEX22.test(spanId) && spanId !== INVALID_SPANID22;
}
function isSpanContextValid22(spanContext) {
  return isValidTraceId22(spanContext.traceId) && isValidSpanId22(spanContext.spanId);
}
function wrapSpanContext22(spanContext) {
  return new NonRecordingSpan22(spanContext);
}
var contextApi22 = ContextAPI22.getInstance();
var NoopTracer22 = (
  /** @class */
  (function() {
    function NoopTracer222() {
    }
    NoopTracer222.prototype.startSpan = function(name163, options, context2) {
      if (context2 === void 0) {
        context2 = contextApi22.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan22();
      }
      var parentFromContext = context2 && getSpanContext22(context2);
      if (isSpanContext22(parentFromContext) && isSpanContextValid22(parentFromContext)) {
        return new NonRecordingSpan22(parentFromContext);
      } else {
        return new NonRecordingSpan22();
      }
    };
    NoopTracer222.prototype.startActiveSpan = function(name163, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi22.active();
      var span = this.startSpan(name163, opts, parentContext);
      var contextWithSpanSet = setSpan22(parentContext, span);
      return contextApi22.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer222;
  })()
);
function isSpanContext22(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER22 = new NoopTracer22();
var ProxyTracer22 = (
  /** @class */
  (function() {
    function ProxyTracer222(_provider, name163, version, options) {
      this._provider = _provider;
      this.name = name163;
      this.version = version;
      this.options = options;
    }
    ProxyTracer222.prototype.startSpan = function(name163, options, context2) {
      return this._getTracer().startSpan(name163, options, context2);
    };
    ProxyTracer222.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer222.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER22;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer222;
  })()
);
var NoopTracerProvider22 = (
  /** @class */
  (function() {
    function NoopTracerProvider222() {
    }
    NoopTracerProvider222.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer22();
    };
    return NoopTracerProvider222;
  })()
);
var NOOP_TRACER_PROVIDER22 = new NoopTracerProvider22();
var ProxyTracerProvider22 = (
  /** @class */
  (function() {
    function ProxyTracerProvider222() {
    }
    ProxyTracerProvider222.prototype.getTracer = function(name163, version, options) {
      var _a163;
      return (_a163 = this.getDelegateTracer(name163, version, options)) !== null && _a163 !== void 0 ? _a163 : new ProxyTracer22(this, name163, version, options);
    };
    ProxyTracerProvider222.prototype.getDelegate = function() {
      var _a163;
      return (_a163 = this._delegate) !== null && _a163 !== void 0 ? _a163 : NOOP_TRACER_PROVIDER22;
    };
    ProxyTracerProvider222.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider222.prototype.getDelegateTracer = function(name163, version, options) {
      var _a163;
      return (_a163 = this._delegate) === null || _a163 === void 0 ? void 0 : _a163.getTracer(name163, version, options);
    };
    return ProxyTracerProvider222;
  })()
);
var SpanStatusCode22;
(function(SpanStatusCode222) {
  SpanStatusCode222[SpanStatusCode222["UNSET"] = 0] = "UNSET";
  SpanStatusCode222[SpanStatusCode222["OK"] = 1] = "OK";
  SpanStatusCode222[SpanStatusCode222["ERROR"] = 2] = "ERROR";
})(SpanStatusCode22 || (SpanStatusCode22 = {}));
var API_NAME322 = "trace";
var TraceAPI22 = (
  /** @class */
  (function() {
    function TraceAPI222() {
      this._proxyTracerProvider = new ProxyTracerProvider22();
      this.wrapSpanContext = wrapSpanContext22;
      this.isSpanContextValid = isSpanContextValid22;
      this.deleteSpan = deleteSpan22;
      this.getSpan = getSpan22;
      this.getActiveSpan = getActiveSpan22;
      this.getSpanContext = getSpanContext22;
      this.setSpan = setSpan22;
      this.setSpanContext = setSpanContext22;
    }
    TraceAPI222.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI222();
      }
      return this._instance;
    };
    TraceAPI222.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal22(API_NAME322, this._proxyTracerProvider, DiagAPI22.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI222.prototype.getTracerProvider = function() {
      return getGlobal22(API_NAME322) || this._proxyTracerProvider;
    };
    TraceAPI222.prototype.getTracer = function(name163, version) {
      return this.getTracerProvider().getTracer(name163, version);
    };
    TraceAPI222.prototype.disable = function() {
      unregisterGlobal22(API_NAME322, DiagAPI22.instance());
      this._proxyTracerProvider = new ProxyTracerProvider22();
    };
    return TraceAPI222;
  })()
);
var trace2 = TraceAPI22.getInstance();
var __defProp32 = Object.defineProperty;
var __export22 = (target, all) => {
  for (var name163 in all)
    __defProp32(target, name163, { get: all[name163], enumerable: true });
};
var name222 = "AI_InvalidArgumentError";
var marker2222 = `vercel.ai.error.${name222}`;
var symbol2222 = Symbol.for(marker2222);
var _a2222;
var InvalidArgumentError222 = class extends AISDKError22 {
  constructor({
    parameter,
    value,
    message
  }) {
    super({
      name: name222,
      message: `Invalid argument for parameter ${parameter}: ${message}`
    });
    this[_a2222] = true;
    this.parameter = parameter;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker2222);
  }
};
_a2222 = symbol2222;
var name622 = "AI_NoObjectGeneratedError";
var marker622 = `vercel.ai.error.${name622}`;
var symbol622 = Symbol.for(marker622);
var _a622;
var NoObjectGeneratedError22 = class extends AISDKError22 {
  constructor({
    message = "No object generated.",
    cause,
    text: text222,
    response,
    usage,
    finishReason
  }) {
    super({ name: name622, message, cause });
    this[_a622] = true;
    this.text = text222;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker622);
  }
};
_a622 = symbol622;
var UnsupportedModelVersionError2 = class extends AISDKError22 {
  constructor(options) {
    super({
      name: "AI_UnsupportedModelVersionError",
      message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`
    });
    this.version = options.version;
    this.provider = options.provider;
    this.modelId = options.modelId;
  }
};
var name142 = "AI_RetryError";
var marker144 = `vercel.ai.error.${name142}`;
var symbol144 = Symbol.for(marker144);
var _a144;
var RetryError2 = class extends AISDKError22 {
  constructor({
    message,
    reason,
    errors
  }) {
    super({ name: name142, message });
    this[_a144] = true;
    this.reason = reason;
    this.errors = errors;
    this.lastError = errors[errors.length - 1];
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker144);
  }
};
_a144 = symbol144;
function resolveEmbeddingModel(model) {
  if (typeof model !== "string") {
    if (model.specificationVersion !== "v2") {
      throw new UnsupportedModelVersionError2({
        version: model.specificationVersion,
        provider: model.provider,
        modelId: model.modelId
      });
    }
    return model;
  }
  return getGlobalProvider().textEmbeddingModel(
    model
  );
}
function getGlobalProvider() {
  var _a163;
  return (_a163 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a163 : gateway;
}
var VERSION32 = "5.0.101";
var dataContentSchema22 = z$2.union([
  z$2.string(),
  z$2.instanceof(Uint8Array),
  z$2.instanceof(ArrayBuffer),
  z$2.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a163, _b83;
      return (_b83 = (_a163 = globalThis.Buffer) == null ? void 0 : _a163.isBuffer(value)) != null ? _b83 : false;
    },
    { message: "Must be a Buffer" }
  )
]);
var jsonValueSchema22 = z$2.lazy(
  () => z$2.union([
    z$2.null(),
    z$2.string(),
    z$2.number(),
    z$2.boolean(),
    z$2.record(z$2.string(), jsonValueSchema22),
    z$2.array(jsonValueSchema22)
  ])
);
var providerMetadataSchema22 = z$2.record(
  z$2.string(),
  z$2.record(z$2.string(), jsonValueSchema22)
);
var textPartSchema22 = z$2.object({
  type: z$2.literal("text"),
  text: z$2.string(),
  providerOptions: providerMetadataSchema22.optional()
});
var imagePartSchema22 = z$2.object({
  type: z$2.literal("image"),
  image: z$2.union([dataContentSchema22, z$2.instanceof(URL)]),
  mediaType: z$2.string().optional(),
  providerOptions: providerMetadataSchema22.optional()
});
var filePartSchema22 = z$2.object({
  type: z$2.literal("file"),
  data: z$2.union([dataContentSchema22, z$2.instanceof(URL)]),
  filename: z$2.string().optional(),
  mediaType: z$2.string(),
  providerOptions: providerMetadataSchema22.optional()
});
var reasoningPartSchema22 = z$2.object({
  type: z$2.literal("reasoning"),
  text: z$2.string(),
  providerOptions: providerMetadataSchema22.optional()
});
var toolCallPartSchema22 = z$2.object({
  type: z$2.literal("tool-call"),
  toolCallId: z$2.string(),
  toolName: z$2.string(),
  input: z$2.unknown(),
  providerOptions: providerMetadataSchema22.optional(),
  providerExecuted: z$2.boolean().optional()
});
var outputSchema = z$2.discriminatedUnion("type", [
  z$2.object({
    type: z$2.literal("text"),
    value: z$2.string()
  }),
  z$2.object({
    type: z$2.literal("json"),
    value: jsonValueSchema22
  }),
  z$2.object({
    type: z$2.literal("error-text"),
    value: z$2.string()
  }),
  z$2.object({
    type: z$2.literal("error-json"),
    value: jsonValueSchema22
  }),
  z$2.object({
    type: z$2.literal("content"),
    value: z$2.array(
      z$2.union([
        z$2.object({
          type: z$2.literal("text"),
          text: z$2.string()
        }),
        z$2.object({
          type: z$2.literal("media"),
          data: z$2.string(),
          mediaType: z$2.string()
        })
      ])
    )
  })
]);
var toolResultPartSchema22 = z$2.object({
  type: z$2.literal("tool-result"),
  toolCallId: z$2.string(),
  toolName: z$2.string(),
  output: outputSchema,
  providerOptions: providerMetadataSchema22.optional()
});
var systemModelMessageSchema = z$2.object(
  {
    role: z$2.literal("system"),
    content: z$2.string(),
    providerOptions: providerMetadataSchema22.optional()
  }
);
var userModelMessageSchema = z$2.object({
  role: z$2.literal("user"),
  content: z$2.union([
    z$2.string(),
    z$2.array(z$2.union([textPartSchema22, imagePartSchema22, filePartSchema22]))
  ]),
  providerOptions: providerMetadataSchema22.optional()
});
var assistantModelMessageSchema = z$2.object({
  role: z$2.literal("assistant"),
  content: z$2.union([
    z$2.string(),
    z$2.array(
      z$2.union([
        textPartSchema22,
        filePartSchema22,
        reasoningPartSchema22,
        toolCallPartSchema22,
        toolResultPartSchema22
      ])
    )
  ]),
  providerOptions: providerMetadataSchema22.optional()
});
var toolModelMessageSchema = z$2.object({
  role: z$2.literal("tool"),
  content: z$2.array(toolResultPartSchema22),
  providerOptions: providerMetadataSchema22.optional()
});
z$2.union([
  systemModelMessageSchema,
  userModelMessageSchema,
  assistantModelMessageSchema,
  toolModelMessageSchema
]);
function assembleOperationName2({
  operationId,
  telemetry
}) {
  return {
    // standardized operation and resource name:
    "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
    "resource.name": telemetry == null ? void 0 : telemetry.functionId,
    // detailed, AI SDK specific data:
    "ai.operationId": operationId,
    "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
  };
}
function getBaseTelemetryAttributes2({
  model,
  settings,
  telemetry,
  headers
}) {
  var _a163;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    // settings:
    ...Object.entries(settings).reduce((attributes, [key, value]) => {
      attributes[`ai.settings.${key}`] = value;
      return attributes;
    }, {}),
    // add metadata as attributes:
    ...Object.entries((_a163 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a163 : {}).reduce(
      (attributes, [key, value]) => {
        attributes[`ai.telemetry.metadata.${key}`] = value;
        return attributes;
      },
      {}
    ),
    // request headers
    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {
      if (value !== void 0) {
        attributes[`ai.request.headers.${key}`] = value;
      }
      return attributes;
    }, {})
  };
}
var noopTracer2 = {
  startSpan() {
    return noopSpan2;
  },
  startActiveSpan(name163, arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
      return arg1(noopSpan2);
    }
    if (typeof arg2 === "function") {
      return arg2(noopSpan2);
    }
    if (typeof arg3 === "function") {
      return arg3(noopSpan2);
    }
  }
};
var noopSpan2 = {
  spanContext() {
    return noopSpanContext2;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  }
};
var noopSpanContext2 = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
function getTracer2({
  isEnabled = false,
  tracer
} = {}) {
  if (!isEnabled) {
    return noopTracer2;
  }
  if (tracer) {
    return tracer;
  }
  return trace2.getTracer("ai");
}
function recordSpan2({
  name: name163,
  tracer,
  attributes,
  fn,
  endWhenDone = true
}) {
  return tracer.startActiveSpan(name163, { attributes }, async (span) => {
    try {
      const result = await fn(span);
      if (endWhenDone) {
        span.end();
      }
      return result;
    } catch (error) {
      try {
        recordErrorOnSpan2(span, error);
      } finally {
        span.end();
      }
      throw error;
    }
  });
}
function recordErrorOnSpan2(span, error) {
  if (error instanceof Error) {
    span.recordException({
      name: error.name,
      message: error.message,
      stack: error.stack
    });
    span.setStatus({
      code: SpanStatusCode22.ERROR,
      message: error.message
    });
  } else {
    span.setStatus({ code: SpanStatusCode22.ERROR });
  }
}
function selectTelemetryAttributes2({
  telemetry,
  attributes
}) {
  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
    return {};
  }
  return Object.entries(attributes).reduce((attributes2, [key, value]) => {
    if (value == null) {
      return attributes2;
    }
    if (typeof value === "object" && "input" in value && typeof value.input === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
        return attributes2;
      }
      const result = value.input();
      return result == null ? attributes2 : { ...attributes2, [key]: result };
    }
    if (typeof value === "object" && "output" in value && typeof value.output === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
        return attributes2;
      }
      const result = value.output();
      return result == null ? attributes2 : { ...attributes2, [key]: result };
    }
    return { ...attributes2, [key]: value };
  }, {});
}
function getRetryDelayInMs({
  error,
  exponentialBackoffDelay
}) {
  const headers = error.responseHeaders;
  if (!headers)
    return exponentialBackoffDelay;
  let ms;
  const retryAfterMs = headers["retry-after-ms"];
  if (retryAfterMs) {
    const timeoutMs = parseFloat(retryAfterMs);
    if (!Number.isNaN(timeoutMs)) {
      ms = timeoutMs;
    }
  }
  const retryAfter = headers["retry-after"];
  if (retryAfter && ms === void 0) {
    const timeoutSeconds = parseFloat(retryAfter);
    if (!Number.isNaN(timeoutSeconds)) {
      ms = timeoutSeconds * 1e3;
    } else {
      ms = Date.parse(retryAfter) - Date.now();
    }
  }
  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {
    return ms;
  }
  return exponentialBackoffDelay;
}
var retryWithExponentialBackoffRespectingRetryHeaders = ({
  maxRetries = 2,
  initialDelayInMs = 2e3,
  backoffFactor = 2,
  abortSignal
} = {}) => async (f) => _retryWithExponentialBackoff2(f, {
  maxRetries,
  delayInMs: initialDelayInMs,
  backoffFactor,
  abortSignal
});
async function _retryWithExponentialBackoff2(f, {
  maxRetries,
  delayInMs,
  backoffFactor,
  abortSignal
}, errors = []) {
  try {
    return await f();
  } catch (error) {
    if (isAbortError2(error)) {
      throw error;
    }
    if (maxRetries === 0) {
      throw error;
    }
    const errorMessage = getErrorMessage222(error);
    const newErrors = [...errors, error];
    const tryNumber = newErrors.length;
    if (tryNumber > maxRetries) {
      throw new RetryError2({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors
      });
    }
    if (error instanceof Error && APICallError2.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
      await delay2(
        getRetryDelayInMs({
          error,
          exponentialBackoffDelay: delayInMs
        }),
        { abortSignal }
      );
      return _retryWithExponentialBackoff2(
        f,
        {
          maxRetries,
          delayInMs: backoffFactor * delayInMs,
          backoffFactor,
          abortSignal
        },
        newErrors
      );
    }
    if (tryNumber === 1) {
      throw error;
    }
    throw new RetryError2({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors
    });
  }
}
function prepareRetries2({
  maxRetries,
  abortSignal
}) {
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries)) {
      throw new InvalidArgumentError222({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer"
      });
    }
    if (maxRetries < 0) {
      throw new InvalidArgumentError222({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0"
      });
    }
  }
  const maxRetriesResult = maxRetries != null ? maxRetries : 2;
  return {
    maxRetries: maxRetriesResult,
    retry: retryWithExponentialBackoffRespectingRetryHeaders({
      maxRetries: maxRetriesResult,
      abortSignal
    })
  };
}
createIdGenerator22({
  prefix: "aitxt",
  size: 24
});
function fixJson22(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
async function parsePartialJson22(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = await safeParseJSON22({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = await safeParseJSON22({ text: fixJson22(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
createIdGenerator22({
  prefix: "aitxt",
  size: 24
});
function splitArray2(array2, chunkSize) {
  if (chunkSize <= 0) {
    throw new Error("chunkSize must be greater than 0");
  }
  const result = [];
  for (let i = 0; i < array2.length; i += chunkSize) {
    result.push(array2.slice(i, i + chunkSize));
  }
  return result;
}
async function embedMany2({
  model: modelArg,
  values,
  maxParallelCalls = Infinity,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  providerOptions,
  experimental_telemetry: telemetry
}) {
  const model = resolveEmbeddingModel(modelArg);
  const { maxRetries, retry } = prepareRetries2({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const headersWithUserAgent = withUserAgentSuffix(
    headers != null ? headers : {},
    `ai/${VERSION32}`
  );
  const baseTelemetryAttributes = getBaseTelemetryAttributes2({
    model,
    telemetry,
    headers: headersWithUserAgent,
    settings: { maxRetries }
  });
  const tracer = getTracer2(telemetry);
  return recordSpan2({
    name: "ai.embedMany",
    attributes: selectTelemetryAttributes2({
      telemetry,
      attributes: {
        ...assembleOperationName2({ operationId: "ai.embedMany", telemetry }),
        ...baseTelemetryAttributes,
        // specific settings that only make sense on the outer level:
        "ai.values": {
          input: () => values.map((value) => JSON.stringify(value))
        }
      }
    }),
    tracer,
    fn: async (span) => {
      var _a163;
      const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([
        model.maxEmbeddingsPerCall,
        model.supportsParallelCalls
      ]);
      if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {
        const { embeddings: embeddings2, usage, response, providerMetadata: providerMetadata2 } = await retry(
          () => {
            return recordSpan2({
              name: "ai.embedMany.doEmbed",
              attributes: selectTelemetryAttributes2({
                telemetry,
                attributes: {
                  ...assembleOperationName2({
                    operationId: "ai.embedMany.doEmbed",
                    telemetry
                  }),
                  ...baseTelemetryAttributes,
                  // specific settings that only make sense on the outer level:
                  "ai.values": {
                    input: () => values.map((value) => JSON.stringify(value))
                  }
                }
              }),
              tracer,
              fn: async (doEmbedSpan) => {
                var _a173;
                const modelResponse = await model.doEmbed({
                  values,
                  abortSignal,
                  headers: headersWithUserAgent,
                  providerOptions
                });
                const embeddings3 = modelResponse.embeddings;
                const usage2 = (_a173 = modelResponse.usage) != null ? _a173 : { tokens: NaN };
                doEmbedSpan.setAttributes(
                  selectTelemetryAttributes2({
                    telemetry,
                    attributes: {
                      "ai.embeddings": {
                        output: () => embeddings3.map(
                          (embedding) => JSON.stringify(embedding)
                        )
                      },
                      "ai.usage.tokens": usage2.tokens
                    }
                  })
                );
                return {
                  embeddings: embeddings3,
                  usage: usage2,
                  providerMetadata: modelResponse.providerMetadata,
                  response: modelResponse.response
                };
              }
            });
          }
        );
        span.setAttributes(
          selectTelemetryAttributes2({
            telemetry,
            attributes: {
              "ai.embeddings": {
                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))
              },
              "ai.usage.tokens": usage.tokens
            }
          })
        );
        return new DefaultEmbedManyResult2({
          values,
          embeddings: embeddings2,
          usage,
          providerMetadata: providerMetadata2,
          responses: [response]
        });
      }
      const valueChunks = splitArray2(values, maxEmbeddingsPerCall);
      const embeddings = [];
      const responses = [];
      let tokens = 0;
      let providerMetadata;
      const parallelChunks = splitArray2(
        valueChunks,
        supportsParallelCalls ? maxParallelCalls : 1
      );
      for (const parallelChunk of parallelChunks) {
        const results = await Promise.all(
          parallelChunk.map((chunk) => {
            return retry(() => {
              return recordSpan2({
                name: "ai.embedMany.doEmbed",
                attributes: selectTelemetryAttributes2({
                  telemetry,
                  attributes: {
                    ...assembleOperationName2({
                      operationId: "ai.embedMany.doEmbed",
                      telemetry
                    }),
                    ...baseTelemetryAttributes,
                    // specific settings that only make sense on the outer level:
                    "ai.values": {
                      input: () => chunk.map((value) => JSON.stringify(value))
                    }
                  }
                }),
                tracer,
                fn: async (doEmbedSpan) => {
                  var _a173;
                  const modelResponse = await model.doEmbed({
                    values: chunk,
                    abortSignal,
                    headers: headersWithUserAgent,
                    providerOptions
                  });
                  const embeddings2 = modelResponse.embeddings;
                  const usage = (_a173 = modelResponse.usage) != null ? _a173 : { tokens: NaN };
                  doEmbedSpan.setAttributes(
                    selectTelemetryAttributes2({
                      telemetry,
                      attributes: {
                        "ai.embeddings": {
                          output: () => embeddings2.map(
                            (embedding) => JSON.stringify(embedding)
                          )
                        },
                        "ai.usage.tokens": usage.tokens
                      }
                    })
                  );
                  return {
                    embeddings: embeddings2,
                    usage,
                    providerMetadata: modelResponse.providerMetadata,
                    response: modelResponse.response
                  };
                }
              });
            });
          })
        );
        for (const result of results) {
          embeddings.push(...result.embeddings);
          responses.push(result.response);
          tokens += result.usage.tokens;
          if (result.providerMetadata) {
            if (!providerMetadata) {
              providerMetadata = { ...result.providerMetadata };
            } else {
              for (const [providerName, metadata] of Object.entries(
                result.providerMetadata
              )) {
                providerMetadata[providerName] = {
                  ...(_a163 = providerMetadata[providerName]) != null ? _a163 : {},
                  ...metadata
                };
              }
            }
          }
        }
      }
      span.setAttributes(
        selectTelemetryAttributes2({
          telemetry,
          attributes: {
            "ai.embeddings": {
              output: () => embeddings.map((embedding) => JSON.stringify(embedding))
            },
            "ai.usage.tokens": tokens
          }
        })
      );
      return new DefaultEmbedManyResult2({
        values,
        embeddings,
        usage: { tokens },
        providerMetadata,
        responses
      });
    }
  });
}
var DefaultEmbedManyResult2 = class {
  constructor(options) {
    this.values = options.values;
    this.embeddings = options.embeddings;
    this.usage = options.usage;
    this.providerMetadata = options.providerMetadata;
    this.responses = options.responses;
  }
};
createIdGenerator22({ prefix: "aiobj", size: 24 });
createIdGenerator22({ prefix: "aiobj", size: 24 });
var output_exports22 = {};
__export22(output_exports22, {
  object: () => object22,
  text: () => text22
});
var text22 = () => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: text222 }) {
    return { partial: text222 };
  },
  async parseOutput({ text: text222 }) {
    return text222;
  }
});
var object22 = ({
  schema: inputSchema
}) => {
  const schema = asSchema22(inputSchema);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: schema.jsonSchema
    },
    async parsePartial({ text: text222 }) {
      const result = await parsePartialJson22(text222);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    async parseOutput({ text: text222 }, context2) {
      const parseResult = await safeParseJSON22({ text: text222 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError22({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text222,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      const validationResult = await safeValidateTypes22({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError22({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text222,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      return validationResult.value;
    }
  };
};
var marker19 = "vercel.ai.error";
var symbol19 = Symbol.for(marker19);
var _a19;
var _b8;
var AISDKError3 = class _AISDKError4 extends (_b8 = Error, _a19 = symbol19, _b8) {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name1422,
    message,
    cause
  }) {
    super(message);
    this[_a19] = true;
    this.name = name1422;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError4.hasMarker(error, marker19);
  }
  static hasMarker(error, marker1522) {
    const markerSymbol = Symbol.for(marker1522);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
var name19 = "AI_APICallError";
var marker25 = `vercel.ai.error.${name19}`;
var symbol25 = Symbol.for(marker25);
var _a25;
var _b22;
var APICallError3 = class extends (_b22 = AISDKError3, _a25 = symbol25, _b22) {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name: name19, message, cause });
    this[_a25] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker25);
  }
};
var name25 = "AI_EmptyResponseBodyError";
var marker35 = `vercel.ai.error.${name25}`;
var symbol35 = Symbol.for(marker35);
var _a35;
var _b32;
var EmptyResponseBodyError2 = class extends (_b32 = AISDKError3, _a35 = symbol35, _b32) {
  // used in isInstance
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name25, message });
    this[_a35] = true;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker35);
  }
};
function getErrorMessage4(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name35 = "AI_InvalidArgumentError";
var marker45 = `vercel.ai.error.${name35}`;
var symbol45 = Symbol.for(marker45);
var _a45;
var _b42;
var InvalidArgumentError4 = class extends (_b42 = AISDKError3, _a45 = symbol45, _b42) {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name35, message, cause });
    this[_a45] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker45);
  }
};
var name65 = "AI_JSONParseError";
var marker75 = `vercel.ai.error.${name65}`;
var symbol75 = Symbol.for(marker75);
var _a75;
var _b72;
var JSONParseError3 = class extends (_b72 = AISDKError3, _a75 = symbol75, _b72) {
  constructor({ text: text42, cause }) {
    super({
      name: name65,
      message: `JSON parsing failed: Text: ${text42}.
Error message: ${getErrorMessage4(cause)}`,
      cause
    });
    this[_a75] = true;
    this.text = text42;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker75);
  }
};
var name125 = "AI_TypeValidationError";
var marker135 = `vercel.ai.error.${name125}`;
var symbol135 = Symbol.for(marker135);
var _a135;
var _b13;
var TypeValidationError3 = class _TypeValidationError4 extends (_b13 = AISDKError3, _a135 = symbol135, _b13) {
  constructor({
    value,
    cause,
    context: context2
  }) {
    let contextPrefix = "Type validation failed";
    if (context2 == null ? void 0 : context2.field) {
      contextPrefix += ` for ${context2.field}`;
    }
    if ((context2 == null ? void 0 : context2.entityName) || (context2 == null ? void 0 : context2.entityId)) {
      contextPrefix += " (";
      const parts = [];
      if (context2.entityName) {
        parts.push(context2.entityName);
      }
      if (context2.entityId) {
        parts.push(`id: "${context2.entityId}"`);
      }
      contextPrefix += parts.join(", ");
      contextPrefix += ")";
    }
    super({
      name: name125,
      message: `${contextPrefix}: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage4(cause)}`,
      cause
    });
    this[_a135] = true;
    this.value = value;
    this.context = context2;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker135);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value and context, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @param {TypeValidationContext} params.context - Optional context about what is being validated.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause,
    context: context2
  }) {
    var _a1522, _b152, _c;
    if (_TypeValidationError4.isInstance(cause) && cause.value === value && ((_a1522 = cause.context) == null ? void 0 : _a1522.field) === (context2 == null ? void 0 : context2.field) && ((_b152 = cause.context) == null ? void 0 : _b152.entityName) === (context2 == null ? void 0 : context2.entityName) && ((_c = cause.context) == null ? void 0 : _c.entityId) === (context2 == null ? void 0 : context2.entityId)) {
      return cause;
    }
    return new _TypeValidationError4({ value, cause, context: context2 });
  }
};
var ParseError2 = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop2(_arg) {
}
function createParser2(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop2, onError = noop2, onRetry = noop2, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines2(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError2(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError2(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines2(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
var EventSourceParserStream2 = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser2({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};
function combineHeaders2(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
async function delay3(delayInMs, options) {
  if (delayInMs == null) {
    return Promise.resolve();
  }
  const signal = options == null ? void 0 : options.abortSignal;
  return new Promise((resolve22, reject) => {
    if (signal == null ? void 0 : signal.aborted) {
      reject(createAbortError2());
      return;
    }
    const timeoutId = setTimeout(() => {
      cleanup();
      resolve22();
    }, delayInMs);
    const cleanup = () => {
      clearTimeout(timeoutId);
      signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
    };
    const onAbort = () => {
      cleanup();
      reject(createAbortError2());
    };
    signal == null ? void 0 : signal.addEventListener("abort", onAbort);
  });
}
function createAbortError2() {
  return new DOMException("Delay was aborted", "AbortError");
}
function extractResponseHeaders2(response) {
  return Object.fromEntries([...response.headers]);
}
var { btoa: btoa3 } = globalThis;
function convertUint8ArrayToBase643(array2) {
  let latin1string = "";
  for (let i = 0; i < array2.length; i++) {
    latin1string += String.fromCodePoint(array2[i]);
  }
  return btoa3(latin1string);
}
var createIdGenerator3 = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0; i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError4({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
createIdGenerator3();
function getErrorMessage23(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
function isAbortError3(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES2 = ["fetch failed", "failed to fetch"];
var BUN_ERROR_CODES = [
  "ConnectionRefused",
  "ConnectionClosed",
  "FailedToOpenSocket",
  "ECONNRESET",
  "ECONNREFUSED",
  "ETIMEDOUT",
  "EPIPE"
];
function isBunNetworkError(error) {
  if (!(error instanceof Error)) {
    return false;
  }
  const code = error.code;
  if (typeof code === "string" && BUN_ERROR_CODES.includes(code)) {
    return true;
  }
  return false;
}
function handleFetchError2({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError3(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES2.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new APICallError3({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  if (isBunNetworkError(error)) {
    return new APICallError3({
      message: `Cannot connect to API: ${error.message}`,
      cause: error,
      url,
      requestBodyValues,
      isRetryable: true
    });
  }
  return error;
}
function getRuntimeEnvironmentUserAgent2(globalThisAny = globalThis) {
  var _a224, _b222, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a224 = globalThisAny.navigator) == null ? void 0 : _a224.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b222 = globalThisAny.process) == null ? void 0 : _b222.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function normalizeHeaders2(headers) {
  if (headers == null) {
    return {};
  }
  const normalized = {};
  if (headers instanceof Headers) {
    headers.forEach((value, key) => {
      normalized[key.toLowerCase()] = value;
    });
  } else {
    if (!Array.isArray(headers)) {
      headers = Object.entries(headers);
    }
    for (const [key, value] of headers) {
      if (value != null) {
        normalized[key.toLowerCase()] = value;
      }
    }
  }
  return normalized;
}
function withUserAgentSuffix2(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = new Headers(normalizeHeaders2(headers));
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders.entries());
}
var VERSION4 = "4.0.13";
var getOriginalFetch3 = () => globalThis.fetch;
var getFromApi2 = async ({
  url,
  headers = {},
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch3()
}) => {
  try {
    const response = await fetch2(url, {
      method: "GET",
      headers: withUserAgentSuffix2(
        headers,
        `ai-sdk/provider-utils/${VERSION4}`,
        getRuntimeEnvironmentUserAgent2()
      ),
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders2(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: {}
        });
      } catch (error) {
        if (isAbortError3(error) || APICallError3.isInstance(error)) {
          throw error;
        }
        throw new APICallError3({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: {}
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: {}
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError3(error) || APICallError3.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError3({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: {}
      });
    }
  } catch (error) {
    throw handleFetchError2({ error, url, requestBodyValues: {} });
  }
};
function loadOptionalSetting2({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return void 0;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return void 0;
  }
  return settingValue;
}
var suspectProtoRx2 = /"__proto__"\s*:/;
var suspectConstructorRx2 = /"constructor"\s*:/;
function _parse2(text42) {
  const obj = JSON.parse(text42);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx2.test(text42) === false && suspectConstructorRx2.test(text42) === false) {
    return obj;
  }
  return filter2(obj);
}
function filter2(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse2(text42) {
  const { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e2) {
    return _parse2(text42);
  }
  try {
    return _parse2(text42);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function addAdditionalPropertiesToJsonSchema(jsonSchema222) {
  if (jsonSchema222.type === "object" || Array.isArray(jsonSchema222.type) && jsonSchema222.type.includes("object")) {
    jsonSchema222.additionalProperties = false;
    const { properties } = jsonSchema222;
    if (properties != null) {
      for (const key of Object.keys(properties)) {
        properties[key] = visit(properties[key]);
      }
    }
  }
  if (jsonSchema222.items != null) {
    jsonSchema222.items = Array.isArray(jsonSchema222.items) ? jsonSchema222.items.map(visit) : visit(jsonSchema222.items);
  }
  if (jsonSchema222.anyOf != null) {
    jsonSchema222.anyOf = jsonSchema222.anyOf.map(visit);
  }
  if (jsonSchema222.allOf != null) {
    jsonSchema222.allOf = jsonSchema222.allOf.map(visit);
  }
  if (jsonSchema222.oneOf != null) {
    jsonSchema222.oneOf = jsonSchema222.oneOf.map(visit);
  }
  const { definitions } = jsonSchema222;
  if (definitions != null) {
    for (const key of Object.keys(definitions)) {
      definitions[key] = visit(definitions[key]);
    }
  }
  return jsonSchema222;
}
function visit(def) {
  if (typeof def === "boolean") return def;
  return addAdditionalPropertiesToJsonSchema(def);
}
var ignoreOverride32 = /* @__PURE__ */ Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var defaultOptions32 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions32 = (options) => typeof options === "string" ? {
  ...defaultOptions32,
  name: options
} : {
  ...defaultOptions32,
  ...options
};
function parseAnyDef32() {
  return {};
}
function parseArrayDef32(def, refs) {
  var _a224, _b222, _c;
  const res = {
    type: "array"
  };
  if (((_a224 = def.type) == null ? void 0 : _a224._def) && ((_c = (_b222 = def.type) == null ? void 0 : _b222._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef32(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef32(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef32() {
  return { type: "boolean" };
}
function parseBrandedDef32(_def, refs) {
  return parseDef32(_def.type._def, refs);
}
var parseCatchDef32 = (def, refs) => {
  return parseDef32(def.innerType._def, refs);
};
function parseDateDef32(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef32(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser32(def);
  }
}
var integerDateParser32 = (def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        res.minimum = check.value;
        break;
      case "max":
        res.maximum = check.value;
        break;
    }
  }
  return res;
};
function parseDefaultDef32(_def, refs) {
  return {
    ...parseDef32(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef32(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef32(_def.schema._def, refs) : parseAnyDef32();
}
function parseEnumDef32(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType32 = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef32(def, refs) {
  const allOf = [
    parseDef32(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef32(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType32(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef32(def) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex32 = void 0;
var zodPatterns32 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex32 === void 0) {
      emojiRegex32 = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u"
      );
    }
    return emojiRegex32;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef32(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat32(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat32(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern32(res, zodPatterns32.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat32(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat32(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern32(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern32(res, zodPatterns32.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern32(res, zodPatterns32.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern32(
            res,
            RegExp(`^${escapeLiteralCheckValue32(check.value, refs)}`),
            check.message,
            refs
          );
          break;
        case "endsWith":
          addPattern32(
            res,
            RegExp(`${escapeLiteralCheckValue32(check.value, refs)}$`),
            check.message,
            refs
          );
          break;
        case "datetime":
          addFormat32(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat32(res, "date", check.message, refs);
          break;
        case "time":
          addFormat32(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat32(res, "duration", check.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "includes": {
          addPattern32(
            res,
            RegExp(escapeLiteralCheckValue32(check.value, refs)),
            check.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat32(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat32(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern32(res, zodPatterns32.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern32(res, zodPatterns32.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern32(res, zodPatterns32.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern32(res, zodPatterns32.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern32(res, zodPatterns32.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern32(res, zodPatterns32.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat32(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern32(res, zodPatterns32.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern32(res, zodPatterns32.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue32(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric32(literal) : literal;
}
var ALPHA_NUMERIC32 = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function escapeNonAlphaNumeric32(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC32.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat32(schema, value, message, refs) {
  var _a224;
  if (schema.format || ((_a224 = schema.anyOf) == null ? void 0 : _a224.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value;
  }
}
function addPattern32(schema, regex, message, refs) {
  var _a224;
  if (schema.pattern || ((_a224 = schema.allOf) == null ? void 0 : _a224.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags32(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags32(regex, refs);
  }
}
function stringifyRegExpWithFlags32(regex, refs) {
  var _a224;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a224 = source[i + 2]) == null ? void 0 : _a224.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  return pattern;
}
function parseRecordDef32(def, refs) {
  var _a224, _b222, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a224 = parseDef32(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a224 : refs.allowedAdditionalProperties
  };
  if (((_b222 = def.keyType) == null ? void 0 : _b222._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef32(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef32(
      def.keyType._def,
      refs
    );
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef32(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef32(def, refs);
  }
  const keys = parseDef32(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef32();
  const values = parseDef32(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef32();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef32(def) {
  const object42 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object42[object42[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object42[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef32() {
  return { not: parseAnyDef32() };
}
function parseNullDef32() {
  return {
    type: "null"
  };
}
var primitiveMappings32 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef32(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings32 && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings32[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf32(def, refs);
}
var asAnyOf32 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef32(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i}`]
    })
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef32(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings32[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef32(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef32(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseObjectDef32(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional32(propDef);
    const parsedDef = parseDef32(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties32(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties32(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef32(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional32(schema) {
  try {
    return schema.isOptional();
  } catch (e2) {
    return true;
  }
}
var parseOptionalDef32 = (def, refs) => {
  var _a224;
  if (refs.currentPath.toString() === ((_a224 = refs.propertyPath) == null ? void 0 : _a224.toString())) {
    return parseDef32(def.innerType._def, refs);
  }
  const innerSchema = parseDef32(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef32() }, innerSchema] } : parseAnyDef32();
};
var parsePipelineDef32 = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef32(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef32(def.out._def, refs);
  }
  const a = parseDef32(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef32(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef32(def, refs) {
  return parseDef32(def.type._def, refs);
}
function parseSetDef32(def, refs) {
  const items = parseDef32(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef32(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef32(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef32(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef32(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
function parseUndefinedDef32() {
  return {
    not: parseAnyDef32()
  };
}
function parseUnknownDef32() {
  return parseAnyDef32();
}
var parseReadonlyDef32 = (def, refs) => {
  return parseDef32(def.innerType._def, refs);
};
var selectParser32 = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef32(def);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef32(def);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef32();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef32();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef32();
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef32(def);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef32(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef32(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef32();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef32();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef32();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef32(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
var getRelativePath32 = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i]) break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
function parseDef32(def, refs, forceResolution = false) {
  var _a224;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a224 = refs.override) == null ? void 0 : _a224.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride32) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref32(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser32(def, def.typeName, refs);
  const jsonSchema222 = typeof jsonSchemaOrGetter === "function" ? parseDef32(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema222) {
    addMeta32(def, refs, jsonSchema222);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema222, def, refs);
    newItem.jsonSchema = jsonSchema222;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema222;
  return jsonSchema222;
}
var get$ref32 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath32(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
        );
        return parseAnyDef32();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef32() : void 0;
    }
  }
};
var addMeta32 = (def, refs, jsonSchema222) => {
  if (def.description) {
    jsonSchema222.description = def.description;
  }
  return jsonSchema222;
};
var getRefs32 = (options) => {
  const _options = getDefaultOptions32(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name224, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name224],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
};
var zod3ToJsonSchema = (schema, options) => {
  var _a224;
  const refs = getRefs32(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name324, schema2]) => {
      var _a324;
      return {
        ...acc,
        [name324]: (_a324 = parseDef32(
          schema2._def,
          {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name324]
          },
          true
        )) != null ? _a324 : parseAnyDef32()
      };
    },
    {}
  ) : void 0;
  const name224 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a224 = parseDef32(
    schema._def,
    name224 === void 0 ? refs : {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name224]
    },
    false
  )) != null ? _a224 : parseAnyDef32();
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined = name224 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name224
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name224]: main
    }
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
};
var schemaSymbol3 = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function lazySchema(createSchema) {
  let schema;
  return () => {
    if (schema == null) {
      schema = createSchema();
    }
    return schema;
  };
}
function jsonSchema3(jsonSchema222, {
  validate
} = {}) {
  return {
    [schemaSymbol3]: true,
    _type: void 0,
    // should never be used directly
    get jsonSchema() {
      if (typeof jsonSchema222 === "function") {
        jsonSchema222 = jsonSchema222();
      }
      return jsonSchema222;
    },
    validate
  };
}
function isSchema3(value) {
  return typeof value === "object" && value !== null && schemaSymbol3 in value && value[schemaSymbol3] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema3(schema) {
  return schema == null ? jsonSchema3({ properties: {}, additionalProperties: false }) : isSchema3(schema) ? schema : "~standard" in schema ? schema["~standard"].vendor === "zod" ? zodSchema3(schema) : standardSchema(schema) : schema();
}
function standardSchema(standardSchema2) {
  return jsonSchema3(
    () => addAdditionalPropertiesToJsonSchema(
      standardSchema2["~standard"].jsonSchema.input({
        target: "draft-07"
      })
    ),
    {
      validate: async (value) => {
        const result = await standardSchema2["~standard"].validate(value);
        return "value" in result ? { success: true, value: result.value } : {
          success: false,
          error: new TypeValidationError3({
            value,
            cause: result.issues
          })
        };
      }
    }
  );
}
function zod3Schema2(zodSchema222, options) {
  var _a224;
  const useReferences = (_a224 = void 0) != null ? _a224 : false;
  return jsonSchema3(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod3ToJsonSchema(zodSchema222, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: async (value) => {
        const result = await zodSchema222.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function zod4Schema2(zodSchema222, options) {
  var _a224;
  const useReferences = (_a224 = void 0) != null ? _a224 : false;
  return jsonSchema3(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => addAdditionalPropertiesToJsonSchema(
      z42.toJSONSchema(zodSchema222, {
        target: "draft-7",
        io: "input",
        reused: useReferences ? "ref" : "inline"
      })
    ),
    {
      validate: async (value) => {
        const result = await z42.safeParseAsync(zodSchema222, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function isZod4Schema2(zodSchema222) {
  return "_zod" in zodSchema222;
}
function zodSchema3(zodSchema222, options) {
  if (isZod4Schema2(zodSchema222)) {
    return zod4Schema2(zodSchema222);
  } else {
    return zod3Schema2(zodSchema222);
  }
}
async function validateTypes2({
  value,
  schema,
  context: context2
}) {
  const result = await safeValidateTypes3({ value, schema, context: context2 });
  if (!result.success) {
    throw TypeValidationError3.wrap({ value, cause: result.error, context: context2 });
  }
  return result.value;
}
async function safeValidateTypes3({
  value,
  schema,
  context: context2
}) {
  const actualSchema = asSchema3(schema);
  try {
    if (actualSchema.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await actualSchema.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError3.wrap({ value, cause: result.error, context: context2 }),
      rawValue: value
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError3.wrap({ value, cause: error, context: context2 }),
      rawValue: value
    };
  }
}
async function parseJSON2({
  text: text42,
  schema
}) {
  try {
    const value = secureJsonParse2(text42);
    if (schema == null) {
      return value;
    }
    return validateTypes2({ value, schema });
  } catch (error) {
    if (JSONParseError3.isInstance(error) || TypeValidationError3.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError3({ text: text42, cause: error });
  }
}
async function safeParseJSON3({
  text: text42,
  schema
}) {
  try {
    const value = secureJsonParse2(text42);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes3({ value, schema });
  } catch (error) {
    return {
      success: false,
      error: JSONParseError3.isInstance(error) ? error : new JSONParseError3({ text: text42, cause: error }),
      rawValue: void 0
    };
  }
}
function parseJsonEventStream2({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream2()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON3({ text: data, schema }));
      }
    })
  );
}
var getOriginalFetch22 = () => globalThis.fetch;
var postJsonToApi2 = async ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi2({
  url,
  headers: {
    "Content-Type": "application/json",
    ...headers
  },
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
});
var postToApi2 = async ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch22()
}) => {
  try {
    const response = await fetch2(url, {
      method: "POST",
      headers: withUserAgentSuffix2(
        headers,
        `ai-sdk/provider-utils/${VERSION4}`,
        getRuntimeEnvironmentUserAgent2()
      ),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders2(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError3(error) || APICallError3.isInstance(error)) {
          throw error;
        }
        throw new APICallError3({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError3(error) || APICallError3.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError3({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    throw handleFetchError2({ error, url, requestBodyValues: body.values });
  }
};
function tool(tool2) {
  return tool2;
}
function createProviderToolFactoryWithOutputSchema({
  id,
  inputSchema,
  outputSchema: outputSchema32,
  supportsDeferredResults
}) {
  return ({
    execute,
    needsApproval,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    ...args
  }) => tool({
    type: "provider",
    id,
    args,
    inputSchema,
    outputSchema: outputSchema32,
    execute,
    needsApproval,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    supportsDeferredResults
  });
}
async function resolve2(value) {
  if (typeof value === "function") {
    value = value();
  }
  return Promise.resolve(value);
}
var createJsonErrorResponseHandler2 = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders2(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError3({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = await parseJSON2({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError3({
        message: errorToMessage(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError3({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler2 = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders2(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError2({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream2({
      stream: response.body,
      schema: chunkSchema
    })
  };
};
var createJsonResponseHandler2 = (responseSchema) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = await safeParseJSON3({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders2(response);
  if (!parsedResult.success) {
    throw new APICallError3({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
function withoutTrailingSlash2(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}
var require_get_context2 = __commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.1.0/node_modules/@vercel/oidc/dist/get-context.js"(exports$1, module) {
    var __defProp222 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __export222 = (target, all) => {
      for (var name21 in all)
        __defProp222(target, name21, { get: all[name21], enumerable: true });
    };
    var __copyProps22 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames22(from))
          if (!__hasOwnProp22.call(to, key) && key !== except)
            __defProp222(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps22(__defProp222({}, "__esModule", { value: true }), mod);
    var get_context_exports = {};
    __export222(get_context_exports, {
      SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,
      getContext: () => getContext3
    });
    module.exports = __toCommonJS(get_context_exports);
    var SYMBOL_FOR_REQ_CONTEXT = /* @__PURE__ */ Symbol.for("@vercel/request-context");
    function getContext3() {
      const fromSymbol = globalThis;
      return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
    }
  }
});
var require_get_vercel_oidc_token2 = __commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.1.0/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js"(exports$1, module) {
    var __defProp222 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __export222 = (target, all) => {
      for (var name21 in all)
        __defProp222(target, name21, { get: all[name21], enumerable: true });
    };
    var __copyProps22 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames22(from))
          if (!__hasOwnProp22.call(to, key) && key !== except)
            __defProp222(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps22(__defProp222({}, "__esModule", { value: true }), mod);
    var get_vercel_oidc_token_exports = {};
    __export222(get_vercel_oidc_token_exports, {
      getVercelOidcToken: () => getVercelOidcToken3,
      getVercelOidcTokenSync: () => getVercelOidcTokenSync2
    });
    module.exports = __toCommonJS(get_vercel_oidc_token_exports);
    var import_get_context = require_get_context2();
    var import_token_error = require_token_error();
    async function getVercelOidcToken3() {
      let token = "";
      let err;
      try {
        token = getVercelOidcTokenSync2();
      } catch (error) {
        err = error;
      }
      try {
        const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
          await import('./token-util-RMHT2CPJ-RJEA3FAN-QWMGWKPO.mjs'),
          await import('./token-APYSY3BW-2DN6RAUY-6HYAXQSH.mjs')
        ]);
        if (!token || isExpired(getTokenPayload(token))) {
          await refreshToken();
          token = getVercelOidcTokenSync2();
        }
      } catch (error) {
        let message = err instanceof Error ? err.message : "";
        if (error instanceof Error) {
          message = `${message}
${error.message}`;
        }
        if (message) {
          throw new import_token_error.VercelOidcTokenError(message);
        }
        throw error;
      }
      return token;
    }
    function getVercelOidcTokenSync2() {
      const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
      if (!token) {
        throw new Error(
          `The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`
        );
      }
      return token;
    }
  }
});
var require_dist2 = __commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.1.0/node_modules/@vercel/oidc/dist/index.js"(exports$1, module) {
    var __defProp222 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __export222 = (target, all) => {
      for (var name21 in all)
        __defProp222(target, name21, { get: all[name21], enumerable: true });
    };
    var __copyProps22 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames22(from))
          if (!__hasOwnProp22.call(to, key) && key !== except)
            __defProp222(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps22(__defProp222({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export222(src_exports, {
      getContext: () => import_get_context.getContext,
      getVercelOidcToken: () => import_get_vercel_oidc_token.getVercelOidcToken,
      getVercelOidcTokenSync: () => import_get_vercel_oidc_token.getVercelOidcTokenSync
    });
    module.exports = __toCommonJS(src_exports);
    var import_get_vercel_oidc_token = require_get_vercel_oidc_token2();
    var import_get_context = require_get_context2();
  }
});
var import_oidc3 = __toESM(require_dist2());
var import_oidc22 = __toESM(require_dist2());
var marker20 = "vercel.ai.gateway.error";
var symbol20 = Symbol.for(marker20);
var _a20;
var _b16;
var GatewayError2 = class _GatewayError2 extends (_b16 = Error, _a20 = symbol20, _b16) {
  constructor({
    message,
    statusCode = 500,
    cause,
    generationId
  }) {
    super(generationId ? `${message} [${generationId}]` : message);
    this[_a20] = true;
    this.statusCode = statusCode;
    this.cause = cause;
    this.generationId = generationId;
  }
  /**
   * Checks if the given error is a Gateway Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is a Gateway Error, false otherwise.
   */
  static isInstance(error) {
    return _GatewayError2.hasMarker(error);
  }
  static hasMarker(error) {
    return typeof error === "object" && error !== null && symbol20 in error && error[symbol20] === true;
  }
};
var name20 = "GatewayAuthenticationError";
var marker26 = `vercel.ai.gateway.error.${name20}`;
var symbol26 = Symbol.for(marker26);
var _a26;
var _b23;
var GatewayAuthenticationError2 = class _GatewayAuthenticationError2 extends (_b23 = GatewayError2, _a26 = symbol26, _b23) {
  constructor({
    message = "Authentication failed",
    statusCode = 401,
    cause,
    generationId
  } = {}) {
    super({ message, statusCode, cause, generationId });
    this[_a26] = true;
    this.name = name20;
    this.type = "authentication_error";
  }
  static isInstance(error) {
    return GatewayError2.hasMarker(error) && symbol26 in error;
  }
  /**
   * Creates a contextual error message when authentication fails
   */
  static createContextualError({
    apiKeyProvided,
    oidcTokenProvided,
    message = "Authentication failed",
    statusCode = 401,
    cause,
    generationId
  }) {
    let contextualMessage;
    if (apiKeyProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid API key.

Create a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys

Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
    } else if (oidcTokenProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.

Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.

Alternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;
    } else {
      contextualMessage = `AI Gateway authentication failed: No authentication provided.

Option 1 - API key:
Create an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys
Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

Option 2 - OIDC token:
Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;
    }
    return new _GatewayAuthenticationError2({
      message: contextualMessage,
      statusCode,
      cause,
      generationId
    });
  }
};
var name26 = "GatewayInvalidRequestError";
var marker36 = `vercel.ai.gateway.error.${name26}`;
var symbol36 = Symbol.for(marker36);
var _a36;
var _b33;
var GatewayInvalidRequestError2 = class extends (_b33 = GatewayError2, _a36 = symbol36, _b33) {
  constructor({
    message = "Invalid request",
    statusCode = 400,
    cause,
    generationId
  } = {}) {
    super({ message, statusCode, cause, generationId });
    this[_a36] = true;
    this.name = name26;
    this.type = "invalid_request_error";
  }
  static isInstance(error) {
    return GatewayError2.hasMarker(error) && symbol36 in error;
  }
};
var name36 = "GatewayRateLimitError";
var marker46 = `vercel.ai.gateway.error.${name36}`;
var symbol46 = Symbol.for(marker46);
var _a46;
var _b43;
var GatewayRateLimitError2 = class extends (_b43 = GatewayError2, _a46 = symbol46, _b43) {
  constructor({
    message = "Rate limit exceeded",
    statusCode = 429,
    cause,
    generationId
  } = {}) {
    super({ message, statusCode, cause, generationId });
    this[_a46] = true;
    this.name = name36;
    this.type = "rate_limit_exceeded";
  }
  static isInstance(error) {
    return GatewayError2.hasMarker(error) && symbol46 in error;
  }
};
var name46 = "GatewayModelNotFoundError";
var marker56 = `vercel.ai.gateway.error.${name46}`;
var symbol56 = Symbol.for(marker56);
var modelNotFoundParamSchema2 = lazySchema(
  () => zodSchema3(
    z$2.object({
      modelId: z$2.string()
    })
  )
);
var _a56;
var _b53;
var GatewayModelNotFoundError2 = class extends (_b53 = GatewayError2, _a56 = symbol56, _b53) {
  constructor({
    message = "Model not found",
    statusCode = 404,
    modelId,
    cause,
    generationId
  } = {}) {
    super({ message, statusCode, cause, generationId });
    this[_a56] = true;
    this.name = name46;
    this.type = "model_not_found";
    this.modelId = modelId;
  }
  static isInstance(error) {
    return GatewayError2.hasMarker(error) && symbol56 in error;
  }
};
var name56 = "GatewayInternalServerError";
var marker66 = `vercel.ai.gateway.error.${name56}`;
var symbol66 = Symbol.for(marker66);
var _a66;
var _b63;
var GatewayInternalServerError2 = class extends (_b63 = GatewayError2, _a66 = symbol66, _b63) {
  constructor({
    message = "Internal server error",
    statusCode = 500,
    cause,
    generationId
  } = {}) {
    super({ message, statusCode, cause, generationId });
    this[_a66] = true;
    this.name = name56;
    this.type = "internal_server_error";
  }
  static isInstance(error) {
    return GatewayError2.hasMarker(error) && symbol66 in error;
  }
};
var name66 = "GatewayResponseError";
var marker76 = `vercel.ai.gateway.error.${name66}`;
var symbol76 = Symbol.for(marker76);
var _a76;
var _b73;
var GatewayResponseError2 = class extends (_b73 = GatewayError2, _a76 = symbol76, _b73) {
  constructor({
    message = "Invalid response from Gateway",
    statusCode = 502,
    response,
    validationError,
    cause,
    generationId
  } = {}) {
    super({ message, statusCode, cause, generationId });
    this[_a76] = true;
    this.name = name66;
    this.type = "response_error";
    this.response = response;
    this.validationError = validationError;
  }
  static isInstance(error) {
    return GatewayError2.hasMarker(error) && symbol76 in error;
  }
};
async function createGatewayErrorFromResponse2({
  response,
  statusCode,
  defaultMessage = "Gateway request failed",
  cause,
  authMethod
}) {
  var _a832;
  const parseResult = await safeValidateTypes3({
    value: response,
    schema: gatewayErrorResponseSchema2
  });
  if (!parseResult.success) {
    const rawGenerationId = typeof response === "object" && response !== null && "generationId" in response ? response.generationId : void 0;
    return new GatewayResponseError2({
      message: `Invalid error response format: ${defaultMessage}`,
      statusCode,
      response,
      validationError: parseResult.error,
      cause,
      generationId: rawGenerationId
    });
  }
  const validatedResponse = parseResult.value;
  const errorType = validatedResponse.error.type;
  const message = validatedResponse.error.message;
  const generationId = (_a832 = validatedResponse.generationId) != null ? _a832 : void 0;
  switch (errorType) {
    case "authentication_error":
      return GatewayAuthenticationError2.createContextualError({
        apiKeyProvided: authMethod === "api-key",
        oidcTokenProvided: authMethod === "oidc",
        statusCode,
        cause,
        generationId
      });
    case "invalid_request_error":
      return new GatewayInvalidRequestError2({
        message,
        statusCode,
        cause,
        generationId
      });
    case "rate_limit_exceeded":
      return new GatewayRateLimitError2({
        message,
        statusCode,
        cause,
        generationId
      });
    case "model_not_found": {
      const modelResult = await safeValidateTypes3({
        value: validatedResponse.error.param,
        schema: modelNotFoundParamSchema2
      });
      return new GatewayModelNotFoundError2({
        message,
        statusCode,
        modelId: modelResult.success ? modelResult.value.modelId : void 0,
        cause,
        generationId
      });
    }
    case "internal_server_error":
      return new GatewayInternalServerError2({
        message,
        statusCode,
        cause,
        generationId
      });
    default:
      return new GatewayInternalServerError2({
        message,
        statusCode,
        cause,
        generationId
      });
  }
}
var gatewayErrorResponseSchema2 = lazySchema(
  () => zodSchema3(
    z$2.object({
      error: z$2.object({
        message: z$2.string(),
        type: z$2.string().nullish(),
        param: z$2.unknown().nullish(),
        code: z$2.union([z$2.string(), z$2.number()]).nullish()
      }),
      generationId: z$2.string().nullish()
    })
  )
);
function asGatewayError2(error, authMethod) {
  var _a832;
  if (GatewayError2.isInstance(error)) {
    return error;
  }
  if (APICallError3.isInstance(error)) {
    return createGatewayErrorFromResponse2({
      response: extractApiCallResponse2(error),
      statusCode: (_a832 = error.statusCode) != null ? _a832 : 500,
      defaultMessage: "Gateway request failed",
      cause: error,
      authMethod
    });
  }
  return createGatewayErrorFromResponse2({
    response: {},
    statusCode: 500,
    defaultMessage: error instanceof Error ? `Gateway request failed: ${error.message}` : "Unknown Gateway error",
    cause: error,
    authMethod
  });
}
function extractApiCallResponse2(error) {
  if (error.data !== void 0) {
    return error.data;
  }
  if (error.responseBody != null) {
    try {
      return JSON.parse(error.responseBody);
    } catch (e2) {
      return error.responseBody;
    }
  }
  return {};
}
var GATEWAY_AUTH_METHOD_HEADER2 = "ai-gateway-auth-method";
async function parseAuthMethod2(headers) {
  const result = await safeValidateTypes3({
    value: headers[GATEWAY_AUTH_METHOD_HEADER2],
    schema: gatewayAuthMethodSchema2
  });
  return result.success ? result.value : void 0;
}
var gatewayAuthMethodSchema2 = lazySchema(
  () => zodSchema3(z$2.union([z$2.literal("api-key"), z$2.literal("oidc")]))
);
var GatewayFetchMetadata2 = class {
  constructor(config) {
    this.config = config;
  }
  async getAvailableModels() {
    try {
      const { value } = await getFromApi2({
        url: `${this.config.baseURL}/config`,
        headers: await resolve2(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler2(
          gatewayAvailableModelsResponseSchema2
        ),
        failedResponseHandler: createJsonErrorResponseHandler2({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error) {
      throw await asGatewayError2(error);
    }
  }
  async getCredits() {
    try {
      const baseUrl = new URL(this.config.baseURL);
      const { value } = await getFromApi2({
        url: `${baseUrl.origin}/v1/credits`,
        headers: await resolve2(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler2(
          gatewayCreditsResponseSchema2
        ),
        failedResponseHandler: createJsonErrorResponseHandler2({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error) {
      throw await asGatewayError2(error);
    }
  }
};
var gatewayAvailableModelsResponseSchema2 = lazySchema(
  () => zodSchema3(
    z$2.object({
      models: z$2.array(
        z$2.object({
          id: z$2.string(),
          name: z$2.string(),
          description: z$2.string().nullish(),
          pricing: z$2.object({
            input: z$2.string(),
            output: z$2.string(),
            input_cache_read: z$2.string().nullish(),
            input_cache_write: z$2.string().nullish()
          }).transform(
            ({ input, output, input_cache_read, input_cache_write }) => ({
              input,
              output,
              ...input_cache_read ? { cachedInputTokens: input_cache_read } : {},
              ...input_cache_write ? { cacheCreationInputTokens: input_cache_write } : {}
            })
          ).nullish(),
          specification: z$2.object({
            specificationVersion: z$2.literal("v3"),
            provider: z$2.string(),
            modelId: z$2.string()
          }),
          modelType: z$2.enum(["language", "embedding", "image"]).nullish()
        })
      )
    })
  )
);
var gatewayCreditsResponseSchema2 = lazySchema(
  () => zodSchema3(
    z$2.object({
      balance: z$2.string(),
      total_used: z$2.string()
    }).transform(({ balance, total_used }) => ({
      balance,
      totalUsed: total_used
    }))
  )
);
var GatewayLanguageModel2 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v3";
    this.supportedUrls = { "*/*": [/.*/] };
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs(options) {
    const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
    return {
      args: this.maybeEncodeFileParts(optionsWithoutSignal),
      warnings: []
    };
  }
  async doGenerate(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve2(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue: rawResponse
      } = await postJsonToApi2({
        url: this.getUrl(),
        headers: combineHeaders2(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, false),
          await resolve2(this.config.o11yHeaders)
        ),
        body: args,
        successfulResponseHandler: createJsonResponseHandler2(z$2.any()),
        failedResponseHandler: createJsonErrorResponseHandler2({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        ...responseBody,
        request: { body: args },
        response: { headers: responseHeaders, body: rawResponse },
        warnings
      };
    } catch (error) {
      throw await asGatewayError2(error, await parseAuthMethod2(resolvedHeaders));
    }
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve2(this.config.headers());
    try {
      const { value: response, responseHeaders } = await postJsonToApi2({
        url: this.getUrl(),
        headers: combineHeaders2(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, true),
          await resolve2(this.config.o11yHeaders)
        ),
        body: args,
        successfulResponseHandler: createEventSourceResponseHandler2(z$2.any()),
        failedResponseHandler: createJsonErrorResponseHandler2({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              if (warnings.length > 0) {
                controller.enqueue({ type: "stream-start", warnings });
              }
            },
            transform(chunk, controller) {
              if (chunk.success) {
                const streamPart = chunk.value;
                if (streamPart.type === "raw" && !options.includeRawChunks) {
                  return;
                }
                if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                  streamPart.timestamp = new Date(streamPart.timestamp);
                }
                controller.enqueue(streamPart);
              } else {
                controller.error(
                  chunk.error
                );
              }
            }
          })
        ),
        request: { body: args },
        response: { headers: responseHeaders }
      };
    } catch (error) {
      throw await asGatewayError2(error, await parseAuthMethod2(resolvedHeaders));
    }
  }
  isFilePart(part) {
    return part && typeof part === "object" && "type" in part && part.type === "file";
  }
  /**
   * Encodes file parts in the prompt to base64. Mutates the passed options
   * instance directly to avoid copying the file data.
   * @param options - The options to encode.
   * @returns The options with the file parts encoded.
   */
  maybeEncodeFileParts(options) {
    for (const message of options.prompt) {
      for (const part of message.content) {
        if (this.isFilePart(part)) {
          const filePart = part;
          if (filePart.data instanceof Uint8Array) {
            const buffer = Uint8Array.from(filePart.data);
            const base64Data = Buffer.from(buffer).toString("base64");
            filePart.data = new URL(
              `data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`
            );
          }
        }
      }
    }
    return options;
  }
  getUrl() {
    return `${this.config.baseURL}/language-model`;
  }
  getModelConfigHeaders(modelId, streaming) {
    return {
      "ai-language-model-specification-version": "3",
      "ai-language-model-id": modelId,
      "ai-language-model-streaming": String(streaming)
    };
  }
};
var GatewayEmbeddingModel2 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v3";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a832;
    const resolvedHeaders = await resolve2(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue
      } = await postJsonToApi2({
        url: this.getUrl(),
        headers: combineHeaders2(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve2(this.config.o11yHeaders)
        ),
        body: {
          values,
          ...providerOptions ? { providerOptions } : {}
        },
        successfulResponseHandler: createJsonResponseHandler2(
          gatewayEmbeddingResponseSchema2
        ),
        failedResponseHandler: createJsonErrorResponseHandler2({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        embeddings: responseBody.embeddings,
        usage: (_a832 = responseBody.usage) != null ? _a832 : void 0,
        providerMetadata: responseBody.providerMetadata,
        response: { headers: responseHeaders, body: rawValue },
        warnings: []
      };
    } catch (error) {
      throw await asGatewayError2(error, await parseAuthMethod2(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/embedding-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-embedding-model-specification-version": "3",
      "ai-model-id": this.modelId
    };
  }
};
var gatewayEmbeddingResponseSchema2 = lazySchema(
  () => zodSchema3(
    z$2.object({
      embeddings: z$2.array(z$2.array(z$2.number())),
      usage: z$2.object({ tokens: z$2.number() }).nullish(),
      providerMetadata: z$2.record(z$2.string(), z$2.record(z$2.string(), z$2.unknown())).optional()
    })
  )
);
var GatewayImageModel2 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v3";
    this.maxImagesPerCall = Number.MAX_SAFE_INTEGER;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    files,
    mask,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a832;
    const resolvedHeaders = await resolve2(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody
      } = await postJsonToApi2({
        url: this.getUrl(),
        headers: combineHeaders2(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve2(this.config.o11yHeaders)
        ),
        body: {
          prompt,
          n,
          ...size && { size },
          ...aspectRatio && { aspectRatio },
          ...seed && { seed },
          ...providerOptions && { providerOptions },
          ...files && {
            files: files.map((file) => maybeEncodeImageFile(file))
          },
          ...mask && { mask: maybeEncodeImageFile(mask) }
        },
        successfulResponseHandler: createJsonResponseHandler2(
          gatewayImageResponseSchema2
        ),
        failedResponseHandler: createJsonErrorResponseHandler2({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        images: responseBody.images,
        // Always base64 strings from server
        warnings: (_a832 = responseBody.warnings) != null ? _a832 : [],
        providerMetadata: responseBody.providerMetadata,
        response: {
          timestamp: /* @__PURE__ */ new Date(),
          modelId: this.modelId,
          headers: responseHeaders
        }
      };
    } catch (error) {
      throw asGatewayError2(error, await parseAuthMethod2(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/image-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-image-model-specification-version": "3",
      "ai-model-id": this.modelId
    };
  }
};
function maybeEncodeImageFile(file) {
  if (file.type === "file" && file.data instanceof Uint8Array) {
    return {
      ...file,
      data: convertUint8ArrayToBase643(file.data)
    };
  }
  return file;
}
var providerMetadataEntrySchema2 = z$2.object({
  images: z$2.array(z$2.unknown()).optional()
}).catchall(z$2.unknown());
var gatewayImageResponseSchema2 = z$2.object({
  images: z$2.array(z$2.string()),
  // Always base64 strings over the wire
  warnings: z$2.array(
    z$2.object({
      type: z$2.literal("other"),
      message: z$2.string()
    })
  ).optional(),
  providerMetadata: z$2.record(z$2.string(), providerMetadataEntrySchema2).optional()
});
var parallelSearchInputSchema = lazySchema(
  () => zodSchema3(
    z.object({
      objective: z.string().describe(
        "Natural-language description of the web research goal, including source or freshness guidance and broader context from the task. Maximum 5000 characters."
      ),
      search_queries: z.array(z.string()).optional().describe(
        "Optional search queries to supplement the objective. Maximum 200 characters per query."
      ),
      mode: z.enum(["one-shot", "agentic"]).optional().describe(
        'Mode preset: "one-shot" for comprehensive results with longer excerpts (default), "agentic" for concise, token-efficient results for multi-step workflows.'
      ),
      max_results: z.number().optional().describe(
        "Maximum number of results to return (1-20). Defaults to 10 if not specified."
      ),
      source_policy: z.object({
        include_domains: z.array(z.string()).optional().describe("List of domains to include in search results."),
        exclude_domains: z.array(z.string()).optional().describe("List of domains to exclude from search results."),
        after_date: z.string().optional().describe(
          "Only include results published after this date (ISO 8601 format)."
        )
      }).optional().describe(
        "Source policy for controlling which domains to include/exclude and freshness."
      ),
      excerpts: z.object({
        max_chars_per_result: z.number().optional().describe("Maximum characters per result."),
        max_chars_total: z.number().optional().describe("Maximum total characters across all results.")
      }).optional().describe("Excerpt configuration for controlling result length."),
      fetch_policy: z.object({
        max_age_seconds: z.number().optional().describe(
          "Maximum age in seconds for cached content. Set to 0 to always fetch fresh content."
        )
      }).optional().describe("Fetch policy for controlling content freshness.")
    })
  )
);
var parallelSearchOutputSchema = lazySchema(
  () => zodSchema3(
    z.union([
      // Success response
      z.object({
        searchId: z.string(),
        results: z.array(
          z.object({
            url: z.string(),
            title: z.string(),
            excerpt: z.string(),
            publishDate: z.string().nullable().optional(),
            relevanceScore: z.number().optional()
          })
        )
      }),
      // Error response
      z.object({
        error: z.enum([
          "api_error",
          "rate_limit",
          "timeout",
          "invalid_input",
          "configuration_error",
          "unknown"
        ]),
        statusCode: z.number().optional(),
        message: z.string()
      })
    ])
  )
);
var parallelSearchToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "gateway.parallel_search",
  inputSchema: parallelSearchInputSchema,
  outputSchema: parallelSearchOutputSchema
});
var parallelSearch = (config = {}) => parallelSearchToolFactory(config);
var perplexitySearchInputSchema = lazySchema(
  () => zodSchema3(
    z.object({
      query: z.union([z.string(), z.array(z.string())]).describe(
        "Search query (string) or multiple queries (array of up to 5 strings). Multi-query searches return combined results from all queries."
      ),
      max_results: z.number().optional().describe(
        "Maximum number of search results to return (1-20, default: 10)"
      ),
      max_tokens_per_page: z.number().optional().describe(
        "Maximum number of tokens to extract per search result page (256-2048, default: 2048)"
      ),
      max_tokens: z.number().optional().describe(
        "Maximum total tokens across all search results (default: 25000, max: 1000000)"
      ),
      country: z.string().optional().describe(
        "Two-letter ISO 3166-1 alpha-2 country code for regional search results (e.g., 'US', 'GB', 'FR')"
      ),
      search_domain_filter: z.array(z.string()).optional().describe(
        "List of domains to include or exclude from search results (max 20). To include: ['nature.com', 'science.org']. To exclude: ['-example.com', '-spam.net']"
      ),
      search_language_filter: z.array(z.string()).optional().describe(
        "List of ISO 639-1 language codes to filter results (max 10, lowercase). Examples: ['en', 'fr', 'de']"
      ),
      search_after_date: z.string().optional().describe(
        "Include only results published after this date. Format: 'MM/DD/YYYY' (e.g., '3/1/2025'). Cannot be used with search_recency_filter."
      ),
      search_before_date: z.string().optional().describe(
        "Include only results published before this date. Format: 'MM/DD/YYYY' (e.g., '3/15/2025'). Cannot be used with search_recency_filter."
      ),
      last_updated_after_filter: z.string().optional().describe(
        "Include only results last updated after this date. Format: 'MM/DD/YYYY' (e.g., '3/1/2025'). Cannot be used with search_recency_filter."
      ),
      last_updated_before_filter: z.string().optional().describe(
        "Include only results last updated before this date. Format: 'MM/DD/YYYY' (e.g., '3/15/2025'). Cannot be used with search_recency_filter."
      ),
      search_recency_filter: z.enum(["day", "week", "month", "year"]).optional().describe(
        "Filter results by relative time period. Cannot be used with search_after_date or search_before_date."
      )
    })
  )
);
var perplexitySearchOutputSchema = lazySchema(
  () => zodSchema3(
    z.union([
      // Success response
      z.object({
        results: z.array(
          z.object({
            title: z.string(),
            url: z.string(),
            snippet: z.string(),
            date: z.string().optional(),
            lastUpdated: z.string().optional()
          })
        ),
        id: z.string()
      }),
      // Error response
      z.object({
        error: z.enum([
          "api_error",
          "rate_limit",
          "timeout",
          "invalid_input",
          "unknown"
        ]),
        statusCode: z.number().optional(),
        message: z.string()
      })
    ])
  )
);
var perplexitySearchToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "gateway.perplexity_search",
  inputSchema: perplexitySearchInputSchema,
  outputSchema: perplexitySearchOutputSchema
});
var perplexitySearch = (config = {}) => perplexitySearchToolFactory(config);
var gatewayTools = {
  /**
   * Search the web using Parallel AI's Search API for LLM-optimized excerpts.
   *
   * Takes a natural language objective and returns relevant excerpts,
   * replacing multiple keyword searches with a single call for broad
   * or complex queries. Supports different search types for depth vs
   * breadth tradeoffs.
   */
  parallelSearch,
  /**
   * Search the web using Perplexity's Search API for real-time information,
   * news, research papers, and articles.
   *
   * Provides ranked search results with advanced filtering options including
   * domain, language, date range, and recency filters.
   */
  perplexitySearch
};
async function getVercelRequestId2() {
  var _a832;
  return (_a832 = (0, import_oidc3.getContext)().headers) == null ? void 0 : _a832["x-vercel-id"];
}
var VERSION5 = "3.0.32";
var AI_GATEWAY_PROTOCOL_VERSION2 = "0.0.1";
function createGatewayProvider2(options = {}) {
  var _a832, _b83;
  let pendingMetadata = null;
  let metadataCache = null;
  const cacheRefreshMillis = (_a832 = options.metadataCacheRefreshMillis) != null ? _a832 : 1e3 * 60 * 5;
  let lastFetchTime = 0;
  const baseURL = (_b83 = withoutTrailingSlash2(options.baseURL)) != null ? _b83 : "https://ai-gateway.vercel.sh/v3/ai";
  const getHeaders = async () => {
    try {
      const auth = await getGatewayAuthToken2(options);
      return withUserAgentSuffix2(
        {
          Authorization: `Bearer ${auth.token}`,
          "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION2,
          [GATEWAY_AUTH_METHOD_HEADER2]: auth.authMethod,
          ...options.headers
        },
        `ai-sdk/gateway/${VERSION5}`
      );
    } catch (error) {
      throw GatewayAuthenticationError2.createContextualError({
        apiKeyProvided: false,
        oidcTokenProvided: false,
        statusCode: 401,
        cause: error
      });
    }
  };
  const createO11yHeaders = () => {
    const deploymentId = loadOptionalSetting2({
      settingValue: void 0,
      environmentVariableName: "VERCEL_DEPLOYMENT_ID"
    });
    const environment = loadOptionalSetting2({
      settingValue: void 0,
      environmentVariableName: "VERCEL_ENV"
    });
    const region = loadOptionalSetting2({
      settingValue: void 0,
      environmentVariableName: "VERCEL_REGION"
    });
    return async () => {
      const requestId = await getVercelRequestId2();
      return {
        ...deploymentId && { "ai-o11y-deployment-id": deploymentId },
        ...environment && { "ai-o11y-environment": environment },
        ...region && { "ai-o11y-region": region },
        ...requestId && { "ai-o11y-request-id": requestId }
      };
    };
  };
  const createLanguageModel = (modelId) => {
    return new GatewayLanguageModel2(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  const getAvailableModels = async () => {
    var _a922, _b92, _c;
    const now2 = (_c = (_b92 = (_a922 = options._internal) == null ? void 0 : _a922.currentDate) == null ? void 0 : _b92.call(_a922).getTime()) != null ? _c : Date.now();
    if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {
      lastFetchTime = now2;
      pendingMetadata = new GatewayFetchMetadata2({
        baseURL,
        headers: getHeaders,
        fetch: options.fetch
      }).getAvailableModels().then((metadata) => {
        metadataCache = metadata;
        return metadata;
      }).catch(async (error) => {
        throw await asGatewayError2(
          error,
          await parseAuthMethod2(await getHeaders())
        );
      });
    }
    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
  };
  const getCredits = async () => {
    return new GatewayFetchMetadata2({
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    }).getCredits().catch(async (error) => {
      throw await asGatewayError2(
        error,
        await parseAuthMethod2(await getHeaders())
      );
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Gateway Provider model function cannot be called with the new keyword."
      );
    }
    return createLanguageModel(modelId);
  };
  provider.specificationVersion = "v3";
  provider.getAvailableModels = getAvailableModels;
  provider.getCredits = getCredits;
  provider.imageModel = (modelId) => {
    return new GatewayImageModel2(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  provider.languageModel = createLanguageModel;
  const createEmbeddingModel = (modelId) => {
    return new GatewayEmbeddingModel2(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  provider.embeddingModel = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.tools = gatewayTools;
  return provider;
}
var gateway2 = createGatewayProvider2();
async function getGatewayAuthToken2(options) {
  const apiKey = loadOptionalSetting2({
    settingValue: options.apiKey,
    environmentVariableName: "AI_GATEWAY_API_KEY"
  });
  if (apiKey) {
    return {
      token: apiKey,
      authMethod: "api-key"
    };
  }
  const oidcToken = await (0, import_oidc22.getVercelOidcToken)();
  return {
    token: oidcToken,
    authMethod: "oidc"
  };
}
var _globalThis3 = typeof globalThis === "object" ? globalThis : global;
var VERSION23 = "1.9.0";
var re3 = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck3(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re3);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible222(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re3);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible3 = _makeCompatibilityCheck3(VERSION23);
var major3 = VERSION23.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY3 = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major3);
var _global3 = _globalThis3;
function registerGlobal3(type, instance, diag, allowOverride) {
  var _a21;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global3[GLOBAL_OPENTELEMETRY_API_KEY3] = (_a21 = _global3[GLOBAL_OPENTELEMETRY_API_KEY3]) !== null && _a21 !== void 0 ? _a21 : {
    version: VERSION23
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION23) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION23);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION23 + ".");
  return true;
}
function getGlobal3(type) {
  var _a21, _b83;
  var globalVersion = (_a21 = _global3[GLOBAL_OPENTELEMETRY_API_KEY3]) === null || _a21 === void 0 ? void 0 : _a21.version;
  if (!globalVersion || !isCompatible3(globalVersion)) {
    return;
  }
  return (_b83 = _global3[GLOBAL_OPENTELEMETRY_API_KEY3]) === null || _b83 === void 0 ? void 0 : _b83[type];
}
function unregisterGlobal3(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION23 + ".");
  var api = _global3[GLOBAL_OPENTELEMETRY_API_KEY3];
  if (api) {
    delete api[type];
  }
}
var __read6 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray6 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger3 = (
  /** @class */
  (function() {
    function DiagComponentLogger222(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger222.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy3("debug", this._namespace, args);
    };
    DiagComponentLogger222.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy3("error", this._namespace, args);
    };
    DiagComponentLogger222.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy3("info", this._namespace, args);
    };
    DiagComponentLogger222.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy3("warn", this._namespace, args);
    };
    DiagComponentLogger222.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy3("verbose", this._namespace, args);
    };
    return DiagComponentLogger222;
  })()
);
function logProxy3(funcName, namespace, args) {
  var logger = getGlobal3("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray6([], __read6(args), false));
}
var DiagLogLevel3;
(function(DiagLogLevel222) {
  DiagLogLevel222[DiagLogLevel222["NONE"] = 0] = "NONE";
  DiagLogLevel222[DiagLogLevel222["ERROR"] = 30] = "ERROR";
  DiagLogLevel222[DiagLogLevel222["WARN"] = 50] = "WARN";
  DiagLogLevel222[DiagLogLevel222["INFO"] = 60] = "INFO";
  DiagLogLevel222[DiagLogLevel222["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel222[DiagLogLevel222["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel222[DiagLogLevel222["ALL"] = 9999] = "ALL";
})(DiagLogLevel3 || (DiagLogLevel3 = {}));
function createLogLevelDiagLogger3(maxLevel, logger) {
  if (maxLevel < DiagLogLevel3.NONE) {
    maxLevel = DiagLogLevel3.NONE;
  } else if (maxLevel > DiagLogLevel3.ALL) {
    maxLevel = DiagLogLevel3.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel3.ERROR),
    warn: _filterFunc("warn", DiagLogLevel3.WARN),
    info: _filterFunc("info", DiagLogLevel3.INFO),
    debug: _filterFunc("debug", DiagLogLevel3.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel3.VERBOSE)
  };
}
var __read23 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray23 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME5 = "diag";
var DiagAPI3 = (
  /** @class */
  (function() {
    function DiagAPI222() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger = getGlobal3("diag");
          if (!logger)
            return;
          return logger[funcName].apply(logger, __spreadArray23([], __read23(args), false));
        };
      }
      var self = this;
      var setLogger = function(logger, optionsOrLogLevel) {
        var _a21, _b83, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel3.INFO };
        }
        if (logger === self) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a21 = err.stack) !== null && _a21 !== void 0 ? _a21 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal3("diag");
        var newLogger = createLogLevelDiagLogger3((_b83 = optionsOrLogLevel.logLevel) !== null && _b83 !== void 0 ? _b83 : DiagLogLevel3.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal3("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = function() {
        unregisterGlobal3(API_NAME5, self);
      };
      self.createComponentLogger = function(options) {
        return new DiagComponentLogger3(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    DiagAPI222.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI222();
      }
      return this._instance;
    };
    return DiagAPI222;
  })()
);
function createContextKey3(description) {
  return Symbol.for(description);
}
var BaseContext3 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BaseContext222(parentContext) {
      var self = this;
      self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self.getValue = function(key) {
        return self._currentContext.get(key);
      };
      self.setValue = function(key, value) {
        var context2 = new BaseContext222(self._currentContext);
        context2._currentContext.set(key, value);
        return context2;
      };
      self.deleteValue = function(key) {
        var context2 = new BaseContext222(self._currentContext);
        context2._currentContext.delete(key);
        return context2;
      };
    }
    return BaseContext222;
  })()
);
var ROOT_CONTEXT3 = new BaseContext3();
var __read33 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray33 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager3 = (
  /** @class */
  (function() {
    function NoopContextManager222() {
    }
    NoopContextManager222.prototype.active = function() {
      return ROOT_CONTEXT3;
    };
    NoopContextManager222.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray33([thisArg], __read33(args), false));
    };
    NoopContextManager222.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager222.prototype.enable = function() {
      return this;
    };
    NoopContextManager222.prototype.disable = function() {
      return this;
    };
    return NoopContextManager222;
  })()
);
var __read43 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray43 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME23 = "context";
var NOOP_CONTEXT_MANAGER3 = new NoopContextManager3();
var ContextAPI3 = (
  /** @class */
  (function() {
    function ContextAPI222() {
    }
    ContextAPI222.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI222();
      }
      return this._instance;
    };
    ContextAPI222.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal3(API_NAME23, contextManager, DiagAPI3.instance());
    };
    ContextAPI222.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI222.prototype.with = function(context2, fn, thisArg) {
      var _a21;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a21 = this._getContextManager()).with.apply(_a21, __spreadArray43([context2, fn, thisArg], __read43(args), false));
    };
    ContextAPI222.prototype.bind = function(context2, target) {
      return this._getContextManager().bind(context2, target);
    };
    ContextAPI222.prototype._getContextManager = function() {
      return getGlobal3(API_NAME23) || NOOP_CONTEXT_MANAGER3;
    };
    ContextAPI222.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal3(API_NAME23, DiagAPI3.instance());
    };
    return ContextAPI222;
  })()
);
var TraceFlags3;
(function(TraceFlags222) {
  TraceFlags222[TraceFlags222["NONE"] = 0] = "NONE";
  TraceFlags222[TraceFlags222["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags3 || (TraceFlags3 = {}));
var INVALID_SPANID3 = "0000000000000000";
var INVALID_TRACEID3 = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT3 = {
  traceId: INVALID_TRACEID3,
  spanId: INVALID_SPANID3,
  traceFlags: TraceFlags3.NONE
};
var NonRecordingSpan3 = (
  /** @class */
  (function() {
    function NonRecordingSpan222(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT3;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan222.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan222.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan222.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan222.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan222.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan222.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan222.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan222.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan222.prototype.end = function(_endTime) {
    };
    NonRecordingSpan222.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan222.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan222;
  })()
);
var SPAN_KEY3 = createContextKey3("OpenTelemetry Context Key SPAN");
function getSpan3(context2) {
  return context2.getValue(SPAN_KEY3) || void 0;
}
function getActiveSpan3() {
  return getSpan3(ContextAPI3.getInstance().active());
}
function setSpan3(context2, span) {
  return context2.setValue(SPAN_KEY3, span);
}
function deleteSpan3(context2) {
  return context2.deleteValue(SPAN_KEY3);
}
function setSpanContext3(context2, spanContext) {
  return setSpan3(context2, new NonRecordingSpan3(spanContext));
}
function getSpanContext3(context2) {
  var _a21;
  return (_a21 = getSpan3(context2)) === null || _a21 === void 0 ? void 0 : _a21.spanContext();
}
var VALID_TRACEID_REGEX3 = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX3 = /^[0-9a-f]{16}$/i;
function isValidTraceId3(traceId) {
  return VALID_TRACEID_REGEX3.test(traceId) && traceId !== INVALID_TRACEID3;
}
function isValidSpanId3(spanId) {
  return VALID_SPANID_REGEX3.test(spanId) && spanId !== INVALID_SPANID3;
}
function isSpanContextValid3(spanContext) {
  return isValidTraceId3(spanContext.traceId) && isValidSpanId3(spanContext.spanId);
}
function wrapSpanContext3(spanContext) {
  return new NonRecordingSpan3(spanContext);
}
var contextApi3 = ContextAPI3.getInstance();
var NoopTracer3 = (
  /** @class */
  (function() {
    function NoopTracer222() {
    }
    NoopTracer222.prototype.startSpan = function(name21, options, context2) {
      if (context2 === void 0) {
        context2 = contextApi3.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan3();
      }
      var parentFromContext = context2 && getSpanContext3(context2);
      if (isSpanContext3(parentFromContext) && isSpanContextValid3(parentFromContext)) {
        return new NonRecordingSpan3(parentFromContext);
      } else {
        return new NonRecordingSpan3();
      }
    };
    NoopTracer222.prototype.startActiveSpan = function(name21, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi3.active();
      var span = this.startSpan(name21, opts, parentContext);
      var contextWithSpanSet = setSpan3(parentContext, span);
      return contextApi3.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer222;
  })()
);
function isSpanContext3(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER3 = new NoopTracer3();
var ProxyTracer3 = (
  /** @class */
  (function() {
    function ProxyTracer222(_provider, name21, version, options) {
      this._provider = _provider;
      this.name = name21;
      this.version = version;
      this.options = options;
    }
    ProxyTracer222.prototype.startSpan = function(name21, options, context2) {
      return this._getTracer().startSpan(name21, options, context2);
    };
    ProxyTracer222.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer222.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER3;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer222;
  })()
);
var NoopTracerProvider3 = (
  /** @class */
  (function() {
    function NoopTracerProvider222() {
    }
    NoopTracerProvider222.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer3();
    };
    return NoopTracerProvider222;
  })()
);
var NOOP_TRACER_PROVIDER3 = new NoopTracerProvider3();
var ProxyTracerProvider3 = (
  /** @class */
  (function() {
    function ProxyTracerProvider222() {
    }
    ProxyTracerProvider222.prototype.getTracer = function(name21, version, options) {
      var _a21;
      return (_a21 = this.getDelegateTracer(name21, version, options)) !== null && _a21 !== void 0 ? _a21 : new ProxyTracer3(this, name21, version, options);
    };
    ProxyTracerProvider222.prototype.getDelegate = function() {
      var _a21;
      return (_a21 = this._delegate) !== null && _a21 !== void 0 ? _a21 : NOOP_TRACER_PROVIDER3;
    };
    ProxyTracerProvider222.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider222.prototype.getDelegateTracer = function(name21, version, options) {
      var _a21;
      return (_a21 = this._delegate) === null || _a21 === void 0 ? void 0 : _a21.getTracer(name21, version, options);
    };
    return ProxyTracerProvider222;
  })()
);
var SpanStatusCode3;
(function(SpanStatusCode222) {
  SpanStatusCode222[SpanStatusCode222["UNSET"] = 0] = "UNSET";
  SpanStatusCode222[SpanStatusCode222["OK"] = 1] = "OK";
  SpanStatusCode222[SpanStatusCode222["ERROR"] = 2] = "ERROR";
})(SpanStatusCode3 || (SpanStatusCode3 = {}));
var context = ContextAPI3.getInstance();
var API_NAME33 = "trace";
var TraceAPI3 = (
  /** @class */
  (function() {
    function TraceAPI222() {
      this._proxyTracerProvider = new ProxyTracerProvider3();
      this.wrapSpanContext = wrapSpanContext3;
      this.isSpanContextValid = isSpanContextValid3;
      this.deleteSpan = deleteSpan3;
      this.getSpan = getSpan3;
      this.getActiveSpan = getActiveSpan3;
      this.getSpanContext = getSpanContext3;
      this.setSpan = setSpan3;
      this.setSpanContext = setSpanContext3;
    }
    TraceAPI222.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI222();
      }
      return this._instance;
    };
    TraceAPI222.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal3(API_NAME33, this._proxyTracerProvider, DiagAPI3.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI222.prototype.getTracerProvider = function() {
      return getGlobal3(API_NAME33) || this._proxyTracerProvider;
    };
    TraceAPI222.prototype.getTracer = function(name21, version) {
      return this.getTracerProvider().getTracer(name21, version);
    };
    TraceAPI222.prototype.disable = function() {
      unregisterGlobal3(API_NAME33, DiagAPI3.instance());
      this._proxyTracerProvider = new ProxyTracerProvider3();
    };
    return TraceAPI222;
  })()
);
var trace3 = TraceAPI3.getInstance();
var __defProp4 = Object.defineProperty;
var __export32 = (target, all) => {
  for (var name21 in all)
    __defProp4(target, name21, { get: all[name21], enumerable: true });
};
var name76 = "AI_InvalidArgumentError";
var marker86 = `vercel.ai.error.${name76}`;
var symbol86 = Symbol.for(marker86);
var _a86;
var InvalidArgumentError23 = class extends AISDKError3 {
  constructor({
    parameter,
    value,
    message
  }) {
    super({
      name: name76,
      message: `Invalid argument for parameter ${parameter}: ${message}`
    });
    this[_a86] = true;
    this.parameter = parameter;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker86);
  }
};
_a86 = symbol86;
var name86 = "AI_NoObjectGeneratedError";
var marker823 = `vercel.ai.error.${name86}`;
var symbol823 = Symbol.for(marker823);
var _a823;
var NoObjectGeneratedError3 = class extends AISDKError3 {
  constructor({
    message = "No object generated.",
    cause,
    text: text222,
    response,
    usage,
    finishReason
  }) {
    super({ name: name86, message, cause });
    this[_a823] = true;
    this.text = text222;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker823);
  }
};
_a823 = symbol823;
var UnsupportedModelVersionError3 = class extends AISDKError3 {
  constructor(options) {
    super({
      name: "AI_UnsupportedModelVersionError",
      message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`
    });
    this.version = options.version;
    this.provider = options.provider;
    this.modelId = options.modelId;
  }
};
var name192 = "AI_RetryError";
var marker192 = `vercel.ai.error.${name192}`;
var symbol192 = Symbol.for(marker192);
var _a192;
var RetryError3 = class extends AISDKError3 {
  constructor({
    message,
    reason,
    errors
  }) {
    super({ name: name192, message });
    this[_a192] = true;
    this.reason = reason;
    this.errors = errors;
    this.lastError = errors[errors.length - 1];
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker192);
  }
};
_a192 = symbol192;
function formatWarning({
  warning,
  provider,
  model
}) {
  const prefix = `AI SDK Warning (${provider} / ${model}):`;
  switch (warning.type) {
    case "unsupported": {
      let message = `${prefix} The feature "${warning.feature}" is not supported.`;
      if (warning.details) {
        message += ` ${warning.details}`;
      }
      return message;
    }
    case "compatibility": {
      let message = `${prefix} The feature "${warning.feature}" is used in a compatibility mode.`;
      if (warning.details) {
        message += ` ${warning.details}`;
      }
      return message;
    }
    case "other": {
      return `${prefix} ${warning.message}`;
    }
    default: {
      return `${prefix} ${JSON.stringify(warning, null, 2)}`;
    }
  }
}
var FIRST_WARNING_INFO_MESSAGE = "AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.";
var hasLoggedBefore = false;
var logWarnings = (options) => {
  if (options.warnings.length === 0) {
    return;
  }
  const logger = globalThis.AI_SDK_LOG_WARNINGS;
  if (logger === false) {
    return;
  }
  if (typeof logger === "function") {
    logger(options);
    return;
  }
  if (!hasLoggedBefore) {
    hasLoggedBefore = true;
    console.info(FIRST_WARNING_INFO_MESSAGE);
  }
  for (const warning of options.warnings) {
    console.warn(
      formatWarning({
        warning,
        provider: options.provider,
        model: options.model
      })
    );
  }
};
function logV2CompatibilityWarning({
  provider,
  modelId
}) {
  logWarnings({
    warnings: [
      {
        type: "compatibility",
        feature: "specificationVersion",
        details: `Using v2 specification compatibility mode. Some features may not be available.`
      }
    ],
    provider,
    model: modelId
  });
}
function asEmbeddingModelV3(model) {
  if (model.specificationVersion === "v3") {
    return model;
  }
  logV2CompatibilityWarning({
    provider: model.provider,
    modelId: model.modelId
  });
  return new Proxy(model, {
    get(target, prop) {
      if (prop === "specificationVersion")
        return "v3";
      return target[prop];
    }
  });
}
function resolveEmbeddingModel2(model) {
  if (typeof model !== "string") {
    if (model.specificationVersion !== "v3" && model.specificationVersion !== "v2") {
      const unsupportedModel = model;
      throw new UnsupportedModelVersionError3({
        version: unsupportedModel.specificationVersion,
        provider: unsupportedModel.provider,
        modelId: unsupportedModel.modelId
      });
    }
    return asEmbeddingModelV3(model);
  }
  return getGlobalProvider2().embeddingModel(model);
}
function getGlobalProvider2() {
  var _a21;
  return (_a21 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a21 : gateway2;
}
function getTotalTimeoutMs(timeout) {
  if (timeout == null) {
    return void 0;
  }
  if (typeof timeout === "number") {
    return timeout;
  }
  return timeout.totalMs;
}
var VERSION33 = "6.0.69";
var dataContentSchema3 = z$2.union([
  z$2.string(),
  z$2.instanceof(Uint8Array),
  z$2.instanceof(ArrayBuffer),
  z$2.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a21, _b83;
      return (_b83 = (_a21 = globalThis.Buffer) == null ? void 0 : _a21.isBuffer(value)) != null ? _b83 : false;
    },
    { message: "Must be a Buffer" }
  )
]);
var jsonValueSchema3 = z$2.lazy(
  () => z$2.union([
    z$2.null(),
    z$2.string(),
    z$2.number(),
    z$2.boolean(),
    z$2.record(z$2.string(), jsonValueSchema3.optional()),
    z$2.array(jsonValueSchema3)
  ])
);
var providerMetadataSchema3 = z$2.record(
  z$2.string(),
  z$2.record(z$2.string(), jsonValueSchema3.optional())
);
var textPartSchema3 = z$2.object({
  type: z$2.literal("text"),
  text: z$2.string(),
  providerOptions: providerMetadataSchema3.optional()
});
var imagePartSchema3 = z$2.object({
  type: z$2.literal("image"),
  image: z$2.union([dataContentSchema3, z$2.instanceof(URL)]),
  mediaType: z$2.string().optional(),
  providerOptions: providerMetadataSchema3.optional()
});
var filePartSchema3 = z$2.object({
  type: z$2.literal("file"),
  data: z$2.union([dataContentSchema3, z$2.instanceof(URL)]),
  filename: z$2.string().optional(),
  mediaType: z$2.string(),
  providerOptions: providerMetadataSchema3.optional()
});
var reasoningPartSchema3 = z$2.object({
  type: z$2.literal("reasoning"),
  text: z$2.string(),
  providerOptions: providerMetadataSchema3.optional()
});
var toolCallPartSchema3 = z$2.object({
  type: z$2.literal("tool-call"),
  toolCallId: z$2.string(),
  toolName: z$2.string(),
  input: z$2.unknown(),
  providerOptions: providerMetadataSchema3.optional(),
  providerExecuted: z$2.boolean().optional()
});
var outputSchema2 = z$2.discriminatedUnion(
  "type",
  [
    z$2.object({
      type: z$2.literal("text"),
      value: z$2.string(),
      providerOptions: providerMetadataSchema3.optional()
    }),
    z$2.object({
      type: z$2.literal("json"),
      value: jsonValueSchema3,
      providerOptions: providerMetadataSchema3.optional()
    }),
    z$2.object({
      type: z$2.literal("execution-denied"),
      reason: z$2.string().optional(),
      providerOptions: providerMetadataSchema3.optional()
    }),
    z$2.object({
      type: z$2.literal("error-text"),
      value: z$2.string(),
      providerOptions: providerMetadataSchema3.optional()
    }),
    z$2.object({
      type: z$2.literal("error-json"),
      value: jsonValueSchema3,
      providerOptions: providerMetadataSchema3.optional()
    }),
    z$2.object({
      type: z$2.literal("content"),
      value: z$2.array(
        z$2.union([
          z$2.object({
            type: z$2.literal("text"),
            text: z$2.string(),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z$2.object({
            type: z$2.literal("media"),
            data: z$2.string(),
            mediaType: z$2.string()
          }),
          z$2.object({
            type: z$2.literal("file-data"),
            data: z$2.string(),
            mediaType: z$2.string(),
            filename: z$2.string().optional(),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z$2.object({
            type: z$2.literal("file-url"),
            url: z$2.string(),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z$2.object({
            type: z$2.literal("file-id"),
            fileId: z$2.union([z$2.string(), z$2.record(z$2.string(), z$2.string())]),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z$2.object({
            type: z$2.literal("image-data"),
            data: z$2.string(),
            mediaType: z$2.string(),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z$2.object({
            type: z$2.literal("image-url"),
            url: z$2.string(),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z$2.object({
            type: z$2.literal("image-file-id"),
            fileId: z$2.union([z$2.string(), z$2.record(z$2.string(), z$2.string())]),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z$2.object({
            type: z$2.literal("custom"),
            providerOptions: providerMetadataSchema3.optional()
          })
        ])
      )
    })
  ]
);
var toolResultPartSchema3 = z$2.object({
  type: z$2.literal("tool-result"),
  toolCallId: z$2.string(),
  toolName: z$2.string(),
  output: outputSchema2,
  providerOptions: providerMetadataSchema3.optional()
});
var toolApprovalRequestSchema = z$2.object({
  type: z$2.literal("tool-approval-request"),
  approvalId: z$2.string(),
  toolCallId: z$2.string()
});
var toolApprovalResponseSchema = z$2.object({
  type: z$2.literal("tool-approval-response"),
  approvalId: z$2.string(),
  approved: z$2.boolean(),
  reason: z$2.string().optional()
});
var systemModelMessageSchema2 = z$2.object(
  {
    role: z$2.literal("system"),
    content: z$2.string(),
    providerOptions: providerMetadataSchema3.optional()
  }
);
var userModelMessageSchema2 = z$2.object({
  role: z$2.literal("user"),
  content: z$2.union([
    z$2.string(),
    z$2.array(z$2.union([textPartSchema3, imagePartSchema3, filePartSchema3]))
  ]),
  providerOptions: providerMetadataSchema3.optional()
});
var assistantModelMessageSchema2 = z$2.object({
  role: z$2.literal("assistant"),
  content: z$2.union([
    z$2.string(),
    z$2.array(
      z$2.union([
        textPartSchema3,
        filePartSchema3,
        reasoningPartSchema3,
        toolCallPartSchema3,
        toolResultPartSchema3,
        toolApprovalRequestSchema
      ])
    )
  ]),
  providerOptions: providerMetadataSchema3.optional()
});
var toolModelMessageSchema2 = z$2.object({
  role: z$2.literal("tool"),
  content: z$2.array(z$2.union([toolResultPartSchema3, toolApprovalResponseSchema])),
  providerOptions: providerMetadataSchema3.optional()
});
z$2.union([
  systemModelMessageSchema2,
  userModelMessageSchema2,
  assistantModelMessageSchema2,
  toolModelMessageSchema2
]);
function assembleOperationName3({
  operationId,
  telemetry
}) {
  return {
    // standardized operation and resource name:
    "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
    "resource.name": telemetry == null ? void 0 : telemetry.functionId,
    // detailed, AI SDK specific data:
    "ai.operationId": operationId,
    "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
  };
}
function getBaseTelemetryAttributes3({
  model,
  settings,
  telemetry,
  headers
}) {
  var _a21;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    // settings:
    ...Object.entries(settings).reduce((attributes, [key, value]) => {
      if (key === "timeout") {
        const totalTimeoutMs = getTotalTimeoutMs(
          value
        );
        if (totalTimeoutMs != null) {
          attributes[`ai.settings.${key}`] = totalTimeoutMs;
        }
      } else {
        attributes[`ai.settings.${key}`] = value;
      }
      return attributes;
    }, {}),
    // add metadata as attributes:
    ...Object.entries((_a21 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a21 : {}).reduce(
      (attributes, [key, value]) => {
        attributes[`ai.telemetry.metadata.${key}`] = value;
        return attributes;
      },
      {}
    ),
    // request headers
    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {
      if (value !== void 0) {
        attributes[`ai.request.headers.${key}`] = value;
      }
      return attributes;
    }, {})
  };
}
var noopTracer3 = {
  startSpan() {
    return noopSpan3;
  },
  startActiveSpan(name21, arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
      return arg1(noopSpan3);
    }
    if (typeof arg2 === "function") {
      return arg2(noopSpan3);
    }
    if (typeof arg3 === "function") {
      return arg3(noopSpan3);
    }
  }
};
var noopSpan3 = {
  spanContext() {
    return noopSpanContext3;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  }
};
var noopSpanContext3 = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
function getTracer3({
  isEnabled = false,
  tracer
} = {}) {
  if (!isEnabled) {
    return noopTracer3;
  }
  if (tracer) {
    return tracer;
  }
  return trace3.getTracer("ai");
}
async function recordSpan3({
  name: name21,
  tracer,
  attributes,
  fn,
  endWhenDone = true
}) {
  return tracer.startActiveSpan(
    name21,
    { attributes: await attributes },
    async (span) => {
      const ctx = context.active();
      try {
        const result = await context.with(ctx, () => fn(span));
        if (endWhenDone) {
          span.end();
        }
        return result;
      } catch (error) {
        try {
          recordErrorOnSpan3(span, error);
        } finally {
          span.end();
        }
        throw error;
      }
    }
  );
}
function recordErrorOnSpan3(span, error) {
  if (error instanceof Error) {
    span.recordException({
      name: error.name,
      message: error.message,
      stack: error.stack
    });
    span.setStatus({
      code: SpanStatusCode3.ERROR,
      message: error.message
    });
  } else {
    span.setStatus({ code: SpanStatusCode3.ERROR });
  }
}
async function selectTelemetryAttributes3({
  telemetry,
  attributes
}) {
  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
    return {};
  }
  const resultAttributes = {};
  for (const [key, value] of Object.entries(attributes)) {
    if (value == null) {
      continue;
    }
    if (typeof value === "object" && "input" in value && typeof value.input === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
        continue;
      }
      const result = await value.input();
      if (result != null) {
        resultAttributes[key] = result;
      }
      continue;
    }
    if (typeof value === "object" && "output" in value && typeof value.output === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
        continue;
      }
      const result = await value.output();
      if (result != null) {
        resultAttributes[key] = result;
      }
      continue;
    }
    resultAttributes[key] = value;
  }
  return resultAttributes;
}
function getRetryDelayInMs2({
  error,
  exponentialBackoffDelay
}) {
  const headers = error.responseHeaders;
  if (!headers)
    return exponentialBackoffDelay;
  let ms;
  const retryAfterMs = headers["retry-after-ms"];
  if (retryAfterMs) {
    const timeoutMs = parseFloat(retryAfterMs);
    if (!Number.isNaN(timeoutMs)) {
      ms = timeoutMs;
    }
  }
  const retryAfter = headers["retry-after"];
  if (retryAfter && ms === void 0) {
    const timeoutSeconds = parseFloat(retryAfter);
    if (!Number.isNaN(timeoutSeconds)) {
      ms = timeoutSeconds * 1e3;
    } else {
      ms = Date.parse(retryAfter) - Date.now();
    }
  }
  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {
    return ms;
  }
  return exponentialBackoffDelay;
}
var retryWithExponentialBackoffRespectingRetryHeaders2 = ({
  maxRetries = 2,
  initialDelayInMs = 2e3,
  backoffFactor = 2,
  abortSignal
} = {}) => async (f) => _retryWithExponentialBackoff3(f, {
  maxRetries,
  delayInMs: initialDelayInMs,
  backoffFactor,
  abortSignal
});
async function _retryWithExponentialBackoff3(f, {
  maxRetries,
  delayInMs,
  backoffFactor,
  abortSignal
}, errors = []) {
  try {
    return await f();
  } catch (error) {
    if (isAbortError3(error)) {
      throw error;
    }
    if (maxRetries === 0) {
      throw error;
    }
    const errorMessage = getErrorMessage23(error);
    const newErrors = [...errors, error];
    const tryNumber = newErrors.length;
    if (tryNumber > maxRetries) {
      throw new RetryError3({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors
      });
    }
    if (error instanceof Error && APICallError3.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
      await delay3(
        getRetryDelayInMs2({
          error,
          exponentialBackoffDelay: delayInMs
        }),
        { abortSignal }
      );
      return _retryWithExponentialBackoff3(
        f,
        {
          maxRetries,
          delayInMs: backoffFactor * delayInMs,
          backoffFactor,
          abortSignal
        },
        newErrors
      );
    }
    if (tryNumber === 1) {
      throw error;
    }
    throw new RetryError3({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors
    });
  }
}
function prepareRetries3({
  maxRetries,
  abortSignal
}) {
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries)) {
      throw new InvalidArgumentError23({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer"
      });
    }
    if (maxRetries < 0) {
      throw new InvalidArgumentError23({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0"
      });
    }
  }
  const maxRetriesResult = maxRetries != null ? maxRetries : 2;
  return {
    maxRetries: maxRetriesResult,
    retry: retryWithExponentialBackoffRespectingRetryHeaders2({
      maxRetries: maxRetriesResult,
      abortSignal
    })
  };
}
var output_exports3 = {};
__export32(output_exports3, {
  array: () => array,
  choice: () => choice,
  json: () => json,
  object: () => object3,
  text: () => text3
});
function fixJson3(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
async function parsePartialJson3(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = await safeParseJSON3({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = await safeParseJSON3({ text: fixJson3(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
var text3 = () => ({
  name: "text",
  responseFormat: Promise.resolve({ type: "text" }),
  async parseCompleteOutput({ text: text222 }) {
    return text222;
  },
  async parsePartialOutput({ text: text222 }) {
    return { partial: text222 };
  },
  createElementStreamTransform() {
    return void 0;
  }
});
var object3 = ({
  schema: inputSchema,
  name: name21,
  description
}) => {
  const schema = asSchema3(inputSchema);
  return {
    name: "object",
    responseFormat: resolve2(schema.jsonSchema).then((jsonSchema222) => ({
      type: "json",
      schema: jsonSchema222,
      ...name21 != null && { name: name21 },
      ...description != null && { description }
    })),
    async parseCompleteOutput({ text: text222 }, context2) {
      const parseResult = await safeParseJSON3({ text: text222 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text222,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      const validationResult = await safeValidateTypes3({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text222,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      return validationResult.value;
    },
    async parsePartialOutput({ text: text222 }) {
      const result = await parsePartialJson3(text222);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input": {
          return void 0;
        }
        case "repaired-parse":
        case "successful-parse": {
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        }
      }
    },
    createElementStreamTransform() {
      return void 0;
    }
  };
};
var array = ({
  element: inputElementSchema,
  name: name21,
  description
}) => {
  const elementSchema = asSchema3(inputElementSchema);
  return {
    name: "array",
    // JSON schema that describes an array of elements:
    responseFormat: resolve2(elementSchema.jsonSchema).then((jsonSchema222) => {
      const { $schema, ...itemSchema } = jsonSchema222;
      return {
        type: "json",
        schema: {
          $schema: "http://json-schema.org/draft-07/schema#",
          type: "object",
          properties: {
            elements: { type: "array", items: itemSchema }
          },
          required: ["elements"],
          additionalProperties: false
        },
        ...name21 != null && { name: name21 },
        ...description != null && { description }
      };
    }),
    async parseCompleteOutput({ text: text222 }, context2) {
      const parseResult = await safeParseJSON3({ text: text222 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text222,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      const outerValue = parseResult.value;
      if (outerValue == null || typeof outerValue !== "object" || !("elements" in outerValue) || !Array.isArray(outerValue.elements)) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: response did not match schema.",
          cause: new TypeValidationError3({
            value: outerValue,
            cause: "response must be an object with an elements array"
          }),
          text: text222,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      for (const element of outerValue.elements) {
        const validationResult = await safeValidateTypes3({
          value: element,
          schema: elementSchema
        });
        if (!validationResult.success) {
          throw new NoObjectGeneratedError3({
            message: "No object generated: response did not match schema.",
            cause: validationResult.error,
            text: text222,
            response: context2.response,
            usage: context2.usage,
            finishReason: context2.finishReason
          });
        }
      }
      return outerValue.elements;
    },
    async parsePartialOutput({ text: text222 }) {
      const result = await parsePartialJson3(text222);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input": {
          return void 0;
        }
        case "repaired-parse":
        case "successful-parse": {
          const outerValue = result.value;
          if (outerValue == null || typeof outerValue !== "object" || !("elements" in outerValue) || !Array.isArray(outerValue.elements)) {
            return void 0;
          }
          const rawElements = result.state === "repaired-parse" && outerValue.elements.length > 0 ? outerValue.elements.slice(0, -1) : outerValue.elements;
          const parsedElements = [];
          for (const rawElement of rawElements) {
            const validationResult = await safeValidateTypes3({
              value: rawElement,
              schema: elementSchema
            });
            if (validationResult.success) {
              parsedElements.push(validationResult.value);
            }
          }
          return { partial: parsedElements };
        }
      }
    },
    createElementStreamTransform() {
      let publishedElements = 0;
      return new TransformStream({
        transform({ partialOutput }, controller) {
          if (partialOutput != null) {
            for (; publishedElements < partialOutput.length; publishedElements++) {
              controller.enqueue(partialOutput[publishedElements]);
            }
          }
        }
      });
    }
  };
};
var choice = ({
  options: choiceOptions,
  name: name21,
  description
}) => {
  return {
    name: "choice",
    // JSON schema that describes an enumeration:
    responseFormat: Promise.resolve({
      type: "json",
      schema: {
        $schema: "http://json-schema.org/draft-07/schema#",
        type: "object",
        properties: {
          result: { type: "string", enum: choiceOptions }
        },
        required: ["result"],
        additionalProperties: false
      },
      ...name21 != null && { name: name21 },
      ...description != null && { description }
    }),
    async parseCompleteOutput({ text: text222 }, context2) {
      const parseResult = await safeParseJSON3({ text: text222 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text222,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      const outerValue = parseResult.value;
      if (outerValue == null || typeof outerValue !== "object" || !("result" in outerValue) || typeof outerValue.result !== "string" || !choiceOptions.includes(outerValue.result)) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: response did not match schema.",
          cause: new TypeValidationError3({
            value: outerValue,
            cause: "response must be an object that contains a choice value."
          }),
          text: text222,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      return outerValue.result;
    },
    async parsePartialOutput({ text: text222 }) {
      const result = await parsePartialJson3(text222);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input": {
          return void 0;
        }
        case "repaired-parse":
        case "successful-parse": {
          const outerValue = result.value;
          if (outerValue == null || typeof outerValue !== "object" || !("result" in outerValue) || typeof outerValue.result !== "string") {
            return void 0;
          }
          const potentialMatches = choiceOptions.filter(
            (choiceOption) => choiceOption.startsWith(outerValue.result)
          );
          if (result.state === "successful-parse") {
            return potentialMatches.includes(outerValue.result) ? { partial: outerValue.result } : void 0;
          } else {
            return potentialMatches.length === 1 ? { partial: potentialMatches[0] } : void 0;
          }
        }
      }
    },
    createElementStreamTransform() {
      return void 0;
    }
  };
};
var json = ({
  name: name21,
  description
} = {}) => {
  return {
    name: "json",
    responseFormat: Promise.resolve({
      type: "json",
      ...name21 != null && { name: name21 },
      ...description != null && { description }
    }),
    async parseCompleteOutput({ text: text222 }, context2) {
      const parseResult = await safeParseJSON3({ text: text222 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text222,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      return parseResult.value;
    },
    async parsePartialOutput({ text: text222 }) {
      const result = await parsePartialJson3(text222);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input": {
          return void 0;
        }
        case "repaired-parse":
        case "successful-parse": {
          return result.value === void 0 ? void 0 : { partial: result.value };
        }
      }
    },
    createElementStreamTransform() {
      return void 0;
    }
  };
};
createIdGenerator3({
  prefix: "aitxt",
  size: 24
});
createIdGenerator3({
  prefix: "aitxt",
  size: 24
});
function splitArray3(array2, chunkSize) {
  if (chunkSize <= 0) {
    throw new Error("chunkSize must be greater than 0");
  }
  const result = [];
  for (let i = 0; i < array2.length; i += chunkSize) {
    result.push(array2.slice(i, i + chunkSize));
  }
  return result;
}
async function embedMany3({
  model: modelArg,
  values,
  maxParallelCalls = Infinity,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  providerOptions,
  experimental_telemetry: telemetry
}) {
  const model = resolveEmbeddingModel2(modelArg);
  const { maxRetries, retry } = prepareRetries3({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const headersWithUserAgent = withUserAgentSuffix2(
    headers != null ? headers : {},
    `ai/${VERSION33}`
  );
  const baseTelemetryAttributes = getBaseTelemetryAttributes3({
    model,
    telemetry,
    headers: headersWithUserAgent,
    settings: { maxRetries }
  });
  const tracer = getTracer3(telemetry);
  return recordSpan3({
    name: "ai.embedMany",
    attributes: selectTelemetryAttributes3({
      telemetry,
      attributes: {
        ...assembleOperationName3({ operationId: "ai.embedMany", telemetry }),
        ...baseTelemetryAttributes,
        // specific settings that only make sense on the outer level:
        "ai.values": {
          input: () => values.map((value) => JSON.stringify(value))
        }
      }
    }),
    tracer,
    fn: async (span) => {
      var _a21;
      const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([
        model.maxEmbeddingsPerCall,
        model.supportsParallelCalls
      ]);
      if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {
        const { embeddings: embeddings2, usage, warnings: warnings2, response, providerMetadata: providerMetadata2 } = await retry(() => {
          return recordSpan3({
            name: "ai.embedMany.doEmbed",
            attributes: selectTelemetryAttributes3({
              telemetry,
              attributes: {
                ...assembleOperationName3({
                  operationId: "ai.embedMany.doEmbed",
                  telemetry
                }),
                ...baseTelemetryAttributes,
                // specific settings that only make sense on the outer level:
                "ai.values": {
                  input: () => values.map((value) => JSON.stringify(value))
                }
              }
            }),
            tracer,
            fn: async (doEmbedSpan) => {
              var _a22222;
              const modelResponse = await model.doEmbed({
                values,
                abortSignal,
                headers: headersWithUserAgent,
                providerOptions
              });
              const embeddings3 = modelResponse.embeddings;
              const usage2 = (_a22222 = modelResponse.usage) != null ? _a22222 : { tokens: NaN };
              doEmbedSpan.setAttributes(
                await selectTelemetryAttributes3({
                  telemetry,
                  attributes: {
                    "ai.embeddings": {
                      output: () => embeddings3.map(
                        (embedding) => JSON.stringify(embedding)
                      )
                    },
                    "ai.usage.tokens": usage2.tokens
                  }
                })
              );
              return {
                embeddings: embeddings3,
                usage: usage2,
                warnings: modelResponse.warnings,
                providerMetadata: modelResponse.providerMetadata,
                response: modelResponse.response
              };
            }
          });
        });
        span.setAttributes(
          await selectTelemetryAttributes3({
            telemetry,
            attributes: {
              "ai.embeddings": {
                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))
              },
              "ai.usage.tokens": usage.tokens
            }
          })
        );
        logWarnings({
          warnings: warnings2,
          provider: model.provider,
          model: model.modelId
        });
        return new DefaultEmbedManyResult3({
          values,
          embeddings: embeddings2,
          usage,
          warnings: warnings2,
          providerMetadata: providerMetadata2,
          responses: [response]
        });
      }
      const valueChunks = splitArray3(values, maxEmbeddingsPerCall);
      const embeddings = [];
      const warnings = [];
      const responses = [];
      let tokens = 0;
      let providerMetadata;
      const parallelChunks = splitArray3(
        valueChunks,
        supportsParallelCalls ? maxParallelCalls : 1
      );
      for (const parallelChunk of parallelChunks) {
        const results = await Promise.all(
          parallelChunk.map((chunk) => {
            return retry(() => {
              return recordSpan3({
                name: "ai.embedMany.doEmbed",
                attributes: selectTelemetryAttributes3({
                  telemetry,
                  attributes: {
                    ...assembleOperationName3({
                      operationId: "ai.embedMany.doEmbed",
                      telemetry
                    }),
                    ...baseTelemetryAttributes,
                    // specific settings that only make sense on the outer level:
                    "ai.values": {
                      input: () => chunk.map((value) => JSON.stringify(value))
                    }
                  }
                }),
                tracer,
                fn: async (doEmbedSpan) => {
                  var _a22222;
                  const modelResponse = await model.doEmbed({
                    values: chunk,
                    abortSignal,
                    headers: headersWithUserAgent,
                    providerOptions
                  });
                  const embeddings2 = modelResponse.embeddings;
                  const usage = (_a22222 = modelResponse.usage) != null ? _a22222 : { tokens: NaN };
                  doEmbedSpan.setAttributes(
                    await selectTelemetryAttributes3({
                      telemetry,
                      attributes: {
                        "ai.embeddings": {
                          output: () => embeddings2.map(
                            (embedding) => JSON.stringify(embedding)
                          )
                        },
                        "ai.usage.tokens": usage.tokens
                      }
                    })
                  );
                  return {
                    embeddings: embeddings2,
                    usage,
                    warnings: modelResponse.warnings,
                    providerMetadata: modelResponse.providerMetadata,
                    response: modelResponse.response
                  };
                }
              });
            });
          })
        );
        for (const result of results) {
          embeddings.push(...result.embeddings);
          warnings.push(...result.warnings);
          responses.push(result.response);
          tokens += result.usage.tokens;
          if (result.providerMetadata) {
            if (!providerMetadata) {
              providerMetadata = { ...result.providerMetadata };
            } else {
              for (const [providerName, metadata] of Object.entries(
                result.providerMetadata
              )) {
                providerMetadata[providerName] = {
                  ...(_a21 = providerMetadata[providerName]) != null ? _a21 : {},
                  ...metadata
                };
              }
            }
          }
        }
      }
      span.setAttributes(
        await selectTelemetryAttributes3({
          telemetry,
          attributes: {
            "ai.embeddings": {
              output: () => embeddings.map((embedding) => JSON.stringify(embedding))
            },
            "ai.usage.tokens": tokens
          }
        })
      );
      logWarnings({
        warnings,
        provider: model.provider,
        model: model.modelId
      });
      return new DefaultEmbedManyResult3({
        values,
        embeddings,
        usage: { tokens },
        warnings,
        providerMetadata,
        responses
      });
    }
  });
}
var DefaultEmbedManyResult3 = class {
  constructor(options) {
    this.values = options.values;
    this.embeddings = options.embeddings;
    this.usage = options.usage;
    this.warnings = options.warnings;
    this.providerMetadata = options.providerMetadata;
    this.responses = options.responses;
  }
};
createIdGenerator3({ prefix: "aiobj", size: 24 });
createIdGenerator3({ prefix: "aiobj", size: 24 });
function deepMergeWorkingMemory(existing, update) {
  if (!update || typeof update !== "object" || Object.keys(update).length === 0) {
    return existing && typeof existing === "object" ? { ...existing } : {};
  }
  if (!existing || typeof existing !== "object") {
    return update;
  }
  const result = { ...existing };
  for (const key of Object.keys(update)) {
    const updateValue = update[key];
    const existingValue = result[key];
    if (updateValue === null) {
      delete result[key];
    } else if (Array.isArray(updateValue)) {
      result[key] = updateValue;
    } else if (typeof updateValue === "object" && updateValue !== null && typeof existingValue === "object" && existingValue !== null && !Array.isArray(existingValue)) {
      result[key] = deepMergeWorkingMemory(
        existingValue,
        updateValue
      );
    } else {
      result[key] = updateValue;
    }
  }
  return result;
}
var updateWorkingMemoryTool = (memoryConfig) => {
  const schema = memoryConfig?.workingMemory?.schema;
  let inputSchema = z.object({
    memory: z.string().describe(`The Markdown formatted working memory content to store. This MUST be a string. Never pass an object.`)
  });
  if (schema) {
    inputSchema = z.object({
      memory: schema instanceof ZodObject ? schema : convertSchemaToZod({ jsonSchema: schema }).describe(
        `The JSON formatted working memory content to store.`
      )
    });
  }
  const usesMergeSemantics = Boolean(schema);
  const description = schema ? `Update the working memory with new information. Data is merged with existing memory - you only need to include fields you want to add or update. Set a field to null to remove it. Arrays are replaced entirely when provided.` : `Update the working memory with new information. Any data not included will be overwritten. Always pass data as string to the memory field. Never pass an object.`;
  return createTool({
    id: "update-working-memory",
    description,
    inputSchema,
    execute: async (inputData, context2) => {
      const threadId = context2?.agent?.threadId;
      const resourceId = context2?.agent?.resourceId;
      const memory = context2?.memory;
      if (!memory) {
        throw new Error("Memory instance is required for working memory updates");
      }
      const scope = memoryConfig?.workingMemory?.scope || "resource";
      if (scope === "thread" && !threadId) {
        throw new Error("Thread ID is required for thread-scoped working memory updates");
      }
      if (scope === "resource" && !resourceId) {
        throw new Error("Resource ID is required for resource-scoped working memory updates");
      }
      if (threadId) {
        let thread = await memory.getThreadById({ threadId });
        if (!thread) {
          thread = await memory.createThread({
            threadId,
            resourceId,
            memoryConfig
          });
        }
        if (thread.resourceId && resourceId && thread.resourceId !== resourceId) {
          throw new Error(`Thread with id ${threadId} resourceId does not match the current resourceId ${resourceId}`);
        }
      }
      let workingMemory;
      if (usesMergeSemantics) {
        const existingRaw = await memory.getWorkingMemory({
          threadId,
          resourceId,
          memoryConfig
        });
        let existingData = null;
        if (existingRaw) {
          try {
            existingData = typeof existingRaw === "string" ? JSON.parse(existingRaw) : existingRaw;
          } catch {
            existingData = null;
          }
        }
        if (inputData.memory === void 0 || inputData.memory === null) {
          return { success: true, message: "No memory data provided, existing memory unchanged." };
        }
        let newData;
        if (typeof inputData.memory === "string") {
          try {
            newData = JSON.parse(inputData.memory);
          } catch (parseError) {
            const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
            throw new Error(
              `Failed to parse working memory input as JSON: ${errorMessage}. Raw input: ${inputData.memory.length > 500 ? inputData.memory.slice(0, 500) + "..." : inputData.memory}`
            );
          }
        } else {
          newData = inputData.memory;
        }
        const mergedData = deepMergeWorkingMemory(existingData, newData);
        workingMemory = JSON.stringify(mergedData);
      } else {
        workingMemory = typeof inputData.memory === "string" ? inputData.memory : JSON.stringify(inputData.memory);
      }
      await memory.updateWorkingMemory({
        threadId,
        resourceId,
        workingMemory,
        memoryConfig
      });
      return { success: true };
    }
  });
};
var __experimental_updateWorkingMemoryToolVNext = (config) => {
  return createTool({
    id: "update-working-memory",
    description: "Update the working memory with new information.",
    inputSchema: z.object({
      newMemory: z.string().optional().describe(
        `The ${config.workingMemory?.schema ? "JSON" : "Markdown"} formatted working memory content to store`
      ),
      searchString: z.string().optional().describe(
        "The working memory string to find. Will be replaced with the newMemory string. If this is omitted or doesn't exist, the newMemory string will be appended to the end of your working memory. Replacing single lines at a time is encouraged for greater accuracy. If updateReason is not 'append-new-memory', this search string must be provided or the tool call will be rejected."
      ),
      updateReason: z.enum(["append-new-memory", "clarify-existing-memory", "replace-irrelevant-memory"]).optional().describe(
        "The reason you're updating working memory. Passing any value other than 'append-new-memory' requires a searchString to be provided. Defaults to append-new-memory"
      )
    }),
    execute: async (inputData, context2) => {
      const threadId = context2?.agent?.threadId;
      const resourceId = context2?.agent?.resourceId;
      const memory = context2?.memory;
      if (!memory) {
        throw new Error("Memory instance is required for working memory updates");
      }
      const scope = config.workingMemory?.scope || "resource";
      if (scope === "thread" && !threadId) {
        throw new Error("Thread ID is required for thread-scoped working memory updates");
      }
      if (scope === "resource" && !resourceId) {
        throw new Error("Resource ID is required for resource-scoped working memory updates");
      }
      if (threadId) {
        let thread = await memory.getThreadById({ threadId });
        if (!thread) {
          thread = await memory.createThread({
            threadId,
            resourceId,
            memoryConfig: config
          });
        }
        if (thread.resourceId && resourceId && thread.resourceId !== resourceId) {
          throw new Error(`Thread with id ${threadId} resourceId does not match the current resourceId ${resourceId}`);
        }
      }
      const workingMemory = inputData.newMemory || "";
      if (!inputData.updateReason) inputData.updateReason = `append-new-memory`;
      if (inputData.searchString && config.workingMemory?.scope === `resource` && inputData.updateReason === `replace-irrelevant-memory`) {
        inputData.searchString = void 0;
      }
      if (inputData.updateReason === `append-new-memory` && inputData.searchString) {
        inputData.searchString = void 0;
      }
      if (inputData.updateReason !== `append-new-memory` && !inputData.searchString) {
        return {
          success: false,
          reason: `updateReason was ${inputData.updateReason} but no searchString was provided. Unable to replace undefined with "${inputData.newMemory}"`
        };
      }
      const result = await memory.__experimental_updateWorkingMemoryVNext({
        threadId,
        resourceId,
        workingMemory,
        searchString: inputData.searchString,
        memoryConfig: config
      });
      if (result) {
        return result;
      }
      return { success: true };
    }
  });
};
function normalizeObservationalMemoryConfig(config) {
  if (config === true) return { model: "google/gemini-2.5-flash" };
  if (config === false || config === void 0) return void 0;
  if (typeof config === "object" && config.enabled === false) return void 0;
  return config;
}
var CHARS_PER_TOKEN = 4;
var DEFAULT_MESSAGE_RANGE = { before: 1, after: 1 };
var DEFAULT_TOP_K = 4;
var isZodObject = (v) => v instanceof ZodObject;
var Memory = class extends MastraMemory {
  constructor(config = {}) {
    super({ name: "Memory", ...config });
    const mergedConfig = this.getMergedThreadConfig({
      workingMemory: config.options?.workingMemory || {
        // these defaults are now set inside @mastra/core/memory in getMergedThreadConfig.
        // In a future release we can remove it from this block - for now if we remove it
        // and someone bumps @mastra/memory without bumping @mastra/core the defaults wouldn't exist yet
        enabled: false,
        template: this.defaultWorkingMemoryTemplate
      },
      observationalMemory: config.options?.observationalMemory
    });
    this.threadConfig = mergedConfig;
  }
  /**
   * Gets the memory storage domain, throwing if not available.
   */
  async getMemoryStore() {
    const store = await this.storage.getStore("memory");
    if (!store) {
      throw new Error(`Memory storage domain is not available on ${this.storage.constructor.name}`);
    }
    return store;
  }
  async listMessagesByResourceId(args) {
    const memoryStore = await this.getMemoryStore();
    return memoryStore.listMessagesByResourceId(args);
  }
  async validateThreadIsOwnedByResource(threadId, resourceId, config) {
    const resourceScope = typeof config?.semanticRecall === "object" && config?.semanticRecall?.scope !== `thread` || config.semanticRecall === true;
    const thread = await this.getThreadById({ threadId });
    if (!thread && !resourceScope) {
      throw new Error(`No thread found with id ${threadId}`);
    }
    if (thread && thread.resourceId !== resourceId) {
      throw new Error(
        `Thread with id ${threadId} is for resource with id ${thread.resourceId} but resource ${resourceId} was queried.`
      );
    }
  }
  async recall(args) {
    const { threadId, resourceId, perPage: perPageArg, page, orderBy, threadConfig, vectorSearchString, filter: filter32 } = args;
    const config = this.getMergedThreadConfig(threadConfig || {});
    if (resourceId) await this.validateThreadIsOwnedByResource(threadId, resourceId, config);
    const perPage = perPageArg !== void 0 ? perPageArg : config.lastMessages;
    const shouldGetNewestAndReverse = !orderBy && perPage !== false;
    const effectiveOrderBy = shouldGetNewestAndReverse ? { field: "createdAt", direction: "DESC" } : orderBy;
    const vectorResults = [];
    this.logger.debug(`Memory recall() with:`, {
      threadId,
      perPage,
      page,
      orderBy: effectiveOrderBy,
      hasWorkingMemorySchema: Boolean(config.workingMemory?.schema),
      workingMemoryEnabled: config.workingMemory?.enabled,
      semanticRecallEnabled: Boolean(config.semanticRecall)
    });
    const defaultRange = DEFAULT_MESSAGE_RANGE;
    const defaultTopK = DEFAULT_TOP_K;
    const vectorConfig = typeof config?.semanticRecall === `boolean` ? {
      topK: defaultTopK,
      messageRange: defaultRange
    } : {
      topK: config?.semanticRecall?.topK ?? defaultTopK,
      messageRange: config?.semanticRecall?.messageRange ?? defaultRange
    };
    const resourceScope = typeof config?.semanticRecall === "object" && config?.semanticRecall?.scope !== `thread` || config.semanticRecall === true;
    if (resourceScope && !resourceId && config?.semanticRecall && vectorSearchString) {
      throw new Error(
        `Memory error: Resource-scoped semantic recall is enabled but no resourceId was provided. Either provide a resourceId or explicitly set semanticRecall.scope to 'thread'.`
      );
    }
    let usage;
    if (config?.semanticRecall && vectorSearchString && this.vector) {
      const result = await this.embedMessageContent(vectorSearchString);
      usage = result.usage;
      const { embeddings, dimension } = result;
      const { indexName } = await this.createEmbeddingIndex(dimension, config);
      await Promise.all(
        embeddings.map(async (embedding) => {
          if (typeof this.vector === `undefined`) {
            throw new Error(
              `Tried to query vector index ${indexName} but this Memory instance doesn't have an attached vector db.`
            );
          }
          vectorResults.push(
            ...await this.vector.query({
              indexName,
              queryVector: embedding,
              topK: vectorConfig.topK,
              filter: resourceScope ? {
                resource_id: resourceId
              } : {
                thread_id: threadId
              }
            })
          );
        })
      );
    }
    const memoryStore = await this.getMemoryStore();
    const paginatedResult = await memoryStore.listMessages({
      threadId,
      resourceId,
      perPage,
      page,
      orderBy: effectiveOrderBy,
      filter: filter32,
      ...vectorResults?.length ? {
        include: vectorResults.map((r) => ({
          id: r.metadata?.message_id,
          threadId: r.metadata?.thread_id,
          withNextMessages: typeof vectorConfig.messageRange === "number" ? vectorConfig.messageRange : vectorConfig.messageRange.after,
          withPreviousMessages: typeof vectorConfig.messageRange === "number" ? vectorConfig.messageRange : vectorConfig.messageRange.before
        }))
      } : {}
    });
    const rawMessages = shouldGetNewestAndReverse ? paginatedResult.messages.reverse() : paginatedResult.messages;
    const list = new MessageList({ threadId, resourceId }).add(rawMessages, "memory");
    const messages = list.get.all.db();
    return { messages, usage };
  }
  async getThreadById({ threadId }) {
    const memoryStore = await this.getMemoryStore();
    return memoryStore.getThreadById({ threadId });
  }
  async listThreads(args) {
    const memoryStore = await this.getMemoryStore();
    return memoryStore.listThreads(args);
  }
  async handleWorkingMemoryFromMetadata({
    workingMemory,
    resourceId,
    memoryConfig
  }) {
    const config = this.getMergedThreadConfig(memoryConfig || {});
    if (config.workingMemory?.enabled) {
      const scope = config.workingMemory.scope || "resource";
      if (scope === "resource" && resourceId) {
        const memoryStore = await this.getMemoryStore();
        await memoryStore.updateResource({
          resourceId,
          workingMemory
        });
      }
    }
  }
  async saveThread({
    thread,
    memoryConfig
  }) {
    const memoryStore = await this.getMemoryStore();
    const savedThread = await memoryStore.saveThread({ thread });
    if (thread.metadata?.workingMemory && typeof thread.metadata.workingMemory === "string" && thread.resourceId) {
      await this.handleWorkingMemoryFromMetadata({
        workingMemory: thread.metadata.workingMemory,
        resourceId: thread.resourceId,
        memoryConfig
      });
    }
    return savedThread;
  }
  async updateThread({
    id,
    title,
    metadata,
    memoryConfig
  }) {
    const memoryStore = await this.getMemoryStore();
    const updatedThread = await memoryStore.updateThread({
      id,
      title,
      metadata
    });
    if (metadata?.workingMemory && typeof metadata.workingMemory === "string" && updatedThread.resourceId) {
      await this.handleWorkingMemoryFromMetadata({
        workingMemory: metadata.workingMemory,
        resourceId: updatedThread.resourceId,
        memoryConfig
      });
    }
    return updatedThread;
  }
  async deleteThread(threadId) {
    const memoryStore = await this.getMemoryStore();
    await memoryStore.deleteThread({ threadId });
  }
  async updateWorkingMemory({
    threadId,
    resourceId,
    workingMemory,
    memoryConfig
  }) {
    const config = this.getMergedThreadConfig(memoryConfig || {});
    if (!config.workingMemory?.enabled) {
      throw new Error("Working memory is not enabled for this memory instance");
    }
    const scope = config.workingMemory.scope || "resource";
    if (scope === "resource" && !resourceId) {
      throw new Error(
        `Memory error: Resource-scoped working memory is enabled but no resourceId was provided. Either provide a resourceId or explicitly set workingMemory.scope to 'thread'.`
      );
    }
    const memoryStore = await this.getMemoryStore();
    if (scope === "resource" && resourceId) {
      await memoryStore.updateResource({
        resourceId,
        workingMemory
      });
    } else {
      const thread = await this.getThreadById({ threadId });
      if (!thread) {
        throw new Error(`Thread ${threadId} not found`);
      }
      await memoryStore.updateThread({
        id: threadId,
        title: thread.title || "Untitled Thread",
        metadata: {
          ...thread.metadata,
          workingMemory
        }
      });
    }
  }
  updateWorkingMemoryMutexes = /* @__PURE__ */ new Map();
  /**
   * @warning experimental! can be removed or changed at any time
   */
  async __experimental_updateWorkingMemoryVNext({
    threadId,
    resourceId,
    workingMemory,
    searchString,
    memoryConfig
  }) {
    const config = this.getMergedThreadConfig(memoryConfig || {});
    if (!config.workingMemory?.enabled) {
      throw new Error("Working memory is not enabled for this memory instance");
    }
    const mutexKey = memoryConfig?.workingMemory?.scope === `resource` ? `resource-${resourceId}` : `thread-${threadId}`;
    const mutex = this.updateWorkingMemoryMutexes.has(mutexKey) ? this.updateWorkingMemoryMutexes.get(mutexKey) : new Mutex();
    this.updateWorkingMemoryMutexes.set(mutexKey, mutex);
    const release = await mutex.acquire();
    try {
      const existingWorkingMemory = await this.getWorkingMemory({ threadId, resourceId, memoryConfig }) || "";
      const template = await this.getWorkingMemoryTemplate({ memoryConfig });
      let reason = "";
      if (existingWorkingMemory) {
        if (searchString && existingWorkingMemory?.includes(searchString)) {
          workingMemory = existingWorkingMemory.replace(searchString, workingMemory);
          reason = `found and replaced searchString with newMemory`;
        } else if (existingWorkingMemory.includes(workingMemory) || template?.content?.trim() === workingMemory.trim()) {
          return {
            success: false,
            reason: `attempted to insert duplicate data into working memory. this entry was skipped`
          };
        } else {
          if (searchString) {
            reason = `attempted to replace working memory string that doesn't exist. Appending to working memory instead.`;
          } else {
            reason = `appended newMemory to end of working memory`;
          }
          workingMemory = existingWorkingMemory + `
${workingMemory}`;
        }
      } else if (workingMemory === template?.content) {
        return {
          success: false,
          reason: `try again when you have data to add. newMemory was equal to the working memory template`
        };
      } else {
        reason = `started new working memory`;
      }
      workingMemory = template?.content ? workingMemory.replaceAll(template?.content, "") : workingMemory;
      const scope = config.workingMemory.scope || "resource";
      if (scope === "resource" && !resourceId) {
        throw new Error(
          `Memory error: Resource-scoped working memory is enabled but no resourceId was provided. Either provide a resourceId or explicitly set workingMemory.scope to 'thread'.`
        );
      }
      const memoryStore = await this.getMemoryStore();
      if (scope === "resource" && resourceId) {
        await memoryStore.updateResource({
          resourceId,
          workingMemory
        });
        if (reason) {
          return { success: true, reason };
        }
      } else {
        const thread = await this.getThreadById({ threadId });
        if (!thread) {
          throw new Error(`Thread ${threadId} not found`);
        }
        await memoryStore.updateThread({
          id: threadId,
          title: thread.title || "Untitled Thread",
          metadata: {
            ...thread.metadata,
            workingMemory
          }
        });
      }
      return { success: true, reason };
    } catch (e2) {
      this.logger.error(e2 instanceof Error ? e2.stack || e2.message : JSON.stringify(e2));
      return { success: false, reason: "Tool error." };
    } finally {
      release();
    }
  }
  chunkText(text42, tokenSize = 4096) {
    const charSize = tokenSize * CHARS_PER_TOKEN;
    const chunks = [];
    let currentChunk = "";
    const words = text42.split(/\s+/);
    for (const word of words) {
      const wordWithSpace = currentChunk ? " " + word : word;
      if (currentChunk.length + wordWithSpace.length > charSize) {
        chunks.push(currentChunk);
        currentChunk = word;
      } else {
        currentChunk += wordWithSpace;
      }
    }
    if (currentChunk) {
      chunks.push(currentChunk);
    }
    return chunks;
  }
  hasher = e();
  // embedding is computationally expensive so cache content -> embeddings/chunks
  embeddingCache = /* @__PURE__ */ new Map();
  firstEmbed;
  async embedMessageContent(content) {
    const key = (await this.hasher).h32(content);
    const cached = this.embeddingCache.get(key);
    if (cached) return cached;
    const chunks = this.chunkText(content);
    if (typeof this.embedder === `undefined`) {
      throw new Error(`Tried to embed message content but this Memory instance doesn't have an attached embedder.`);
    }
    const isFastEmbed = this.embedder.provider === `fastembed`;
    if (isFastEmbed && this.firstEmbed instanceof Promise) {
      await this.firstEmbed;
    }
    let embedFn;
    const specVersion = this.embedder.specificationVersion;
    switch (specVersion) {
      case "v3":
        embedFn = embedMany3;
        break;
      case "v2":
        embedFn = embedMany2;
        break;
      default:
        embedFn = embedMany;
        break;
    }
    const promise = embedFn({
      values: chunks,
      maxRetries: 3,
      // @ts-expect-error - embedder type mismatch
      model: this.embedder,
      ...this.embedderOptions || {}
    });
    if (isFastEmbed && !this.firstEmbed) this.firstEmbed = promise;
    const { embeddings, usage } = await promise;
    const result = {
      embeddings,
      chunks,
      usage,
      dimension: embeddings[0]?.length
    };
    this.embeddingCache.set(key, result);
    return result;
  }
  async saveMessages({
    messages,
    memoryConfig
  }) {
    const updatedMessages = messages.map((m) => {
      return this.updateMessageToHideWorkingMemoryV2(m);
    }).filter((m) => Boolean(m));
    const config = this.getMergedThreadConfig(memoryConfig);
    const dbMessages = new MessageList({
      generateMessageId: () => this.generateId()
    }).add(updatedMessages, "memory").get.all.db();
    const memoryStore = await this.getMemoryStore();
    const result = await memoryStore.saveMessages({
      messages: dbMessages
    });
    let totalTokens = 0;
    if (this.vector && config.semanticRecall) {
      const embeddingData = [];
      let dimension;
      await Promise.all(
        updatedMessages.map(async (message) => {
          let textForEmbedding = null;
          if (message.content.content && typeof message.content.content === "string" && message.content.content.trim() !== "") {
            textForEmbedding = message.content.content;
          } else if (message.content.parts && message.content.parts.length > 0) {
            const joined = message.content.parts.filter((part) => part.type === "text").map((part) => part.text).join(" ").trim();
            if (joined) textForEmbedding = joined;
          }
          if (!textForEmbedding) return;
          const result2 = await this.embedMessageContent(textForEmbedding);
          dimension = result2.dimension;
          if (result2.usage?.tokens) {
            totalTokens += result2.usage.tokens;
          }
          embeddingData.push({
            embeddings: result2.embeddings,
            metadata: result2.chunks.map(() => ({
              message_id: message.id,
              thread_id: message.threadId,
              resource_id: message.resourceId
            }))
          });
        })
      );
      if (embeddingData.length > 0 && dimension !== void 0) {
        if (typeof this.vector === `undefined`) {
          throw new Error(`Tried to upsert embeddings but this Memory instance doesn't have an attached vector db.`);
        }
        const { indexName } = await this.createEmbeddingIndex(dimension, config);
        const allVectors = [];
        const allMetadata = [];
        for (const data of embeddingData) {
          allVectors.push(...data.embeddings);
          allMetadata.push(...data.metadata);
        }
        await this.vector.upsert({
          indexName,
          vectors: allVectors,
          metadata: allMetadata
        });
      }
    }
    return { ...result, usage: totalTokens > 0 ? { tokens: totalTokens } : void 0 };
  }
  updateMessageToHideWorkingMemoryV2(message) {
    const newMessage = { ...message };
    if (message.content && typeof message.content === "object" && !Array.isArray(message.content)) {
      newMessage.content = { ...message.content };
    }
    if (typeof newMessage.content?.content === "string" && newMessage.content.content.length > 0) {
      newMessage.content.content = removeWorkingMemoryTags(newMessage.content.content).trim();
    }
    if (Array.isArray(newMessage.content?.parts)) {
      newMessage.content.parts = newMessage.content.parts.filter((part) => {
        if (part?.type === "tool-invocation") {
          return part.toolInvocation?.toolName !== "updateWorkingMemory";
        }
        return true;
      }).map((part) => {
        if (part?.type === "text") {
          const text42 = typeof part.text === "string" ? part.text : "";
          return {
            ...part,
            text: removeWorkingMemoryTags(text42).trim()
          };
        }
        return part;
      });
      if (newMessage.content.parts.length === 0) {
        return null;
      }
    }
    return newMessage;
  }
  parseWorkingMemory(text42) {
    if (!this.threadConfig.workingMemory?.enabled) return null;
    const content = extractWorkingMemoryContent(text42);
    return content?.trim() ?? null;
  }
  async getWorkingMemory({
    threadId,
    resourceId,
    memoryConfig
  }) {
    const config = this.getMergedThreadConfig(memoryConfig || {});
    if (!config.workingMemory?.enabled) {
      return null;
    }
    const scope = config.workingMemory.scope || "resource";
    let workingMemoryData = null;
    if (scope === "resource" && !resourceId) {
      throw new Error(
        `Memory error: Resource-scoped working memory is enabled but no resourceId was provided. Either provide a resourceId or explicitly set workingMemory.scope to 'thread'.`
      );
    }
    if (scope === "resource" && resourceId) {
      const memoryStore = await this.getMemoryStore();
      const resource = await memoryStore.getResourceById({ resourceId });
      workingMemoryData = resource?.workingMemory || null;
    } else {
      const thread = await this.getThreadById({ threadId });
      workingMemoryData = thread?.metadata?.workingMemory;
    }
    if (!workingMemoryData) {
      return null;
    }
    return workingMemoryData;
  }
  /**
   * Gets the working memory template for the current memory configuration.
   * Supports both ZodObject and JSONSchema7 schemas.
   *
   * @param memoryConfig - The memory configuration containing the working memory settings
   * @returns The working memory template with format and content, or null if working memory is disabled
   */
  async getWorkingMemoryTemplate({
    memoryConfig
  }) {
    const config = this.getMergedThreadConfig(memoryConfig);
    if (!config.workingMemory?.enabled) {
      return null;
    }
    if (config.workingMemory?.schema) {
      try {
        const schema = config.workingMemory.schema;
        let convertedSchema;
        if (isZodObject(schema)) {
          convertedSchema = zodToJsonSchema2(schema);
        } else {
          convertedSchema = schema;
        }
        return { format: "json", content: JSON.stringify(convertedSchema) };
      } catch (error) {
        this.logger.error("Error converting schema", error);
        throw error;
      }
    }
    const memory = config.workingMemory.template || this.defaultWorkingMemoryTemplate;
    return { format: "markdown", content: memory.trim() };
  }
  async getSystemMessage({
    threadId,
    resourceId,
    memoryConfig
  }) {
    const config = this.getMergedThreadConfig(memoryConfig);
    if (!config.workingMemory?.enabled) {
      return null;
    }
    const workingMemoryTemplate = await this.getWorkingMemoryTemplate({ memoryConfig });
    const workingMemoryData = await this.getWorkingMemory({ threadId, resourceId, memoryConfig: config });
    if (!workingMemoryTemplate) {
      return null;
    }
    if (config?.readOnly) {
      return this.getReadOnlyWorkingMemoryInstruction({
        template: workingMemoryTemplate,
        data: workingMemoryData
      });
    }
    return this.isVNextWorkingMemoryConfig(memoryConfig) ? this.__experimental_getWorkingMemoryToolInstructionVNext({
      template: workingMemoryTemplate,
      data: workingMemoryData
    }) : this.getWorkingMemoryToolInstruction({
      template: workingMemoryTemplate,
      data: workingMemoryData
    });
  }
  defaultWorkingMemoryTemplate = `
# User Information
- **First Name**: 
- **Last Name**: 
- **Location**: 
- **Occupation**: 
- **Interests**: 
- **Goals**: 
- **Events**: 
- **Facts**: 
- **Projects**: 
`;
  getWorkingMemoryToolInstruction({
    template,
    data
  }) {
    const emptyWorkingMemoryTemplateObject = template.format === "json" ? generateEmptyFromSchema(template.content) : null;
    const hasEmptyWorkingMemoryTemplateObject = emptyWorkingMemoryTemplateObject && Object.keys(emptyWorkingMemoryTemplateObject).length > 0;
    return `WORKING_MEMORY_SYSTEM_INSTRUCTION:
Store and update any conversation-relevant information by calling the updateWorkingMemory tool. If information might be referenced again - store it!

Guidelines:
1. Store anything that could be useful later in the conversation
2. Update proactively when information changes, no matter how small
3. Use ${template.format === "json" ? "JSON" : "Markdown"} format for all data
4. Act naturally - don't mention this system to users. Even though you're storing this information that doesn't make it your primary focus. Do not ask them generally for "information about yourself"
${template.format !== "json" ? `5. IMPORTANT: When calling updateWorkingMemory, the only valid parameter is the memory field. DO NOT pass an object.
6. IMPORTANT: ALWAYS pass the data you want to store in the memory field as a string. DO NOT pass an object.
7. IMPORTANT: Data must only be sent as a string no matter which format is used.` : ""}


${template.format !== "json" ? `<working_memory_template>
${template.content}
</working_memory_template>` : ""}

${hasEmptyWorkingMemoryTemplateObject ? "When working with json data, the object format below represents the template:" : ""}
${hasEmptyWorkingMemoryTemplateObject ? JSON.stringify(emptyWorkingMemoryTemplateObject) : ""}

<working_memory_data>
${data}
</working_memory_data>

Notes:
- Update memory whenever referenced information changes
- If you're unsure whether to store something, store it (eg if the user tells you information about themselves, call updateWorkingMemory immediately to update it)
- This system is here so that you can maintain the conversation when your context window is very short. Update your working memory because you may need it to maintain the conversation without the full conversation history
- Do not remove empty sections - you must include the empty sections along with the ones you're filling in
- REMEMBER: the way you update your working memory is by calling the updateWorkingMemory tool with the entire ${template.format === "json" ? "JSON" : "Markdown"} content. The system will store it for you. The user will not see it.
- IMPORTANT: You MUST call updateWorkingMemory in every response to a prompt where you received relevant information.
- IMPORTANT: Preserve the ${template.format === "json" ? "JSON" : "Markdown"} formatting structure above while updating the content.`;
  }
  __experimental_getWorkingMemoryToolInstructionVNext({
    template,
    data
  }) {
    return `WORKING_MEMORY_SYSTEM_INSTRUCTION:
Store and update any conversation-relevant information by calling the updateWorkingMemory tool.

Guidelines:
1. Store anything that could be useful later in the conversation
2. Update proactively when information changes, no matter how small
3. Use ${template.format === "json" ? "JSON" : "Markdown"} format for all data
4. Act naturally - don't mention this system to users. Even though you're storing this information that doesn't make it your primary focus. Do not ask them generally for "information about yourself"
5. If your memory has not changed, you do not need to call the updateWorkingMemory tool. By default it will persist and be available for you in future interactions
6. Information not being relevant to the current conversation is not a valid reason to replace or remove working memory information. Your working memory spans across multiple conversations and may be needed again later, even if it's not currently relevant.

<working_memory_template>
${template.content}
</working_memory_template>

<working_memory_data>
${data}
</working_memory_data>

Notes:
- Update memory whenever referenced information changes
${template.content !== this.defaultWorkingMemoryTemplate ? `- Only store information if it's in the working memory template, do not store other information unless the user asks you to remember it, as that non-template information may be irrelevant` : `- If you're unsure whether to store something, store it (eg if the user tells you information about themselves, call updateWorkingMemory immediately to update it)
`}
- This system is here so that you can maintain the conversation when your context window is very short. Update your working memory because you may need it to maintain the conversation without the full conversation history
- REMEMBER: the way you update your working memory is by calling the updateWorkingMemory tool with the ${template.format === "json" ? "JSON" : "Markdown"} content. The system will store it for you. The user will not see it.
- IMPORTANT: You MUST call updateWorkingMemory in every response to a prompt where you received relevant information if that information is not already stored.
- IMPORTANT: Preserve the ${template.format === "json" ? "JSON" : "Markdown"} formatting structure above while updating the content.
`;
  }
  /**
   * Generate read-only working memory instructions.
   * This provides the working memory context without any tool update instructions.
   * Used when memory is in readOnly mode.
   */
  getReadOnlyWorkingMemoryInstruction({ data }) {
    return `WORKING_MEMORY_SYSTEM_INSTRUCTION (READ-ONLY):
The following is your working memory - persistent information about the user and conversation collected over previous interactions. This data is provided for context to help you maintain continuity.

<working_memory_data>
${data || "No working memory data available."}
</working_memory_data>

Guidelines:
1. Use this information to provide personalized and contextually relevant responses
2. Act naturally - don't mention this system to users. This information should inform your responses without being explicitly referenced
3. This memory is read-only in the current session - you cannot update it

Notes:
- This system is here so that you can maintain the conversation when your context window is very short
- The user will not see the working memory data directly`;
  }
  isVNextWorkingMemoryConfig(config) {
    if (!config?.workingMemory) return false;
    const isMDWorkingMemory = !(`schema` in config.workingMemory) && (typeof config.workingMemory.template === `string` || config.workingMemory.template) && config.workingMemory;
    return Boolean(isMDWorkingMemory && isMDWorkingMemory.version === `vnext`);
  }
  listTools(config) {
    const mergedConfig = this.getMergedThreadConfig(config);
    if (mergedConfig.workingMemory?.enabled && !mergedConfig.readOnly) {
      return {
        updateWorkingMemory: this.isVNextWorkingMemoryConfig(mergedConfig) ? (
          // use the new experimental tool
          __experimental_updateWorkingMemoryToolVNext(mergedConfig)
        ) : updateWorkingMemoryTool(mergedConfig)
      };
    }
    return {};
  }
  /**
   * Updates a list of messages and syncs the vector database for semantic recall.
   * When message content is updated, the corresponding vector embeddings are also updated
   * to ensure semantic recall stays in sync with the message content.
   *
   * @param messages - The list of messages to update (must include id, can include partial content)
   * @param memoryConfig - Optional memory configuration to determine if semantic recall is enabled
   * @returns The list of updated messages
   */
  async updateMessages({
    messages,
    memoryConfig
  }) {
    if (messages.length === 0) return [];
    const memoryStore = await this.getMemoryStore();
    const config = this.getMergedThreadConfig(memoryConfig);
    if (this.vector && config.semanticRecall) {
      const messagesWithContent = messages.filter((m) => m.content !== void 0);
      if (messagesWithContent.length > 0) {
        const existingMessagesResult = await memoryStore.listMessagesById({
          messageIds: messagesWithContent.map((m) => m.id)
        });
        const existingMessagesMap = new Map(existingMessagesResult.messages.map((m) => [m.id, m]));
        const embeddingData = [];
        let dimension;
        const messageIdsWithNewEmbeddings = /* @__PURE__ */ new Set();
        const messageIdsWithClearedContent = /* @__PURE__ */ new Set();
        await Promise.all(
          messagesWithContent.map(async (message) => {
            const existingMessage = existingMessagesMap.get(message.id);
            if (!existingMessage) return;
            let textForEmbedding = null;
            const content = message.content;
            if (content) {
              if ("content" in content && content.content && typeof content.content === "string" && content.content.trim() !== "") {
                textForEmbedding = content.content;
              } else if ("parts" in content && content.parts && Array.isArray(content.parts) && content.parts.length > 0) {
                const joined = content.parts.filter((part) => part?.type === "text").map((part) => part.text).join(" ").trim();
                if (joined) textForEmbedding = joined;
              }
            }
            if (textForEmbedding) {
              const result = await this.embedMessageContent(textForEmbedding);
              dimension = result.dimension;
              embeddingData.push({
                embeddings: result.embeddings,
                metadata: result.chunks.map(() => ({
                  message_id: message.id,
                  thread_id: existingMessage.threadId,
                  resource_id: existingMessage.resourceId
                }))
              });
              messageIdsWithNewEmbeddings.add(message.id);
            } else {
              messageIdsWithClearedContent.add(message.id);
            }
          })
        );
        const messageIdsNeedingDeletion = /* @__PURE__ */ new Set([...messageIdsWithClearedContent, ...messageIdsWithNewEmbeddings]);
        if (messageIdsNeedingDeletion.size > 0) {
          try {
            const indexes = await this.vector.listIndexes();
            const memoryIndexes = indexes.filter((name21) => name21.startsWith("memory_messages"));
            for (const indexName of memoryIndexes) {
              for (const messageId of messageIdsNeedingDeletion) {
                try {
                  await this.vector.deleteVectors({
                    indexName,
                    filter: { message_id: messageId }
                  });
                } catch {
                  this.logger.debug(
                    `No existing vectors found for message ${messageId} in ${indexName}, skipping delete`
                  );
                }
              }
            }
          } catch {
            this.logger.debug(`No memory indexes found to delete from`);
          }
        }
        if (embeddingData.length > 0 && dimension !== void 0) {
          const { indexName } = await this.createEmbeddingIndex(dimension, config);
          const allVectors = [];
          const allMetadata = [];
          for (const data of embeddingData) {
            allVectors.push(...data.embeddings);
            allMetadata.push(...data.metadata);
          }
          await this.vector.upsert({
            indexName,
            vectors: allVectors,
            metadata: allMetadata
          });
        }
      }
    }
    return memoryStore.updateMessages({ messages });
  }
  /**
   * Deletes one or more messages
   * @param input - Must be an array containing either:
   *   - Message ID strings
   *   - Message objects with 'id' properties
   * @returns Promise that resolves when all messages are deleted
   */
  async deleteMessages(input) {
    let messageIds;
    if (!Array.isArray(input)) {
      throw new Error("Invalid input: must be an array of message IDs or message objects");
    }
    if (input.length === 0) {
      return;
    }
    messageIds = input.map((item) => {
      if (typeof item === "string") {
        return item;
      } else if (item && typeof item === "object" && "id" in item) {
        return item.id;
      } else {
        throw new Error("Invalid input: array items must be strings or objects with an id property");
      }
    });
    const invalidIds = messageIds.filter((id) => !id || typeof id !== "string");
    if (invalidIds.length > 0) {
      throw new Error("All message IDs must be non-empty strings");
    }
    const memoryStore = await this.getMemoryStore();
    await memoryStore.deleteMessages(messageIds);
  }
  /**
   * Clone a thread and its messages to create a new independent thread.
   * The cloned thread will have metadata tracking its source.
   *
   * If semantic recall is enabled, the cloned messages will also be embedded
   * and added to the vector store for semantic search.
   *
   * @param args - Clone configuration options
   * @param args.sourceThreadId - ID of the thread to clone
   * @param args.newThreadId - ID for the new cloned thread (if not provided, a random UUID will be generated)
   * @param args.resourceId - Resource ID for the new thread (defaults to source thread's resourceId)
   * @param args.title - Title for the new cloned thread
   * @param args.metadata - Additional metadata to merge with clone metadata
   * @param args.options - Options for filtering which messages to include
   * @param args.options.messageLimit - Maximum number of messages to copy (from most recent)
   * @param args.options.messageFilter - Filter messages by date range or specific IDs
   * @param memoryConfig - Optional memory configuration override
   * @returns The newly created thread and the cloned messages
   *
   * @example
   * ```typescript
   * // Clone entire thread
   * const { thread, clonedMessages } = await memory.cloneThread({
   *   sourceThreadId: 'thread-123',
   * });
   *
   * // Clone with custom ID
   * const { thread, clonedMessages } = await memory.cloneThread({
   *   sourceThreadId: 'thread-123',
   *   newThreadId: 'my-custom-thread-id',
   * });
   *
   * // Clone with message limit
   * const { thread, clonedMessages } = await memory.cloneThread({
   *   sourceThreadId: 'thread-123',
   *   title: 'My cloned conversation',
   *   options: {
   *     messageLimit: 10, // Only clone last 10 messages
   *   },
   * });
   *
   * // Clone with date filter
   * const { thread, clonedMessages } = await memory.cloneThread({
   *   sourceThreadId: 'thread-123',
   *   options: {
   *     messageFilter: {
   *       startDate: new Date('2024-01-01'),
   *       endDate: new Date('2024-06-01'),
   *     },
   *   },
   * });
   * ```
   */
  async cloneThread(args, memoryConfig) {
    const memoryStore = await this.getMemoryStore();
    const result = await memoryStore.cloneThread(args);
    const config = this.getMergedThreadConfig(memoryConfig);
    if (this.vector && config.semanticRecall && result.clonedMessages.length > 0) {
      await this.embedClonedMessages(result.clonedMessages, config);
    }
    if (config.workingMemory?.enabled) {
      const scope = config.workingMemory.scope || "resource";
      const sourceThread = await this.getThreadById({ threadId: args.sourceThreadId });
      const sourceResourceId = sourceThread?.resourceId;
      const shouldCopy = scope === "thread" || scope === "resource" && args.resourceId && args.resourceId !== sourceResourceId;
      if (shouldCopy) {
        const sourceWm = await this.getWorkingMemory({
          threadId: args.sourceThreadId,
          resourceId: sourceResourceId,
          memoryConfig
        });
        if (sourceWm) {
          await this.updateWorkingMemory({
            threadId: result.thread.id,
            resourceId: result.thread.resourceId,
            workingMemory: sourceWm,
            memoryConfig
          });
        }
      }
    }
    return result;
  }
  /**
   * Embed cloned messages for semantic recall.
   * This is similar to the embedding logic in saveMessages but operates on already-saved messages.
   */
  async embedClonedMessages(messages, config) {
    if (!this.vector || !this.embedder) {
      return;
    }
    const embeddingData = [];
    let dimension;
    await Promise.all(
      messages.map(async (message) => {
        let textForEmbedding = null;
        if (message.content?.content && typeof message.content.content === "string" && message.content.content.trim() !== "") {
          textForEmbedding = message.content.content;
        } else if (message.content?.parts && message.content.parts.length > 0) {
          const joined = message.content.parts.filter((part) => part.type === "text").map((part) => part.text).join(" ").trim();
          if (joined) textForEmbedding = joined;
        }
        if (!textForEmbedding) return;
        const result = await this.embedMessageContent(textForEmbedding);
        dimension = result.dimension;
        embeddingData.push({
          embeddings: result.embeddings,
          metadata: result.chunks.map(() => ({
            message_id: message.id,
            thread_id: message.threadId,
            resource_id: message.resourceId
          }))
        });
      })
    );
    if (embeddingData.length > 0 && dimension !== void 0) {
      const { indexName } = await this.createEmbeddingIndex(dimension, config);
      const allVectors = [];
      const allMetadata = [];
      for (const data of embeddingData) {
        allVectors.push(...data.embeddings);
        allMetadata.push(...data.metadata);
      }
      await this.vector.upsert({
        indexName,
        vectors: allVectors,
        metadata: allMetadata
      });
    }
  }
  /**
   * Get the clone metadata from a thread if it was cloned from another thread.
   *
   * @param thread - The thread to check
   * @returns The clone metadata if the thread is a clone, null otherwise
   *
   * @example
   * ```typescript
   * const thread = await memory.getThreadById({ threadId: 'thread-123' });
   * const cloneInfo = memory.getCloneMetadata(thread);
   * if (cloneInfo) {
   *   console.log(`This thread was cloned from ${cloneInfo.sourceThreadId}`);
   * }
   * ```
   */
  getCloneMetadata(thread) {
    if (!thread?.metadata?.clone) {
      return null;
    }
    return thread.metadata.clone;
  }
  /**
   * Check if a thread is a clone of another thread.
   *
   * @param thread - The thread to check
   * @returns True if the thread is a clone, false otherwise
   *
   * @example
   * ```typescript
   * const thread = await memory.getThreadById({ threadId: 'thread-123' });
   * if (memory.isClone(thread)) {
   *   console.log('This is a cloned thread');
   * }
   * ```
   */
  isClone(thread) {
    return this.getCloneMetadata(thread) !== null;
  }
  /**
   * Get the source thread that a cloned thread was created from.
   *
   * @param threadId - ID of the cloned thread
   * @returns The source thread if found, null if the thread is not a clone or source doesn't exist
   *
   * @example
   * ```typescript
   * const sourceThread = await memory.getSourceThread('cloned-thread-123');
   * if (sourceThread) {
   *   console.log(`Original thread: ${sourceThread.title}`);
   * }
   * ```
   */
  async getSourceThread(threadId) {
    const thread = await this.getThreadById({ threadId });
    const cloneMetadata = this.getCloneMetadata(thread);
    if (!cloneMetadata) {
      return null;
    }
    return this.getThreadById({ threadId: cloneMetadata.sourceThreadId });
  }
  /**
   * List all threads that were cloned from a specific source thread.
   *
   * @param sourceThreadId - ID of the source thread
   * @param resourceId - Optional resource ID to filter by
   * @returns Array of threads that are clones of the source thread
   *
   * @example
   * ```typescript
   * const clones = await memory.listClones('original-thread-123', 'user-456');
   * console.log(`Found ${clones.length} clones of this thread`);
   * ```
   */
  async listClones(sourceThreadId, resourceId) {
    let targetResourceId = resourceId;
    if (!targetResourceId) {
      const sourceThread = await this.getThreadById({ threadId: sourceThreadId });
      if (!sourceThread) {
        return [];
      }
      targetResourceId = sourceThread.resourceId;
    }
    const { threads } = await this.listThreads({
      filter: { resourceId: targetResourceId },
      perPage: false
      // Get all threads
    });
    return threads.filter((thread) => {
      const cloneMetadata = this.getCloneMetadata(thread);
      return cloneMetadata?.sourceThreadId === sourceThreadId;
    });
  }
  /**
   * Get the clone history chain for a thread (all ancestors back to the original).
   *
   * @param threadId - ID of the thread to get history for
   * @returns Array of threads from oldest ancestor to the given thread (inclusive)
   *
   * @example
   * ```typescript
   * const history = await memory.getCloneHistory('deeply-cloned-thread');
   * // Returns: [originalThread, firstClone, secondClone, deeplyClonedThread]
   * ```
   */
  async getCloneHistory(threadId) {
    const history = [];
    let currentThreadId = threadId;
    while (currentThreadId) {
      const thread = await this.getThreadById({ threadId: currentThreadId });
      if (!thread) {
        break;
      }
      history.unshift(thread);
      const cloneMetadata = this.getCloneMetadata(thread);
      currentThreadId = cloneMetadata?.sourceThreadId ?? null;
    }
    return history;
  }
  /**
   * Get input processors for this memory instance.
   * Extends the base implementation to add ObservationalMemory processor when configured.
   *
   * @param configuredProcessors - Processors already configured by the user (for deduplication)
   * @param context - Request context for runtime configuration
   * @returns Array of input processors configured for this memory instance
   */
  async getInputProcessors(configuredProcessors = [], context2) {
    const processors = await super.getInputProcessors(configuredProcessors, context2);
    const om = await this.createOMProcessor(configuredProcessors, context2);
    if (om) {
      processors.push(om);
    }
    return processors;
  }
  /**
   * Extends the base implementation to add ObservationalMemory as an output processor.
   * OM needs processOutputResult to save messages at the end of the agent turn,
   * even when the observation threshold was never reached during the loop.
   */
  async getOutputProcessors(configuredProcessors = [], context2) {
    const processors = await super.getOutputProcessors(configuredProcessors, context2);
    const om = await this.createOMProcessor(configuredProcessors, context2);
    if (om) {
      processors.push(om);
    }
    return processors;
  }
  /**
   * Creates an ObservationalMemory processor instance if configured and not already present.
   * A new instance is created per call — processorStates (e.g., sealedIds) are shared
   * via the ProcessorRunner's state map keyed by processor ID, not by instance identity.
   */
  async createOMProcessor(configuredProcessors = [], context2) {
    const hasObservationalMemory = configuredProcessors.some(
      (p) => !("workflow" in p) && p.id === "observational-memory"
    );
    const memoryContext = context2?.get("MastraMemory");
    const runtimeMemoryConfig = memoryContext?.memoryConfig;
    const effectiveConfig = runtimeMemoryConfig ? this.getMergedThreadConfig(runtimeMemoryConfig) : this.threadConfig;
    const omConfig = normalizeObservationalMemoryConfig(effectiveConfig.observationalMemory);
    if (!omConfig || hasObservationalMemory) {
      return null;
    }
    const coreSupportsOM = coreFeatures.has("observationalMemory");
    if (!coreSupportsOM) {
      throw new Error(
        "Observational memory is enabled but the installed version of @mastra/core does not support it. Please upgrade @mastra/core to a version that includes observational memory support."
      );
    }
    const memoryStore = await this.storage.getStore("memory");
    if (!memoryStore) {
      throw new Error(
        "Using Mastra Memory observational memory requires a storage adapter but no attached adapter was detected."
      );
    }
    if (!memoryStore.supportsObservationalMemory) {
      throw new Error(
        `Observational memory is enabled but the storage adapter (${memoryStore.constructor.name}) does not support it. If you're using @mastra/libsql, @mastra/pg, or @mastra/mongodb, upgrade to the latest version. Otherwise, use one of those adapters or disable observational memory.`
      );
    }
    if (omConfig.observation?.bufferTokens !== false && !coreFeatures.has("asyncBuffering")) {
      throw new Error(
        "Observational memory async buffering is enabled by default but the installed version of @mastra/core does not support it. Either upgrade @mastra/core, @mastra/memory, and your storage adapter (@mastra/libsql, @mastra/pg, or @mastra/mongodb) to the latest version, or explicitly disable async buffering by setting `observation: { bufferTokens: false }` in your observationalMemory config."
      );
    }
    const { ObservationalMemory } = await import('./observational-memory-3DA7KJIH-6FXIVBWF.mjs');
    return new ObservationalMemory({
      storage: memoryStore,
      scope: omConfig.scope,
      shareTokenBudget: omConfig.shareTokenBudget,
      model: omConfig.model,
      observation: omConfig.observation ? {
        model: omConfig.observation.model,
        messageTokens: omConfig.observation.messageTokens,
        modelSettings: omConfig.observation.modelSettings,
        maxTokensPerBatch: omConfig.observation.maxTokensPerBatch,
        providerOptions: omConfig.observation.providerOptions,
        bufferTokens: omConfig.observation.bufferTokens,
        bufferActivation: omConfig.observation.bufferActivation,
        blockAfter: omConfig.observation.blockAfter
      } : void 0,
      reflection: omConfig.reflection ? {
        model: omConfig.reflection.model,
        observationTokens: omConfig.reflection.observationTokens,
        modelSettings: omConfig.reflection.modelSettings,
        providerOptions: omConfig.reflection.providerOptions,
        bufferActivation: omConfig.reflection.bufferActivation,
        blockAfter: omConfig.reflection.blockAfter
      } : void 0
    });
  }
};

// ../agent-builder/dist/index.js
var import_ignore = __toESM$3(require_ignore());
var UNIT_KINDS = ["mcp-server", "tool", "workflow", "agent", "integration", "network", "other"];
var TemplateUnitSchema = z.object({
  kind: z.enum(UNIT_KINDS),
  id: z.string(),
  file: z.string()
});
z.object({
  slug: z.string(),
  ref: z.string().optional(),
  description: z.string().optional(),
  units: z.array(TemplateUnitSchema)
});
var AgentBuilderInputSchema = z.object({
  repo: z.string().describe("Git URL or local path of the template repo"),
  ref: z.string().optional().describe("Tag/branch/commit to checkout (defaults to main/master)"),
  slug: z.string().optional().describe("Slug for branch/scripts; defaults to inferred from repo"),
  targetPath: z.string().optional().describe("Project path to merge into; defaults to current directory"),
  variables: z.record(z.string()).optional().describe("Environment variables to set in .env file")
});
z.object({
  slug: z.string(),
  commitSha: z.string(),
  templateDir: z.string(),
  units: z.array(TemplateUnitSchema)
});
var CopiedFileSchema = z.object({
  source: z.string(),
  destination: z.string(),
  unit: z.object({
    kind: z.enum(UNIT_KINDS),
    id: z.string()
  })
});
var ConflictSchema = z.object({
  unit: z.object({
    kind: z.enum(UNIT_KINDS),
    id: z.string()
  }),
  issue: z.string(),
  sourceFile: z.string(),
  targetFile: z.string()
});
var FileCopyInputSchema = z.object({
  orderedUnits: z.array(TemplateUnitSchema),
  templateDir: z.string(),
  commitSha: z.string(),
  slug: z.string(),
  targetPath: z.string().optional(),
  variables: z.record(z.string()).optional()
});
var FileCopyResultSchema = z.object({
  success: z.boolean(),
  copiedFiles: z.array(CopiedFileSchema),
  conflicts: z.array(ConflictSchema),
  message: z.string(),
  error: z.string().optional()
});
var ConflictResolutionSchema = z.object({
  unit: z.object({
    kind: z.enum(UNIT_KINDS),
    id: z.string()
  }),
  issue: z.string(),
  resolution: z.string()
});
var IntelligentMergeInputSchema = z.object({
  conflicts: z.array(ConflictSchema),
  copiedFiles: z.array(CopiedFileSchema),
  templateDir: z.string(),
  commitSha: z.string(),
  slug: z.string(),
  targetPath: z.string().optional(),
  branchName: z.string().optional()
});
var IntelligentMergeResultSchema = z.object({
  success: z.boolean(),
  applied: z.boolean(),
  message: z.string(),
  conflictsResolved: z.array(ConflictResolutionSchema),
  error: z.string().optional()
});
var ValidationResultsSchema = z.object({
  valid: z.boolean(),
  errorsFixed: z.number(),
  remainingErrors: z.number(),
  errors: z.array(z.any()).optional()
  // Include specific validation errors
});
var ValidationFixInputSchema = z.object({
  commitSha: z.string(),
  slug: z.string(),
  targetPath: z.string().optional(),
  templateDir: z.string(),
  orderedUnits: z.array(TemplateUnitSchema),
  copiedFiles: z.array(CopiedFileSchema),
  conflictsResolved: z.array(ConflictResolutionSchema).optional(),
  maxIterations: z.number().optional().default(5)
});
var ValidationFixResultSchema = z.object({
  success: z.boolean(),
  applied: z.boolean(),
  message: z.string(),
  validationResults: ValidationResultsSchema,
  error: z.string().optional()
});
var ApplyResultSchema = z.object({
  success: z.boolean(),
  applied: z.boolean(),
  branchName: z.string().optional(),
  message: z.string(),
  validationResults: ValidationResultsSchema.optional(),
  error: z.string().optional(),
  errors: z.array(z.string()).optional(),
  stepResults: z.object({
    cloneSuccess: z.boolean().optional(),
    analyzeSuccess: z.boolean().optional(),
    discoverSuccess: z.boolean().optional(),
    orderSuccess: z.boolean().optional(),
    prepareBranchSuccess: z.boolean().optional(),
    packageMergeSuccess: z.boolean().optional(),
    installSuccess: z.boolean().optional(),
    copySuccess: z.boolean().optional(),
    mergeSuccess: z.boolean().optional(),
    validationSuccess: z.boolean().optional(),
    filesCopied: z.number(),
    conflictsSkipped: z.number(),
    conflictsResolved: z.number()
  }).optional()
});
var CloneTemplateResultSchema = z.object({
  templateDir: z.string(),
  commitSha: z.string(),
  slug: z.string(),
  success: z.boolean().optional(),
  error: z.string().optional(),
  targetPath: z.string().optional()
});
var PackageAnalysisSchema = z.object({
  name: z.string().optional(),
  version: z.string().optional(),
  description: z.string().optional(),
  dependencies: z.record(z.string()).optional(),
  devDependencies: z.record(z.string()).optional(),
  peerDependencies: z.record(z.string()).optional(),
  scripts: z.record(z.string()).optional(),
  success: z.boolean().optional(),
  error: z.string().optional()
});
var DiscoveryResultSchema = z.object({
  units: z.array(TemplateUnitSchema),
  success: z.boolean().optional(),
  error: z.string().optional()
});
var OrderedUnitsSchema = z.object({
  orderedUnits: z.array(TemplateUnitSchema),
  success: z.boolean().optional(),
  error: z.string().optional()
});
var PackageMergeInputSchema = z.object({
  commitSha: z.string(),
  slug: z.string(),
  targetPath: z.string().optional(),
  packageInfo: PackageAnalysisSchema
});
var PackageMergeResultSchema = z.object({
  success: z.boolean(),
  applied: z.boolean(),
  message: z.string(),
  error: z.string().optional()
});
var InstallInputSchema = z.object({
  targetPath: z.string().optional().describe("Path to the project to install packages in")
});
var InstallResultSchema = z.object({
  success: z.boolean(),
  error: z.string().optional()
});
var PrepareBranchInputSchema = z.object({
  slug: z.string(),
  commitSha: z.string().optional(),
  // from clone-template if relevant
  targetPath: z.string().optional()
});
var PrepareBranchResultSchema = z.object({
  branchName: z.string(),
  success: z.boolean().optional(),
  error: z.string().optional()
});
var exec = promisify(exec$1);
var execFile = promisify(execFile$1);
function isInWorkspaceSubfolder(cwd) {
  try {
    const currentPackageJson = resolve$2(cwd, "package.json");
    if (!existsSync(currentPackageJson)) {
      return false;
    }
    let currentDir = cwd;
    let previousDir = "";
    while (currentDir !== previousDir && currentDir !== "/") {
      previousDir = currentDir;
      currentDir = dirname(currentDir);
      if (currentDir === cwd) {
        continue;
      }
      console.info(`Checking for workspace indicators in: ${currentDir}`);
      if (existsSync(resolve$2(currentDir, "pnpm-workspace.yaml"))) {
        return true;
      }
      const parentPackageJson = resolve$2(currentDir, "package.json");
      if (existsSync(parentPackageJson)) {
        try {
          const parentPkg = JSON.parse(readFileSync(parentPackageJson, "utf-8"));
          if (parentPkg.workspaces) {
            return true;
          }
        } catch {
        }
      }
      if (existsSync(resolve$2(currentDir, "lerna.json"))) {
        return true;
      }
    }
    return false;
  } catch (error) {
    console.warn(`Error in workspace detection: ${error}`);
    return false;
  }
}
function spawn(command, args, options) {
  return new Promise((resolve5, reject) => {
    const childProcess = spawn$1(command, args, {
      stdio: "inherit",
      // Enable proper stdio handling
      ...options
    });
    childProcess.on("error", (error) => {
      reject(error);
    });
    childProcess.on("close", (code) => {
      if (code === 0) {
        resolve5(void 0);
      } else {
        reject(new Error(`Command failed with exit code ${code}`));
      }
    });
  });
}
async function isGitInstalled() {
  try {
    await spawnWithOutput("git", ["--version"], {});
    return true;
  } catch {
    return false;
  }
}
async function isInsideGitRepo(cwd) {
  try {
    if (!await isGitInstalled()) return false;
    const { stdout } = await spawnWithOutput("git", ["rev-parse", "--is-inside-work-tree"], { cwd });
    return stdout.trim() === "true";
  } catch {
    return false;
  }
}
function spawnWithOutput(command, args, options) {
  return new Promise((resolvePromise, rejectPromise) => {
    const childProcess = spawn$1(command, args, {
      ...options
    });
    let stdout = "";
    let stderr = "";
    childProcess.on("error", (error) => {
      rejectPromise(error);
    });
    childProcess.stdout?.on("data", (chunk) => {
      process.stdout.write(chunk);
      stdout += chunk?.toString?.() ?? String(chunk);
    });
    childProcess.stderr?.on("data", (chunk) => {
      stderr += chunk?.toString?.() ?? String(chunk);
      process.stderr.write(chunk);
    });
    childProcess.on("close", (code) => {
      if (code === 0) {
        resolvePromise({ stdout, stderr, code: code ?? 0 });
      } else {
        const err = new Error(stderr || `Command failed: ${command} ${args.join(" ")}`);
        err.code = code;
        rejectPromise(err);
      }
    });
  });
}
async function spawnSWPM(cwd, command, packageNames) {
  try {
    console.info("Running install command with swpm");
    const swpmPath = createRequire(import.meta.filename).resolve("swpm");
    await spawn(swpmPath, [command, ...packageNames], { cwd });
    return;
  } catch (e2) {
    console.warn("Failed to run install command with swpm", e2);
  }
  try {
    let packageManager;
    if (existsSync(resolve$2(cwd, "pnpm-lock.yaml"))) {
      packageManager = "pnpm";
    } else if (existsSync(resolve$2(cwd, "yarn.lock"))) {
      packageManager = "yarn";
    } else {
      packageManager = "npm";
    }
    let nativeCommand = command === "add" ? "add" : command === "install" ? "install" : command;
    const args = [nativeCommand];
    if (nativeCommand === "install") {
      const inWorkspace = isInWorkspaceSubfolder(cwd);
      if (packageManager === "pnpm") {
        args.push("--force");
        if (inWorkspace) {
          args.push("--ignore-workspace");
        }
      } else if (packageManager === "npm") {
        args.push("--yes");
        if (inWorkspace) {
          args.push("--ignore-workspaces");
        }
      }
    }
    args.push(...packageNames);
    console.info(`Falling back to ${packageManager} ${args.join(" ")}`);
    await spawn(packageManager, args, { cwd });
    return;
  } catch (e2) {
    console.warn(`Failed to run install command with native package manager: ${e2}`);
  }
  throw new Error(`Failed to run install command with swpm and native package managers`);
}
function kindWeight(kind) {
  const idx = UNIT_KINDS.indexOf(kind);
  return idx === -1 ? UNIT_KINDS.length : idx;
}
async function logGitState(targetPath, label) {
  try {
    if (!await isInsideGitRepo(targetPath)) return;
    const gitStatusResult = await git(targetPath, "status", "--porcelain");
    const gitLogResult = await git(targetPath, "log", "--oneline", "-3");
    const gitCountResult = await git(targetPath, "rev-list", "--count", "HEAD");
    console.info(`\u{1F4CA} Git state ${label}:`);
    console.info("Status:", gitStatusResult.stdout.trim() || "Clean working directory");
    console.info("Recent commits:", gitLogResult.stdout.trim());
    console.info("Total commits:", gitCountResult.stdout.trim());
  } catch (gitError) {
    console.warn(`Could not get git state ${label}:`, gitError);
  }
}
async function git(cwd, ...args) {
  const { stdout, stderr } = await spawnWithOutput("git", args, { cwd });
  return { stdout: stdout ?? "", stderr: stderr ?? "" };
}
async function gitClone(repo, destDir, cwd) {
  await git(process.cwd(), "clone", repo, destDir);
}
async function gitCheckoutRef(cwd, ref) {
  if (!await isInsideGitRepo(cwd)) return;
  await git(cwd, "checkout", ref);
}
async function gitRevParse(cwd, rev) {
  if (!await isInsideGitRepo(cwd)) return "";
  const { stdout } = await git(cwd, "rev-parse", rev);
  return stdout.trim();
}
async function gitAddFiles(cwd, files) {
  if (!files || files.length === 0) return;
  if (!await isInsideGitRepo(cwd)) return;
  await git(cwd, "add", ...files);
}
async function gitAddAll(cwd) {
  if (!await isInsideGitRepo(cwd)) return;
  await git(cwd, "add", ".");
}
async function gitHasStagedChanges(cwd) {
  if (!await isInsideGitRepo(cwd)) return false;
  const { stdout } = await git(cwd, "diff", "--cached", "--name-only");
  return stdout.trim().length > 0;
}
async function gitCommit(cwd, message, opts) {
  try {
    if (!await isInsideGitRepo(cwd)) return false;
    if (opts?.skipIfNoStaged) {
      const has = await gitHasStagedChanges(cwd);
      if (!has) return false;
    }
    const args = ["commit", "-m", message];
    if (opts?.allowEmpty) args.push("--allow-empty");
    await git(cwd, ...args);
    return true;
  } catch (e2) {
    const msg = e2 instanceof Error ? e2.message : String(e2);
    if (/nothing to commit/i.test(msg) || /no changes added to commit/i.test(msg)) {
      return false;
    }
    throw e2;
  }
}
async function gitAddAndCommit(cwd, message, files, opts) {
  try {
    if (!await isInsideGitRepo(cwd)) return false;
    if (files && files.length > 0) {
      await gitAddFiles(cwd, files);
    } else {
      await gitAddAll(cwd);
    }
    return gitCommit(cwd, message, opts);
  } catch (e2) {
    console.error(`Failed to add and commit files: ${e2 instanceof Error ? e2.message : String(e2)}`);
    return false;
  }
}
async function gitCheckoutBranch(branchName, targetPath) {
  try {
    if (!await isInsideGitRepo(targetPath)) return;
    await git(targetPath, "checkout", "-b", branchName);
    console.info(`Created new branch: ${branchName}`);
  } catch (error) {
    const errorStr = error instanceof Error ? error.message : String(error);
    if (errorStr.includes("already exists")) {
      try {
        await git(targetPath, "checkout", branchName);
        console.info(`Switched to existing branch: ${branchName}`);
      } catch {
        const timestamp = Date.now().toString().slice(-6);
        const uniqueBranchName = `${branchName}-${timestamp}`;
        await git(targetPath, "checkout", "-b", uniqueBranchName);
        console.info(`Created unique branch: ${uniqueBranchName}`);
      }
    } else {
      throw error;
    }
  }
}
async function backupAndReplaceFile(sourceFile, targetFile) {
  const backupFile = `${targetFile}.backup-${Date.now()}`;
  await copyFile(targetFile, backupFile);
  console.info(`\u{1F4E6} Created backup: ${basename(backupFile)}`);
  await copyFile(sourceFile, targetFile);
  console.info(`\u{1F504} Replaced file with template version (backup created)`);
}
async function renameAndCopyFile(sourceFile, targetFile) {
  let counter = 1;
  let uniqueTargetFile = targetFile;
  const baseName = basename(targetFile, extname(targetFile));
  const extension = extname(targetFile);
  const directory = dirname(targetFile);
  while (existsSync(uniqueTargetFile)) {
    const uniqueName = `${baseName}.template-${counter}${extension}`;
    uniqueTargetFile = resolve$2(directory, uniqueName);
    counter++;
  }
  await copyFile(sourceFile, uniqueTargetFile);
  console.info(`\u{1F4DD} Copied with unique name: ${basename(uniqueTargetFile)}`);
  return uniqueTargetFile;
}
var isValidMastraLanguageModel = (model) => {
  return model && typeof model === "object" && typeof model.modelId === "string";
};
var resolveTargetPath = (inputData, requestContext) => {
  if (inputData.targetPath) {
    return inputData.targetPath;
  }
  const contextPath = requestContext.get("targetPath");
  if (contextPath) {
    return contextPath;
  }
  const envRoot = process.env.MASTRA_PROJECT_ROOT?.trim();
  if (envRoot) {
    return envRoot;
  }
  const cwd = process.cwd();
  const parent = dirname(cwd);
  const grand = dirname(parent);
  if (basename(cwd) === "output" && basename(parent) === ".mastra") {
    return grand;
  }
  return cwd;
};
var mergeGitignoreFiles = (targetContent, templateContent, templateSlug) => {
  const targetLines = targetContent.replace(/\r\n/g, "\n").split("\n");
  const templateLines = templateContent.replace(/\r\n/g, "\n").split("\n");
  const existingEntries = /* @__PURE__ */ new Set();
  for (const line of targetLines) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith("#")) {
      const normalized = trimmed.replace(/^\.\//, "").replace(/\\/g, "/");
      existingEntries.add(normalized);
    }
  }
  const newEntries = [];
  for (const line of templateLines) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith("#")) {
      const normalized = trimmed.replace(/^\.\//, "").replace(/\\/g, "/");
      if (!existingEntries.has(normalized)) {
        const isNegation = normalized.startsWith("!");
        const basePath = isNegation ? normalized.slice(1) : normalized;
        const hasConflict = isNegation ? existingEntries.has(basePath) : existingEntries.has("!" + basePath);
        if (!hasConflict) {
          newEntries.push(trimmed);
        } else {
          console.info(`\u26A0 Skipping conflicting .gitignore rule: ${trimmed} (conflicts with existing rule)`);
        }
      }
    }
  }
  if (newEntries.length === 0) {
    return targetContent;
  }
  const result = [...targetLines];
  const lastLine = result[result.length - 1];
  if (result.length > 0 && lastLine && lastLine.trim() !== "") {
    result.push("");
  }
  result.push(`# Added by template: ${templateSlug}`);
  result.push(...newEntries);
  return result.join("\n");
};
var mergeEnvFiles = (targetContent, templateVariables, templateSlug) => {
  const targetLines = targetContent.replace(/\r\n/g, "\n").split("\n");
  const existingVars = /* @__PURE__ */ new Set();
  for (const line of targetLines) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith("#")) {
      const equalIndex = trimmed.indexOf("=");
      if (equalIndex > 0) {
        const varName = trimmed.substring(0, equalIndex).trim();
        existingVars.add(varName);
      }
    }
  }
  const newVars = [];
  for (const [key, value] of Object.entries(templateVariables)) {
    if (!existingVars.has(key)) {
      newVars.push({ key, value });
    } else {
      console.info(`\u26A0 Skipping existing environment variable: ${key} (already exists in .env)`);
    }
  }
  if (newVars.length === 0) {
    return targetContent;
  }
  const result = [...targetLines];
  const lastLine = result[result.length - 1];
  if (result.length > 0 && lastLine && lastLine.trim() !== "") {
    result.push("");
  }
  result.push(`# Added by template: ${templateSlug}`);
  for (const { key, value } of newVars) {
    result.push(`${key}=${value}`);
  }
  return result.join("\n");
};
var detectAISDKVersion = async (projectPath) => {
  try {
    const packageJsonPath = join(projectPath, "package.json");
    if (!existsSync(packageJsonPath)) {
      console.info("No package.json found, defaulting to v2");
      return "v2";
    }
    const packageContent = await readFile(packageJsonPath, "utf-8");
    const packageJson = JSON.parse(packageContent);
    const allDeps = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies,
      ...packageJson.peerDependencies
    };
    const providerPackages = ["@ai-sdk/openai", "@ai-sdk/anthropic", "@ai-sdk/google", "@ai-sdk/groq", "@ai-sdk/xai"];
    for (const pkg of providerPackages) {
      const version = allDeps[pkg];
      if (version) {
        const versionMatch = version.match(/(\d+)/);
        if (versionMatch) {
          const majorVersion = parseInt(versionMatch[1]);
          if (majorVersion >= 2) {
            console.info(`Detected ${pkg} v${majorVersion} -> using v2 specification`);
            return "v2";
          } else {
            console.info(`Detected ${pkg} v${majorVersion} -> using v1 specification`);
            return "v1";
          }
        }
      }
    }
    console.info("No AI SDK version detected, defaulting to v2");
    return "v2";
  } catch (error) {
    console.warn(`Failed to detect AI SDK version: ${error instanceof Error ? error.message : String(error)}`);
    return "v2";
  }
};
var createModelInstance = async (provider, modelId, version = "v2") => {
  try {
    const providerMap = {
      v1: {
        openai: async () => {
          const { openai: openai2 } = await Promise.resolve().then(function () { return distEDO7GEGI; });
          return openai2(modelId);
        },
        anthropic: async () => {
          const { anthropic } = await import('./dist-B5GMANA6.mjs');
          return anthropic(modelId);
        },
        groq: async () => {
          const { groq } = await import('./dist-THPMW5QR.mjs');
          return groq(modelId);
        },
        xai: async () => {
          const { xai } = await import('./dist-ZOZ6MHJH.mjs');
          return xai(modelId);
        },
        google: async () => {
          const { google } = await import('./dist-SMBO5KVB.mjs');
          return google(modelId);
        }
      }
    };
    const providerFn = version === `v1` ? providerMap[version][provider] : () => new ModelRouterLanguageModel(`${provider}/${modelId}`);
    if (!providerFn) {
      console.error(`Unsupported provider: ${provider}`);
      return null;
    }
    const modelInstance = await providerFn();
    console.info(`Created ${provider} model instance (${version}): ${modelId}`);
    return modelInstance;
  } catch (error) {
    console.error(`Failed to create model instance: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
};
var resolveModel = async ({
  requestContext,
  defaultModel = "openai/gpt-4.1",
  projectPath
}) => {
  const modelFromContext = requestContext.get("model");
  if (modelFromContext) {
    console.info("Using model from request context");
    if (isValidMastraLanguageModel(modelFromContext)) {
      return modelFromContext;
    }
    throw new Error(
      'Invalid model provided. Model must be a MastraLanguageModel instance (e.g., openai("gpt-4"), anthropic("claude-3-5-sonnet"), etc.)'
    );
  }
  const selectedModel = requestContext.get("selectedModel");
  if (selectedModel?.provider && selectedModel?.modelId && projectPath) {
    console.info(`Resolving selected model: ${selectedModel.provider}/${selectedModel.modelId}`);
    const version = await detectAISDKVersion(projectPath);
    const modelInstance = await createModelInstance(selectedModel.provider, selectedModel.modelId, version);
    if (modelInstance) {
      requestContext.set("model", modelInstance);
      return modelInstance;
    }
  }
  console.info("Using default model");
  return typeof defaultModel === `string` ? new ModelRouterLanguageModel(defaultModel) : defaultModel;
};
var AgentBuilderDefaults = class _AgentBuilderDefaults {
  static DEFAULT_INSTRUCTIONS = (projectPath) => `You are a Mastra Expert Agent, specialized in building production-ready AI applications using the Mastra framework. You excel at creating agents, tools, workflows, and complete applications with real, working implementations.

## Core Identity & Capabilities

**Primary Role:** Transform natural language requirements into working Mastra applications
**Key Strength:** Deep knowledge of Mastra patterns, conventions, and best practices
**Output Quality:** Production-ready code that follows Mastra ecosystem standards

## Workflow: The MASTRA Method

Follow this sequence for every coding task:

IF NO PROJECT EXISTS, USE THE MANAGEPROJECT TOOL TO CREATE A NEW PROJECT

DO NOT INCLUDE TODOS IN THE CODE, UNLESS SPECIFICALLY ASKED TO DO SO, CREATE REAL WORLD CODE

### 1. \u{1F50D} **UNDERSTAND** (Information Gathering)
- **Explore Mastra Docs**: Use docs tools to understand relevant Mastra patterns and APIs
- **Analyze Project**: Use file exploration to understand existing codebase structure
- **Web Research**: Search for packages, examples, or solutions when docs are insufficient
- **Clarify Requirements**: Ask targeted questions only when critical information is missing

### 2. \u{1F4CB} **PLAN** (Strategy & Design)
- **Architecture**: Design using Mastra conventions (agents, tools, workflows, memory)
- **Dependencies**: Identify required packages and Mastra components
- **Integration**: Plan how to integrate with existing project structure
- **Validation**: Define how to test and verify the implementation

### 3. \u{1F6E0}\uFE0F **BUILD** (Implementation)
- **Install First**: Use \`manageProject\` tool to install required packages
- **Follow Patterns**: Implement using established Mastra conventions
- **Real Code Only**: Build actual working functionality, never mock implementations
- **Environment Setup**: Create proper .env configuration and documentation

### 4. \u2705 **VALIDATE** (Quality Assurance)
- **Code Validation**: Run \`validateCode\` with types and lint checks
- **Testing**: Execute tests if available
- **Server Testing**: Use \`manageServer\` and \`httpRequest\` for API validation
- **Fix Issues**: Address all errors before completion

## Mastra-Specific Guidelines

### Framework Knowledge
- **Agents**: Use \`@mastra/core/agent\` with proper configuration
- **Tools**: Create tools with \`@mastra/core/tools\` and proper schemas
- **Memory**: Implement memory with \`@mastra/memory\` and appropriate processors
- **Workflows**: Build workflows with \`@mastra/core/workflows\`
- **Integrations**: Leverage Mastra's extensive integration ecosystem

### Code Standards
- **TypeScript First**: All code must be properly typed
- **Zod Schemas**: Use Zod for all data validation
- **Environment Variables**: Proper .env configuration with examples
- **Error Handling**: Comprehensive error handling with meaningful messages
- **Security**: Never expose credentials or sensitive data

### Project Structure
- Follow Mastra project conventions (\`src/mastra/\`, config files)
- Use proper file organization (agents, tools, workflows in separate directories)
- Maintain consistent naming conventions
- Include proper exports and imports

## Communication Style

**Conciseness**: Keep responses focused and actionable
**Clarity**: Explain complex concepts in simple terms
**Directness**: State what you're doing and why
**No Fluff**: Avoid unnecessary explanations or apologies

### Response Format
1. **Brief Status**: One line stating what you're doing
2. **Tool Usage**: Execute necessary tools
3. **Results Summary**: Concise summary of what was accomplished
4. **Next Steps**: Clear indication of completion or next actions

## Tool Usage Strategy

### File Operations
- **Project-Relative Paths**: All file paths are resolved relative to the project directory (unless absolute paths are used)
- **Read First**: Always read files before editing to understand context
- **Precise Edits**: Use exact text matching for search/replace operations
- **Batch Operations**: Group related file operations when possible

### Project Management
- **manageProject**: Use for package installation, project creation, dependency management
- **validateCode**: Always run after code changes to ensure quality
- **manageServer**: Use for testing Mastra server functionality
- **httpRequest**: Test API endpoints and integrations

### Information Gathering
- **Mastra Docs**: Primary source for Mastra-specific information
- **Web Search**: Secondary source for packages and external solutions
- **File Exploration**: Understand existing project structure and patterns

## Error Handling & Recovery

### Validation Failures
- Fix TypeScript errors immediately
- Address linting issues systematically
- Re-validate until clean

### Build Issues
- Check dependencies and versions
- Verify Mastra configuration
- Test in isolation when needed

### Integration Problems
- Verify API keys and environment setup
- Test connections independently
- Debug with logging and error messages

## Security & Best Practices

**Never:**
- Hard-code API keys or secrets
- Generate mock or placeholder implementations
- Skip error handling
- Ignore TypeScript errors
- Create insecure code patterns
- ask for file paths, you should be able to use the provided tools to explore the file system

**Always:**
- Use environment variables for configuration
- Implement proper input validation
- Follow security best practices
- Create complete, working implementations
- Test thoroughly before completion

## Output Requirements

### Code Quality
- \u2705 TypeScript compilation passes
- \u2705 ESLint validation passes
- \u2705 Proper error handling implemented
- \u2705 Environment variables configured
- \u2705 Tests included when appropriate

### Documentation
- \u2705 Clear setup instructions
- \u2705 Environment variable documentation
- \u2705 Usage examples provided
- \u2705 API documentation for custom tools

### Integration
- \u2705 Follows Mastra conventions
- \u2705 Integrates with existing project
- \u2705 Proper imports and exports
- \u2705 Compatible with Mastra ecosystem

## Project Context

**Working Directory**: ${projectPath}
**Focus**: Mastra framework applications
**Goal**: Production-ready implementations

Remember: You are building real applications, not prototypes. Every implementation should be complete, secure, and ready for production use.

## Enhanced Tool Set

You have access to an enhanced set of tools based on production coding agent patterns:

### Task Management
- **taskManager**: Create and track multi-step coding tasks with states (pending, in_progress, completed, blocked). Use this for complex projects that require systematic progress tracking.

### Code Discovery & Analysis
- **codeAnalyzer**: Analyze codebase structure, discover definitions (functions, classes, interfaces), map dependencies, and understand architectural patterns.
- **smartSearch**: Intelligent search with context awareness, pattern matching, and relevance scoring.

### Advanced File Operations
- **readFile**: Read files with optional line ranges, encoding support, metadata
- **writeFile**: Write files with directory creation
- **listDirectory**: Directory listing with filtering, recursion, metadata
- **multiEdit**: Perform multiple search-replace operations across files atomically with backup creation
- **executeCommand**: Execute shell commands with proper error handling and working directory support

**Important**: All file paths are resolved relative to the project directory unless absolute paths are provided.

### Communication & Workflow
- **attemptCompletion**: Signal task completion with validation status and confidence metrics.

### Guidelines for Enhanced Tools:

1. **Use taskManager proactively** for any task requiring 3+ steps or complex coordination
2. **Start with codeAnalyzer** when working with unfamiliar codebases to understand structure
3. **Use smartSearch** for intelligent pattern discovery across the codebase
4. **Apply multiEdit** for systematic refactoring across multiple files
5. **Ask for clarification** when requirements are ambiguous rather than making assumptions
6. **Signal completion** with comprehensive summaries and validation status

Use the following basic examples to guide your implementation.

<examples>
### Weather Agent
\`\`\`
// ./src/agents/weather-agent.ts
import { openai } from '@ai-sdk/openai';
import { Agent } from '@mastra/core/agent';
import { Memory } from '@mastra/memory';
import { LibSQLStore } from '@mastra/libsql';
import { weatherTool } from '../tools/weather-tool';

export const weatherAgent = new Agent({
  id: 'weather-agent',
  name: 'Weather Agent',
  instructions: \${instructions},
  model: openai('gpt-4o-mini'),
  tools: { weatherTool },
  memory: new Memory({
    storage: new LibSQLStore({
      id: 'mastra-memory-storage',
      url: 'file:../mastra.db', // ask user what database to use, use this as the default
    }),
  }),
});
\`\`\`

### Weather Tool
\`\`\`
// ./src/tools/weather-tool.ts
import { createTool } from '@mastra/core/tools';
import { z } from 'zod';
import { getWeather } from '../tools/weather-tool';

export const weatherTool = createTool({
  id: 'get-weather',
  description: 'Get current weather for a location',
  inputSchema: z.object({
    location: z.string().describe('City name'),
  }),
  outputSchema: z.object({
    temperature: z.number(),
    feelsLike: z.number(),
    humidity: z.number(),
    windSpeed: z.number(),
    windGust: z.number(),
    conditions: z.string(),
    location: z.string(),
  }),
  execute: async (inputData) => {
    return await getWeather(inputData.location);
  },
});
\`\`\`

### Weather Workflow
\`\`\`
// ./src/workflows/weather-workflow.ts
import { createStep, createWorkflow } from '@mastra/core/workflows';
import { z } from 'zod';

const fetchWeather = createStep({
  id: 'fetch-weather',
  description: 'Fetches weather forecast for a given city',
  inputSchema: z.object({
    city: z.string().describe('The city to get the weather for'),
  }),
  outputSchema: forecastSchema,
  execute: async (inputData) => {
    if (!inputData) {
      throw new Error('Input data not found');
    }

    const geocodingUrl = \`https://geocoding-api.open-meteo.com/v1/search?name=\${encodeURIComponent(inputData.city)}&count=1\`;
    const geocodingResponse = await fetch(geocodingUrl);
    const geocodingData = (await geocodingResponse.json()) as {
      results: { latitude: number; longitude: number; name: string }[];
    };

    if (!geocodingData.results?.[0]) {
      throw new Error(\`Location '\${inputData.city}' not found\`);
    }

    const { latitude, longitude, name } = geocodingData.results[0];

    const weatherUrl = \`https://api.open-meteo.com/v1/forecast?latitude=\${latitude}&longitude=\${longitude}&current=precipitation,weathercode&timezone=auto,&hourly=precipitation_probability,temperature_2m\`
    const response = await fetch(weatherUrl);
    const data = (await response.json()) as {
      current: {
        time: string;
        precipitation: number;
        weathercode: number;
      };
      hourly: {
        precipitation_probability: number[];
        temperature_2m: number[];
      };
    };

    const forecast = {
      date: new Date().toISOString(),
      maxTemp: Math.max(...data.hourly.temperature_2m),
      minTemp: Math.min(...data.hourly.temperature_2m),
      condition: getWeatherCondition(data.current.weathercode),
      precipitationChance: data.hourly.precipitation_probability.reduce(
        (acc, curr) => Math.max(acc, curr),
        0,
      ),
      location: name,
    };

    return forecast;
  },
});

const planActivities = createStep({
  id: 'plan-activities',
  description: 'Suggests activities based on weather conditions',
  inputSchema: forecastSchema,
  outputSchema: z.object({
    activities: z.string(),
  }),
  execute: async (inputData, context) => {
    const mastra = context?.mastra;
    const forecast = inputData;

    if (!forecast) {
      throw new Error('Forecast data not found');
    }

    const agent = mastra?.getAgent('weatherAgent');
    if (!agent) {
      throw new Error('Weather agent not found');
    }

    const prompt = \${weatherWorkflowPrompt}

    const response = await agent.stream([
      {
        role: 'user',
        content: prompt,
      },
    ]);

    let activitiesText = '';

    for await (const chunk of response.textStream) {
      process.stdout.write(chunk);
      activitiesText += chunk;
    }

    return {
      activities: activitiesText,
    };
  },
});

const weatherWorkflow = createWorkflow({
  id: 'weather-workflow',
  inputSchema: z.object({
    city: z.string().describe('The city to get the weather for'),
  }),
  outputSchema: z.object({
    activities: z.string(),
  }),
})
  .then(fetchWeather)
  .then(planActivities);

weatherWorkflow.commit();
\`\`\`
export { weatherWorkflow };
\`\`\`

### Mastra instance
\`\`\`
// ./src/mastra.ts

import { Mastra } from '@mastra/core/mastra';
import { PinoLogger } from '@mastra/loggers';
import { LibSQLStore } from '@mastra/libsql';
import { weatherWorkflow } from './workflows/weather-workflow';
import { weatherAgent } from './agents/weather-agent';

export const mastra = new Mastra({
  workflows: { weatherWorkflow },
  agents: { weatherAgent },
  storage: new LibSQLStore({
    id: 'mastra-storage',
    // stores observability, evals, ... into memory storage, if it needs to persist, change to file:../mastra.db
    url: ":memory:",
  }),
  logger: new PinoLogger({
    name: 'Mastra',
    level: 'info',
  }),
});
\`\`\`

</examples>`;
  static DEFAULT_MEMORY_CONFIG = {
    lastMessages: 20
  };
  static DEFAULT_FOLDER_STRUCTURE = {
    agent: "src/mastra/agents",
    workflow: "src/mastra/workflows",
    tool: "src/mastra/tools",
    "mcp-server": "src/mastra/mcp",
    network: "src/mastra/networks"
  };
  static DEFAULT_TOOLS = async (projectPath) => {
    return {
      readFile: createTool({
        id: "read-file",
        description: "Read contents of a file with optional line range selection.",
        inputSchema: z.object({
          filePath: z.string().describe("Path to the file to read"),
          startLine: z.number().optional().describe("Starting line number (1-indexed)"),
          endLine: z.number().optional().describe("Ending line number (1-indexed, inclusive)"),
          encoding: z.string().default("utf-8").describe("File encoding")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          content: z.string().optional(),
          lines: z.array(z.string()).optional(),
          metadata: z.object({
            size: z.number(),
            totalLines: z.number(),
            encoding: z.string(),
            lastModified: z.string()
          }).optional(),
          errorMessage: z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.readFile({ ...inputData, projectPath });
        }
      }),
      writeFile: createTool({
        id: "write-file",
        description: "Write content to a file, with options for creating directories.",
        inputSchema: z.object({
          filePath: z.string().describe("Path to the file to write"),
          content: z.string().describe("Content to write to the file"),
          createDirs: z.boolean().default(true).describe("Create parent directories if they don't exist"),
          encoding: z.string().default("utf-8").describe("File encoding")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          filePath: z.string(),
          bytesWritten: z.number().optional(),
          message: z.string(),
          errorMessage: z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.writeFile({ ...inputData, projectPath });
        }
      }),
      listDirectory: createTool({
        id: "list-directory",
        description: "List contents of a directory with filtering and metadata options.",
        inputSchema: z.object({
          path: z.string().describe("Directory path to list"),
          recursive: z.boolean().default(false).describe("List subdirectories recursively"),
          includeHidden: z.boolean().default(false).describe("Include hidden files and directories"),
          pattern: z.string().default("*").describe("Glob pattern to filter files"),
          maxDepth: z.number().default(10).describe("Maximum recursion depth"),
          includeMetadata: z.boolean().default(true).describe("Include file metadata")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          items: z.array(
            z.object({
              name: z.string(),
              path: z.string(),
              type: z.enum(["file", "directory", "symlink"]),
              size: z.number().optional(),
              lastModified: z.string().optional(),
              permissions: z.string().optional()
            })
          ),
          totalItems: z.number(),
          path: z.string(),
          message: z.string(),
          errorMessage: z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.listDirectory({ ...inputData, projectPath });
        }
      }),
      executeCommand: createTool({
        id: "execute-command",
        description: "Execute shell commands with proper error handling and output capture.",
        inputSchema: z.object({
          command: z.string().describe("Shell command to execute"),
          workingDirectory: z.string().optional().describe("Working directory for command execution"),
          timeout: z.number().default(3e4).describe("Timeout in milliseconds"),
          captureOutput: z.boolean().default(true).describe("Capture command output"),
          shell: z.string().optional().describe("Shell to use (defaults to system shell)"),
          env: z.record(z.string()).optional().describe("Environment variables")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          exitCode: z.number().optional(),
          stdout: z.string().optional(),
          stderr: z.string().optional(),
          command: z.string(),
          workingDirectory: z.string().optional(),
          executionTime: z.number().optional(),
          errorMessage: z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.executeCommand({
            ...inputData,
            workingDirectory: inputData.workingDirectory || projectPath
          });
        }
      }),
      // Enhanced Task Management (Critical for complex coding tasks)
      taskManager: createTool({
        id: "task-manager",
        description: "Create and manage structured task lists for coding sessions. Use this for complex multi-step tasks to track progress and ensure thoroughness.",
        inputSchema: z.object({
          action: z.enum(["create", "update", "list", "complete", "remove"]).describe("Task management action"),
          tasks: z.array(
            z.object({
              id: z.string().describe("Unique task identifier"),
              content: z.string().describe("Task description, optional if just updating the status").optional(),
              status: z.enum(["pending", "in_progress", "completed", "blocked"]).describe("Task status"),
              priority: z.enum(["high", "medium", "low"]).default("medium").describe("Task priority"),
              dependencies: z.array(z.string()).optional().describe("IDs of tasks this depends on"),
              notes: z.string().optional().describe("Additional notes or context")
            })
          ).optional().describe("Tasks to create or update"),
          taskId: z.string().optional().describe("Specific task ID for single task operations")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          tasks: z.array(
            z.object({
              id: z.string(),
              content: z.string(),
              status: z.string(),
              priority: z.string(),
              dependencies: z.array(z.string()).optional(),
              notes: z.string().optional(),
              createdAt: z.string(),
              updatedAt: z.string()
            })
          ),
          message: z.string()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.manageTaskList(inputData);
        }
      }),
      // Advanced File Operations
      multiEdit: createTool({
        id: "multi-edit",
        description: "Perform multiple search-replace operations on one or more files in a single atomic operation.",
        inputSchema: z.object({
          operations: z.array(
            z.object({
              filePath: z.string().describe("Path to the file to edit"),
              edits: z.array(
                z.object({
                  oldString: z.string().describe("Exact text to replace"),
                  newString: z.string().describe("Replacement text"),
                  replaceAll: z.boolean().default(false).describe("Replace all occurrences")
                })
              ).describe("List of edit operations for this file")
            })
          ).describe("File edit operations to perform"),
          createBackup: z.boolean().default(false).describe("Create backup files before editing")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          results: z.array(
            z.object({
              filePath: z.string(),
              editsApplied: z.number(),
              errors: z.array(z.string()),
              backup: z.string().optional()
            })
          ),
          message: z.string()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.performMultiEdit({ ...inputData, projectPath });
        }
      }),
      replaceLines: createTool({
        id: "replace-lines",
        description: "Replace specific line ranges in files with new content. IMPORTANT: This tool replaces ENTIRE lines, not partial content within lines. Lines are 1-indexed.",
        inputSchema: z.object({
          filePath: z.string().describe("Path to the file to edit"),
          startLine: z.number().describe("Starting line number to replace (1-indexed, inclusive). Count from the first line = 1"),
          endLine: z.number().describe(
            "Ending line number to replace (1-indexed, inclusive). To replace single line, use same number as startLine"
          ),
          newContent: z.string().describe(
            'New content to replace the lines with. Use empty string "" to delete lines completely. For multiline content, include \\n characters'
          ),
          createBackup: z.boolean().default(false).describe("Create backup file before editing")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          message: z.string(),
          linesReplaced: z.number().optional(),
          backup: z.string().optional(),
          errorMessage: z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.replaceLines({ ...inputData, projectPath });
        }
      }),
      // File diagnostics tool to help debug line replacement issues
      showFileLines: createTool({
        id: "show-file-lines",
        description: "Show specific lines from a file with line numbers. Useful for debugging before using replaceLines.",
        inputSchema: z.object({
          filePath: z.string().describe("Path to the file to examine"),
          startLine: z.number().optional().describe("Starting line number to show (1-indexed). If not provided, shows all lines"),
          endLine: z.number().optional().describe(
            "Ending line number to show (1-indexed, inclusive). If not provided but startLine is, shows only that line"
          ),
          context: z.number().default(2).describe("Number of context lines to show before and after the range")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          lines: z.array(
            z.object({
              lineNumber: z.number(),
              content: z.string(),
              isTarget: z.boolean().describe("Whether this line is in the target range")
            })
          ),
          totalLines: z.number(),
          message: z.string(),
          errorMessage: z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.showFileLines({ ...inputData, projectPath });
        }
      }),
      // Enhanced Pattern Search
      smartSearch: createTool({
        id: "smart-search",
        description: "Intelligent search across codebase with context awareness and pattern matching.",
        inputSchema: z.object({
          query: z.string().describe("Search query or pattern"),
          type: z.enum(["text", "regex", "fuzzy", "semantic"]).default("text").describe("Type of search to perform"),
          scope: z.object({
            paths: z.array(z.string()).optional().describe("Specific paths to search"),
            fileTypes: z.array(z.string()).optional().describe("File extensions to include"),
            excludePaths: z.array(z.string()).optional().describe("Paths to exclude"),
            maxResults: z.number().default(50).describe("Maximum number of results")
          }).optional(),
          context: z.object({
            beforeLines: z.number().default(2).describe("Lines of context before match"),
            afterLines: z.number().default(2).describe("Lines of context after match"),
            includeDefinitions: z.boolean().default(false).describe("Include function/class definitions")
          }).optional()
        }),
        outputSchema: z.object({
          success: z.boolean(),
          matches: z.array(
            z.object({
              file: z.string(),
              line: z.number(),
              column: z.number().optional(),
              match: z.string(),
              context: z.object({
                before: z.array(z.string()),
                after: z.array(z.string())
              }),
              relevance: z.number().optional()
            })
          ),
          summary: z.object({
            totalMatches: z.number(),
            filesSearched: z.number(),
            patterns: z.array(z.string())
          })
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.performSmartSearch(inputData, projectPath);
        }
      }),
      validateCode: createTool({
        id: "validate-code",
        description: "Validates code using a fast hybrid approach: syntax \u2192 semantic \u2192 lint. RECOMMENDED: Always provide specific files for optimal performance and accuracy.",
        inputSchema: z.object({
          projectPath: z.string().optional().describe("Path to the project to validate (defaults to current project)"),
          validationType: z.array(z.enum(["types", "lint", "schemas", "tests", "build"])).describe('Types of validation to perform. Recommended: ["types", "lint"] for code quality'),
          files: z.array(z.string()).optional().describe(
            "RECOMMENDED: Specific files to validate (e.g., files you created/modified). Uses hybrid validation: fast syntax check \u2192 semantic types \u2192 ESLint. Without files, falls back to slower CLI validation."
          )
        }),
        outputSchema: z.object({
          valid: z.boolean(),
          errors: z.array(
            z.object({
              type: z.enum(["typescript", "eslint", "schema", "test", "build"]),
              severity: z.enum(["error", "warning", "info"]),
              message: z.string(),
              file: z.string().optional(),
              line: z.number().optional(),
              column: z.number().optional(),
              code: z.string().optional()
            })
          ),
          summary: z.object({
            totalErrors: z.number(),
            totalWarnings: z.number(),
            validationsPassed: z.array(z.string()),
            validationsFailed: z.array(z.string())
          })
        }),
        execute: async (inputData) => {
          const { projectPath: validationProjectPath, validationType, files } = inputData;
          const targetPath = validationProjectPath || projectPath;
          return await _AgentBuilderDefaults.validateCode({
            projectPath: targetPath,
            validationType,
            files
          });
        }
      }),
      // Web Search (replaces MCP web search)
      webSearch: createTool({
        id: "web-search",
        description: "Search the web for current information and return structured results.",
        inputSchema: z.object({
          query: z.string().describe("Search query"),
          maxResults: z.number().default(10).describe("Maximum number of results to return"),
          region: z.string().default("us").describe("Search region/country code"),
          language: z.string().default("en").describe("Search language"),
          includeImages: z.boolean().default(false).describe("Include image results"),
          dateRange: z.enum(["day", "week", "month", "year", "all"]).default("all").describe("Date range filter")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          query: z.string(),
          results: z.array(
            z.object({
              title: z.string(),
              url: z.string(),
              snippet: z.string(),
              domain: z.string(),
              publishDate: z.string().optional(),
              relevanceScore: z.number().optional()
            })
          ),
          totalResults: z.number(),
          searchTime: z.number(),
          suggestions: z.array(z.string()).optional(),
          errorMessage: z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.webSearch(inputData);
        }
      }),
      // Task Completion Signaling
      attemptCompletion: createTool({
        id: "attempt-completion",
        description: "Signal that you believe the requested task has been completed and provide a summary.",
        inputSchema: z.object({
          summary: z.string().describe("Summary of what was accomplished"),
          changes: z.array(
            z.object({
              type: z.enum(["file_created", "file_modified", "file_deleted", "command_executed", "dependency_added"]),
              description: z.string(),
              path: z.string().optional()
            })
          ).describe("List of changes made"),
          validation: z.object({
            testsRun: z.boolean().default(false),
            buildsSuccessfully: z.boolean().default(false),
            manualTestingRequired: z.boolean().default(false)
          }).describe("Validation status"),
          nextSteps: z.array(z.string()).optional().describe("Suggested next steps or follow-up actions")
        }),
        outputSchema: z.object({
          completionId: z.string(),
          status: z.enum(["completed", "needs_review", "needs_testing"]),
          summary: z.string(),
          confidence: z.number().min(0).max(100)
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.signalCompletion(inputData);
        }
      }),
      manageProject: createTool({
        id: "manage-project",
        description: "Handles project management including creating project structures, managing dependencies, and package operations.",
        inputSchema: z.object({
          action: z.enum(["create", "install", "upgrade"]).describe("The action to perform"),
          features: z.array(z.string()).optional().describe('Mastra features to include (e.g., ["agents", "memory", "workflows"])'),
          packages: z.array(
            z.object({
              name: z.string(),
              version: z.string().optional()
            })
          ).optional().describe("Packages to install/upgrade")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          installed: z.array(z.string()).optional(),
          upgraded: z.array(z.string()).optional(),
          warnings: z.array(z.string()).optional(),
          message: z.string().optional(),
          details: z.string().optional(),
          errorMessage: z.string().optional()
        }),
        execute: async (inputData) => {
          const { action, features, packages } = inputData;
          try {
            switch (action) {
              case "create":
                return await _AgentBuilderDefaults.createMastraProject({
                  projectName: projectPath,
                  features
                });
              case "install":
                if (!packages?.length) {
                  return {
                    success: false,
                    message: "Packages array is required for install action"
                  };
                }
                return await _AgentBuilderDefaults.installPackages({
                  packages,
                  projectPath
                });
              case "upgrade":
                if (!packages?.length) {
                  return {
                    success: false,
                    message: "Packages array is required for upgrade action"
                  };
                }
                return await _AgentBuilderDefaults.upgradePackages({
                  packages,
                  projectPath
                });
              default:
                return {
                  success: false,
                  message: `Unknown action: ${action}`
                };
            }
          } catch (error) {
            return {
              success: false,
              message: `Error executing ${action}: ${error instanceof Error ? error.message : String(error)}`
            };
          }
        }
      }),
      manageServer: createTool({
        id: "manage-server",
        description: "Manages the Mastra server - start, stop, restart, and check status, use the terminal tool to make curl requests to the server. There is an openapi spec for the server at http://localhost:{port}/openapi.json",
        inputSchema: z.object({
          action: z.enum(["start", "stop", "restart", "status"]).describe("Server management action"),
          port: z.number().optional().default(4200).describe("Port to run the server on")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          status: z.enum(["running", "stopped", "starting", "stopping", "unknown"]),
          pid: z.number().optional(),
          port: z.number().optional(),
          url: z.string().optional(),
          message: z.string().optional(),
          stdout: z.array(z.string()).optional().describe("Server output lines captured during startup"),
          errorMessage: z.string().optional()
        }),
        execute: async (inputData) => {
          const { action, port } = inputData;
          try {
            switch (action) {
              case "start":
                return await _AgentBuilderDefaults.startMastraServer({
                  port,
                  projectPath
                });
              case "stop":
                return await _AgentBuilderDefaults.stopMastraServer({
                  port,
                  projectPath
                });
              case "restart":
                const stopResult = await _AgentBuilderDefaults.stopMastraServer({
                  port,
                  projectPath
                });
                if (!stopResult.success) {
                  return {
                    success: false,
                    status: "unknown",
                    message: `Failed to restart: could not stop server on port ${port}`,
                    errorMessage: stopResult.errorMessage || "Unknown stop error"
                  };
                }
                await new Promise((resolve5) => setTimeout(resolve5, 500));
                const startResult = await _AgentBuilderDefaults.startMastraServer({
                  port,
                  projectPath
                });
                if (!startResult.success) {
                  return {
                    success: false,
                    status: "stopped",
                    message: `Failed to restart: server stopped successfully but failed to start on port ${port}`,
                    errorMessage: startResult.errorMessage || "Unknown start error"
                  };
                }
                return {
                  ...startResult,
                  message: `Mastra server restarted successfully on port ${port}`
                };
              case "status":
                return await _AgentBuilderDefaults.checkMastraServerStatus({
                  port,
                  projectPath
                });
              default:
                return {
                  success: false,
                  status: "unknown",
                  message: `Unknown action: ${action}`
                };
            }
          } catch (error) {
            return {
              success: false,
              status: "unknown",
              message: `Error managing server: ${error instanceof Error ? error.message : String(error)}`
            };
          }
        }
      }),
      httpRequest: createTool({
        id: "http-request",
        description: "Makes HTTP requests to the Mastra server or external APIs for testing and integration",
        inputSchema: z.object({
          method: z.enum(["GET", "POST", "PUT", "DELETE", "PATCH"]).describe("HTTP method"),
          url: z.string().describe("Full URL or path (if baseUrl provided)"),
          baseUrl: z.string().optional().describe("Base URL for the server (e.g., http://localhost:4200)"),
          headers: z.record(z.string()).optional().describe("HTTP headers"),
          body: z.any().optional().describe("Request body (will be JSON stringified if object)"),
          timeout: z.number().optional().default(3e4).describe("Request timeout in milliseconds")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          status: z.number().optional(),
          statusText: z.string().optional(),
          headers: z.record(z.string()).optional(),
          data: z.any().optional(),
          errorMessage: z.string().optional(),
          url: z.string(),
          method: z.string()
        }),
        execute: async (inputData) => {
          const { method, url, baseUrl, headers, body, timeout } = inputData;
          try {
            return await _AgentBuilderDefaults.makeHttpRequest({
              method,
              url,
              baseUrl,
              headers,
              body,
              timeout
            });
          } catch (error) {
            return {
              success: false,
              url: baseUrl ? `${baseUrl}${url}` : url,
              method,
              errorMessage: error instanceof Error ? error.message : String(error)
            };
          }
        }
      })
    };
  };
  /**
   * Filter tools for template builder mode (excludes web search and other advanced tools)
   */
  static filterToolsForTemplateBuilder(tools) {
    const templateBuilderTools = [
      "readFile",
      "writeFile",
      "listDirectory",
      "executeCommand",
      "taskManager",
      "multiEdit",
      "replaceLines",
      "showFileLines",
      "smartSearch",
      "validateCode"
    ];
    const filtered = {};
    for (const toolName of templateBuilderTools) {
      if (tools[toolName]) {
        filtered[toolName] = tools[toolName];
      }
    }
    return filtered;
  }
  /**
   * Filter tools for code editor mode (includes all tools)
   */
  static filterToolsForCodeEditor(tools) {
    return tools;
  }
  /**
   * Get tools for a specific mode
   */
  static async listToolsForMode(projectPath, mode = "code-editor") {
    const allTools = await _AgentBuilderDefaults.DEFAULT_TOOLS(projectPath);
    if (mode === "template") {
      return _AgentBuilderDefaults.filterToolsForTemplateBuilder(allTools);
    } else {
      return _AgentBuilderDefaults.filterToolsForCodeEditor(allTools);
    }
  }
  /**
   * Create a new Mastra project using create-mastra CLI
   */
  static async createMastraProject({ features, projectName }) {
    try {
      const args = ["pnpx", "create-mastra@latest", projectName?.replace(/[;&|`$(){}\[\]]/g, "") ?? "", "-l", "openai"];
      if (features && features.length > 0) {
        args.push("--components", features.join(","));
      }
      args.push("--example");
      const { stdout, stderr } = await spawnWithOutput(args[0], args.slice(1), {});
      return {
        success: true,
        projectPath: `./${projectName}`,
        message: `Successfully created Mastra project: ${projectName}.`,
        details: stdout,
        errorMessage: stderr
      };
    } catch (error) {
      console.error(error);
      return {
        success: false,
        message: `Failed to create project: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  /**
   * Install packages using the detected package manager
   */
  static async installPackages({
    packages,
    projectPath
  }) {
    try {
      console.info("Installing packages:", JSON.stringify(packages, null, 2));
      const packageStrings = packages.map((p) => `${p.name}`);
      await spawnSWPM(projectPath || "", "add", packageStrings);
      return {
        success: true,
        installed: packageStrings,
        message: `Successfully installed ${packages.length} package(s).`,
        details: ""
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to install packages: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  /**
   * Upgrade packages using the detected package manager
   */
  static async upgradePackages({
    packages,
    projectPath
  }) {
    try {
      console.info("Upgrading specific packages:", JSON.stringify(packages, null, 2));
      let packageNames = [];
      if (packages && packages.length > 0) {
        packageNames = packages.map((p) => `${p.name}`);
      }
      await spawnSWPM(projectPath || "", "upgrade", packageNames);
      return {
        success: true,
        upgraded: packages?.map((p) => p.name) || ["all packages"],
        message: `Packages upgraded successfully.`,
        details: ""
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to upgrade packages: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  /**
   * Start the Mastra server
   */
  static async startMastraServer({
    port = 4200,
    projectPath,
    env = {}
  }) {
    try {
      const serverEnv = { ...process.env, ...env, PORT: port.toString() };
      const execOptions = {
        cwd: projectPath || process.cwd(),
        env: serverEnv
      };
      const serverProcess = spawn$1("pnpm", ["run", "dev"], {
        ...execOptions,
        detached: true,
        stdio: "pipe"
      });
      const stdoutLines = [];
      const serverStarted = new Promise((resolve5, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error(`Server startup timeout after 30 seconds. Output: ${stdoutLines.join("\n")}`));
        }, 3e4);
        serverProcess.stdout?.on("data", (data) => {
          const output = data.toString();
          const lines = output.split("\n").filter((line) => line.trim());
          stdoutLines.push(...lines);
          if (output.includes("Mastra API running on ")) {
            clearTimeout(timeout);
            resolve5({
              success: true,
              status: "running",
              pid: serverProcess.pid,
              port,
              url: `http://localhost:${port}`,
              message: `Mastra server started successfully on port ${port}`,
              stdout: stdoutLines
            });
          }
        });
        serverProcess.stderr?.on("data", (data) => {
          const errorOutput = data.toString();
          stdoutLines.push(`[STDERR] ${errorOutput}`);
          clearTimeout(timeout);
          reject(new Error(`Server startup failed with error: ${errorOutput}`));
        });
        serverProcess.on("error", (error) => {
          clearTimeout(timeout);
          reject(error);
        });
        serverProcess.on("exit", (code, signal) => {
          clearTimeout(timeout);
          if (code !== 0 && code !== null) {
            reject(
              new Error(
                `Server process exited with code ${code}${signal ? ` (signal: ${signal})` : ""}. Output: ${stdoutLines.join("\n")}`
              )
            );
          }
        });
      });
      return await serverStarted;
    } catch (error) {
      return {
        success: false,
        status: "stopped",
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Stop the Mastra server
   */
  static async stopMastraServer({ port = 4200, projectPath: _projectPath }) {
    if (typeof port !== "number" || !Number.isInteger(port) || port < 1 || port > 65535) {
      return {
        success: false,
        status: "error",
        errorMessage: `Invalid port value: ${String(port)}`
      };
    }
    try {
      const { stdout } = await execFile("lsof", ["-ti", String(port)]);
      const effectiveStdout = stdout.trim() ? stdout : "No process found";
      if (!effectiveStdout || effectiveStdout === "No process found") {
        return {
          success: true,
          status: "stopped",
          message: `No Mastra server found running on port ${port}`
        };
      }
      const pids = stdout.trim().split("\n").filter((pid) => pid.trim());
      const killedPids = [];
      const failedPids = [];
      for (const pidStr of pids) {
        const pid = parseInt(pidStr.trim());
        if (isNaN(pid)) continue;
        try {
          process.kill(pid, "SIGTERM");
          killedPids.push(pid);
        } catch (e2) {
          failedPids.push(pid);
          console.warn(`Failed to kill process ${pid}:`, e2);
        }
      }
      if (killedPids.length === 0) {
        return {
          success: false,
          status: "unknown",
          message: `Failed to stop any processes on port ${port}`,
          errorMessage: `Could not kill PIDs: ${failedPids.join(", ")}`
        };
      }
      if (failedPids.length > 0) {
        console.warn(
          `Killed ${killedPids.length} processes but failed to kill ${failedPids.length} processes: ${failedPids.join(", ")}`
        );
      }
      await new Promise((resolve5) => setTimeout(resolve5, 2e3));
      try {
        const { stdout: checkStdoutRaw } = await execFile("lsof", ["-ti", String(port)]);
        const checkStdout = checkStdoutRaw.trim() ? checkStdoutRaw : "No process found";
        if (checkStdout && checkStdout !== "No process found") {
          const remainingPids = checkStdout.trim().split("\n").filter((pid) => pid.trim());
          for (const pidStr of remainingPids) {
            const pid = parseInt(pidStr.trim());
            if (!isNaN(pid)) {
              try {
                process.kill(pid, "SIGKILL");
              } catch {
              }
            }
          }
          await new Promise((resolve5) => setTimeout(resolve5, 1e3));
          const { stdout: finalCheckRaw } = await execFile("lsof", ["-ti", String(port)]);
          const finalCheck = finalCheckRaw.trim() ? finalCheckRaw : "No process found";
          if (finalCheck && finalCheck !== "No process found") {
            return {
              success: false,
              status: "unknown",
              message: `Server processes still running on port ${port} after stop attempts`,
              errorMessage: `Remaining PIDs: ${finalCheck.trim()}`
            };
          }
        }
      } catch (error) {
        console.warn("Failed to verify server stop:", error);
      }
      return {
        success: true,
        status: "stopped",
        message: `Mastra server stopped successfully (port ${port}). Killed PIDs: ${killedPids.join(", ")}`
      };
    } catch (error) {
      return {
        success: false,
        status: "unknown",
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Check Mastra server status
   */
  static async checkMastraServerStatus({
    port = 4200,
    projectPath: _projectPath
  }) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5e3);
      const response = await fetch(`http://localhost:${port}/health`, {
        method: "GET",
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (response.ok) {
        return {
          success: true,
          status: "running",
          port,
          url: `http://localhost:${port}`,
          message: "Mastra server is running and healthy"
        };
      } else {
        return {
          success: false,
          status: "unknown",
          port,
          message: `Server responding but not healthy (status: ${response.status})`
        };
      }
    } catch {
      try {
        const { stdout } = await execFile("lsof", ["-ti", String(port)]);
        const effectiveStdout = stdout.trim() ? stdout : "No process found";
        const hasProcess = effectiveStdout && effectiveStdout !== "No process found";
        return {
          success: Boolean(hasProcess),
          status: hasProcess ? "starting" : "stopped",
          port,
          message: hasProcess ? "Server process exists but not responding to health checks" : "No server process found on specified port"
        };
      } catch {
        return {
          success: false,
          status: "stopped",
          port,
          message: "Server is not running"
        };
      }
    }
  }
  // Cache for TypeScript program (lazily loaded)
  static tsProgram = null;
  static programProjectPath = null;
  /**
   * Validate code using hybrid approach: syntax -> types -> lint
   *
   * BEST PRACTICES FOR CODING AGENTS:
   *
   * ✅ RECOMMENDED (Fast & Accurate):
   * validateCode({
   *   validationType: ['types', 'lint'],
   *   files: ['src/workflows/my-workflow.ts', 'src/components/Button.tsx']
   * })
   *
   * Performance: ~150ms
   * - Syntax check (1ms) - catches 80% of issues instantly
   * - Semantic validation (100ms) - full type checking with dependencies
   * - ESLint (50ms) - style and best practices
   * - Only shows errors from YOUR files
   *
   * ❌ AVOID (Slow & Noisy):
   * validateCode({ validationType: ['types', 'lint'] }) // no files specified
   *
   * Performance: ~2000ms+
   * - Full project CLI validation
   * - Shows errors from all project files (confusing)
   * - Much slower for coding agents
   *
   * @param projectPath - Project root directory (defaults to cwd)
   * @param validationType - ['types', 'lint'] recommended for most use cases
   * @param files - ALWAYS provide this for best performance
   */
  static async validateCode({
    projectPath,
    validationType,
    files
  }) {
    const errors = [];
    const validationsPassed = [];
    const validationsFailed = [];
    const targetProjectPath = projectPath || process.cwd();
    if (!files || files.length === 0) {
      return this.validateCodeCLI({ projectPath, validationType });
    }
    for (const filePath of files) {
      const absolutePath = isAbsolute(filePath) ? filePath : resolve$2(targetProjectPath, filePath);
      try {
        const fileContent = await readFile(absolutePath, "utf-8");
        const fileResults = await this.validateSingleFileHybrid(
          absolutePath,
          fileContent,
          targetProjectPath,
          validationType
        );
        errors.push(...fileResults.errors);
        for (const type of validationType) {
          const hasErrors = fileResults.errors.some((e2) => e2.type === type && e2.severity === "error");
          if (hasErrors) {
            if (!validationsFailed.includes(type)) validationsFailed.push(type);
          } else {
            if (!validationsPassed.includes(type)) validationsPassed.push(type);
          }
        }
      } catch (error) {
        errors.push({
          type: "typescript",
          severity: "error",
          message: `Failed to read file ${filePath}: ${error instanceof Error ? error.message : String(error)}`,
          file: filePath
        });
        validationsFailed.push("types");
      }
    }
    const totalErrors = errors.filter((e2) => e2.severity === "error").length;
    const totalWarnings = errors.filter((e2) => e2.severity === "warning").length;
    const isValid = totalErrors === 0;
    return {
      valid: isValid,
      errors,
      summary: {
        totalErrors,
        totalWarnings,
        validationsPassed,
        validationsFailed
      }
    };
  }
  /**
   * CLI-based validation for when no specific files are provided
   */
  static async validateCodeCLI({
    projectPath,
    validationType
  }) {
    const errors = [];
    const validationsPassed = [];
    const validationsFailed = [];
    const execOptions = { cwd: projectPath };
    if (validationType.includes("types")) {
      try {
        const args = ["tsc", "--noEmit"];
        await execFile("npx", args, execOptions);
        validationsPassed.push("types");
      } catch (error) {
        let tsOutput = "";
        if (error.stdout) {
          tsOutput = error.stdout;
        } else if (error.stderr) {
          tsOutput = error.stderr;
        } else if (error.message) {
          tsOutput = error.message;
        }
        errors.push({
          type: "typescript",
          severity: "error",
          message: tsOutput.trim() || `TypeScript validation failed: ${error.message || String(error)}`
        });
        validationsFailed.push("types");
      }
    }
    if (validationType.includes("lint")) {
      try {
        const eslintArgs = ["eslint", "--format", "json"];
        const { stdout } = await execFile("npx", eslintArgs, execOptions);
        if (stdout) {
          const eslintResults = JSON.parse(stdout);
          const eslintErrors = _AgentBuilderDefaults.parseESLintErrors(eslintResults);
          errors.push(...eslintErrors);
          if (eslintErrors.some((e2) => e2.severity === "error")) {
            validationsFailed.push("lint");
          } else {
            validationsPassed.push("lint");
          }
        } else {
          validationsPassed.push("lint");
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage.includes('"filePath"') || errorMessage.includes("messages")) {
          try {
            const eslintResults = JSON.parse(errorMessage);
            const eslintErrors = _AgentBuilderDefaults.parseESLintErrors(eslintResults);
            errors.push(...eslintErrors);
            validationsFailed.push("lint");
          } catch {
            errors.push({
              type: "eslint",
              severity: "error",
              message: `ESLint validation failed: ${errorMessage}`
            });
            validationsFailed.push("lint");
          }
        } else {
          validationsPassed.push("lint");
        }
      }
    }
    const totalErrors = errors.filter((e2) => e2.severity === "error").length;
    const totalWarnings = errors.filter((e2) => e2.severity === "warning").length;
    const isValid = totalErrors === 0;
    return {
      valid: isValid,
      errors,
      summary: {
        totalErrors,
        totalWarnings,
        validationsPassed,
        validationsFailed
      }
    };
  }
  /**
   * Hybrid validation for a single file
   */
  static async validateSingleFileHybrid(filePath, fileContent, projectPath, validationType) {
    const errors = [];
    if (validationType.includes("types")) {
      const syntaxErrors = await this.validateSyntaxOnly(fileContent, filePath);
      errors.push(...syntaxErrors);
      if (syntaxErrors.length > 0) {
        return { errors };
      }
      const typeErrors = await this.validateTypesSemantic(filePath, projectPath);
      errors.push(...typeErrors);
    }
    if (validationType.includes("lint") && !errors.some((e2) => e2.severity === "error")) {
      const lintErrors = await this.validateESLintSingle(filePath, projectPath);
      errors.push(...lintErrors);
    }
    return { errors };
  }
  /**
   * Fast syntax-only validation using TypeScript parser
   */
  static async validateSyntaxOnly(fileContent, fileName) {
    const errors = [];
    try {
      const ts = await import('typescript');
      const sourceFile = ts.createSourceFile(fileName, fileContent, ts.ScriptTarget.Latest, true);
      const options = {
        allowJs: true,
        checkJs: false,
        noEmit: true
      };
      const host = {
        getSourceFile: (name16) => name16 === fileName ? sourceFile : void 0,
        writeFile: () => {
        },
        getCurrentDirectory: () => "",
        getDirectories: () => [],
        fileExists: (name16) => name16 === fileName,
        readFile: (name16) => name16 === fileName ? fileContent : void 0,
        getCanonicalFileName: (name16) => name16,
        useCaseSensitiveFileNames: () => true,
        getNewLine: () => "\n",
        getDefaultLibFileName: () => "lib.d.ts"
      };
      const program = ts.createProgram([fileName], options, host);
      const diagnostics = program.getSyntacticDiagnostics(sourceFile);
      for (const diagnostic of diagnostics) {
        if (diagnostic.start !== void 0) {
          const position = sourceFile.getLineAndCharacterOfPosition(diagnostic.start);
          errors.push({
            type: "typescript",
            severity: "error",
            message: ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n"),
            file: fileName,
            line: position.line + 1,
            column: position.character + 1
          });
        }
      }
    } catch (error) {
      console.warn("TypeScript not available for syntax validation:", error);
      const lines = fileContent.split("\n");
      const commonErrors = [
        { pattern: /\bimport\s+.*\s+from\s+['""][^'"]*$/, message: "Unterminated import statement" },
        { pattern: /\{[^}]*$/, message: "Unclosed brace" },
        { pattern: /\([^)]*$/, message: "Unclosed parenthesis" },
        { pattern: /\[[^\]]*$/, message: "Unclosed bracket" }
      ];
      lines.forEach((line, index) => {
        commonErrors.forEach(({ pattern, message }) => {
          if (pattern.test(line)) {
            errors.push({
              type: "typescript",
              severity: "error",
              message,
              file: fileName,
              line: index + 1
            });
          }
        });
      });
    }
    return errors;
  }
  /**
   * TypeScript semantic validation using incremental program
   */
  static async validateTypesSemantic(filePath, projectPath) {
    const errors = [];
    try {
      const program = await this.getOrCreateTSProgram(projectPath);
      if (!program) {
        return errors;
      }
      const sourceFile = program.getSourceFile(filePath);
      if (!sourceFile) {
        return errors;
      }
      const diagnostics = [
        ...program.getSemanticDiagnostics(sourceFile),
        ...program.getSyntacticDiagnostics(sourceFile)
      ];
      const ts = await import('typescript');
      for (const diagnostic of diagnostics) {
        if (diagnostic.start !== void 0) {
          const position = sourceFile.getLineAndCharacterOfPosition(diagnostic.start);
          errors.push({
            type: "typescript",
            severity: diagnostic.category === ts.DiagnosticCategory.Warning ? "warning" : "error",
            message: ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n"),
            file: filePath,
            line: position.line + 1,
            column: position.character + 1
          });
        }
      }
    } catch (error) {
      console.warn(`TypeScript semantic validation failed for ${filePath}:`, error);
    }
    return errors;
  }
  /**
   * ESLint validation for a single file
   */
  static async validateESLintSingle(filePath, projectPath) {
    const errors = [];
    try {
      const { stdout } = await execFile("npx", ["eslint", filePath, "--format", "json"], { cwd: projectPath });
      if (stdout) {
        const eslintResults = JSON.parse(stdout);
        const eslintErrors = this.parseESLintErrors(eslintResults);
        errors.push(...eslintErrors);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes('"filePath"') || errorMessage.includes("messages")) {
        try {
          const eslintResults = JSON.parse(errorMessage);
          const eslintErrors = this.parseESLintErrors(eslintResults);
          errors.push(...eslintErrors);
        } catch {
        }
      }
    }
    return errors;
  }
  /**
   * Get or create TypeScript program
   */
  static async getOrCreateTSProgram(projectPath) {
    if (this.tsProgram && this.programProjectPath === projectPath) {
      return this.tsProgram;
    }
    try {
      const ts = await import('typescript');
      const configPath = ts.findConfigFile(projectPath, ts.sys.fileExists, "tsconfig.json");
      if (!configPath) {
        return null;
      }
      const configFile = ts.readConfigFile(configPath, ts.sys.readFile);
      if (configFile.error) {
        return null;
      }
      const parsedConfig = ts.parseJsonConfigFileContent(configFile.config, ts.sys, projectPath);
      if (parsedConfig.errors.length > 0) {
        return null;
      }
      this.tsProgram = ts.createProgram({
        rootNames: parsedConfig.fileNames,
        options: parsedConfig.options
      });
      this.programProjectPath = projectPath;
      return this.tsProgram;
    } catch (error) {
      console.warn("Failed to create TypeScript program:", error);
      return null;
    }
  }
  // Note: Old filterTypeScriptErrors method removed in favor of hybrid validation approach
  /**
   * Parse ESLint errors from JSON output
   */
  static parseESLintErrors(eslintResults) {
    const errors = [];
    for (const result of eslintResults) {
      for (const message of result.messages || []) {
        if (message.message) {
          errors.push({
            type: "eslint",
            severity: message.severity === 1 ? "warning" : "error",
            message: message.message,
            file: result.filePath || void 0,
            line: message.line || void 0,
            column: message.column || void 0,
            code: message.ruleId || void 0
          });
        }
      }
    }
    return errors;
  }
  /**
   * Make HTTP request to server or external API
   */
  static async makeHttpRequest({
    method,
    url,
    baseUrl,
    headers = {},
    body,
    timeout = 3e4
  }) {
    try {
      const fullUrl = baseUrl ? `${baseUrl}${url}` : url;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      const requestOptions = {
        method,
        headers: {
          "Content-Type": "application/json",
          ...headers
        },
        signal: controller.signal
      };
      if (body && (method === "POST" || method === "PUT" || method === "PATCH")) {
        requestOptions.body = typeof body === "string" ? body : JSON.stringify(body);
      }
      const response = await fetch(fullUrl, requestOptions);
      clearTimeout(timeoutId);
      let data;
      const contentType = response.headers.get("content-type");
      if (contentType?.includes("application/json")) {
        data = await response.json();
      } else {
        data = await response.text();
      }
      const responseHeaders = {};
      response.headers.forEach((value, key) => {
        responseHeaders[key] = value;
      });
      return {
        success: response.ok,
        status: response.status,
        statusText: response.statusText,
        headers: responseHeaders,
        data,
        url: fullUrl,
        method
      };
    } catch (error) {
      return {
        success: false,
        url: baseUrl ? `${baseUrl}${url}` : url,
        method,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Enhanced task management system for complex coding tasks
   */
  static async manageTaskList(context2) {
    if (!_AgentBuilderDefaults.taskStorage) {
      _AgentBuilderDefaults.taskStorage = /* @__PURE__ */ new Map();
    }
    const sessions = Array.from(_AgentBuilderDefaults.taskStorage.keys());
    if (sessions.length > 10) {
      const sessionsToRemove = sessions.slice(0, sessions.length - 10);
      sessionsToRemove.forEach((session) => _AgentBuilderDefaults.taskStorage.delete(session));
    }
    const sessionId = "current";
    const existingTasks = _AgentBuilderDefaults.taskStorage.get(sessionId) || [];
    try {
      switch (context2.action) {
        case "create":
          if (!context2.tasks?.length) {
            return {
              success: false,
              tasks: existingTasks,
              message: "No tasks provided for creation"
            };
          }
          const newTasks = context2.tasks.map((task) => ({
            ...task,
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          }));
          const allTasks = [...existingTasks, ...newTasks];
          _AgentBuilderDefaults.taskStorage.set(sessionId, allTasks);
          return {
            success: true,
            tasks: allTasks,
            message: `Created ${newTasks.length} new task(s)`
          };
        case "update":
          if (!context2.tasks?.length) {
            return {
              success: false,
              tasks: existingTasks,
              message: "No tasks provided for update"
            };
          }
          const updatedTasks = existingTasks.map((existing) => {
            const update = context2.tasks.find((t) => t.id === existing.id);
            return update ? { ...existing, ...update, updatedAt: (/* @__PURE__ */ new Date()).toISOString() } : existing;
          });
          _AgentBuilderDefaults.taskStorage.set(sessionId, updatedTasks);
          return {
            success: true,
            tasks: updatedTasks,
            message: "Tasks updated successfully"
          };
        case "complete":
          if (!context2.taskId) {
            return {
              success: false,
              tasks: existingTasks,
              message: "Task ID required for completion"
            };
          }
          const completedTasks = existingTasks.map(
            (task) => task.id === context2.taskId ? { ...task, status: "completed", updatedAt: (/* @__PURE__ */ new Date()).toISOString() } : task
          );
          _AgentBuilderDefaults.taskStorage.set(sessionId, completedTasks);
          return {
            success: true,
            tasks: completedTasks,
            message: `Task ${context2.taskId} marked as completed`
          };
        case "remove":
          if (!context2.taskId) {
            return {
              success: false,
              tasks: existingTasks,
              message: "Task ID required for removal"
            };
          }
          const filteredTasks = existingTasks.filter((task) => task.id !== context2.taskId);
          _AgentBuilderDefaults.taskStorage.set(sessionId, filteredTasks);
          return {
            success: true,
            tasks: filteredTasks,
            message: `Task ${context2.taskId} removed`
          };
        case "list":
        default:
          return {
            success: true,
            tasks: existingTasks,
            message: `Found ${existingTasks.length} task(s)`
          };
      }
    } catch (error) {
      return {
        success: false,
        tasks: existingTasks,
        message: `Task management error: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  /**
   * Perform multiple edits across files atomically
   */
  static async performMultiEdit(context2) {
    const { operations, createBackup = false, projectPath = process.cwd() } = context2;
    const results = [];
    try {
      for (const operation of operations) {
        const filePath = isAbsolute(operation.filePath) ? operation.filePath : join(projectPath, operation.filePath);
        let editsApplied = 0;
        const errors = [];
        let backup;
        try {
          if (createBackup) {
            const backupPath = `${filePath}.backup.${Date.now()}`;
            const originalContent = await readFile(filePath, "utf-8");
            await writeFile(backupPath, originalContent, "utf-8");
            backup = backupPath;
          }
          let content = await readFile(filePath, "utf-8");
          for (const edit of operation.edits) {
            const { oldString, newString, replaceAll = false } = edit;
            if (replaceAll) {
              const regex = new RegExp(oldString.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
              const matches = content.match(regex);
              if (matches) {
                content = content.replace(regex, newString);
                editsApplied += matches.length;
              }
            } else {
              if (content.includes(oldString)) {
                content = content.replace(oldString, newString);
                editsApplied++;
              } else {
                errors.push(`String not found: "${oldString.substring(0, 50)}${oldString.length > 50 ? "..." : ""}"`);
              }
            }
          }
          await writeFile(filePath, content, "utf-8");
        } catch (error) {
          errors.push(`File operation error: ${error instanceof Error ? error.message : String(error)}`);
        }
        results.push({
          filePath: operation.filePath,
          editsApplied,
          errors,
          backup
        });
      }
      const totalEdits = results.reduce((sum, r) => sum + r.editsApplied, 0);
      const totalErrors = results.reduce((sum, r) => sum + r.errors.length, 0);
      return {
        success: totalErrors === 0,
        results,
        message: `Applied ${totalEdits} edits across ${operations.length} files${totalErrors > 0 ? ` with ${totalErrors} errors` : ""}`
      };
    } catch (error) {
      return {
        success: false,
        results,
        message: `Multi-edit operation failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  /**
   * Replace specific line ranges in a file with new content
   */
  static async replaceLines(context2) {
    const { filePath, startLine, endLine, newContent, createBackup = false, projectPath = process.cwd() } = context2;
    try {
      const fullPath = isAbsolute(filePath) ? filePath : join(projectPath, filePath);
      const content = await readFile(fullPath, "utf-8");
      const lines = content.split("\n");
      if (startLine < 1 || endLine < 1) {
        return {
          success: false,
          message: `Line numbers must be 1 or greater. Got startLine: ${startLine}, endLine: ${endLine}`,
          errorMessage: "Invalid line range"
        };
      }
      if (startLine > lines.length || endLine > lines.length) {
        return {
          success: false,
          message: `Line range ${startLine}-${endLine} is out of bounds. File has ${lines.length} lines. Remember: lines are 1-indexed, so valid range is 1-${lines.length}.`,
          errorMessage: "Invalid line range"
        };
      }
      if (startLine > endLine) {
        return {
          success: false,
          message: `Start line (${startLine}) cannot be greater than end line (${endLine}).`,
          errorMessage: "Invalid line range"
        };
      }
      let backup;
      if (createBackup) {
        const backupPath = `${fullPath}.backup.${Date.now()}`;
        await writeFile(backupPath, content, "utf-8");
        backup = backupPath;
      }
      const beforeLines = lines.slice(0, startLine - 1);
      const afterLines = lines.slice(endLine);
      const newLines = newContent ? newContent.split("\n") : [];
      const updatedLines = [...beforeLines, ...newLines, ...afterLines];
      const updatedContent = updatedLines.join("\n");
      await writeFile(fullPath, updatedContent, "utf-8");
      const linesReplaced = endLine - startLine + 1;
      const newLineCount = newLines.length;
      return {
        success: true,
        message: `Successfully replaced ${linesReplaced} lines (${startLine}-${endLine}) with ${newLineCount} new lines in ${filePath}`,
        linesReplaced,
        backup
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to replace lines: ${error instanceof Error ? error.message : String(error)}`,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Show file lines with line numbers for debugging
   */
  static async showFileLines(context2) {
    const { filePath, startLine, endLine, context: contextLines = 2, projectPath = process.cwd() } = context2;
    try {
      const fullPath = isAbsolute(filePath) ? filePath : join(projectPath, filePath);
      const content = await readFile(fullPath, "utf-8");
      const lines = content.split("\n");
      let targetStart = startLine;
      let targetEnd = endLine;
      if (!targetStart) {
        targetStart = 1;
        targetEnd = lines.length;
      } else if (!targetEnd) {
        targetEnd = targetStart;
      }
      const displayStart = Math.max(1, targetStart - contextLines);
      const displayEnd = Math.min(lines.length, targetEnd + contextLines);
      const result = [];
      for (let i = displayStart; i <= displayEnd; i++) {
        const lineIndex = i - 1;
        const isTarget = i >= targetStart && i <= targetEnd;
        result.push({
          lineNumber: i,
          content: lineIndex < lines.length ? lines[lineIndex] ?? "" : "",
          isTarget
        });
      }
      return {
        success: true,
        lines: result,
        totalLines: lines.length,
        message: `Showing lines ${displayStart}-${displayEnd} of ${lines.length} total lines in ${filePath}`
      };
    } catch (error) {
      return {
        success: false,
        lines: [],
        totalLines: 0,
        message: `Failed to read file: ${error instanceof Error ? error.message : String(error)}`,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Signal task completion
   */
  static async signalCompletion(context2) {
    const completionId = `completion_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    let confidence = 70;
    if (context2.validation.testsRun) confidence += 15;
    if (context2.validation.buildsSuccessfully) confidence += 15;
    if (context2.validation.manualTestingRequired) confidence -= 10;
    let status;
    if (context2.validation.testsRun && context2.validation.buildsSuccessfully) {
      status = "completed";
    } else if (context2.validation.manualTestingRequired) {
      status = "needs_testing";
    } else {
      status = "needs_review";
    }
    return {
      completionId,
      status,
      summary: context2.summary,
      confidence: Math.min(100, Math.max(0, confidence))
    };
  }
  /**
   * Perform intelligent search with context
   */
  static async performSmartSearch(context2, projectPath) {
    try {
      const { query, type = "text", scope = {}, context: searchContext = {} } = context2;
      const { paths = ["."], fileTypes = [], excludePaths = [], maxResults = 50 } = scope;
      const { beforeLines = 2, afterLines = 2 } = searchContext;
      const rgArgs = [];
      if (beforeLines > 0) {
        rgArgs.push("-B", beforeLines.toString());
      }
      if (afterLines > 0) {
        rgArgs.push("-A", afterLines.toString());
      }
      rgArgs.push("-n");
      if (type === "regex") {
        rgArgs.push("-e");
      } else if (type === "fuzzy") {
        rgArgs.push("--fixed-strings");
      }
      if (fileTypes.length > 0) {
        fileTypes.forEach((ft) => {
          rgArgs.push("--type-add", `custom:*.${ft}`, "-t", "custom");
        });
      }
      excludePaths.forEach((path) => {
        rgArgs.push("--glob", `!${path}`);
      });
      rgArgs.push("-m", maxResults.toString());
      rgArgs.push(query);
      rgArgs.push(...paths);
      const { stdout } = await execFile("rg", rgArgs, {
        cwd: projectPath
      });
      const lines = stdout.split("\n").filter((line) => line.trim());
      const matches = [];
      let currentMatch = null;
      lines.forEach((line) => {
        if (line.includes(":") && !line.startsWith("-")) {
          const parts = line.split(":");
          if (parts.length >= 3) {
            if (currentMatch) {
              matches.push(currentMatch);
            }
            currentMatch = {
              file: parts[0] || "",
              line: parseInt(parts[1] || "0"),
              match: parts.slice(2).join(":"),
              context: { before: [], after: [] },
              relevance: type === "fuzzy" ? Math.random() * 100 : void 0
            };
          }
        } else if (line.startsWith("-") && currentMatch) {
          const contextLine = line.substring(1);
          if (currentMatch.context.before.length < beforeLines) {
            currentMatch.context.before.push(contextLine);
          } else {
            currentMatch.context.after.push(contextLine);
          }
        }
      });
      if (currentMatch) {
        matches.push(currentMatch);
      }
      const filesSearched = new Set(matches.map((m) => m.file)).size;
      return {
        success: true,
        matches: matches.slice(0, maxResults),
        summary: {
          totalMatches: matches.length,
          filesSearched,
          patterns: [query]
        }
      };
    } catch {
      return {
        success: false,
        matches: [],
        summary: {
          totalMatches: 0,
          filesSearched: 0,
          patterns: [context2.query]
        }
      };
    }
  }
  // Static storage properties
  static taskStorage;
  static pendingQuestions;
  /**
   * Read file contents with optional line range
   */
  static async readFile(context2) {
    try {
      const { filePath, startLine, endLine, encoding = "utf-8", projectPath } = context2;
      const resolvedPath = isAbsolute(filePath) ? filePath : resolve$2(projectPath || process.cwd(), filePath);
      const stats = await stat(resolvedPath);
      const content = await readFile(resolvedPath, { encoding });
      const lines = content.split("\n");
      let resultContent = content;
      let resultLines = lines;
      if (startLine !== void 0 || endLine !== void 0) {
        const start = Math.max(0, (startLine || 1) - 1);
        const end = endLine !== void 0 ? Math.min(lines.length, endLine) : lines.length;
        resultLines = lines.slice(start, end);
        resultContent = resultLines.join("\n");
      }
      return {
        success: true,
        content: resultContent,
        lines: resultLines,
        metadata: {
          size: stats.size,
          totalLines: lines.length,
          encoding,
          lastModified: stats.mtime.toISOString()
        }
      };
    } catch (error) {
      return {
        success: false,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Write content to file with directory creation and backup options
   */
  static async writeFile(context2) {
    try {
      const { filePath, content, createDirs = true, encoding = "utf-8", projectPath } = context2;
      const resolvedPath = isAbsolute(filePath) ? filePath : resolve$2(projectPath || process.cwd(), filePath);
      const dir = dirname(resolvedPath);
      if (createDirs) {
        await mkdir(dir, { recursive: true });
      }
      await writeFile(resolvedPath, content, { encoding });
      return {
        success: true,
        filePath: resolvedPath,
        bytesWritten: Buffer.byteLength(content, encoding),
        message: `Successfully wrote ${Buffer.byteLength(content, encoding)} bytes to ${filePath}`
      };
    } catch (error) {
      return {
        success: false,
        filePath: context2.filePath,
        message: `Failed to write file: ${error instanceof Error ? error.message : String(error)}`,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * List directory contents with filtering and metadata
   */
  static async listDirectory(context2) {
    try {
      const {
        path,
        recursive = false,
        includeHidden = false,
        pattern,
        maxDepth = 10,
        includeMetadata = true,
        projectPath
      } = context2;
      const gitignorePath = join(projectPath || process.cwd(), ".gitignore");
      let gitignoreFilter;
      try {
        const gitignoreContent = await readFile(gitignorePath, "utf-8");
        gitignoreFilter = (0, import_ignore.default)().add(gitignoreContent);
      } catch (err) {
        if (err.code !== "ENOENT") {
          console.error(`Error reading .gitignore file:`, err);
        }
      }
      const resolvedPath = isAbsolute(path) ? path : resolve$2(projectPath || process.cwd(), path);
      const items = [];
      async function processDirectory(dirPath, currentDepth = 0) {
        const relativeToProject = relative(projectPath || process.cwd(), dirPath);
        if (gitignoreFilter?.ignores(relativeToProject)) return;
        if (currentDepth > maxDepth) return;
        const entries = await readdir(dirPath);
        for (const entry of entries) {
          const entryPath = join(dirPath, entry);
          const relativeEntryPath = relative(projectPath || process.cwd(), entryPath);
          if (gitignoreFilter?.ignores(relativeEntryPath)) continue;
          if (!includeHidden && entry.startsWith(".")) continue;
          const fullPath = entryPath;
          const relativePath = relative(resolvedPath, fullPath);
          if (pattern) {
            const regexPattern = pattern.replace(/\*/g, ".*").replace(/\?/g, ".");
            if (!new RegExp(regexPattern).test(entry)) continue;
          }
          let stats;
          let type;
          try {
            stats = await stat(fullPath);
            if (stats.isDirectory()) {
              type = "directory";
            } else if (stats.isSymbolicLink()) {
              type = "symlink";
            } else {
              type = "file";
            }
          } catch {
            continue;
          }
          const item = {
            name: entry,
            path: relativePath || entry,
            type
          };
          if (includeMetadata) {
            item.size = stats.size;
            item.lastModified = stats.mtime.toISOString();
            item.permissions = `0${(stats.mode & parseInt("777", 8)).toString(8)}`;
          }
          items.push(item);
          if (recursive && type === "directory") {
            await processDirectory(fullPath, currentDepth + 1);
          }
        }
      }
      await processDirectory(resolvedPath);
      return {
        success: true,
        items,
        totalItems: items.length,
        path: resolvedPath,
        message: `Listed ${items.length} items in ${resolvedPath}`
      };
    } catch (error) {
      return {
        success: false,
        items: [],
        totalItems: 0,
        path: context2.path,
        message: `Failed to list directory: ${error instanceof Error ? error.message : String(error)}`,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Execute shell commands with proper error handling
   */
  static async executeCommand(context2) {
    const startTime = Date.now();
    try {
      const { command, workingDirectory, timeout = 3e4, captureOutput = true, shell, env } = context2;
      const execOptions = {
        timeout,
        env: { ...process.env, ...env }
      };
      if (workingDirectory) {
        execOptions.cwd = workingDirectory;
      }
      if (shell) {
        execOptions.shell = shell;
      }
      const { stdout, stderr } = await exec(command, execOptions);
      const executionTime = Date.now() - startTime;
      return {
        success: true,
        exitCode: 0,
        stdout: captureOutput ? String(stdout) : void 0,
        stderr: captureOutput ? String(stderr) : void 0,
        command,
        workingDirectory,
        executionTime
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      return {
        success: false,
        exitCode: error.code || 1,
        stdout: String(error.stdout || ""),
        stderr: String(error.stderr || ""),
        command: context2.command,
        workingDirectory: context2.workingDirectory,
        executionTime,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Web search using a simple search approach
   */
  static async webSearch(context2) {
    try {
      const {
        query,
        maxResults = 10
        // region = 'us',
        // language = 'en',
        // includeImages = false,
        // dateRange = 'all',
      } = context2;
      const startTime = Date.now();
      const searchUrl = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&no_redirect=1&skip_disambig=1`;
      const response = await fetch(searchUrl);
      const data = await response.json();
      const results = [];
      if (data.RelatedTopics && Array.isArray(data.RelatedTopics)) {
        for (const topic of data.RelatedTopics.slice(0, maxResults)) {
          if (topic.FirstURL && topic.Text) {
            const url = new URL(topic.FirstURL);
            results.push({
              title: topic.Text.split(" - ")[0] || topic.Text.substring(0, 60),
              url: topic.FirstURL,
              snippet: topic.Text,
              domain: url.hostname,
              relevanceScore: Math.random() * 100
              // Placeholder scoring
            });
          }
        }
      }
      if (data.Abstract && data.AbstractURL) {
        const url = new URL(data.AbstractURL);
        results.unshift({
          title: data.Heading || "Main Result",
          url: data.AbstractURL,
          snippet: data.Abstract,
          domain: url.hostname,
          relevanceScore: 100
        });
      }
      const searchTime = Date.now() - startTime;
      return {
        success: true,
        query,
        results: results.slice(0, maxResults),
        totalResults: results.length,
        searchTime,
        suggestions: data.RelatedTopics?.slice(maxResults, maxResults + 3)?.map((t) => t.Text?.split(" - ")[0] || t.Text?.substring(0, 30)).filter(Boolean) || []
      };
    } catch (error) {
      return {
        success: false,
        query: context2.query,
        results: [],
        totalResults: 0,
        searchTime: 0,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
};
var ToolSummaryProcessor = class {
  id = "tool-summary-processor";
  name = "ToolSummaryProcessor";
  summaryAgent;
  summaryCache = /* @__PURE__ */ new Map();
  constructor({ summaryModel }) {
    this.summaryAgent = new Agent({
      id: "tool-summary-agent",
      name: "Tool Summary Agent",
      description: "A summary agent that summarizes tool calls and results",
      instructions: "You are a summary agent that summarizes tool calls and results",
      model: summaryModel
    });
  }
  /**
   * Creates a cache key from tool call arguments
   */
  createCacheKey(toolCall) {
    if (!toolCall) return "unknown";
    const toolName = toolCall.toolName || "unknown";
    const args = toolCall.args || {};
    const sortedArgs = Object.keys(args).sort().reduce((result, key) => {
      result[key] = args[key];
      return result;
    }, {});
    return `${toolName}:${JSON.stringify(sortedArgs)}`;
  }
  /**
   * Clears the summary cache
   */
  clearCache() {
    this.summaryCache.clear();
  }
  /**
   * Gets cache statistics
   */
  getCacheStats() {
    return {
      size: this.summaryCache.size,
      keys: Array.from(this.summaryCache.keys())
    };
  }
  async processInput({
    messages,
    messageList: _messageList
  }) {
    const summaryTasks = [];
    for (const message of messages) {
      if (message.content.format === 2 && message.content.parts) {
        for (let partIndex = 0; partIndex < message.content.parts.length; partIndex++) {
          const part = message.content.parts[partIndex];
          if (part && part.type === "tool-invocation" && part.toolInvocation?.state === "result") {
            const cacheKey = this.createCacheKey(part.toolInvocation);
            const cachedSummary = this.summaryCache.get(cacheKey);
            if (cachedSummary) {
              message.content.parts[partIndex] = {
                type: "tool-invocation",
                toolInvocation: {
                  state: "result",
                  step: part.toolInvocation.step,
                  toolCallId: part.toolInvocation.toolCallId,
                  toolName: part.toolInvocation.toolName,
                  args: part.toolInvocation.args,
                  result: `Tool call summary: ${cachedSummary}`
                }
              };
            } else {
              const summaryPromise = this.summaryAgent.generate(
                `Summarize the following tool call: ${JSON.stringify(part.toolInvocation)}`
              );
              summaryTasks.push({
                message,
                partIndex,
                promise: summaryPromise,
                cacheKey
              });
            }
          }
        }
      }
    }
    if (summaryTasks.length > 0) {
      const summaryResults = await Promise.allSettled(summaryTasks.map((task) => task.promise));
      summaryTasks.forEach((task, index) => {
        const result = summaryResults[index];
        if (!result) return;
        if (result.status === "fulfilled") {
          const summaryResult = result.value;
          const summaryText = summaryResult.text;
          this.summaryCache.set(task.cacheKey, summaryText);
          if (task.message.content.format === 2 && task.message.content.parts) {
            const part = task.message.content.parts[task.partIndex];
            if (part && part.type === "tool-invocation" && part.toolInvocation?.state === "result") {
              task.message.content.parts[task.partIndex] = {
                type: "tool-invocation",
                toolInvocation: {
                  state: "result",
                  step: part.toolInvocation.step,
                  toolCallId: part.toolInvocation.toolCallId,
                  toolName: part.toolInvocation.toolName,
                  args: part.toolInvocation.args,
                  result: `Tool call summary: ${summaryText}`
                }
              };
            }
          }
        } else if (result.status === "rejected") {
          console.warn(`Failed to generate summary for tool call:`, result.reason);
        }
      });
    }
    return messages;
  }
};
var AgentBuilder = class extends Agent {
  builderConfig;
  /**
   * Constructor for AgentBuilder
   */
  constructor(config) {
    const additionalInstructions = config.instructions ? `## Priority Instructions 

${config.instructions}` : "";
    const combinedInstructions = additionalInstructions + AgentBuilderDefaults.DEFAULT_INSTRUCTIONS(config.projectPath);
    const memory = new Memory({
      options: AgentBuilderDefaults.DEFAULT_MEMORY_CONFIG
    });
    memory.setStorage(config.storage ?? new InMemoryStore());
    const agentConfig = {
      id: "agent-builder",
      name: "agent-builder",
      description: "An AI agent specialized in generating Mastra agents, tools, and workflows from natural language requirements.",
      instructions: combinedInstructions,
      model: config.model,
      tools: async () => {
        return {
          ...await AgentBuilderDefaults.listToolsForMode(config.projectPath, config.mode),
          ...config.tools || {}
        };
      },
      memory,
      inputProcessors: [
        // use the write to disk processor to debug the agent's context
        // new WriteToDiskProcessor({ prefix: 'before-filter' }),
        new ToolSummaryProcessor({ summaryModel: config.summaryModel || config.model })
        // new WriteToDiskProcessor({ prefix: 'after-filter' }),
      ]
    };
    super(agentConfig);
    this.builderConfig = config;
  }
  /**
   * Enhanced generate method with AgentBuilder-specific configuration
   * Overrides the base Agent generate method to provide additional project context
   */
  generateLegacy = async (messages, generateOptions = {}) => {
    const { maxSteps, ...baseOptions } = generateOptions;
    const originalInstructions = await this.getInstructions({ requestContext: generateOptions?.requestContext });
    const additionalInstructions = baseOptions.instructions;
    let enhancedInstructions = originalInstructions;
    if (additionalInstructions) {
      enhancedInstructions = `${originalInstructions}

${additionalInstructions}`;
    }
    const enhancedContext = [...baseOptions.context || []];
    const enhancedOptions = {
      ...baseOptions,
      maxSteps: maxSteps || 100,
      // Higher default for code generation
      temperature: 0.3,
      // Lower temperature for more consistent code generation
      instructions: enhancedInstructions,
      context: enhancedContext
    };
    this.logger.debug(`[AgentBuilder:${this.name}] Starting generation with enhanced context`, {
      projectPath: this.builderConfig.projectPath
    });
    return super.generateLegacy(messages, enhancedOptions);
  };
  /**
   * Enhanced stream method with AgentBuilder-specific configuration
   * Overrides the base Agent stream method to provide additional project context
   */
  streamLegacy = async (messages, streamOptions = {}) => {
    const { maxSteps, ...baseOptions } = streamOptions;
    const originalInstructions = await this.getInstructions({ requestContext: streamOptions?.requestContext });
    const additionalInstructions = baseOptions.instructions;
    let enhancedInstructions = originalInstructions;
    if (additionalInstructions) {
      enhancedInstructions = `${originalInstructions}

${additionalInstructions}`;
    }
    const enhancedContext = [...baseOptions.context || []];
    const enhancedOptions = {
      ...baseOptions,
      maxSteps: maxSteps || 100,
      // Higher default for code generation
      temperature: 0.3,
      // Lower temperature for more consistent code generation
      instructions: enhancedInstructions,
      context: enhancedContext
    };
    this.logger.debug(`[AgentBuilder:${this.name}] Starting streaming with enhanced context`, {
      projectPath: this.builderConfig.projectPath
    });
    return super.streamLegacy(messages, enhancedOptions);
  };
  async stream(messages, streamOptions) {
    const { ...baseOptions } = streamOptions || {};
    const originalInstructions = await this.getInstructions({ requestContext: streamOptions?.requestContext });
    const additionalInstructions = baseOptions.instructions;
    let enhancedInstructions = originalInstructions;
    if (additionalInstructions) {
      enhancedInstructions = `${originalInstructions}

${additionalInstructions}`;
    }
    const enhancedContext = [...baseOptions.context || []];
    const enhancedOptions = {
      ...baseOptions,
      temperature: 0.3,
      // Lower temperature for more consistent code generation
      maxSteps: baseOptions?.maxSteps || 100,
      instructions: enhancedInstructions,
      context: enhancedContext
    };
    this.logger.debug(`[AgentBuilder:${this.name}] Starting streaming with enhanced context`, {
      projectPath: this.builderConfig.projectPath
    });
    return super.stream(messages, enhancedOptions);
  }
  async generate(messages, options) {
    const { ...baseOptions } = options || {};
    const originalInstructions = await this.getInstructions({ requestContext: options?.requestContext });
    const additionalInstructions = baseOptions.instructions;
    let enhancedInstructions = originalInstructions;
    if (additionalInstructions) {
      enhancedInstructions = `${originalInstructions}

${additionalInstructions}`;
    }
    const enhancedContext = [...baseOptions.context || []];
    const enhancedOptions = {
      ...baseOptions,
      temperature: 0.3,
      // Lower temperature for more consistent code generation
      maxSteps: baseOptions?.maxSteps || 100,
      instructions: enhancedInstructions,
      context: enhancedContext
    };
    this.logger.debug(`[AgentBuilder:${this.name}] Starting streaming with enhanced context`, {
      projectPath: this.builderConfig.projectPath
    });
    return super.generate(messages, enhancedOptions);
  }
};
var cloneTemplateStep = createStep({
  id: "clone-template",
  description: "Clone the template repository to a temporary directory at the specified ref",
  inputSchema: AgentBuilderInputSchema,
  outputSchema: CloneTemplateResultSchema,
  execute: async ({ inputData }) => {
    const { repo, ref = "main", slug, targetPath } = inputData;
    if (!repo) {
      throw new Error("Repository URL or path is required");
    }
    const inferredSlug = slug || repo.split("/").pop()?.replace(/\.git$/, "") || "template";
    const tempDir = await mkdtemp(join(tmpdir(), "mastra-template-"));
    try {
      await gitClone(repo, tempDir);
      if (ref !== "main" && ref !== "master") {
        await gitCheckoutRef(tempDir, ref);
      }
      const commitSha = await gitRevParse(tempDir, "HEAD");
      return {
        templateDir: tempDir,
        commitSha: commitSha.trim(),
        slug: inferredSlug,
        success: true,
        targetPath
      };
    } catch (error) {
      try {
        await rm(tempDir, { recursive: true, force: true });
      } catch {
      }
      return {
        templateDir: "",
        commitSha: "",
        slug: slug || "unknown",
        success: false,
        error: `Failed to clone template: ${error instanceof Error ? error.message : String(error)}`,
        targetPath
      };
    }
  }
});
var analyzePackageStep = createStep({
  id: "analyze-package",
  description: "Analyze the template package.json to extract dependency information",
  inputSchema: CloneTemplateResultSchema,
  outputSchema: PackageAnalysisSchema,
  execute: async ({ inputData }) => {
    console.info("Analyzing template package.json...");
    const { templateDir } = inputData;
    const packageJsonPath = join(templateDir, "package.json");
    try {
      const packageJsonContent = await readFile(packageJsonPath, "utf-8");
      const packageJson = JSON.parse(packageJsonContent);
      console.info("Template package.json:", JSON.stringify(packageJson, null, 2));
      return {
        dependencies: packageJson.dependencies || {},
        devDependencies: packageJson.devDependencies || {},
        peerDependencies: packageJson.peerDependencies || {},
        scripts: packageJson.scripts || {},
        name: packageJson.name || "",
        version: packageJson.version || "",
        description: packageJson.description || "",
        success: true
      };
    } catch (error) {
      console.warn(`Failed to read template package.json: ${error instanceof Error ? error.message : String(error)}`);
      return {
        dependencies: {},
        devDependencies: {},
        peerDependencies: {},
        scripts: {},
        name: "",
        version: "",
        description: "",
        success: true
        // This is a graceful fallback, not a failure
      };
    }
  }
});
var discoverUnitsStep = createStep({
  id: "discover-units",
  description: "Discover template units by analyzing the templates directory structure",
  inputSchema: CloneTemplateResultSchema,
  outputSchema: DiscoveryResultSchema,
  execute: async ({ inputData, requestContext }) => {
    const { templateDir } = inputData;
    const targetPath = resolveTargetPath(inputData, requestContext);
    const tools = await AgentBuilderDefaults.DEFAULT_TOOLS(templateDir);
    console.info("targetPath", targetPath);
    const model = await resolveModel({ requestContext, projectPath: targetPath, defaultModel: openai("gpt-4.1") });
    try {
      const agent = new Agent({
        id: "mastra-project-discoverer",
        model,
        instructions: `You are an expert at analyzing Mastra projects.

Your task is to scan the provided directory and identify all available units (agents, workflows, tools, MCP servers, networks).

Mastra Project Structure Analysis:
- Each Mastra project has a structure like: ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.agent}, ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.workflow}, ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.tool}, ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE["mcp-server"]}, ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.network}
- Analyze TypeScript files in each category directory to identify exported units

CRITICAL: YOU MUST USE YOUR TOOLS (readFile, listDirectory) TO DISCOVER THE UNITS IN THE TEMPLATE DIRECTORY.

IMPORTANT - Agent Discovery Rules:
1. **Multiple Agent Files**: Some templates have separate files for each agent (e.g., evaluationAgent.ts, researchAgent.ts)
2. **Single File Multiple Agents**: Some files may export multiple agents (look for multiple 'export const' or 'export default' statements)
3. **Agent Identification**: Look for exported variables that are instances of 'new Agent()' or similar patterns
4. **Naming Convention**: Agent names should be extracted from the export name (e.g., 'weatherAgent', 'evaluationAgent')

For each Mastra project directory you analyze:
1. Scan all TypeScript files in ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.agent} and identify ALL exported agents
2. Scan all TypeScript files in ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.workflow} and identify ALL exported workflows
3. Scan all TypeScript files in ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.tool} and identify ALL exported tools
4. Scan all TypeScript files in ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE["mcp-server"]} and identify ALL exported MCP servers
5. Scan all TypeScript files in ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.network} and identify ALL exported networks
6. Scan for any OTHER files in src/mastra that are NOT in the above default folders (e.g., lib/, utils/, types/, etc.) and identify them as 'other' files

IMPORTANT - Naming Consistency Rules:
- For ALL unit types (including 'other'), the 'name' field should be the filename WITHOUT extension
- For structured units (agents, workflows, tools, etc.), prefer the actual export name if clearly identifiable
- use the base filename without extension for the id (e.g., 'util.ts' \u2192 name: 'util')
- use the relative path from the template root for the file (e.g., 'src/mastra/lib/util.ts' \u2192 file: 'src/mastra/lib/util.ts')

Return the actual exported names of the units, as well as the file names.`,
        name: "Mastra Project Discoverer",
        tools: {
          readFile: tools.readFile,
          listDirectory: tools.listDirectory
        }
      });
      const resolvedModel = await agent.getModel();
      const isSupported = isSupportedLanguageModel(resolvedModel);
      const prompt = `Analyze the Mastra project directory structure at "${templateDir}".

            List directory contents using listDirectory tool, and then analyze each file with readFile tool.
      IMPORTANT:
      - Look inside the actual file content to find export statements like 'export const agentName = new Agent(...)'
      - A single file may contain multiple exports
      - Return the actual exported variable names, as well as the file names
      - If a directory doesn't exist or has no files, return an empty array

      Return the analysis in the exact format specified in the output schema.`;
      const output = z.object({
        agents: z.array(z.object({ name: z.string(), file: z.string() })).optional(),
        workflows: z.array(z.object({ name: z.string(), file: z.string() })).optional(),
        tools: z.array(z.object({ name: z.string(), file: z.string() })).optional(),
        mcp: z.array(z.object({ name: z.string(), file: z.string() })).optional(),
        networks: z.array(z.object({ name: z.string(), file: z.string() })).optional(),
        other: z.array(z.object({ name: z.string(), file: z.string() })).optional()
      });
      const result = isSupported ? await tryGenerateWithJsonFallback(agent, prompt, {
        structuredOutput: {
          schema: output
        },
        maxSteps: 100
      }) : await agent.generateLegacy(prompt, {
        experimental_output: output,
        maxSteps: 100
      });
      const template = result.object ?? {};
      const units = [];
      template.agents?.forEach((agentId) => {
        units.push({ kind: "agent", id: agentId.name, file: agentId.file });
      });
      template.workflows?.forEach((workflowId) => {
        units.push({ kind: "workflow", id: workflowId.name, file: workflowId.file });
      });
      template.tools?.forEach((toolId) => {
        units.push({ kind: "tool", id: toolId.name, file: toolId.file });
      });
      template.mcp?.forEach((mcpId) => {
        units.push({ kind: "mcp-server", id: mcpId.name, file: mcpId.file });
      });
      template.networks?.forEach((networkId) => {
        units.push({ kind: "network", id: networkId.name, file: networkId.file });
      });
      template.other?.forEach((otherId) => {
        units.push({ kind: "other", id: otherId.name, file: otherId.file });
      });
      console.info("Discovered units:", JSON.stringify(units, null, 2));
      if (units.length === 0) {
        throw new Error(`No Mastra units (agents, workflows, tools) found in template.
          Possible causes:
          - Template may not follow standard Mastra structure
          - AI agent couldn't analyze template files (model/token limits)
          - Template is empty or in wrong branch

          Debug steps:
          - Check template has files in src/mastra/ directories
          - Try a different branch
          - Check template repository structure manually`);
      }
      return {
        units,
        success: true
      };
    } catch (error) {
      console.error("Failed to discover units:", error);
      return {
        units: [],
        success: false,
        error: `Failed to discover units: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
});
var orderUnitsStep = createStep({
  id: "order-units",
  description: "Sort units in topological order based on kind weights",
  inputSchema: DiscoveryResultSchema,
  outputSchema: OrderedUnitsSchema,
  execute: async ({ inputData }) => {
    const { units } = inputData;
    const orderedUnits = [...units].sort((a, b) => {
      const aWeight = kindWeight(a.kind);
      const bWeight = kindWeight(b.kind);
      return aWeight - bWeight;
    });
    return {
      orderedUnits,
      success: true
    };
  }
});
var prepareBranchStep = createStep({
  id: "prepare-branch",
  description: "Create or switch to integration branch before modifications",
  inputSchema: PrepareBranchInputSchema,
  outputSchema: PrepareBranchResultSchema,
  execute: async ({ inputData, requestContext }) => {
    const targetPath = resolveTargetPath(inputData, requestContext);
    try {
      const branchName = `feat/install-template-${inputData.slug}`;
      await gitCheckoutBranch(branchName, targetPath);
      return {
        branchName,
        success: true
      };
    } catch (error) {
      console.error("Failed to prepare branch:", error);
      return {
        branchName: `feat/install-template-${inputData.slug}`,
        // Return the intended name anyway
        success: false,
        error: `Failed to prepare branch: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
});
var packageMergeStep = createStep({
  id: "package-merge",
  description: "Merge template package.json dependencies into target project",
  inputSchema: PackageMergeInputSchema,
  outputSchema: PackageMergeResultSchema,
  execute: async ({ inputData, requestContext }) => {
    console.info("Package merge step starting...");
    const { slug, packageInfo } = inputData;
    const targetPath = resolveTargetPath(inputData, requestContext);
    try {
      const targetPkgPath = join(targetPath, "package.json");
      let targetPkgRaw = "{}";
      try {
        targetPkgRaw = await readFile(targetPkgPath, "utf-8");
      } catch {
        console.warn(`No existing package.json at ${targetPkgPath}, creating a new one`);
      }
      let targetPkg;
      try {
        targetPkg = JSON.parse(targetPkgRaw || "{}");
      } catch (e2) {
        throw new Error(
          `Failed to parse existing package.json at ${targetPkgPath}: ${e2 instanceof Error ? e2.message : String(e2)}`
        );
      }
      const ensureObj = (o) => o && typeof o === "object" ? o : {};
      targetPkg.dependencies = ensureObj(targetPkg.dependencies);
      targetPkg.devDependencies = ensureObj(targetPkg.devDependencies);
      targetPkg.peerDependencies = ensureObj(targetPkg.peerDependencies);
      targetPkg.scripts = ensureObj(targetPkg.scripts);
      const tplDeps = ensureObj(packageInfo.dependencies);
      const tplDevDeps = ensureObj(packageInfo.devDependencies);
      const tplPeerDeps = ensureObj(packageInfo.peerDependencies);
      const tplScripts = ensureObj(packageInfo.scripts);
      const existsAnywhere = (name16) => name16 in targetPkg.dependencies || name16 in targetPkg.devDependencies || name16 in targetPkg.peerDependencies;
      for (const [name16, ver] of Object.entries(tplDeps)) {
        if (!existsAnywhere(name16)) {
          targetPkg.dependencies[name16] = String(ver);
        }
      }
      for (const [name16, ver] of Object.entries(tplDevDeps)) {
        if (!existsAnywhere(name16)) {
          targetPkg.devDependencies[name16] = String(ver);
        }
      }
      for (const [name16, ver] of Object.entries(tplPeerDeps)) {
        if (!(name16 in targetPkg.peerDependencies)) {
          targetPkg.peerDependencies[name16] = String(ver);
        }
      }
      const prefix = `template:${slug}:`;
      for (const [name16, cmd] of Object.entries(tplScripts)) {
        const newKey = `${prefix}${name16}`;
        if (!(newKey in targetPkg.scripts)) {
          targetPkg.scripts[newKey] = String(cmd);
        }
      }
      await writeFile(targetPkgPath, JSON.stringify(targetPkg, null, 2), "utf-8");
      await gitAddAndCommit(targetPath, `feat(template): merge deps for ${slug}`, [targetPkgPath], {
        skipIfNoStaged: true
      });
      return {
        success: true,
        applied: true,
        message: `Successfully merged template dependencies for ${slug}`
      };
    } catch (error) {
      console.error("Package merge failed:", error);
      return {
        success: false,
        applied: false,
        message: `Package merge failed: ${error instanceof Error ? error.message : String(error)}`,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var installStep = createStep({
  id: "install",
  description: "Install packages based on merged package.json",
  inputSchema: InstallInputSchema,
  outputSchema: InstallResultSchema,
  execute: async ({ inputData, requestContext }) => {
    console.info("Running install step...");
    const targetPath = resolveTargetPath(inputData, requestContext);
    try {
      await spawnSWPM(targetPath, "install", []);
      const lock = ["pnpm-lock.yaml", "package-lock.json", "yarn.lock"].map((f) => join(targetPath, f)).find((f) => existsSync(f));
      if (lock) {
        await gitAddAndCommit(targetPath, `chore(template): commit lockfile after install`, [lock], {
          skipIfNoStaged: true
        });
      }
      return {
        success: true
      };
    } catch (error) {
      console.error("Install failed:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var programmaticFileCopyStep = createStep({
  id: "programmatic-file-copy",
  description: "Programmatically copy template files to target project based on ordered units",
  inputSchema: FileCopyInputSchema,
  outputSchema: FileCopyResultSchema,
  execute: async ({ inputData, requestContext }) => {
    console.info("Programmatic file copy step starting...");
    const { orderedUnits, templateDir, commitSha, slug } = inputData;
    const targetPath = resolveTargetPath(inputData, requestContext);
    try {
      const copiedFiles = [];
      const conflicts = [];
      const analyzeNamingConvention = async (directory) => {
        try {
          const files = await readdir(resolve$2(targetPath, directory), { withFileTypes: true });
          const tsFiles = files.filter((f) => f.isFile() && f.name.endsWith(".ts")).map((f) => f.name);
          if (tsFiles.length === 0) return "unknown";
          const camelCaseCount = tsFiles.filter((f) => /^[a-z][a-zA-Z0-9]*\.ts$/.test(f)).length;
          const snakeCaseCount = tsFiles.filter((f) => /^[a-z][a-z0-9_]*\.ts$/.test(f) && f.includes("_")).length;
          const kebabCaseCount = tsFiles.filter((f) => /^[a-z][a-z0-9-]*\.ts$/.test(f) && f.includes("-")).length;
          const pascalCaseCount = tsFiles.filter((f) => /^[A-Z][a-zA-Z0-9]*\.ts$/.test(f)).length;
          const max = Math.max(camelCaseCount, snakeCaseCount, kebabCaseCount, pascalCaseCount);
          if (max === 0) return "unknown";
          if (camelCaseCount === max) return "camelCase";
          if (snakeCaseCount === max) return "snake_case";
          if (kebabCaseCount === max) return "kebab-case";
          if (pascalCaseCount === max) return "PascalCase";
          return "unknown";
        } catch {
          return "unknown";
        }
      };
      const convertNaming = (name16, convention) => {
        const baseName = basename(name16, extname(name16));
        const ext = extname(name16);
        const toWords = (s) => {
          return s.replace(/[-_]/g, " ").replace(/([A-Z]+)([A-Z][a-z])/g, "$1 $2").replace(/([a-z0-9])([A-Z])/g, "$1 $2").split(/\s+/).filter(Boolean).map((w) => w.toLowerCase());
        };
        const words = toWords(baseName);
        switch (convention) {
          case "camelCase":
            return words.map((w, i) => i === 0 ? w : w.charAt(0).toUpperCase() + w.slice(1)).join("") + ext;
          case "snake_case":
            return words.join("_") + ext;
          case "kebab-case":
            return words.join("-") + ext;
          case "PascalCase":
            return words.map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join("") + ext;
          default:
            return name16;
        }
      };
      for (const unit of orderedUnits) {
        console.info(`Processing ${unit.kind} unit "${unit.id}" from file "${unit.file}"`);
        let sourceFile;
        let resolvedUnitFile;
        if (unit.file.includes("/")) {
          sourceFile = resolve$2(templateDir, unit.file);
          resolvedUnitFile = unit.file;
        } else {
          const folderPath = AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE[unit.kind];
          if (!folderPath) {
            conflicts.push({
              unit: { kind: unit.kind, id: unit.id },
              issue: `Unknown unit kind: ${unit.kind}`,
              sourceFile: unit.file,
              targetFile: "N/A"
            });
            continue;
          }
          resolvedUnitFile = `${folderPath}/${unit.file}`;
          sourceFile = resolve$2(templateDir, resolvedUnitFile);
        }
        if (!existsSync(sourceFile)) {
          conflicts.push({
            unit: { kind: unit.kind, id: unit.id },
            issue: `Source file not found: ${sourceFile}`,
            sourceFile: resolvedUnitFile,
            targetFile: "N/A"
          });
          continue;
        }
        const targetDir = dirname(resolvedUnitFile);
        const namingConvention = await analyzeNamingConvention(targetDir);
        console.info(`Detected naming convention in ${targetDir}: ${namingConvention}`);
        const hasExtension = extname(unit.id) !== "";
        const baseId = hasExtension ? basename(unit.id, extname(unit.id)) : unit.id;
        const fileExtension = extname(unit.file);
        const convertedFileName = namingConvention !== "unknown" ? convertNaming(baseId + fileExtension, namingConvention) : baseId + fileExtension;
        const targetFile = resolve$2(targetPath, targetDir, convertedFileName);
        if (existsSync(targetFile)) {
          const strategy = determineConflictStrategy();
          console.info(`File exists: ${convertedFileName}, using strategy: ${strategy}`);
          switch (strategy) {
            case "skip":
              conflicts.push({
                unit: { kind: unit.kind, id: unit.id },
                issue: `File exists - skipped: ${convertedFileName}`,
                sourceFile: unit.file,
                targetFile: `${targetDir}/${convertedFileName}`
              });
              console.info(`\u23ED\uFE0F Skipped ${unit.kind} "${unit.id}": file already exists`);
              continue;
            case "backup-and-replace":
              try {
                await backupAndReplaceFile(sourceFile, targetFile);
                copiedFiles.push({
                  source: sourceFile,
                  destination: targetFile,
                  unit: { kind: unit.kind, id: unit.id }
                });
                console.info(
                  `\u{1F504} Replaced ${unit.kind} "${unit.id}": ${unit.file} \u2192 ${convertedFileName} (backup created)`
                );
                continue;
              } catch (backupError) {
                conflicts.push({
                  unit: { kind: unit.kind, id: unit.id },
                  issue: `Failed to backup and replace: ${backupError instanceof Error ? backupError.message : String(backupError)}`,
                  sourceFile: unit.file,
                  targetFile: `${targetDir}/${convertedFileName}`
                });
                continue;
              }
            case "rename":
              try {
                const uniqueTargetFile = await renameAndCopyFile(sourceFile, targetFile);
                copiedFiles.push({
                  source: sourceFile,
                  destination: uniqueTargetFile,
                  unit: { kind: unit.kind, id: unit.id }
                });
                console.info(`\u{1F4DD} Renamed ${unit.kind} "${unit.id}": ${unit.file} \u2192 ${basename(uniqueTargetFile)}`);
                continue;
              } catch (renameError) {
                conflicts.push({
                  unit: { kind: unit.kind, id: unit.id },
                  issue: `Failed to rename and copy: ${renameError instanceof Error ? renameError.message : String(renameError)}`,
                  sourceFile: unit.file,
                  targetFile: `${targetDir}/${convertedFileName}`
                });
                continue;
              }
            default:
              conflicts.push({
                unit: { kind: unit.kind, id: unit.id },
                issue: `Unknown conflict strategy: ${strategy}`,
                sourceFile: unit.file,
                targetFile: `${targetDir}/${convertedFileName}`
              });
              continue;
          }
        }
        await mkdir(dirname(targetFile), { recursive: true });
        try {
          await copyFile(sourceFile, targetFile);
          copiedFiles.push({
            source: sourceFile,
            destination: targetFile,
            unit: { kind: unit.kind, id: unit.id }
          });
          console.info(`\u2713 Copied ${unit.kind} "${unit.id}": ${unit.file} \u2192 ${convertedFileName}`);
        } catch (copyError) {
          conflicts.push({
            unit: { kind: unit.kind, id: unit.id },
            issue: `Failed to copy file: ${copyError instanceof Error ? copyError.message : String(copyError)}`,
            sourceFile: unit.file,
            targetFile: `${targetDir}/${convertedFileName}`
          });
        }
      }
      try {
        const targetTsconfig = resolve$2(targetPath, "tsconfig.json");
        if (!existsSync(targetTsconfig)) {
          const templateTsconfig = resolve$2(templateDir, "tsconfig.json");
          if (existsSync(templateTsconfig)) {
            await copyFile(templateTsconfig, targetTsconfig);
            copiedFiles.push({
              source: templateTsconfig,
              destination: targetTsconfig,
              unit: { kind: "other", id: "tsconfig.json" }
            });
            console.info("\u2713 Copied tsconfig.json from template to target");
          } else {
            const minimalTsconfig = {
              compilerOptions: {
                target: "ES2020",
                module: "NodeNext",
                moduleResolution: "NodeNext",
                strict: false,
                esModuleInterop: true,
                skipLibCheck: true,
                resolveJsonModule: true,
                outDir: "dist"
              },
              include: ["**/*.ts", "**/*.tsx", "**/*.mts", "**/*.cts"],
              exclude: ["node_modules", "dist", "build", ".next", ".output", ".turbo"]
            };
            await writeFile(targetTsconfig, JSON.stringify(minimalTsconfig, null, 2), "utf-8");
            copiedFiles.push({
              source: "[generated tsconfig.json]",
              destination: targetTsconfig,
              unit: { kind: "other", id: "tsconfig.json" }
            });
            console.info("\u2713 Generated minimal tsconfig.json in target");
          }
        }
      } catch (e2) {
        conflicts.push({
          unit: { kind: "other", id: "tsconfig.json" },
          issue: `Failed to ensure tsconfig.json: ${e2 instanceof Error ? e2.message : String(e2)}`,
          sourceFile: "tsconfig.json",
          targetFile: "tsconfig.json"
        });
      }
      try {
        const targetMastraIndex = resolve$2(targetPath, "src/mastra/index.ts");
        if (!existsSync(targetMastraIndex)) {
          const templateMastraIndex = resolve$2(templateDir, "src/mastra/index.ts");
          if (existsSync(templateMastraIndex)) {
            if (!existsSync(dirname(targetMastraIndex))) {
              await mkdir(dirname(targetMastraIndex), { recursive: true });
            }
            await copyFile(templateMastraIndex, targetMastraIndex);
            copiedFiles.push({
              source: templateMastraIndex,
              destination: targetMastraIndex,
              unit: { kind: "other", id: "mastra-index" }
            });
            console.info("\u2713 Copied Mastra index file from template");
          }
        }
      } catch (e2) {
        conflicts.push({
          unit: { kind: "other", id: "mastra-index" },
          issue: `Failed to ensure Mastra index file: ${e2 instanceof Error ? e2.message : String(e2)}`,
          sourceFile: "src/mastra/index.ts",
          targetFile: "src/mastra/index.ts"
        });
      }
      try {
        const targetGitignore = resolve$2(targetPath, ".gitignore");
        const templateGitignore = resolve$2(templateDir, ".gitignore");
        const targetExists = existsSync(targetGitignore);
        const templateExists = existsSync(templateGitignore);
        if (templateExists) {
          if (!targetExists) {
            await copyFile(templateGitignore, targetGitignore);
            copiedFiles.push({
              source: templateGitignore,
              destination: targetGitignore,
              unit: { kind: "other", id: "gitignore" }
            });
            console.info("\u2713 Copied .gitignore from template to target");
          } else {
            const targetContent = await readFile(targetGitignore, "utf-8");
            const templateContent = await readFile(templateGitignore, "utf-8");
            const mergedContent = mergeGitignoreFiles(targetContent, templateContent, slug);
            if (mergedContent !== targetContent) {
              const addedLines = mergedContent.split("\n").length - targetContent.split("\n").length;
              await writeFile(targetGitignore, mergedContent, "utf-8");
              copiedFiles.push({
                source: templateGitignore,
                destination: targetGitignore,
                unit: { kind: "other", id: "gitignore-merge" }
              });
              console.info(`\u2713 Merged template .gitignore entries into existing .gitignore (${addedLines} new entries)`);
            } else {
              console.info("\u2139 No new .gitignore entries to add from template");
            }
          }
        }
      } catch (e2) {
        conflicts.push({
          unit: { kind: "other", id: "gitignore" },
          issue: `Failed to handle .gitignore file: ${e2 instanceof Error ? e2.message : String(e2)}`,
          sourceFile: ".gitignore",
          targetFile: ".gitignore"
        });
      }
      try {
        const { variables } = inputData;
        if (variables && Object.keys(variables).length > 0) {
          const targetEnv = resolve$2(targetPath, ".env");
          const targetExists = existsSync(targetEnv);
          if (!targetExists) {
            const envContent = [
              `# Environment variables for ${slug}`,
              ...Object.entries(variables).map(([key, value]) => `${key}=${value}`)
            ].join("\n");
            await writeFile(targetEnv, envContent, "utf-8");
            copiedFiles.push({
              source: "[template variables]",
              destination: targetEnv,
              unit: { kind: "other", id: "env" }
            });
            console.info(`\u2713 Created .env file with ${Object.keys(variables).length} template variables`);
          } else {
            const targetContent = await readFile(targetEnv, "utf-8");
            const mergedContent = mergeEnvFiles(targetContent, variables, slug);
            if (mergedContent !== targetContent) {
              const addedLines = mergedContent.split("\n").length - targetContent.split("\n").length;
              await writeFile(targetEnv, mergedContent, "utf-8");
              copiedFiles.push({
                source: "[template variables]",
                destination: targetEnv,
                unit: { kind: "other", id: "env-merge" }
              });
              console.info(`\u2713 Merged new environment variables into existing .env file (${addedLines} new entries)`);
            } else {
              console.info("\u2139 No new environment variables to add (all already exist in .env)");
            }
          }
        }
      } catch (e2) {
        conflicts.push({
          unit: { kind: "other", id: "env" },
          issue: `Failed to handle .env file: ${e2 instanceof Error ? e2.message : String(e2)}`,
          sourceFile: ".env",
          targetFile: ".env"
        });
      }
      if (copiedFiles.length > 0) {
        try {
          const fileList = copiedFiles.map((f) => f.destination);
          await gitAddAndCommit(
            targetPath,
            `feat(template): copy ${copiedFiles.length} files from ${slug}@${commitSha.substring(0, 7)}`,
            fileList,
            { skipIfNoStaged: true }
          );
          console.info(`\u2713 Committed ${copiedFiles.length} copied files`);
        } catch (commitError) {
          console.warn("Failed to commit copied files:", commitError);
        }
      }
      const message = `Programmatic file copy completed. Copied ${copiedFiles.length} files, ${conflicts.length} conflicts detected.`;
      console.info(message);
      return {
        success: true,
        copiedFiles,
        conflicts,
        message
      };
    } catch (error) {
      console.error("Programmatic file copy failed:", error);
      return {
        success: false,
        copiedFiles: [],
        conflicts: [],
        message: `Programmatic file copy failed: ${error instanceof Error ? error.message : String(error)}`,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var intelligentMergeStep = createStep({
  id: "intelligent-merge",
  description: "Use AgentBuilder to intelligently merge template files",
  inputSchema: IntelligentMergeInputSchema,
  outputSchema: IntelligentMergeResultSchema,
  execute: async ({ inputData, requestContext }) => {
    console.info("Intelligent merge step starting...");
    const { conflicts, copiedFiles, commitSha, slug, templateDir, branchName } = inputData;
    const targetPath = resolveTargetPath(inputData, requestContext);
    try {
      const model = await resolveModel({ requestContext, projectPath: targetPath, defaultModel: openai("gpt-4.1") });
      const copyFileTool = createTool({
        id: "copy-file",
        description: "Copy a file from template to target project (use only for edge cases - most files are already copied programmatically).",
        inputSchema: z.object({
          sourcePath: z.string().describe("Path to the source file relative to template directory"),
          destinationPath: z.string().describe("Path to the destination file relative to target project")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          message: z.string(),
          errorMessage: z.string().optional()
        }),
        execute: async (input) => {
          try {
            const { sourcePath, destinationPath } = input;
            const resolvedSourcePath = resolve$2(templateDir, sourcePath);
            const resolvedDestinationPath = resolve$2(targetPath, destinationPath);
            if (existsSync(resolvedSourcePath) && !existsSync(dirname(resolvedDestinationPath))) {
              await mkdir(dirname(resolvedDestinationPath), { recursive: true });
            }
            await copyFile(resolvedSourcePath, resolvedDestinationPath);
            return {
              success: true,
              message: `Successfully copied file from ${sourcePath} to ${destinationPath}`
            };
          } catch (err) {
            return {
              success: false,
              message: `Failed to copy file: ${err instanceof Error ? err.message : String(err)}`,
              errorMessage: err instanceof Error ? err.message : String(err)
            };
          }
        }
      });
      const agentBuilder = new AgentBuilder({
        projectPath: targetPath,
        mode: "template",
        model,
        instructions: `
You are an expert at integrating Mastra template components into existing projects.

CRITICAL CONTEXT:
- Files have been programmatically copied from template to target project
- Your job is to handle integration issues, registration, and validation

FILES SUCCESSFULLY COPIED:
${JSON.stringify(copiedFiles, null, 2)}

CONFLICTS TO RESOLVE:
${JSON.stringify(conflicts, null, 2)}

CRITICAL INSTRUCTIONS:
1. **Package management**: NO need to install packages (already handled by package merge step)
2. **File copying**: Most files are already copied programmatically. Only use copyFile tool for edge cases where additional files are needed for conflict resolution

KEY RESPONSIBILITIES:
1. Resolve any conflicts from the programmatic copy step
2. Register components in existing Mastra index file (agents, workflows, networks, mcp-servers)
3. DO NOT register tools in existing Mastra index file - tools should remain standalone
4. Copy additional files ONLY if needed for conflict resolution

MASTRA INDEX FILE HANDLING (src/mastra/index.ts):
1. **Verify the file exists**
   - Call readFile
   - If it fails with ENOENT (or listDirectory shows it missing) -> copyFile the template version to src/mastra/index.ts, then confirm it now exists
   - Always verify after copying that the file exists and is accessible

2. **Edit the file**
   - Always work with the full file content
   - Generate the complete, correct source (imports, anchors, registrations, formatting)
   - Keep existing registrations intact and maintain file structure
   - Ensure proper spacing and organization of new additions

3. **Handle anchors and structure**
   - When generating new content, ensure you do not duplicate existing imports or object entries
   - If required anchors (e.g., agents: {}) are missing, add them while generating the new content
   - Add missing anchors just before the closing brace of the Mastra config
   - Do not restructure or reorder existing anchors and registrations

CRITICAL: ALWAYS use writeFile to update the mastra/index.ts file when needed to register new components.

MASTRA-SPECIFIC REGISTRATION:
- Agents: Register in existing Mastra index file
- Workflows: Register in existing Mastra index file
- Networks: Register in existing Mastra index file
- MCP servers: Register in existing Mastra index file
- Tools: Copy to ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.tool} but DO NOT register in existing Mastra index file
- If an anchor (e.g., "agents: {") is not found, avoid complex restructuring; instead, insert the missing anchor on a new line (e.g., add "agents: {" just before the closing brace of the Mastra config) and then proceed with the other registrations.

CONFLICT RESOLUTION AND FILE COPYING:
- Only copy files if needed to resolve specific conflicts
- When copying files from template:
  - Ensure you get the right file name and path
  - Verify the destination directory exists
  - Maintain the same relative path structure
  - Only copy files that are actually needed
- Preserve existing functionality when resolving conflicts
- Focus on registration and conflict resolution, validation will happen in a later step

Template information:
- Slug: ${slug}
- Commit: ${commitSha.substring(0, 7)}
- Branch: ${branchName}
`,
        tools: {
          copyFile: copyFileTool
        }
      });
      const tasks = [];
      conflicts.forEach((conflict) => {
        tasks.push({
          id: `conflict-${conflict.unit.kind}-${conflict.unit.id}`,
          content: `Resolve conflict: ${conflict.issue}`,
          status: "pending",
          priority: "high",
          notes: `Unit: ${conflict.unit.kind}:${conflict.unit.id}, Issue: ${conflict.issue}, Source: ${conflict.sourceFile}, Target: ${conflict.targetFile}`
        });
      });
      const registrableKinds = /* @__PURE__ */ new Set(["agent", "workflow", "network", "mcp-server"]);
      const registrableFiles = copiedFiles.filter((f) => registrableKinds.has(f.unit.kind));
      const targetMastraIndex = resolve$2(targetPath, "src/mastra/index.ts");
      const mastraIndexExists = existsSync(targetMastraIndex);
      console.info(`Mastra index exists: ${mastraIndexExists} at ${targetMastraIndex}`);
      console.info(
        "Registrable components:",
        registrableFiles.map((f) => `${f.unit.kind}:${f.unit.id}`)
      );
      if (registrableFiles.length > 0) {
        tasks.push({
          id: "register-components",
          content: `Register ${registrableFiles.length} components in existing Mastra index file (src/mastra/index.ts)`,
          status: "pending",
          priority: "medium",
          dependencies: conflicts.length > 0 ? conflicts.map((c) => `conflict-${c.unit.kind}-${c.unit.id}`) : void 0,
          notes: `Components to register: ${registrableFiles.map((f) => `${f.unit.kind}:${f.unit.id}`).join(", ")}`
        });
      }
      console.info(`Creating task list with ${tasks.length} tasks...`);
      await AgentBuilderDefaults.manageTaskList({ action: "create", tasks });
      await logGitState(targetPath, "before intelligent merge");
      const prompt = `
You need to work through a task list to complete the template integration.

CRITICAL INSTRUCTIONS:

**STEP 1: GET YOUR TASK LIST**
1. Use manageTaskList tool with action "list" to see all pending tasks
2. Work through tasks in dependency order (complete dependencies first)

**STEP 2: PROCESS EACH TASK SYSTEMATICALLY**
For each task:
1. Use manageTaskList to mark the current task as 'in_progress'
2. Complete the task according to its requirements
3. Use manageTaskList to mark the task as 'completed' when done
4. Continue until all tasks are completed

**TASK TYPES AND REQUIREMENTS:**

**Conflict Resolution Tasks:**
- Analyze the specific conflict and determine best resolution strategy
- For file name conflicts: merge content or rename appropriately
- For missing files: investigate and copy if needed
- For other issues: apply appropriate fixes

**Component Registration Task:**
- Update main Mastra instance file to register new components
- Only register: agents, workflows, networks, mcp-servers
- DO NOT register tools in main config
- Ensure proper import paths and naming conventions

**COMMIT STRATEGY:**
- After resolving conflicts: "feat(template): resolve conflicts for ${slug}@${commitSha.substring(0, 7)}"
- After registration: "feat(template): register components from ${slug}@${commitSha.substring(0, 7)}"

**CRITICAL NOTES:**
- Template source: ${templateDir}
- Target project: ${targetPath}
- Focus ONLY on conflict resolution and component registration
- Use executeCommand for git commits after each task
- DO NOT perform validation - that's handled by the dedicated validation step

Start by listing your tasks and work through them systematically!
`;
      const resolvedModel = await agentBuilder.getModel();
      const isSupported = isSupportedLanguageModel(resolvedModel);
      const result = isSupported ? await agentBuilder.stream(prompt) : await agentBuilder.streamLegacy(prompt);
      const actualResolutions = [];
      for await (const chunk of result.fullStream) {
        if (chunk.type === "step-finish" || chunk.type === "step-start") {
          const chunkData = "payload" in chunk ? chunk.payload : chunk;
          console.info({
            type: chunk.type,
            msgId: chunkData.messageId
          });
        } else {
          console.info(JSON.stringify(chunk, null, 2));
          if (chunk.type === "tool-result") {
            const chunkData = "payload" in chunk ? chunk.payload : chunk;
            if (chunkData.toolName === "manageTaskList") {
              try {
                const toolResult = chunkData.result;
                if (toolResult.action === "update" && toolResult.status === "completed") {
                  actualResolutions.push({
                    taskId: toolResult.taskId || "",
                    action: toolResult.action,
                    status: toolResult.status,
                    content: toolResult.content || "",
                    notes: toolResult.notes
                  });
                  console.info(`\u{1F4CB} Task completed: ${toolResult.taskId} - ${toolResult.content}`);
                }
              } catch (parseError) {
                console.warn("Failed to parse task management result:", parseError);
              }
            }
          }
        }
      }
      await logGitState(targetPath, "after intelligent merge");
      const conflictResolutions = conflicts.map((conflict) => {
        const taskId = `conflict-${conflict.unit.kind}-${conflict.unit.id}`;
        const actualResolution = actualResolutions.find((r) => r.taskId === taskId);
        if (actualResolution) {
          return {
            unit: conflict.unit,
            issue: conflict.issue,
            resolution: actualResolution.notes || actualResolution.content || `Completed: ${conflict.unit.kind} ${conflict.unit.id}`,
            actualWork: true
          };
        } else {
          return {
            unit: conflict.unit,
            issue: conflict.issue,
            resolution: `No specific resolution found for ${conflict.unit.kind} ${conflict.unit.id}`,
            actualWork: false
          };
        }
      });
      await gitAddAndCommit(targetPath, `feat(template): apply intelligent merge for ${slug}`, void 0, {
        skipIfNoStaged: true
      });
      return {
        success: true,
        applied: true,
        message: `Successfully resolved ${conflicts.length} conflicts from template ${slug}`,
        conflictsResolved: conflictResolutions
      };
    } catch (error) {
      return {
        success: false,
        applied: false,
        message: `Failed to resolve conflicts: ${error instanceof Error ? error.message : String(error)}`,
        conflictsResolved: [],
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var validationAndFixStep = createStep({
  id: "validation-and-fix",
  description: "Validate the merged template code and fix any issues using a specialized agent",
  inputSchema: ValidationFixInputSchema,
  outputSchema: ValidationFixResultSchema,
  execute: async ({ inputData, requestContext }) => {
    console.info("Validation and fix step starting...");
    const { commitSha, slug, orderedUnits, templateDir, copiedFiles, conflictsResolved, maxIterations = 5 } = inputData;
    const targetPath = resolveTargetPath(inputData, requestContext);
    const hasChanges = copiedFiles.length > 0 || conflictsResolved && conflictsResolved.length > 0;
    if (!hasChanges) {
      console.info("\u23ED\uFE0F Skipping validation - no files copied or conflicts resolved");
      return {
        success: true,
        applied: false,
        message: "No changes to validate - template already integrated or no conflicts resolved",
        validationResults: {
          valid: true,
          errorsFixed: 0,
          remainingErrors: 0
        }
      };
    }
    console.info(
      `\u{1F4CB} Changes detected: ${copiedFiles.length} files copied, ${conflictsResolved?.length || 0} conflicts resolved`
    );
    let currentIteration = 1;
    try {
      const model = await resolveModel({ requestContext, projectPath: targetPath, defaultModel: openai("gpt-4.1") });
      const allTools = await AgentBuilderDefaults.listToolsForMode(targetPath, "template");
      const validationAgent = new Agent({
        id: "code-validator-fixer",
        name: "Code Validator Fixer",
        description: "Specialized agent for validating and fixing template integration issues",
        instructions: `You are a code validation and fixing specialist. Your job is to:

1. **Run comprehensive validation** using the validateCode tool to check for:
   - TypeScript compilation errors
   - ESLint issues
   - Import/export problems
   - Missing dependencies
   - Index file structure and exports
   - Component registration correctness
   - Naming convention compliance

2. **Fix validation errors systematically**:
   - Use readFile to examine files with errors
   - Use multiEdit for simple search-replace fixes (single line changes)
   - Use replaceLines for complex multiline fixes (imports, function signatures, etc.)
   - Use listDirectory to understand project structure when fixing import paths
   - Update file contents to resolve TypeScript and linting issues

3. **Choose the right tool for the job**:
   - multiEdit: Simple replacements, single line changes, small fixes
   - replaceLines: Multiline imports, function signatures, complex code blocks
   - writeFile: ONLY for creating new files (never overwrite existing)

4. **Create missing files ONLY when necessary**:
   - Use writeFile ONLY for creating NEW files that don't exist
   - NEVER overwrite existing files - use multiEdit or replaceLines instead
   - Common cases: missing barrel files (index.ts), missing config files, missing type definitions
   - Always check with readFile first to ensure file doesn't exist

5. **Fix ALL template integration issues**:
   - Fix import path issues in copied files
   - Ensure TypeScript imports and exports are correct
   - Validate integration works properly
   - Fix files copied with new names based on unit IDs
   - Update original template imports that reference old filenames
   - Fix missing imports in index files
   - Fix incorrect file paths in imports
   - Fix type mismatches after integration
   - Fix missing exports in barrel files
   - Use the COPIED FILES mapping below to fix import paths
   - Fix any missing dependencies or module resolution issues

6. **Validate index file structure**:
   - Correct imports for all components
   - Proper anchor structure (agents: {}, etc.)
   - No duplicate registrations
   - Correct export names and paths
   - Proper formatting and organization

7. **Follow naming conventions**:
   Import paths:
   - camelCase: import { myAgent } from './myAgent'
   - snake_case: import { myAgent } from './my_agent'
   - kebab-case: import { myAgent } from './my-agent'
   - PascalCase: import { MyAgent } from './MyAgent'

   File names:
   - camelCase: weatherAgent.ts, chatAgent.ts
   - snake_case: weather_agent.ts, chat_agent.ts
   - kebab-case: weather-agent.ts, chat-agent.ts
   - PascalCase: WeatherAgent.ts, ChatAgent.ts

   Key Rule: Keep variable/export names unchanged, only adapt file names and import paths

8. **Re-validate after fixes** to ensure all issues are resolved

CRITICAL: Always validate the entire project first to get a complete picture of issues, then fix them systematically, and re-validate to confirm fixes worked.

CRITICAL TOOL SELECTION GUIDE:
- **multiEdit**: Use for simple string replacements, single-line changes
  Example: changing './oldPath' to './newPath'
  
- **replaceLines**: Use for multiline fixes, complex code structures
  Example: fixing multiline imports, function signatures, or code blocks
  Usage: replaceLines({ filePath: 'file.ts', startLine: 5, endLine: 8, newContent: 'new multiline content' })
  
- **writeFile**: ONLY for creating new files that don't exist
  Example: creating missing index.ts barrel files

CRITICAL WRITEFIL\u0415 SAFETY RULES:
- ONLY use writeFile for creating NEW files that don't exist
- ALWAYS check with readFile first to verify file doesn't exist
- NEVER use writeFile to overwrite existing files - use multiEdit or replaceLines instead
- Common valid uses: missing index.ts barrel files, missing type definitions, missing config files

CRITICAL IMPORT PATH RESOLUTION:
The following files were copied from template with new names:
${JSON.stringify(copiedFiles, null, 2)}

When fixing import errors:
1. Check if the missing module corresponds to a copied file
2. Use listDirectory to verify actual filenames in target directories
3. Update import paths to match the actual copied filenames
4. Ensure exported variable names match what's being imported

EXAMPLE: If error shows "Cannot find module './tools/download-csv-tool'" but a file was copied as "csv-fetcher-tool.ts", update the import to "./tools/csv-fetcher-tool"

${conflictsResolved ? `CONFLICTS RESOLVED BY INTELLIGENT MERGE:
${JSON.stringify(conflictsResolved, null, 2)}
` : ""}

INTEGRATED UNITS:
${JSON.stringify(orderedUnits, null, 2)}

Be thorough and methodical. Always use listDirectory to verify actual file existence before fixing imports.`,
        model,
        tools: {
          validateCode: allTools.validateCode,
          readFile: allTools.readFile,
          writeFile: allTools.writeFile,
          multiEdit: allTools.multiEdit,
          replaceLines: allTools.replaceLines,
          listDirectory: allTools.listDirectory,
          executeCommand: allTools.executeCommand
        }
      });
      console.info("Starting validation and fix agent with internal loop...");
      let validationResults = {
        valid: false,
        errorsFixed: 0,
        remainingErrors: 1,
        // Start with 1 to enter the loop
        iteration: currentIteration,
        lastValidationErrors: []
        // Store the actual error details
      };
      while (validationResults.remainingErrors > 0 && currentIteration <= maxIterations) {
        console.info(`
=== Validation Iteration ${currentIteration} ===`);
        const iterationPrompt = currentIteration === 1 ? `Please validate the template integration and fix any errors found in the project at ${targetPath}. The template "${slug}" (${commitSha.substring(0, 7)}) was just integrated and may have validation issues that need fixing.

Start by running validateCode with all validation types to get a complete picture of any issues, then systematically fix them.` : `Continue validation and fixing for the template integration at ${targetPath}. This is iteration ${currentIteration} of validation.

Previous iterations may have fixed some issues, so start by re-running validateCode to see the current state, then fix any remaining issues.`;
        const resolvedModel = await validationAgent.getModel();
        const isSupported = isSupportedLanguageModel(resolvedModel);
        const output = z.object({ success: z.boolean() });
        const result = isSupported ? await tryStreamWithJsonFallback(validationAgent, iterationPrompt, {
          structuredOutput: {
            schema: output
          }
        }) : await validationAgent.streamLegacy(iterationPrompt, {
          experimental_output: output
        });
        let iterationErrors = 0;
        let previousErrors = validationResults.remainingErrors;
        let lastValidationResult = null;
        for await (const chunk of result.fullStream) {
          if (chunk.type === "step-finish" || chunk.type === "step-start") {
            const chunkData = "payload" in chunk ? chunk.payload : chunk;
            console.info({
              type: chunk.type,
              msgId: chunkData.messageId,
              iteration: currentIteration
            });
          } else {
            console.info(JSON.stringify(chunk, null, 2));
          }
          if (chunk.type === "tool-result") {
            const chunkData = "payload" in chunk ? chunk.payload : chunk;
            if (chunkData.toolName === "validateCode") {
              const toolResult = chunkData.result;
              lastValidationResult = toolResult;
              if (toolResult?.summary) {
                iterationErrors = toolResult.summary.totalErrors || 0;
                console.info(`Iteration ${currentIteration}: Found ${iterationErrors} errors`);
              }
            }
          }
        }
        validationResults.remainingErrors = iterationErrors;
        validationResults.errorsFixed += Math.max(0, previousErrors - iterationErrors);
        validationResults.valid = iterationErrors === 0;
        validationResults.iteration = currentIteration;
        if (iterationErrors > 0 && lastValidationResult?.errors) {
          validationResults.lastValidationErrors = lastValidationResult.errors;
        }
        console.info(`Iteration ${currentIteration} complete: ${iterationErrors} errors remaining`);
        if (iterationErrors === 0) {
          console.info(`\u2705 All validation issues resolved in ${currentIteration} iterations!`);
          break;
        } else if (currentIteration >= maxIterations) {
          console.info(`\u26A0\uFE0F  Max iterations (${maxIterations}) reached. ${iterationErrors} errors still remaining.`);
          break;
        }
        currentIteration++;
      }
      try {
        await gitAddAndCommit(
          targetPath,
          `fix(template): resolve validation errors for ${slug}@${commitSha.substring(0, 7)}`,
          void 0,
          {
            skipIfNoStaged: true
          }
        );
      } catch (commitError) {
        console.warn("Failed to commit validation fixes:", commitError);
      }
      const success = validationResults.valid;
      return {
        success,
        applied: true,
        message: `Validation completed in ${currentIteration} iteration${currentIteration > 1 ? "s" : ""}. ${validationResults.valid ? "All issues resolved!" : `${validationResults.remainingErrors} issue${validationResults.remainingErrors > 1 ? "s" : ""} remaining`}`,
        validationResults: {
          valid: validationResults.valid,
          errorsFixed: validationResults.errorsFixed,
          remainingErrors: validationResults.remainingErrors,
          errors: validationResults.lastValidationErrors
        }
      };
    } catch (error) {
      console.error("Validation and fix failed:", error);
      return {
        success: false,
        applied: false,
        message: `Validation and fix failed: ${error instanceof Error ? error.message : String(error)}`,
        validationResults: {
          valid: false,
          errorsFixed: 0,
          remainingErrors: -1
        },
        error: error instanceof Error ? error.message : String(error)
      };
    } finally {
      try {
        await rm(templateDir, { recursive: true, force: true });
        console.info(`\u2713 Cleaned up template directory: ${templateDir}`);
      } catch (cleanupError) {
        console.warn("Failed to cleanup template directory:", cleanupError);
      }
    }
  }
});
var agentBuilderTemplateWorkflow = createWorkflow({
  id: "agent-builder-template",
  description: "Merges a Mastra template repository into the current project using intelligent AgentBuilder-powered merging",
  inputSchema: AgentBuilderInputSchema,
  outputSchema: ApplyResultSchema,
  steps: [
    cloneTemplateStep,
    analyzePackageStep,
    discoverUnitsStep,
    orderUnitsStep,
    packageMergeStep,
    installStep,
    programmaticFileCopyStep,
    intelligentMergeStep,
    validationAndFixStep
  ]
}).then(cloneTemplateStep).map(async ({ getStepResult }) => {
  const cloneResult = getStepResult(cloneTemplateStep);
  if (shouldAbortWorkflow(cloneResult)) {
    throw new Error(`Critical failure in clone step: ${cloneResult.error}`);
  }
  return cloneResult;
}).parallel([analyzePackageStep, discoverUnitsStep]).map(async ({ getStepResult }) => {
  const analyzeResult = getStepResult(analyzePackageStep);
  const discoverResult = getStepResult(discoverUnitsStep);
  if (shouldAbortWorkflow(analyzeResult)) {
    throw new Error(`Failure in analyze package step: ${analyzeResult.error || "Package analysis failed"}`);
  }
  if (shouldAbortWorkflow(discoverResult)) {
    throw new Error(`Failure in discover units step: ${discoverResult.error || "Unit discovery failed"}`);
  }
  return discoverResult;
}).then(orderUnitsStep).map(async ({ getStepResult, getInitData }) => {
  const cloneResult = getStepResult(cloneTemplateStep);
  const initData = getInitData();
  return {
    commitSha: cloneResult.commitSha,
    slug: cloneResult.slug,
    targetPath: initData.targetPath
  };
}).then(prepareBranchStep).map(async ({ getStepResult, getInitData }) => {
  const cloneResult = getStepResult(cloneTemplateStep);
  const packageResult = getStepResult(analyzePackageStep);
  const initData = getInitData();
  return {
    commitSha: cloneResult.commitSha,
    slug: cloneResult.slug,
    targetPath: initData.targetPath,
    packageInfo: packageResult
  };
}).then(packageMergeStep).map(async ({ getInitData }) => {
  const initData = getInitData();
  return {
    targetPath: initData.targetPath
  };
}).then(installStep).map(async ({ getStepResult, getInitData }) => {
  const cloneResult = getStepResult(cloneTemplateStep);
  const orderResult = getStepResult(orderUnitsStep);
  const installResult = getStepResult(installStep);
  const initData = getInitData();
  if (shouldAbortWorkflow(installResult)) {
    throw new Error(`Failure in install step: ${installResult.error || "Install failed"}`);
  }
  return {
    orderedUnits: orderResult.orderedUnits,
    templateDir: cloneResult.templateDir,
    commitSha: cloneResult.commitSha,
    slug: cloneResult.slug,
    targetPath: initData.targetPath,
    variables: initData.variables
  };
}).then(programmaticFileCopyStep).map(async ({ getStepResult, getInitData }) => {
  const copyResult = getStepResult(programmaticFileCopyStep);
  const cloneResult = getStepResult(cloneTemplateStep);
  const initData = getInitData();
  return {
    conflicts: copyResult.conflicts,
    copiedFiles: copyResult.copiedFiles,
    commitSha: cloneResult.commitSha,
    slug: cloneResult.slug,
    targetPath: initData.targetPath,
    templateDir: cloneResult.templateDir
  };
}).then(intelligentMergeStep).map(async ({ getStepResult, getInitData }) => {
  const cloneResult = getStepResult(cloneTemplateStep);
  const orderResult = getStepResult(orderUnitsStep);
  const copyResult = getStepResult(programmaticFileCopyStep);
  const mergeResult = getStepResult(intelligentMergeStep);
  const initData = getInitData();
  return {
    commitSha: cloneResult.commitSha,
    slug: cloneResult.slug,
    targetPath: initData.targetPath,
    templateDir: cloneResult.templateDir,
    orderedUnits: orderResult.orderedUnits,
    copiedFiles: copyResult.copiedFiles,
    conflictsResolved: mergeResult.conflictsResolved
  };
}).then(validationAndFixStep).map(async ({ getStepResult }) => {
  const cloneResult = getStepResult(cloneTemplateStep);
  const analyzeResult = getStepResult(analyzePackageStep);
  const discoverResult = getStepResult(discoverUnitsStep);
  const orderResult = getStepResult(orderUnitsStep);
  const prepareBranchResult = getStepResult(prepareBranchStep);
  const packageMergeResult = getStepResult(packageMergeStep);
  const installResult = getStepResult(installStep);
  const copyResult = getStepResult(programmaticFileCopyStep);
  const intelligentMergeResult = getStepResult(intelligentMergeStep);
  const validationResult = getStepResult(validationAndFixStep);
  const branchName = prepareBranchResult.branchName;
  const allErrors = [
    cloneResult.error,
    analyzeResult.error,
    discoverResult.error,
    orderResult.error,
    prepareBranchResult.error,
    packageMergeResult.error,
    installResult.error,
    copyResult.error,
    intelligentMergeResult.error,
    validationResult.error
  ].filter(Boolean);
  const overallSuccess = cloneResult.success !== false && analyzeResult.success !== false && discoverResult.success !== false && orderResult.success !== false && prepareBranchResult.success !== false && packageMergeResult.success !== false && installResult.success !== false && copyResult.success !== false && intelligentMergeResult.success !== false && validationResult.success !== false;
  const messages = [];
  if (copyResult.copiedFiles?.length > 0) {
    messages.push(`${copyResult.copiedFiles.length} files copied`);
  }
  if (copyResult.conflicts?.length > 0) {
    messages.push(`${copyResult.conflicts.length} conflicts skipped`);
  }
  if (intelligentMergeResult.conflictsResolved?.length > 0) {
    messages.push(`${intelligentMergeResult.conflictsResolved.length} conflicts resolved`);
  }
  if (validationResult.validationResults?.errorsFixed > 0) {
    messages.push(`${validationResult.validationResults.errorsFixed} validation errors fixed`);
  }
  if (validationResult.validationResults?.remainingErrors > 0) {
    messages.push(`${validationResult.validationResults.remainingErrors} validation issues remain`);
  }
  const comprehensiveMessage = messages.length > 0 ? `Template merge completed: ${messages.join(", ")}` : validationResult.message || "Template merge completed";
  return {
    success: overallSuccess,
    applied: validationResult.applied || copyResult.copiedFiles?.length > 0 || false,
    message: comprehensiveMessage,
    validationResults: validationResult.validationResults,
    error: allErrors.length > 0 ? allErrors.join("; ") : void 0,
    errors: allErrors.length > 0 ? allErrors : void 0,
    branchName,
    // Additional debugging info
    stepResults: {
      cloneSuccess: cloneResult.success,
      analyzeSuccess: analyzeResult.success,
      discoverSuccess: discoverResult.success,
      orderSuccess: orderResult.success,
      prepareBranchSuccess: prepareBranchResult.success,
      packageMergeSuccess: packageMergeResult.success,
      installSuccess: installResult.success,
      copySuccess: copyResult.success,
      mergeSuccess: intelligentMergeResult.success,
      validationSuccess: validationResult.success,
      filesCopied: copyResult.copiedFiles?.length || 0,
      conflictsSkipped: copyResult.conflicts?.length || 0,
      conflictsResolved: intelligentMergeResult.conflictsResolved?.length || 0
    }
  };
}).commit();
var determineConflictStrategy = (_unit, _targetFile) => {
  return "skip";
};
var shouldAbortWorkflow = (stepResult) => {
  return stepResult?.success === false || stepResult?.error;
};
var marker3 = "vercel.ai.error";
var symbol3 = Symbol.for(marker3);
var _a3;
var _AISDKError5 = class _AISDKError23 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name143,
    message,
    cause
  }) {
    super(message);
    this[_a3] = true;
    this.name = name143;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError23.hasMarker(error, marker3);
  }
  static hasMarker(error, marker153) {
    const markerSymbol = Symbol.for(marker153);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a3 = symbol3;
var AISDKError4 = _AISDKError5;
var name2 = "AI_APICallError";
var marker27 = `vercel.ai.error.${name2}`;
var symbol27 = Symbol.for(marker27);
var _a27;
var APICallError4 = class extends AISDKError4 {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name: name2, message, cause });
    this[_a27] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError4.hasMarker(error, marker27);
  }
};
_a27 = symbol27;
var name27 = "AI_EmptyResponseBodyError";
var marker32 = `vercel.ai.error.${name27}`;
var symbol32 = Symbol.for(marker32);
var _a32;
var EmptyResponseBodyError3 = class extends AISDKError4 {
  // used in isInstance
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name27, message });
    this[_a32] = true;
  }
  static isInstance(error) {
    return AISDKError4.hasMarker(error, marker32);
  }
};
_a32 = symbol32;
function getErrorMessage5(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name37 = "AI_InvalidArgumentError";
var marker47 = `vercel.ai.error.${name37}`;
var symbol47 = Symbol.for(marker47);
var _a47;
var InvalidArgumentError5 = class extends AISDKError4 {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name37, message, cause });
    this[_a47] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError4.hasMarker(error, marker47);
  }
};
_a47 = symbol47;
var name67 = "AI_JSONParseError";
var marker77 = `vercel.ai.error.${name67}`;
var symbol77 = Symbol.for(marker77);
var _a77;
var JSONParseError4 = class extends AISDKError4 {
  constructor({ text: text23, cause }) {
    super({
      name: name67,
      message: `JSON parsing failed: Text: ${text23}.
Error message: ${getErrorMessage5(cause)}`,
      cause
    });
    this[_a77] = true;
    this.text = text23;
  }
  static isInstance(error) {
    return AISDKError4.hasMarker(error, marker77);
  }
};
_a77 = symbol77;
var name124 = "AI_TypeValidationError";
var marker134 = `vercel.ai.error.${name124}`;
var symbol134 = Symbol.for(marker134);
var _a134;
var _TypeValidationError5 = class _TypeValidationError23 extends AISDKError4 {
  constructor({ value, cause }) {
    super({
      name: name124,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage5(cause)}`,
      cause
    });
    this[_a134] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError4.hasMarker(error, marker134);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError23.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError23({ value, cause });
  }
};
_a134 = symbol134;
var TypeValidationError4 = _TypeValidationError5;
var ParseError3 = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop3(_arg) {
}
function createParser3(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop3, onError = noop3, onRetry = noop3, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines3(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError3(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError3(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines3(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
var EventSourceParserStream3 = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser3({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};
function combineHeaders3(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
function extractResponseHeaders3(response) {
  return Object.fromEntries([...response.headers]);
}
var createIdGenerator4 = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0; i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError5({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
createIdGenerator4();
function isAbortError4(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES3 = ["fetch failed", "failed to fetch"];
function handleFetchError3({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError4(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES3.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new APICallError4({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error;
}
function getRuntimeEnvironmentUserAgent3(globalThisAny = globalThis) {
  var _a153, _b82, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a153 = globalThisAny.navigator) == null ? void 0 : _a153.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b82 = globalThisAny.process) == null ? void 0 : _b82.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function normalizeHeaders3(headers) {
  if (headers == null) {
    return {};
  }
  const normalized = {};
  if (headers instanceof Headers) {
    headers.forEach((value, key) => {
      normalized[key.toLowerCase()] = value;
    });
  } else {
    if (!Array.isArray(headers)) {
      headers = Object.entries(headers);
    }
    for (const [key, value] of headers) {
      if (value != null) {
        normalized[key.toLowerCase()] = value;
      }
    }
  }
  return normalized;
}
function withUserAgentSuffix3(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = new Headers(normalizeHeaders3(headers));
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders.entries());
}
var VERSION6 = "3.0.17";
var getOriginalFetch4 = () => globalThis.fetch;
var getFromApi3 = async ({
  url,
  headers = {},
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch4()
}) => {
  try {
    const response = await fetch2(url, {
      method: "GET",
      headers: withUserAgentSuffix3(
        headers,
        `ai-sdk/provider-utils/${VERSION6}`,
        getRuntimeEnvironmentUserAgent3()
      ),
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders3(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: {}
        });
      } catch (error) {
        if (isAbortError4(error) || APICallError4.isInstance(error)) {
          throw error;
        }
        throw new APICallError4({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: {}
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: {}
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError4(error) || APICallError4.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError4({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: {}
      });
    }
  } catch (error) {
    throw handleFetchError3({ error, url, requestBodyValues: {} });
  }
};
function loadOptionalSetting3({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return void 0;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return void 0;
  }
  return settingValue;
}
var suspectProtoRx3 = /"__proto__"\s*:/;
var suspectConstructorRx3 = /"constructor"\s*:/;
function _parse3(text23) {
  const obj = JSON.parse(text23);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx3.test(text23) === false && suspectConstructorRx3.test(text23) === false) {
    return obj;
  }
  return filter3(obj);
}
function filter3(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse3(text23) {
  const { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e2) {
    return _parse3(text23);
  }
  try {
    return _parse3(text23);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
var validatorSymbol3 = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator3(validate) {
  return { [validatorSymbol3]: true, validate };
}
function isValidator3(value) {
  return typeof value === "object" && value !== null && validatorSymbol3 in value && value[validatorSymbol3] === true && "validate" in value;
}
function lazyValidator2(createValidator) {
  let validator23;
  return () => {
    if (validator23 == null) {
      validator23 = createValidator();
    }
    return validator23;
  };
}
function asValidator3(value) {
  return isValidator3(value) ? value : typeof value === "function" ? value() : standardSchemaValidator2(value);
}
function standardSchemaValidator2(standardSchema2) {
  return validator3(async (value) => {
    const result = await standardSchema2["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError4({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes3({
  value,
  schema
}) {
  const result = await safeValidateTypes4({ value, schema });
  if (!result.success) {
    throw TypeValidationError4.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes4({
  value,
  schema
}) {
  const validator23 = asValidator3(schema);
  try {
    if (validator23.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator23.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError4.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError4.wrap({ value, cause: error }),
      rawValue: value
    };
  }
}
async function parseJSON3({
  text: text23,
  schema
}) {
  try {
    const value = secureJsonParse3(text23);
    if (schema == null) {
      return value;
    }
    return validateTypes3({ value, schema });
  } catch (error) {
    if (JSONParseError4.isInstance(error) || TypeValidationError4.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError4({ text: text23, cause: error });
  }
}
async function safeParseJSON4({
  text: text23,
  schema
}) {
  try {
    const value = secureJsonParse3(text23);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes4({ value, schema });
  } catch (error) {
    return {
      success: false,
      error: JSONParseError4.isInstance(error) ? error : new JSONParseError4({ text: text23, cause: error }),
      rawValue: void 0
    };
  }
}
function parseJsonEventStream3({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream3()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON4({ text: data, schema }));
      }
    })
  );
}
var getOriginalFetch23 = () => globalThis.fetch;
var postJsonToApi3 = async ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi3({
  url,
  headers: {
    "Content-Type": "application/json",
    ...headers
  },
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
});
var postToApi3 = async ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch23()
}) => {
  try {
    const response = await fetch2(url, {
      method: "POST",
      headers: withUserAgentSuffix3(
        headers,
        `ai-sdk/provider-utils/${VERSION6}`,
        getRuntimeEnvironmentUserAgent3()
      ),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders3(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError4(error) || APICallError4.isInstance(error)) {
          throw error;
        }
        throw new APICallError4({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError4(error) || APICallError4.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError4({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    throw handleFetchError3({ error, url, requestBodyValues: body.values });
  }
};
async function resolve4(value) {
  if (typeof value === "function") {
    value = value();
  }
  return Promise.resolve(value);
}
var createJsonErrorResponseHandler3 = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders3(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError4({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = await parseJSON3({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError4({
        message: errorToMessage(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError4({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler3 = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders3(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError3({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream3({
      stream: response.body,
      schema: chunkSchema
    })
  };
};
var createJsonResponseHandler3 = (responseSchema) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = await safeParseJSON4({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders3(response);
  if (!parsedResult.success) {
    throw new APICallError4({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
var getRelativePath4 = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i]) break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
var ignoreOverride4 = /* @__PURE__ */ Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var defaultOptions4 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions4 = (options) => typeof options === "string" ? {
  ...defaultOptions4,
  name: options
} : {
  ...defaultOptions4,
  ...options
};
function parseAnyDef4() {
  return {};
}
function parseArrayDef4(def, refs) {
  var _a153, _b82, _c;
  const res = {
    type: "array"
  };
  if (((_a153 = def.type) == null ? void 0 : _a153._def) && ((_c = (_b82 = def.type) == null ? void 0 : _b82._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef4(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef4(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef4() {
  return { type: "boolean" };
}
function parseBrandedDef4(_def, refs) {
  return parseDef4(_def.type._def, refs);
}
var parseCatchDef4 = (def, refs) => {
  return parseDef4(def.innerType._def, refs);
};
function parseDateDef4(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef4(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser4(def);
  }
}
var integerDateParser4 = (def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        res.minimum = check.value;
        break;
      case "max":
        res.maximum = check.value;
        break;
    }
  }
  return res;
};
function parseDefaultDef4(_def, refs) {
  return {
    ...parseDef4(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef4(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef4(_def.schema._def, refs) : parseAnyDef4();
}
function parseEnumDef4(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType4 = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef4(def, refs) {
  const allOf = [
    parseDef4(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef4(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType4(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef4(def) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex4 = void 0;
var zodPatterns4 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex4 === void 0) {
      emojiRegex4 = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u"
      );
    }
    return emojiRegex4;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef4(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat4(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat4(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern4(res, zodPatterns4.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat4(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat4(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern4(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern4(res, zodPatterns4.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern4(res, zodPatterns4.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern4(
            res,
            RegExp(`^${escapeLiteralCheckValue4(check.value, refs)}`),
            check.message,
            refs
          );
          break;
        case "endsWith":
          addPattern4(
            res,
            RegExp(`${escapeLiteralCheckValue4(check.value, refs)}$`),
            check.message,
            refs
          );
          break;
        case "datetime":
          addFormat4(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat4(res, "date", check.message, refs);
          break;
        case "time":
          addFormat4(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat4(res, "duration", check.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "includes": {
          addPattern4(
            res,
            RegExp(escapeLiteralCheckValue4(check.value, refs)),
            check.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat4(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat4(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern4(res, zodPatterns4.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern4(res, zodPatterns4.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern4(res, zodPatterns4.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern4(res, zodPatterns4.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern4(res, zodPatterns4.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern4(res, zodPatterns4.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat4(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern4(res, zodPatterns4.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern4(res, zodPatterns4.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue4(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric4(literal) : literal;
}
var ALPHA_NUMERIC4 = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function escapeNonAlphaNumeric4(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC4.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat4(schema, value, message, refs) {
  var _a153;
  if (schema.format || ((_a153 = schema.anyOf) == null ? void 0 : _a153.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value;
  }
}
function addPattern4(schema, regex, message, refs) {
  var _a153;
  if (schema.pattern || ((_a153 = schema.allOf) == null ? void 0 : _a153.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags4(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags4(regex, refs);
  }
}
function stringifyRegExpWithFlags4(regex, refs) {
  var _a153;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a153 = source[i + 2]) == null ? void 0 : _a153.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  return pattern;
}
function parseRecordDef4(def, refs) {
  var _a153, _b82, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a153 = parseDef4(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a153 : refs.allowedAdditionalProperties
  };
  if (((_b82 = def.keyType) == null ? void 0 : _b82._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef4(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef4(
      def.keyType._def,
      refs
    );
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef4(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef4(def, refs);
  }
  const keys = parseDef4(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef4();
  const values = parseDef4(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef4();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef4(def) {
  const object23 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object23[object23[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object23[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef4() {
  return { not: parseAnyDef4() };
}
function parseNullDef4() {
  return {
    type: "null"
  };
}
var primitiveMappings4 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef4(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings4 && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings4[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf4(def, refs);
}
var asAnyOf4 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef4(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i}`]
    })
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef4(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings4[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef4(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef4(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseObjectDef4(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional4(propDef);
    const parsedDef = parseDef4(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties4(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties4(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef4(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional4(schema) {
  try {
    return schema.isOptional();
  } catch (e2) {
    return true;
  }
}
var parseOptionalDef4 = (def, refs) => {
  var _a153;
  if (refs.currentPath.toString() === ((_a153 = refs.propertyPath) == null ? void 0 : _a153.toString())) {
    return parseDef4(def.innerType._def, refs);
  }
  const innerSchema = parseDef4(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef4() }, innerSchema] } : parseAnyDef4();
};
var parsePipelineDef4 = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef4(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef4(def.out._def, refs);
  }
  const a = parseDef4(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef4(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef4(def, refs) {
  return parseDef4(def.type._def, refs);
}
function parseSetDef4(def, refs) {
  const items = parseDef4(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef4(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef4(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef4(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef4(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
function parseUndefinedDef4() {
  return {
    not: parseAnyDef4()
  };
}
function parseUnknownDef4() {
  return parseAnyDef4();
}
var parseReadonlyDef4 = (def, refs) => {
  return parseDef4(def.innerType._def, refs);
};
var selectParser4 = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef4(def);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef4(def);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef4();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef4();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef4();
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef4(def);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef4(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef4(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef4();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef4();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef4();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef4(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
function parseDef4(def, refs, forceResolution = false) {
  var _a153;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a153 = refs.override) == null ? void 0 : _a153.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride4) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref4(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser4(def, def.typeName, refs);
  const jsonSchema23 = typeof jsonSchemaOrGetter === "function" ? parseDef4(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema23) {
    addMeta4(def, refs, jsonSchema23);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema23, def, refs);
    newItem.jsonSchema = jsonSchema23;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema23;
  return jsonSchema23;
}
var get$ref4 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath4(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
        );
        return parseAnyDef4();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef4() : void 0;
    }
  }
};
var addMeta4 = (def, refs, jsonSchema23) => {
  if (def.description) {
    jsonSchema23.description = def.description;
  }
  return jsonSchema23;
};
var getRefs4 = (options) => {
  const _options = getDefaultOptions4(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name143, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name143],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
};
var zodToJsonSchema4 = (schema, options) => {
  var _a153;
  const refs = getRefs4(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name2232, schema2]) => {
      var _a2232;
      return {
        ...acc,
        [name2232]: (_a2232 = parseDef4(
          schema2._def,
          {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name2232]
          },
          true
        )) != null ? _a2232 : parseAnyDef4()
      };
    },
    {}
  ) : void 0;
  const name143 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a153 = parseDef4(
    schema._def,
    name143 === void 0 ? refs : {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name143]
    },
    false
  )) != null ? _a153 : parseAnyDef4();
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined = name143 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name143
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name143]: main
    }
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
};
var zod_to_json_schema_default2 = zodToJsonSchema4;
function zod3Schema3(zodSchema23, options) {
  var _a153;
  const useReferences = (_a153 = void 0) != null ? _a153 : false;
  return jsonSchema4(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod_to_json_schema_default2(zodSchema23, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: async (value) => {
        const result = await zodSchema23.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function zod4Schema3(zodSchema23, options) {
  var _a153;
  const useReferences = (_a153 = void 0) != null ? _a153 : false;
  return jsonSchema4(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => z42.toJSONSchema(zodSchema23, {
      target: "draft-7",
      io: "output",
      reused: useReferences ? "ref" : "inline"
    }),
    {
      validate: async (value) => {
        const result = await z42.safeParseAsync(zodSchema23, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function isZod4Schema3(zodSchema23) {
  return "_zod" in zodSchema23;
}
function zodSchema4(zodSchema23, options) {
  if (isZod4Schema3(zodSchema23)) {
    return zod4Schema3(zodSchema23);
  } else {
    return zod3Schema3(zodSchema23);
  }
}
var schemaSymbol4 = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function jsonSchema4(jsonSchema23, {
  validate
} = {}) {
  return {
    [schemaSymbol4]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol3]: true,
    get jsonSchema() {
      if (typeof jsonSchema23 === "function") {
        jsonSchema23 = jsonSchema23();
      }
      return jsonSchema23;
    },
    validate
  };
}
function isSchema4(value) {
  return typeof value === "object" && value !== null && schemaSymbol4 in value && value[schemaSymbol4] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema4(schema) {
  return schema == null ? jsonSchema4({
    properties: {},
    additionalProperties: false
  }) : isSchema4(schema) ? schema : typeof schema === "function" ? schema() : zodSchema4(schema);
}
function withoutTrailingSlash3(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}
var require_get_context3 = __commonJS$2({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-context.js"(exports$1, module) {
    var __defProp24 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export23 = (target, all) => {
      for (var name16 in all)
        __defProp24(target, name16, { get: all[name16], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp24(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps4(__defProp24({}, "__esModule", { value: true }), mod);
    var get_context_exports = {};
    __export23(get_context_exports, {
      SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,
      getContext: () => getContext3
    });
    module.exports = __toCommonJS(get_context_exports);
    var SYMBOL_FOR_REQ_CONTEXT = /* @__PURE__ */ Symbol.for("@vercel/request-context");
    function getContext3() {
      const fromSymbol = globalThis;
      return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
    }
  }
});
var require_get_vercel_oidc_token3 = __commonJS$2({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js"(exports$1, module) {
    var __defProp24 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export23 = (target, all) => {
      for (var name16 in all)
        __defProp24(target, name16, { get: all[name16], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp24(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps4(__defProp24({}, "__esModule", { value: true }), mod);
    var get_vercel_oidc_token_exports = {};
    __export23(get_vercel_oidc_token_exports, {
      getVercelOidcToken: () => getVercelOidcToken3,
      getVercelOidcTokenSync: () => getVercelOidcTokenSync2
    });
    module.exports = __toCommonJS(get_vercel_oidc_token_exports);
    var import_get_context = require_get_context3();
    var import_token_error = require_token_error$2();
    async function getVercelOidcToken3() {
      let token = "";
      let err;
      try {
        token = getVercelOidcTokenSync2();
      } catch (error) {
        err = error;
      }
      try {
        const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
          await import('./token-util-NEHG7TUY-4YJ4EPCL-MBTAVIJ3.mjs'),
          await import('./token-6GSAFR2W-F2L44NEJ-GFZ37A2V.mjs')
        ]);
        if (!token || isExpired(getTokenPayload(token))) {
          await refreshToken();
          token = getVercelOidcTokenSync2();
        }
      } catch (error) {
        if (err?.message && error instanceof Error) {
          error.message = `${err.message}
${error.message}`;
        }
        throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, error);
      }
      return token;
    }
    function getVercelOidcTokenSync2() {
      const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
      if (!token) {
        throw new Error(
          `The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`
        );
      }
      return token;
    }
  }
});
var require_dist3 = __commonJS$2({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/index.js"(exports$1, module) {
    var __defProp24 = Object.defineProperty;
    var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames4 = Object.getOwnPropertyNames;
    var __hasOwnProp4 = Object.prototype.hasOwnProperty;
    var __export23 = (target, all) => {
      for (var name16 in all)
        __defProp24(target, name16, { get: all[name16], enumerable: true });
    };
    var __copyProps4 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames4(from))
          if (!__hasOwnProp4.call(to, key) && key !== except)
            __defProp24(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps4(__defProp24({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export23(src_exports, {
      getContext: () => import_get_context.getContext,
      getVercelOidcToken: () => import_get_vercel_oidc_token.getVercelOidcToken,
      getVercelOidcTokenSync: () => import_get_vercel_oidc_token.getVercelOidcTokenSync
    });
    module.exports = __toCommonJS(src_exports);
    var import_get_vercel_oidc_token = require_get_vercel_oidc_token3();
    var import_get_context = require_get_context3();
  }
});
var import_oidc4 = __toESM$2(require_dist3());
var import_oidc23 = __toESM$2(require_dist3());
var marker15 = "vercel.ai.gateway.error";
var symbol15 = Symbol.for(marker15);
var _a15;
var _b9;
var GatewayError3 = class _GatewayError3 extends (_b9 = Error, _a15 = symbol15, _b9) {
  constructor({
    message,
    statusCode = 500,
    cause
  }) {
    super(message);
    this[_a15] = true;
    this.statusCode = statusCode;
    this.cause = cause;
  }
  /**
   * Checks if the given error is a Gateway Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is a Gateway Error, false otherwise.
   */
  static isInstance(error) {
    return _GatewayError3.hasMarker(error);
  }
  static hasMarker(error) {
    return typeof error === "object" && error !== null && symbol15 in error && error[symbol15] === true;
  }
};
var name14 = "GatewayAuthenticationError";
var marker223 = `vercel.ai.gateway.error.${name14}`;
var symbol223 = Symbol.for(marker223);
var _a223;
var _b24;
var GatewayAuthenticationError3 = class _GatewayAuthenticationError3 extends (_b24 = GatewayError3, _a223 = symbol223, _b24) {
  constructor({
    message = "Authentication failed",
    statusCode = 401,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a223] = true;
    this.name = name14;
    this.type = "authentication_error";
  }
  static isInstance(error) {
    return GatewayError3.hasMarker(error) && symbol223 in error;
  }
  /**
   * Creates a contextual error message when authentication fails
   */
  static createContextualError({
    apiKeyProvided,
    oidcTokenProvided,
    message = "Authentication failed",
    statusCode = 401,
    cause
  }) {
    let contextualMessage;
    if (apiKeyProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid API key.

Create a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys

Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
    } else if (oidcTokenProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.

Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.

Alternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;
    } else {
      contextualMessage = `AI Gateway authentication failed: No authentication provided.

Option 1 - API key:
Create an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys
Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

Option 2 - OIDC token:
Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;
    }
    return new _GatewayAuthenticationError3({
      message: contextualMessage,
      statusCode,
      cause
    });
  }
};
var name223 = "GatewayInvalidRequestError";
var marker322 = `vercel.ai.gateway.error.${name223}`;
var symbol322 = Symbol.for(marker322);
var _a322;
var _b34;
var GatewayInvalidRequestError3 = class extends (_b34 = GatewayError3, _a322 = symbol322, _b34) {
  constructor({
    message = "Invalid request",
    statusCode = 400,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a322] = true;
    this.name = name223;
    this.type = "invalid_request_error";
  }
  static isInstance(error) {
    return GatewayError3.hasMarker(error) && symbol322 in error;
  }
};
var name322 = "GatewayRateLimitError";
var marker423 = `vercel.ai.gateway.error.${name322}`;
var symbol423 = Symbol.for(marker423);
var _a423;
var _b44;
var GatewayRateLimitError3 = class extends (_b44 = GatewayError3, _a423 = symbol423, _b44) {
  constructor({
    message = "Rate limit exceeded",
    statusCode = 429,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a423] = true;
    this.name = name322;
    this.type = "rate_limit_exceeded";
  }
  static isInstance(error) {
    return GatewayError3.hasMarker(error) && symbol423 in error;
  }
};
var name423 = "GatewayModelNotFoundError";
var marker52 = `vercel.ai.gateway.error.${name423}`;
var symbol52 = Symbol.for(marker52);
var modelNotFoundParamSchema3 = lazyValidator2(
  () => zodSchema4(
    z$2.object({
      modelId: z$2.string()
    })
  )
);
var _a52;
var _b52;
var GatewayModelNotFoundError3 = class extends (_b52 = GatewayError3, _a52 = symbol52, _b52) {
  constructor({
    message = "Model not found",
    statusCode = 404,
    modelId,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a52] = true;
    this.name = name423;
    this.type = "model_not_found";
    this.modelId = modelId;
  }
  static isInstance(error) {
    return GatewayError3.hasMarker(error) && symbol52 in error;
  }
};
var name52 = "GatewayInternalServerError";
var marker62 = `vercel.ai.gateway.error.${name52}`;
var symbol62 = Symbol.for(marker62);
var _a62;
var _b62;
var GatewayInternalServerError3 = class extends (_b62 = GatewayError3, _a62 = symbol62, _b62) {
  constructor({
    message = "Internal server error",
    statusCode = 500,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a62] = true;
    this.name = name52;
    this.type = "internal_server_error";
  }
  static isInstance(error) {
    return GatewayError3.hasMarker(error) && symbol62 in error;
  }
};
var name623 = "GatewayResponseError";
var marker722 = `vercel.ai.gateway.error.${name623}`;
var symbol722 = Symbol.for(marker722);
var _a722;
var _b74;
var GatewayResponseError3 = class extends (_b74 = GatewayError3, _a722 = symbol722, _b74) {
  constructor({
    message = "Invalid response from Gateway",
    statusCode = 502,
    response,
    validationError,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a722] = true;
    this.name = name623;
    this.type = "response_error";
    this.response = response;
    this.validationError = validationError;
  }
  static isInstance(error) {
    return GatewayError3.hasMarker(error) && symbol722 in error;
  }
};
async function createGatewayErrorFromResponse3({
  response,
  statusCode,
  defaultMessage = "Gateway request failed",
  cause,
  authMethod
}) {
  const parseResult = await safeValidateTypes4({
    value: response,
    schema: gatewayErrorResponseSchema3
  });
  if (!parseResult.success) {
    return new GatewayResponseError3({
      message: `Invalid error response format: ${defaultMessage}`,
      statusCode,
      response,
      validationError: parseResult.error,
      cause
    });
  }
  const validatedResponse = parseResult.value;
  const errorType = validatedResponse.error.type;
  const message = validatedResponse.error.message;
  switch (errorType) {
    case "authentication_error":
      return GatewayAuthenticationError3.createContextualError({
        apiKeyProvided: authMethod === "api-key",
        oidcTokenProvided: authMethod === "oidc",
        statusCode,
        cause
      });
    case "invalid_request_error":
      return new GatewayInvalidRequestError3({ message, statusCode, cause });
    case "rate_limit_exceeded":
      return new GatewayRateLimitError3({ message, statusCode, cause });
    case "model_not_found": {
      const modelResult = await safeValidateTypes4({
        value: validatedResponse.error.param,
        schema: modelNotFoundParamSchema3
      });
      return new GatewayModelNotFoundError3({
        message,
        statusCode,
        modelId: modelResult.success ? modelResult.value.modelId : void 0,
        cause
      });
    }
    case "internal_server_error":
      return new GatewayInternalServerError3({ message, statusCode, cause });
    default:
      return new GatewayInternalServerError3({ message, statusCode, cause });
  }
}
var gatewayErrorResponseSchema3 = lazyValidator2(
  () => zodSchema4(
    z$2.object({
      error: z$2.object({
        message: z$2.string(),
        type: z$2.string().nullish(),
        param: z$2.unknown().nullish(),
        code: z$2.union([z$2.string(), z$2.number()]).nullish()
      })
    })
  )
);
function asGatewayError3(error, authMethod) {
  var _a83;
  if (GatewayError3.isInstance(error)) {
    return error;
  }
  if (APICallError4.isInstance(error)) {
    return createGatewayErrorFromResponse3({
      response: extractApiCallResponse3(error),
      statusCode: (_a83 = error.statusCode) != null ? _a83 : 500,
      defaultMessage: "Gateway request failed",
      cause: error,
      authMethod
    });
  }
  return createGatewayErrorFromResponse3({
    response: {},
    statusCode: 500,
    defaultMessage: error instanceof Error ? `Gateway request failed: ${error.message}` : "Unknown Gateway error",
    cause: error,
    authMethod
  });
}
function extractApiCallResponse3(error) {
  if (error.data !== void 0) {
    return error.data;
  }
  if (error.responseBody != null) {
    try {
      return JSON.parse(error.responseBody);
    } catch (e2) {
      return error.responseBody;
    }
  }
  return {};
}
var GATEWAY_AUTH_METHOD_HEADER3 = "ai-gateway-auth-method";
async function parseAuthMethod3(headers) {
  const result = await safeValidateTypes4({
    value: headers[GATEWAY_AUTH_METHOD_HEADER3],
    schema: gatewayAuthMethodSchema3
  });
  return result.success ? result.value : void 0;
}
var gatewayAuthMethodSchema3 = lazyValidator2(
  () => zodSchema4(z$2.union([z$2.literal("api-key"), z$2.literal("oidc")]))
);
var GatewayFetchMetadata3 = class {
  constructor(config) {
    this.config = config;
  }
  async getAvailableModels() {
    try {
      const { value } = await getFromApi3({
        url: `${this.config.baseURL}/config`,
        headers: await resolve4(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler3(
          gatewayAvailableModelsResponseSchema3
        ),
        failedResponseHandler: createJsonErrorResponseHandler3({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error) {
      throw await asGatewayError3(error);
    }
  }
  async getCredits() {
    try {
      const baseUrl = new URL(this.config.baseURL);
      const { value } = await getFromApi3({
        url: `${baseUrl.origin}/v1/credits`,
        headers: await resolve4(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler3(
          gatewayCreditsResponseSchema3
        ),
        failedResponseHandler: createJsonErrorResponseHandler3({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error) {
      throw await asGatewayError3(error);
    }
  }
};
var gatewayAvailableModelsResponseSchema3 = lazyValidator2(
  () => zodSchema4(
    z$2.object({
      models: z$2.array(
        z$2.object({
          id: z$2.string(),
          name: z$2.string(),
          description: z$2.string().nullish(),
          pricing: z$2.object({
            input: z$2.string(),
            output: z$2.string(),
            input_cache_read: z$2.string().nullish(),
            input_cache_write: z$2.string().nullish()
          }).transform(
            ({ input, output, input_cache_read, input_cache_write }) => ({
              input,
              output,
              ...input_cache_read ? { cachedInputTokens: input_cache_read } : {},
              ...input_cache_write ? { cacheCreationInputTokens: input_cache_write } : {}
            })
          ).nullish(),
          specification: z$2.object({
            specificationVersion: z$2.literal("v2"),
            provider: z$2.string(),
            modelId: z$2.string()
          }),
          modelType: z$2.enum(["language", "embedding", "image"]).nullish()
        })
      )
    })
  )
);
var gatewayCreditsResponseSchema3 = lazyValidator2(
  () => zodSchema4(
    z$2.object({
      balance: z$2.string(),
      total_used: z$2.string()
    }).transform(({ balance, total_used }) => ({
      balance,
      totalUsed: total_used
    }))
  )
);
var GatewayLanguageModel3 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.supportedUrls = { "*/*": [/.*/] };
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs(options) {
    const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
    return {
      args: this.maybeEncodeFileParts(optionsWithoutSignal),
      warnings: []
    };
  }
  async doGenerate(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve4(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue: rawResponse
      } = await postJsonToApi3({
        url: this.getUrl(),
        headers: combineHeaders3(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, false),
          await resolve4(this.config.o11yHeaders)
        ),
        body: args,
        successfulResponseHandler: createJsonResponseHandler3(z$2.any()),
        failedResponseHandler: createJsonErrorResponseHandler3({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        ...responseBody,
        request: { body: args },
        response: { headers: responseHeaders, body: rawResponse },
        warnings
      };
    } catch (error) {
      throw await asGatewayError3(error, await parseAuthMethod3(resolvedHeaders));
    }
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve4(this.config.headers());
    try {
      const { value: response, responseHeaders } = await postJsonToApi3({
        url: this.getUrl(),
        headers: combineHeaders3(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, true),
          await resolve4(this.config.o11yHeaders)
        ),
        body: args,
        successfulResponseHandler: createEventSourceResponseHandler3(z$2.any()),
        failedResponseHandler: createJsonErrorResponseHandler3({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              if (warnings.length > 0) {
                controller.enqueue({ type: "stream-start", warnings });
              }
            },
            transform(chunk, controller) {
              if (chunk.success) {
                const streamPart = chunk.value;
                if (streamPart.type === "raw" && !options.includeRawChunks) {
                  return;
                }
                if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                  streamPart.timestamp = new Date(streamPart.timestamp);
                }
                controller.enqueue(streamPart);
              } else {
                controller.error(
                  chunk.error
                );
              }
            }
          })
        ),
        request: { body: args },
        response: { headers: responseHeaders }
      };
    } catch (error) {
      throw await asGatewayError3(error, await parseAuthMethod3(resolvedHeaders));
    }
  }
  isFilePart(part) {
    return part && typeof part === "object" && "type" in part && part.type === "file";
  }
  /**
   * Encodes file parts in the prompt to base64. Mutates the passed options
   * instance directly to avoid copying the file data.
   * @param options - The options to encode.
   * @returns The options with the file parts encoded.
   */
  maybeEncodeFileParts(options) {
    for (const message of options.prompt) {
      for (const part of message.content) {
        if (this.isFilePart(part)) {
          const filePart = part;
          if (filePart.data instanceof Uint8Array) {
            const buffer = Uint8Array.from(filePart.data);
            const base64Data = Buffer.from(buffer).toString("base64");
            filePart.data = new URL(
              `data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`
            );
          }
        }
      }
    }
    return options;
  }
  getUrl() {
    return `${this.config.baseURL}/language-model`;
  }
  getModelConfigHeaders(modelId, streaming) {
    return {
      "ai-language-model-specification-version": "2",
      "ai-language-model-id": modelId,
      "ai-language-model-streaming": String(streaming)
    };
  }
};
var GatewayEmbeddingModel3 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a83;
    const resolvedHeaders = await resolve4(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue
      } = await postJsonToApi3({
        url: this.getUrl(),
        headers: combineHeaders3(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve4(this.config.o11yHeaders)
        ),
        body: {
          input: values.length === 1 ? values[0] : values,
          ...providerOptions ? { providerOptions } : {}
        },
        successfulResponseHandler: createJsonResponseHandler3(
          gatewayEmbeddingResponseSchema3
        ),
        failedResponseHandler: createJsonErrorResponseHandler3({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        embeddings: responseBody.embeddings,
        usage: (_a83 = responseBody.usage) != null ? _a83 : void 0,
        providerMetadata: responseBody.providerMetadata,
        response: { headers: responseHeaders, body: rawValue }
      };
    } catch (error) {
      throw await asGatewayError3(error, await parseAuthMethod3(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/embedding-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-embedding-model-specification-version": "2",
      "ai-model-id": this.modelId
    };
  }
};
var gatewayEmbeddingResponseSchema3 = lazyValidator2(
  () => zodSchema4(
    z$2.object({
      embeddings: z$2.array(z$2.array(z$2.number())),
      usage: z$2.object({ tokens: z$2.number() }).nullish(),
      providerMetadata: z$2.record(z$2.string(), z$2.record(z$2.string(), z$2.unknown())).optional()
    })
  )
);
var GatewayImageModel3 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxImagesPerCall = Number.MAX_SAFE_INTEGER;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a83;
    const resolvedHeaders = await resolve4(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody
      } = await postJsonToApi3({
        url: this.getUrl(),
        headers: combineHeaders3(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve4(this.config.o11yHeaders)
        ),
        body: {
          prompt,
          n,
          ...size && { size },
          ...aspectRatio && { aspectRatio },
          ...seed && { seed },
          ...providerOptions && { providerOptions }
        },
        successfulResponseHandler: createJsonResponseHandler3(
          gatewayImageResponseSchema3
        ),
        failedResponseHandler: createJsonErrorResponseHandler3({
          errorSchema: z$2.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        images: responseBody.images,
        // Always base64 strings from server
        warnings: (_a83 = responseBody.warnings) != null ? _a83 : [],
        providerMetadata: responseBody.providerMetadata,
        response: {
          timestamp: /* @__PURE__ */ new Date(),
          modelId: this.modelId,
          headers: responseHeaders
        }
      };
    } catch (error) {
      throw asGatewayError3(error, await parseAuthMethod3(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/image-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-image-model-specification-version": "2",
      "ai-model-id": this.modelId
    };
  }
};
var providerMetadataEntrySchema3 = z$2.object({
  images: z$2.array(z$2.unknown()).optional()
}).catchall(z$2.unknown());
var gatewayImageResponseSchema3 = z$2.object({
  images: z$2.array(z$2.string()),
  // Always base64 strings over the wire
  warnings: z$2.array(
    z$2.object({
      type: z$2.literal("other"),
      message: z$2.string()
    })
  ).optional(),
  providerMetadata: z$2.record(z$2.string(), providerMetadataEntrySchema3).optional()
});
async function getVercelRequestId3() {
  var _a83;
  return (_a83 = (0, import_oidc4.getContext)().headers) == null ? void 0 : _a83["x-vercel-id"];
}
var VERSION24 = "2.0.15";
var AI_GATEWAY_PROTOCOL_VERSION3 = "0.0.1";
function createGatewayProvider3(options = {}) {
  var _a83, _b82;
  let pendingMetadata = null;
  let metadataCache = null;
  const cacheRefreshMillis = (_a83 = options.metadataCacheRefreshMillis) != null ? _a83 : 1e3 * 60 * 5;
  let lastFetchTime = 0;
  const baseURL = (_b82 = withoutTrailingSlash3(options.baseURL)) != null ? _b82 : "https://ai-gateway.vercel.sh/v1/ai";
  const getHeaders = async () => {
    const auth = await getGatewayAuthToken3(options);
    if (auth) {
      return withUserAgentSuffix3(
        {
          Authorization: `Bearer ${auth.token}`,
          "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION3,
          [GATEWAY_AUTH_METHOD_HEADER3]: auth.authMethod,
          ...options.headers
        },
        `ai-sdk/gateway/${VERSION24}`
      );
    }
    throw GatewayAuthenticationError3.createContextualError({
      apiKeyProvided: false,
      oidcTokenProvided: false,
      statusCode: 401
    });
  };
  const createO11yHeaders = () => {
    const deploymentId = loadOptionalSetting3({
      settingValue: void 0,
      environmentVariableName: "VERCEL_DEPLOYMENT_ID"
    });
    const environment = loadOptionalSetting3({
      settingValue: void 0,
      environmentVariableName: "VERCEL_ENV"
    });
    const region = loadOptionalSetting3({
      settingValue: void 0,
      environmentVariableName: "VERCEL_REGION"
    });
    return async () => {
      const requestId = await getVercelRequestId3();
      return {
        ...deploymentId && { "ai-o11y-deployment-id": deploymentId },
        ...environment && { "ai-o11y-environment": environment },
        ...region && { "ai-o11y-region": region },
        ...requestId && { "ai-o11y-request-id": requestId }
      };
    };
  };
  const createLanguageModel = (modelId) => {
    return new GatewayLanguageModel3(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  const getAvailableModels = async () => {
    var _a922, _b92, _c;
    const now2 = (_c = (_b92 = (_a922 = options._internal) == null ? void 0 : _a922.currentDate) == null ? void 0 : _b92.call(_a922).getTime()) != null ? _c : Date.now();
    if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {
      lastFetchTime = now2;
      pendingMetadata = new GatewayFetchMetadata3({
        baseURL,
        headers: getHeaders,
        fetch: options.fetch
      }).getAvailableModels().then((metadata) => {
        metadataCache = metadata;
        return metadata;
      }).catch(async (error) => {
        throw await asGatewayError3(
          error,
          await parseAuthMethod3(await getHeaders())
        );
      });
    }
    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
  };
  const getCredits = async () => {
    return new GatewayFetchMetadata3({
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    }).getCredits().catch(async (error) => {
      throw await asGatewayError3(
        error,
        await parseAuthMethod3(await getHeaders())
      );
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Gateway Provider model function cannot be called with the new keyword."
      );
    }
    return createLanguageModel(modelId);
  };
  provider.getAvailableModels = getAvailableModels;
  provider.getCredits = getCredits;
  provider.imageModel = (modelId) => {
    return new GatewayImageModel3(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  provider.languageModel = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    return new GatewayEmbeddingModel3(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  return provider;
}
createGatewayProvider3();
async function getGatewayAuthToken3(options) {
  const apiKey = loadOptionalSetting3({
    settingValue: options.apiKey,
    environmentVariableName: "AI_GATEWAY_API_KEY"
  });
  if (apiKey) {
    return {
      token: apiKey,
      authMethod: "api-key"
    };
  }
  try {
    const oidcToken = await (0, import_oidc23.getVercelOidcToken)();
    return {
      token: oidcToken,
      authMethod: "oidc"
    };
  } catch (e2) {
    return null;
  }
}
var _globalThis4 = typeof globalThis === "object" ? globalThis : global;
var VERSION223 = "1.9.0";
var re4 = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck4(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re4);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible23(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re4);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible4 = _makeCompatibilityCheck4(VERSION223);
var major4 = VERSION223.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY4 = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major4);
var _global4 = _globalThis4;
function registerGlobal4(type, instance, diag, allowOverride) {
  var _a16;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global4[GLOBAL_OPENTELEMETRY_API_KEY4] = (_a16 = _global4[GLOBAL_OPENTELEMETRY_API_KEY4]) !== null && _a16 !== void 0 ? _a16 : {
    version: VERSION223
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION223) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION223);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION223 + ".");
  return true;
}
function getGlobal4(type) {
  var _a16, _b82;
  var globalVersion = (_a16 = _global4[GLOBAL_OPENTELEMETRY_API_KEY4]) === null || _a16 === void 0 ? void 0 : _a16.version;
  if (!globalVersion || !isCompatible4(globalVersion)) {
    return;
  }
  return (_b82 = _global4[GLOBAL_OPENTELEMETRY_API_KEY4]) === null || _b82 === void 0 ? void 0 : _b82[type];
}
function unregisterGlobal4(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION223 + ".");
  var api = _global4[GLOBAL_OPENTELEMETRY_API_KEY4];
  if (api) {
    delete api[type];
  }
}
var __read7 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray7 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger4 = (
  /** @class */
  (function() {
    function DiagComponentLogger23(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger23.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy4("debug", this._namespace, args);
    };
    DiagComponentLogger23.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy4("error", this._namespace, args);
    };
    DiagComponentLogger23.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy4("info", this._namespace, args);
    };
    DiagComponentLogger23.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy4("warn", this._namespace, args);
    };
    DiagComponentLogger23.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy4("verbose", this._namespace, args);
    };
    return DiagComponentLogger23;
  })()
);
function logProxy4(funcName, namespace, args) {
  var logger = getGlobal4("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray7([], __read7(args), false));
}
var DiagLogLevel4;
(function(DiagLogLevel23) {
  DiagLogLevel23[DiagLogLevel23["NONE"] = 0] = "NONE";
  DiagLogLevel23[DiagLogLevel23["ERROR"] = 30] = "ERROR";
  DiagLogLevel23[DiagLogLevel23["WARN"] = 50] = "WARN";
  DiagLogLevel23[DiagLogLevel23["INFO"] = 60] = "INFO";
  DiagLogLevel23[DiagLogLevel23["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel23[DiagLogLevel23["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel23[DiagLogLevel23["ALL"] = 9999] = "ALL";
})(DiagLogLevel4 || (DiagLogLevel4 = {}));
function createLogLevelDiagLogger4(maxLevel, logger) {
  if (maxLevel < DiagLogLevel4.NONE) {
    maxLevel = DiagLogLevel4.NONE;
  } else if (maxLevel > DiagLogLevel4.ALL) {
    maxLevel = DiagLogLevel4.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel4.ERROR),
    warn: _filterFunc("warn", DiagLogLevel4.WARN),
    info: _filterFunc("info", DiagLogLevel4.INFO),
    debug: _filterFunc("debug", DiagLogLevel4.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel4.VERBOSE)
  };
}
var __read24 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray24 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME6 = "diag";
var DiagAPI4 = (
  /** @class */
  (function() {
    function DiagAPI23() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger = getGlobal4("diag");
          if (!logger)
            return;
          return logger[funcName].apply(logger, __spreadArray24([], __read24(args), false));
        };
      }
      var self = this;
      var setLogger = function(logger, optionsOrLogLevel) {
        var _a16, _b82, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel4.INFO };
        }
        if (logger === self) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a16 = err.stack) !== null && _a16 !== void 0 ? _a16 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal4("diag");
        var newLogger = createLogLevelDiagLogger4((_b82 = optionsOrLogLevel.logLevel) !== null && _b82 !== void 0 ? _b82 : DiagLogLevel4.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal4("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = function() {
        unregisterGlobal4(API_NAME6, self);
      };
      self.createComponentLogger = function(options) {
        return new DiagComponentLogger4(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    DiagAPI23.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI23();
      }
      return this._instance;
    };
    return DiagAPI23;
  })()
);
function createContextKey4(description) {
  return Symbol.for(description);
}
var BaseContext4 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BaseContext23(parentContext) {
      var self = this;
      self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self.getValue = function(key) {
        return self._currentContext.get(key);
      };
      self.setValue = function(key, value) {
        var context2 = new BaseContext23(self._currentContext);
        context2._currentContext.set(key, value);
        return context2;
      };
      self.deleteValue = function(key) {
        var context2 = new BaseContext23(self._currentContext);
        context2._currentContext.delete(key);
        return context2;
      };
    }
    return BaseContext23;
  })()
);
var ROOT_CONTEXT4 = new BaseContext4();
var __read34 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray34 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager4 = (
  /** @class */
  (function() {
    function NoopContextManager23() {
    }
    NoopContextManager23.prototype.active = function() {
      return ROOT_CONTEXT4;
    };
    NoopContextManager23.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray34([thisArg], __read34(args), false));
    };
    NoopContextManager23.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager23.prototype.enable = function() {
      return this;
    };
    NoopContextManager23.prototype.disable = function() {
      return this;
    };
    return NoopContextManager23;
  })()
);
var __read44 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray44 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME24 = "context";
var NOOP_CONTEXT_MANAGER4 = new NoopContextManager4();
var ContextAPI4 = (
  /** @class */
  (function() {
    function ContextAPI23() {
    }
    ContextAPI23.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI23();
      }
      return this._instance;
    };
    ContextAPI23.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal4(API_NAME24, contextManager, DiagAPI4.instance());
    };
    ContextAPI23.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI23.prototype.with = function(context2, fn, thisArg) {
      var _a16;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a16 = this._getContextManager()).with.apply(_a16, __spreadArray44([context2, fn, thisArg], __read44(args), false));
    };
    ContextAPI23.prototype.bind = function(context2, target) {
      return this._getContextManager().bind(context2, target);
    };
    ContextAPI23.prototype._getContextManager = function() {
      return getGlobal4(API_NAME24) || NOOP_CONTEXT_MANAGER4;
    };
    ContextAPI23.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal4(API_NAME24, DiagAPI4.instance());
    };
    return ContextAPI23;
  })()
);
var TraceFlags4;
(function(TraceFlags23) {
  TraceFlags23[TraceFlags23["NONE"] = 0] = "NONE";
  TraceFlags23[TraceFlags23["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags4 || (TraceFlags4 = {}));
var INVALID_SPANID4 = "0000000000000000";
var INVALID_TRACEID4 = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT4 = {
  traceId: INVALID_TRACEID4,
  spanId: INVALID_SPANID4,
  traceFlags: TraceFlags4.NONE
};
var NonRecordingSpan4 = (
  /** @class */
  (function() {
    function NonRecordingSpan23(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT4;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan23.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan23.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan23.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan23.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan23.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan23.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan23.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan23.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan23.prototype.end = function(_endTime) {
    };
    NonRecordingSpan23.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan23.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan23;
  })()
);
var SPAN_KEY4 = createContextKey4("OpenTelemetry Context Key SPAN");
function getSpan4(context2) {
  return context2.getValue(SPAN_KEY4) || void 0;
}
function getActiveSpan4() {
  return getSpan4(ContextAPI4.getInstance().active());
}
function setSpan4(context2, span) {
  return context2.setValue(SPAN_KEY4, span);
}
function deleteSpan4(context2) {
  return context2.deleteValue(SPAN_KEY4);
}
function setSpanContext4(context2, spanContext) {
  return setSpan4(context2, new NonRecordingSpan4(spanContext));
}
function getSpanContext4(context2) {
  var _a16;
  return (_a16 = getSpan4(context2)) === null || _a16 === void 0 ? void 0 : _a16.spanContext();
}
var VALID_TRACEID_REGEX4 = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX4 = /^[0-9a-f]{16}$/i;
function isValidTraceId4(traceId) {
  return VALID_TRACEID_REGEX4.test(traceId) && traceId !== INVALID_TRACEID4;
}
function isValidSpanId4(spanId) {
  return VALID_SPANID_REGEX4.test(spanId) && spanId !== INVALID_SPANID4;
}
function isSpanContextValid4(spanContext) {
  return isValidTraceId4(spanContext.traceId) && isValidSpanId4(spanContext.spanId);
}
function wrapSpanContext4(spanContext) {
  return new NonRecordingSpan4(spanContext);
}
var contextApi4 = ContextAPI4.getInstance();
var NoopTracer4 = (
  /** @class */
  (function() {
    function NoopTracer23() {
    }
    NoopTracer23.prototype.startSpan = function(name16, options, context2) {
      if (context2 === void 0) {
        context2 = contextApi4.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan4();
      }
      var parentFromContext = context2 && getSpanContext4(context2);
      if (isSpanContext4(parentFromContext) && isSpanContextValid4(parentFromContext)) {
        return new NonRecordingSpan4(parentFromContext);
      } else {
        return new NonRecordingSpan4();
      }
    };
    NoopTracer23.prototype.startActiveSpan = function(name16, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi4.active();
      var span = this.startSpan(name16, opts, parentContext);
      var contextWithSpanSet = setSpan4(parentContext, span);
      return contextApi4.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer23;
  })()
);
function isSpanContext4(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER4 = new NoopTracer4();
var ProxyTracer4 = (
  /** @class */
  (function() {
    function ProxyTracer23(_provider, name16, version, options) {
      this._provider = _provider;
      this.name = name16;
      this.version = version;
      this.options = options;
    }
    ProxyTracer23.prototype.startSpan = function(name16, options, context2) {
      return this._getTracer().startSpan(name16, options, context2);
    };
    ProxyTracer23.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer23.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER4;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer23;
  })()
);
var NoopTracerProvider4 = (
  /** @class */
  (function() {
    function NoopTracerProvider23() {
    }
    NoopTracerProvider23.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer4();
    };
    return NoopTracerProvider23;
  })()
);
var NOOP_TRACER_PROVIDER4 = new NoopTracerProvider4();
var ProxyTracerProvider4 = (
  /** @class */
  (function() {
    function ProxyTracerProvider23() {
    }
    ProxyTracerProvider23.prototype.getTracer = function(name16, version, options) {
      var _a16;
      return (_a16 = this.getDelegateTracer(name16, version, options)) !== null && _a16 !== void 0 ? _a16 : new ProxyTracer4(this, name16, version, options);
    };
    ProxyTracerProvider23.prototype.getDelegate = function() {
      var _a16;
      return (_a16 = this._delegate) !== null && _a16 !== void 0 ? _a16 : NOOP_TRACER_PROVIDER4;
    };
    ProxyTracerProvider23.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider23.prototype.getDelegateTracer = function(name16, version, options) {
      var _a16;
      return (_a16 = this._delegate) === null || _a16 === void 0 ? void 0 : _a16.getTracer(name16, version, options);
    };
    return ProxyTracerProvider23;
  })()
);
var SpanStatusCode4;
(function(SpanStatusCode23) {
  SpanStatusCode23[SpanStatusCode23["UNSET"] = 0] = "UNSET";
  SpanStatusCode23[SpanStatusCode23["OK"] = 1] = "OK";
  SpanStatusCode23[SpanStatusCode23["ERROR"] = 2] = "ERROR";
})(SpanStatusCode4 || (SpanStatusCode4 = {}));
var API_NAME34 = "trace";
var TraceAPI4 = (
  /** @class */
  (function() {
    function TraceAPI23() {
      this._proxyTracerProvider = new ProxyTracerProvider4();
      this.wrapSpanContext = wrapSpanContext4;
      this.isSpanContextValid = isSpanContextValid4;
      this.deleteSpan = deleteSpan4;
      this.getSpan = getSpan4;
      this.getActiveSpan = getActiveSpan4;
      this.getSpanContext = getSpanContext4;
      this.setSpan = setSpan4;
      this.setSpanContext = setSpanContext4;
    }
    TraceAPI23.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI23();
      }
      return this._instance;
    };
    TraceAPI23.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal4(API_NAME34, this._proxyTracerProvider, DiagAPI4.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI23.prototype.getTracerProvider = function() {
      return getGlobal4(API_NAME34) || this._proxyTracerProvider;
    };
    TraceAPI23.prototype.getTracer = function(name16, version) {
      return this.getTracerProvider().getTracer(name16, version);
    };
    TraceAPI23.prototype.disable = function() {
      unregisterGlobal4(API_NAME34, DiagAPI4.instance());
      this._proxyTracerProvider = new ProxyTracerProvider4();
    };
    return TraceAPI23;
  })()
);
TraceAPI4.getInstance();
var __defProp5 = Object.defineProperty;
var __export4 = (target, all) => {
  for (var name16 in all)
    __defProp5(target, name16, { get: all[name16], enumerable: true });
};
var name6222 = "AI_NoObjectGeneratedError";
var marker6222 = `vercel.ai.error.${name6222}`;
var symbol6222 = Symbol.for(marker6222);
var _a6222;
var NoObjectGeneratedError4 = class extends AISDKError4 {
  constructor({
    message = "No object generated.",
    cause,
    text: text23,
    response,
    usage,
    finishReason
  }) {
    super({ name: name6222, message, cause });
    this[_a6222] = true;
    this.text = text23;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error) {
    return AISDKError4.hasMarker(error, marker6222);
  }
};
_a6222 = symbol6222;
var dataContentSchema4 = z$2.union([
  z$2.string(),
  z$2.instanceof(Uint8Array),
  z$2.instanceof(ArrayBuffer),
  z$2.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a16, _b82;
      return (_b82 = (_a16 = globalThis.Buffer) == null ? void 0 : _a16.isBuffer(value)) != null ? _b82 : false;
    },
    { message: "Must be a Buffer" }
  )
]);
var jsonValueSchema4 = z$2.lazy(
  () => z$2.union([
    z$2.null(),
    z$2.string(),
    z$2.number(),
    z$2.boolean(),
    z$2.record(z$2.string(), jsonValueSchema4),
    z$2.array(jsonValueSchema4)
  ])
);
var providerMetadataSchema4 = z$2.record(
  z$2.string(),
  z$2.record(z$2.string(), jsonValueSchema4)
);
var textPartSchema4 = z$2.object({
  type: z$2.literal("text"),
  text: z$2.string(),
  providerOptions: providerMetadataSchema4.optional()
});
var imagePartSchema4 = z$2.object({
  type: z$2.literal("image"),
  image: z$2.union([dataContentSchema4, z$2.instanceof(URL)]),
  mediaType: z$2.string().optional(),
  providerOptions: providerMetadataSchema4.optional()
});
var filePartSchema4 = z$2.object({
  type: z$2.literal("file"),
  data: z$2.union([dataContentSchema4, z$2.instanceof(URL)]),
  filename: z$2.string().optional(),
  mediaType: z$2.string(),
  providerOptions: providerMetadataSchema4.optional()
});
var reasoningPartSchema4 = z$2.object({
  type: z$2.literal("reasoning"),
  text: z$2.string(),
  providerOptions: providerMetadataSchema4.optional()
});
var toolCallPartSchema4 = z$2.object({
  type: z$2.literal("tool-call"),
  toolCallId: z$2.string(),
  toolName: z$2.string(),
  input: z$2.unknown(),
  providerOptions: providerMetadataSchema4.optional(),
  providerExecuted: z$2.boolean().optional()
});
var outputSchema3 = z$2.discriminatedUnion("type", [
  z$2.object({
    type: z$2.literal("text"),
    value: z$2.string()
  }),
  z$2.object({
    type: z$2.literal("json"),
    value: jsonValueSchema4
  }),
  z$2.object({
    type: z$2.literal("error-text"),
    value: z$2.string()
  }),
  z$2.object({
    type: z$2.literal("error-json"),
    value: jsonValueSchema4
  }),
  z$2.object({
    type: z$2.literal("content"),
    value: z$2.array(
      z$2.union([
        z$2.object({
          type: z$2.literal("text"),
          text: z$2.string()
        }),
        z$2.object({
          type: z$2.literal("media"),
          data: z$2.string(),
          mediaType: z$2.string()
        })
      ])
    )
  })
]);
var toolResultPartSchema4 = z$2.object({
  type: z$2.literal("tool-result"),
  toolCallId: z$2.string(),
  toolName: z$2.string(),
  output: outputSchema3,
  providerOptions: providerMetadataSchema4.optional()
});
var systemModelMessageSchema3 = z$2.object(
  {
    role: z$2.literal("system"),
    content: z$2.string(),
    providerOptions: providerMetadataSchema4.optional()
  }
);
var userModelMessageSchema3 = z$2.object({
  role: z$2.literal("user"),
  content: z$2.union([
    z$2.string(),
    z$2.array(z$2.union([textPartSchema4, imagePartSchema4, filePartSchema4]))
  ]),
  providerOptions: providerMetadataSchema4.optional()
});
var assistantModelMessageSchema3 = z$2.object({
  role: z$2.literal("assistant"),
  content: z$2.union([
    z$2.string(),
    z$2.array(
      z$2.union([
        textPartSchema4,
        filePartSchema4,
        reasoningPartSchema4,
        toolCallPartSchema4,
        toolResultPartSchema4
      ])
    )
  ]),
  providerOptions: providerMetadataSchema4.optional()
});
var toolModelMessageSchema3 = z$2.object({
  role: z$2.literal("tool"),
  content: z$2.array(toolResultPartSchema4),
  providerOptions: providerMetadataSchema4.optional()
});
z$2.union([
  systemModelMessageSchema3,
  userModelMessageSchema3,
  assistantModelMessageSchema3,
  toolModelMessageSchema3
]);
function stepCountIs(stepCount) {
  return ({ steps }) => steps.length === stepCount;
}
createIdGenerator4({
  prefix: "aitxt",
  size: 24
});
function fixJson4(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
async function parsePartialJson4(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = await safeParseJSON4({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = await safeParseJSON4({ text: fixJson4(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
createIdGenerator4({
  prefix: "aitxt",
  size: 24
});
createIdGenerator4({ prefix: "aiobj", size: 24 });
createIdGenerator4({ prefix: "aiobj", size: 24 });
var output_exports4 = {};
__export4(output_exports4, {
  object: () => object4,
  text: () => text4
});
var text4 = () => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: text23 }) {
    return { partial: text23 };
  },
  async parseOutput({ text: text23 }) {
    return text23;
  }
});
var object4 = ({
  schema: inputSchema
}) => {
  const schema = asSchema4(inputSchema);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: schema.jsonSchema
    },
    async parsePartial({ text: text23 }) {
      const result = await parsePartialJson4(text23);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    async parseOutput({ text: text23 }, context2) {
      const parseResult = await safeParseJSON4({ text: text23 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError4({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text23,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      const validationResult = await safeValidateTypes4({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError4({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text23,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      return validationResult.value;
    }
  };
};
var TaskSchema = z.array(
  z.object({
    id: z.string().describe("Unique task ID using kebab-case"),
    content: z.string().describe("Specific, actionable task description"),
    status: z.enum(["pending", "in_progress", "completed", "blocked"]).default("pending"),
    priority: z.enum(["high", "medium", "low"]).describe("Task priority"),
    dependencies: z.array(z.string()).optional().describe("IDs of tasks this depends on"),
    notes: z.string().describe("Detailed implementation notes and specifics")
  })
);
var QuestionSchema = z.array(
  z.object({
    id: z.string().describe("Unique question ID"),
    question: z.string().describe("Clear, specific question for the user"),
    type: z.enum(["choice", "text", "boolean"]).describe("Type of answer expected"),
    options: z.array(z.string()).optional().describe("Options for choice questions"),
    context: z.string().optional().describe("Additional context or explanation")
  })
);
var PlanningIterationResultSchema = z.object({
  success: z.boolean(),
  tasks: TaskSchema,
  questions: QuestionSchema,
  reasoning: z.string(),
  planComplete: z.boolean(),
  message: z.string(),
  error: z.string().optional(),
  allPreviousQuestions: z.array(z.any()).optional(),
  allPreviousAnswers: z.record(z.string()).optional()
});
var taskPlanningPrompts = {
  planningAgent: {
    instructions: (context2) => `You are a Mastra workflow planning expert. Your task is to create a detailed, executable task plan.

PLANNING RESPONSIBILITIES:
1. **Analyze Requirements**: Review the user's description and requirements thoroughly
2. **Identify Decision Points**: Find any choices that require user input (email providers, databases, APIs, etc.)
3. **Create Specific Tasks**: Generate concrete, actionable tasks with clear implementation notes
4. **Ask Clarifying Questions**: If any decisions are unclear, formulate specific questions for the user 
- do not ask about package managers
- Assume the user is going to use zod for validation
- You do not need to ask questions if you have none
- NEVER ask questions that have already been answered before
5. **Incorporate Feedback**: Use any previous answers or feedback to refine the plan

${context2.storedQAPairs.length > 0 ? `PREVIOUS QUESTION-ANSWER PAIRS (${context2.storedQAPairs.length} total):
${context2.storedQAPairs.map(
      (pair, index) => `${index + 1}. Q: ${pair.question.question}
   A: ${pair.answer || "NOT ANSWERED YET"}
   Type: ${pair.question.type}
   Asked: ${pair.askedAt}
   ${pair.answer ? `Answered: ${pair.answeredAt}` : ""}`
    ).join("\n\n")}

IMPORTANT: DO NOT ASK ANY QUESTIONS THAT HAVE ALREADY BEEN ASKED!` : ""}

Based on the context and any user answers, create or refine the task plan.`,
    refinementPrompt: (context2) => `Refine the existing task plan based on all user answers collected so far. 

ANSWERED QUESTIONS AND RESPONSES:
${context2.storedQAPairs.filter((pair) => pair.answer).map(
      (pair, index) => `${index + 1}. Q: ${pair.question.question}
   A: ${pair.answer}
   Context: ${pair.question.context || "None"}`
    ).join("\n\n")}

REQUIREMENTS:
- Action: ${context2.action}
- Workflow Name: ${context2.workflowName || "To be determined"}
- Description: ${context2.description || "Not specified"}
- Requirements: ${context2.requirements || "Not specified"}

PROJECT CONTEXT:
- Discovered Workflows: ${JSON.stringify(context2.discoveredWorkflows, null, 2)}
- Project Structure: ${JSON.stringify(context2.projectStructure, null, 2)}
- Research: ${JSON.stringify(context2.research, null, 2)}

${context2.hasTaskFeedback ? `
USER FEEDBACK ON PREVIOUS TASK LIST:
${context2.userAnswers?.taskFeedback}

PLEASE INCORPORATE THIS FEEDBACK INTO THE REFINED TASK LIST.` : ""}

Refine the task list and determine if any additional questions are needed.`,
    initialPrompt: (context2) => `Create an initial task plan for ${context2.action}ing a Mastra workflow.

REQUIREMENTS:
- Action: ${context2.action}
- Workflow Name: ${context2.workflowName || "To be determined"}
- Description: ${context2.description || "Not specified"}  
- Requirements: ${context2.requirements || "Not specified"}

PROJECT CONTEXT:
- Discovered Workflows: ${JSON.stringify(context2.discoveredWorkflows, null, 2)}
- Project Structure: ${JSON.stringify(context2.projectStructure, null, 2)}
- Research: ${JSON.stringify(context2.research, null, 2)}

Create specific tasks and identify any questions that need user clarification.`
  },
  taskApproval: {
    message: (questionsCount) => `Please answer ${questionsCount} question(s) to finalize the workflow plan:`,
    approvalMessage: (tasksCount) => `Please review and approve the ${tasksCount} task(s) for execution:`
  }
};
var WorkflowBuilderInputSchema = z.object({
  workflowName: z.string().optional().describe("Name of the workflow to create or edit"),
  action: z.enum(["create", "edit"]).describe("Action to perform: create new or edit existing workflow"),
  description: z.string().optional().describe("Description of what the workflow should do"),
  requirements: z.string().optional().describe("Detailed requirements for the workflow"),
  projectPath: z.string().optional().describe("Path to the Mastra project (defaults to current directory)")
});
var DiscoveredWorkflowSchema = z.object({
  name: z.string(),
  file: z.string(),
  description: z.string().optional(),
  inputSchema: z.any().optional(),
  outputSchema: z.any().optional(),
  steps: z.array(z.string()).optional()
});
var WorkflowDiscoveryResultSchema = z.object({
  success: z.boolean(),
  workflows: z.array(DiscoveredWorkflowSchema),
  mastraIndexExists: z.boolean(),
  message: z.string(),
  error: z.string().optional()
});
var ProjectDiscoveryResultSchema = z.object({
  success: z.boolean(),
  structure: z.object({
    hasWorkflowsDir: z.boolean(),
    hasAgentsDir: z.boolean(),
    hasToolsDir: z.boolean(),
    hasMastraIndex: z.boolean(),
    existingWorkflows: z.array(z.string()),
    existingAgents: z.array(z.string()),
    existingTools: z.array(z.string())
  }),
  dependencies: z.record(z.string()),
  message: z.string(),
  error: z.string().optional()
});
var WorkflowResearchResultSchema = z.object({
  success: z.boolean(),
  documentation: z.object({
    workflowPatterns: z.array(z.string()),
    stepExamples: z.array(z.string()),
    bestPractices: z.array(z.string())
  }),
  webResources: z.array(
    z.object({
      title: z.string(),
      url: z.string(),
      snippet: z.string(),
      relevance: z.number()
    })
  ),
  message: z.string(),
  error: z.string().optional()
});
var TaskManagementResultSchema = z.object({
  success: z.boolean(),
  tasks: TaskSchema,
  message: z.string(),
  error: z.string().optional()
});
var TaskExecutionInputSchema = z.object({
  action: z.enum(["create", "edit"]),
  workflowName: z.string().optional(),
  description: z.string().optional(),
  requirements: z.string().optional(),
  tasks: TaskSchema,
  discoveredWorkflows: z.array(z.any()),
  projectStructure: z.any(),
  research: z.any(),
  projectPath: z.string().optional()
});
var TaskExecutionSuspendSchema = z.object({
  questions: QuestionSchema,
  currentProgress: z.string(),
  completedTasks: z.array(z.string()),
  message: z.string()
});
var TaskExecutionResumeSchema = z.object({
  answers: z.array(
    z.object({
      questionId: z.string(),
      answer: z.string()
    })
  )
});
var TaskExecutionResultSchema = z.object({
  success: z.boolean(),
  filesModified: z.array(z.string()),
  validationResults: z.object({
    passed: z.boolean(),
    errors: z.array(z.string()),
    warnings: z.array(z.string())
  }),
  completedTasks: z.array(z.string()),
  message: z.string(),
  error: z.string().optional()
});
z.object({
  questions: QuestionSchema
});
z.object({
  answers: z.record(z.string()),
  hasAnswers: z.boolean()
});
var WorkflowBuilderResultSchema = z.object({
  success: z.boolean(),
  action: z.enum(["create", "edit"]),
  workflowName: z.string().optional(),
  workflowFile: z.string().optional(),
  discovery: WorkflowDiscoveryResultSchema.optional(),
  projectStructure: ProjectDiscoveryResultSchema.optional(),
  research: WorkflowResearchResultSchema.optional(),
  planning: PlanningIterationResultSchema.optional(),
  taskManagement: TaskManagementResultSchema.optional(),
  execution: TaskExecutionResultSchema.optional(),
  needsUserInput: z.boolean().optional(),
  questions: QuestionSchema.optional(),
  message: z.string(),
  nextSteps: z.array(z.string()).optional(),
  error: z.string().optional()
});
var TaskExecutionIterationInputSchema = (taskLength) => z.object({
  status: z.enum(["in_progress", "completed", "needs_clarification"]).describe('Status - only use "completed" when ALL remaining tasks are finished'),
  progress: z.string().describe("Current progress description"),
  completedTasks: z.array(z.string()).describe("List of ALL completed task IDs (including previously completed ones)"),
  totalTasksRequired: z.number().describe(`Total number of tasks that must be completed (should be ${taskLength})`),
  tasksRemaining: z.array(z.string()).describe("List of task IDs that still need to be completed"),
  filesModified: z.array(z.string()).describe("List of files that were created or modified - use these exact paths for validateCode tool"),
  questions: QuestionSchema.optional().describe("Questions for user if clarification is needed"),
  message: z.string().describe("Summary of work completed or current status"),
  error: z.string().optional().describe("Any errors encountered")
});
var PlanningIterationInputSchema = z.object({
  action: z.enum(["create", "edit"]),
  workflowName: z.string().optional(),
  description: z.string().optional(),
  requirements: z.string().optional(),
  discoveredWorkflows: z.array(DiscoveredWorkflowSchema),
  projectStructure: ProjectDiscoveryResultSchema,
  research: WorkflowResearchResultSchema,
  userAnswers: z.record(z.string()).optional()
});
var PlanningIterationSuspendSchema = z.object({
  questions: QuestionSchema,
  message: z.string(),
  currentPlan: z.object({
    tasks: TaskSchema,
    reasoning: z.string()
  })
});
var PlanningIterationResumeSchema = z.object({
  answers: z.record(z.string())
});
var PlanningAgentOutputSchema = z.object({
  tasks: TaskSchema,
  questions: QuestionSchema.optional(),
  reasoning: z.string().describe("Explanation of the plan and any questions"),
  planComplete: z.boolean().describe("Whether the plan is ready for execution (no more questions)")
});
var TaskApprovalOutputSchema = z.object({
  approved: z.boolean(),
  tasks: TaskSchema,
  message: z.string(),
  userFeedback: z.string().optional()
});
var TaskApprovalSuspendSchema = z.object({
  taskList: TaskSchema,
  summary: z.string(),
  message: z.string()
});
var TaskApprovalResumeSchema = z.object({
  approved: z.boolean(),
  modifications: z.string().optional()
});
var planningIterationStep = createStep({
  id: "planning-iteration",
  description: "Create or refine task plan with user input",
  inputSchema: PlanningIterationInputSchema,
  outputSchema: PlanningIterationResultSchema,
  suspendSchema: PlanningIterationSuspendSchema,
  resumeSchema: PlanningIterationResumeSchema,
  execute: async ({ inputData, resumeData, suspend, requestContext }) => {
    const {
      action,
      workflowName,
      description,
      requirements,
      discoveredWorkflows,
      projectStructure,
      research,
      userAnswers
    } = inputData;
    console.info("Starting planning iteration...");
    const qaKey = "workflow-builder-qa";
    let storedQAPairs = requestContext.get(qaKey) || [];
    const newAnswers = { ...userAnswers || {}, ...resumeData?.answers || {} };
    if (Object.keys(newAnswers).length > 0) {
      storedQAPairs = storedQAPairs.map((pair) => {
        if (newAnswers[pair.question.id]) {
          return {
            ...pair,
            answer: newAnswers[pair.question.id] || null,
            answeredAt: (/* @__PURE__ */ new Date()).toISOString()
          };
        }
        return pair;
      });
      requestContext.set(qaKey, storedQAPairs);
    }
    try {
      const model = await resolveModel({ requestContext });
      const planningAgent = new Agent({
        id: "workflow-planning-agent",
        model,
        instructions: taskPlanningPrompts.planningAgent.instructions({
          storedQAPairs
        }),
        name: "Workflow Planning Agent"
        // tools: filteredMcpTools,
      });
      const hasTaskFeedback = Boolean(userAnswers && userAnswers.taskFeedback);
      const planningPrompt = storedQAPairs.some((pair) => pair.answer) ? taskPlanningPrompts.planningAgent.refinementPrompt({
        action,
        workflowName,
        description,
        requirements,
        discoveredWorkflows,
        projectStructure,
        research,
        storedQAPairs,
        hasTaskFeedback,
        userAnswers
      }) : taskPlanningPrompts.planningAgent.initialPrompt({
        action,
        workflowName,
        description,
        requirements,
        discoveredWorkflows,
        projectStructure,
        research
      });
      const result = await planningAgent.generate(planningPrompt, {
        structuredOutput: {
          schema: PlanningAgentOutputSchema
        }
        // maxSteps: 15,
      });
      const planResult = await result.object;
      if (!planResult) {
        return {
          tasks: [],
          success: false,
          questions: [],
          reasoning: "Planning agent failed to generate a valid response",
          planComplete: false,
          message: "Planning failed"
        };
      }
      if (planResult.questions && planResult.questions.length > 0 && !planResult.planComplete) {
        console.info(`Planning needs user clarification: ${planResult.questions.length} questions`);
        console.info(planResult.questions);
        const newQAPairs = planResult.questions.map((question) => ({
          question,
          answer: null,
          askedAt: (/* @__PURE__ */ new Date()).toISOString(),
          answeredAt: null
        }));
        storedQAPairs = [...storedQAPairs, ...newQAPairs];
        requestContext.set(qaKey, storedQAPairs);
        console.info(
          `Updated Q&A state: ${storedQAPairs.length} total question-answer pairs, ${storedQAPairs.filter((p) => p.answer).length} answered`
        );
        return suspend({
          questions: planResult.questions,
          message: taskPlanningPrompts.taskApproval.message(planResult.questions.length),
          currentPlan: {
            tasks: planResult.tasks,
            reasoning: planResult.reasoning
          }
        });
      }
      console.info(`Planning complete with ${planResult.tasks.length} tasks`);
      requestContext.set(qaKey, storedQAPairs);
      console.info(
        `Final Q&A state: ${storedQAPairs.length} total question-answer pairs, ${storedQAPairs.filter((p) => p.answer).length} answered`
      );
      return {
        tasks: planResult.tasks,
        success: true,
        questions: [],
        reasoning: planResult.reasoning,
        planComplete: true,
        message: `Successfully created ${planResult.tasks.length} tasks`,
        allPreviousQuestions: storedQAPairs.map((pair) => pair.question),
        allPreviousAnswers: Object.fromEntries(
          storedQAPairs.filter((pair) => pair.answer).map((pair) => [pair.question.id, pair.answer])
        )
      };
    } catch (error) {
      console.error("Planning iteration failed:", error);
      return {
        tasks: [],
        success: false,
        questions: [],
        reasoning: `Planning failed: ${error instanceof Error ? error.message : String(error)}`,
        planComplete: false,
        message: "Planning iteration failed",
        error: error instanceof Error ? error.message : String(error),
        allPreviousQuestions: storedQAPairs.map((pair) => pair.question),
        allPreviousAnswers: Object.fromEntries(
          storedQAPairs.filter((pair) => pair.answer).map((pair) => [pair.question.id, pair.answer])
        )
      };
    }
  }
});
var taskApprovalStep = createStep({
  id: "task-approval",
  description: "Get user approval for the final task list",
  inputSchema: PlanningIterationResultSchema,
  outputSchema: TaskApprovalOutputSchema,
  suspendSchema: TaskApprovalSuspendSchema,
  resumeSchema: TaskApprovalResumeSchema,
  execute: async ({ inputData, resumeData, suspend }) => {
    const { tasks } = inputData;
    if (!resumeData?.approved && resumeData?.approved !== false) {
      console.info(`Requesting user approval for ${tasks.length} tasks`);
      const summary = `Task List for Approval:

${tasks.length} tasks planned:
${tasks.map((task, i) => `${i + 1}. [${task.priority.toUpperCase()}] ${task.content}${task.dependencies?.length ? ` (depends on: ${task.dependencies.join(", ")})` : ""}
   Notes: ${task.notes || "None"}`).join("\n")}`;
      return suspend({
        taskList: tasks,
        summary,
        message: taskPlanningPrompts.taskApproval.approvalMessage(tasks.length)
      });
    }
    if (resumeData.approved) {
      console.info("Task list approved by user");
      return {
        approved: true,
        tasks,
        message: "Task list approved, ready for execution"
      };
    } else {
      console.info("Task list rejected by user");
      return {
        approved: false,
        tasks,
        message: "Task list rejected",
        userFeedback: resumeData.modifications
      };
    }
  }
});
var planningAndApprovalWorkflow = createWorkflow({
  id: "planning-and-approval",
  description: "Handle iterative planning with questions and task list approval",
  inputSchema: PlanningIterationInputSchema,
  outputSchema: TaskApprovalOutputSchema,
  steps: [planningIterationStep, taskApprovalStep]
}).dountil(planningIterationStep, async ({ inputData }) => {
  console.info(`Sub-workflow planning check: planComplete=${inputData.planComplete}`);
  return inputData.planComplete === true;
}).map(async ({ inputData }) => {
  return {
    tasks: inputData.tasks || [],
    success: inputData.success || false,
    questions: inputData.questions || [],
    reasoning: inputData.reasoning || "",
    planComplete: inputData.planComplete || false,
    message: inputData.message || ""
  };
}).then(taskApprovalStep).commit();
var workflowResearch = `
## \u{1F50D} **COMPREHENSIVE MASTRA WORKFLOW RESEARCH SUMMARY**

Based on extensive research of Mastra documentation and examples, here's essential information for building effective Mastra workflows:

### **\u{1F4CB} WORKFLOW FUNDAMENTALS**

**Core Components:**
- **\`createWorkflow()\`**: Main factory function that creates workflow instances
- **\`createStep()\`**: Creates individual workflow steps with typed inputs/outputs  
- **\`.commit()\`**: Finalizes workflow definition (REQUIRED to make workflows executable)
- **Zod schemas**: Used for strict input/output typing and validation

**Basic Structure:**
\`\`\`typescript
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const workflow = createWorkflow({
  id: "unique-workflow-id",           // Required: kebab-case recommended
  description: "What this workflow does", // Optional but recommended
  inputSchema: z.object({...}),       // Required: Defines workflow inputs
  outputSchema: z.object({...})       // Required: Defines final outputs
})
  .then(step1)                       // Chain steps sequentially
  .then(step2)
  .commit();                         // CRITICAL: Makes workflow executable
\`\`\`

### **\u{1F527} STEP CREATION PATTERNS**

**Standard Step Definition:**
\`\`\`typescript
const myStep = createStep({
  id: "step-id",                     // Required: unique identifier
  description: "Step description",    // Recommended for clarity
  inputSchema: z.object({...}),       // Required: input validation
  outputSchema: z.object({...}),      // Required: output validation
  execute: async ({ inputData, mastra, getStepResult, getInitData }) => {
    // Step logic here
    return { /* matches outputSchema */ };
  }
});
\`\`\`

**Execute Function Parameters:**
- \`inputData\`: Validated input matching inputSchema
- \`mastra\`: Access to Mastra instance (agents, tools, other workflows)
- \`getStepResult(stepInstance)\`: Get results from previous steps
- \`getInitData()\`: Access original workflow input data
- \`requestContext\`: Runtime dependency injection context
- \`runCount\`: Number of times this step has run (useful for retries)

### **\u{1F504} CONTROL FLOW METHODS**

**Sequential Execution:**
- \`.then(step)\`: Execute steps one after another
- Data flows automatically if schemas match

**Parallel Execution:**
- \`.parallel([step1, step2])\`: Run steps simultaneously
- All parallel steps complete before continuing

**Conditional Logic:**
- \`.branch([[condition, step], [condition, step]])\`: Execute different steps based on conditions
- Conditions evaluated sequentially, matching steps run in parallel

**Loops:**
- \`.dountil(step, condition)\`: Repeat until condition becomes true
- \`.dowhile(step, condition)\`: Repeat while condition is true  
- \`.foreach(step, {concurrency: N})\`: Execute step for each array item

**Data Transformation:**
- \`.map(({ inputData, getStepResult, getInitData }) => transformedData)\`: Transform data between steps

### **\u23F8\uFE0F SUSPEND & RESUME CAPABILITIES**

**For Human-in-the-Loop Workflows:**
\`\`\`typescript
const userInputStep = createStep({
  id: "user-input",
  suspendSchema: z.object({}),        // Schema for suspension payload
  resumeSchema: z.object({            // Schema for resume data
    userResponse: z.string()
  }),
  execute: async ({ resumeData, suspend }) => {
    if (!resumeData?.userResponse) {
      await suspend({});  // Pause workflow
      return { response: "" };
    }
    return { response: resumeData.userResponse };
  }
});
\`\`\`

**Resume Workflow:**
\`\`\`typescript
const result = await run.start({ inputData: {...} });
if (result.status === "suspended") {
  await run.resume({
    step: result.suspended[0],        // Or specific step ID
    resumeData: { userResponse: "answer" }
  });
}
\`\`\`

### **\u{1F6E0}\uFE0F INTEGRATING AGENTS & TOOLS**

**Using Agents in Steps:**
\`\`\`typescript
// Method 1: Agent as step
const agentStep = createStep(myAgent);

// Method 2: Call agent in execute function
const step = createStep({
  execute: async ({ inputData }) => {
    const result = await myAgent.generate(prompt);
    return { output: result.text };
  }
});
\`\`\`

**Using Tools in Steps:**
\`\`\`typescript
// Method 1: Tool as step  
const toolStep = createStep(myTool);

// Method 2: Call tool in execute function
const step = createStep({
  execute: async ({ inputData, requestContext }) => {
    const result = await myTool.execute({
      context: inputData,
      requestContext
    });
    return result;
  }
});
\`\`\`

### **\u{1F5C2}\uFE0F PROJECT ORGANIZATION PATTERNS**

**MANDATORY Workflow Organization:**
Each workflow MUST be organized in its own dedicated folder with separated concerns:

\`\`\`
src/mastra/workflows/
\u251C\u2500\u2500 my-workflow-name/         # Kebab-case folder name
\u2502   \u251C\u2500\u2500 types.ts             # All Zod schemas and TypeScript types
\u2502   \u251C\u2500\u2500 steps.ts             # All individual step definitions
\u2502   \u251C\u2500\u2500 workflow.ts          # Main workflow composition and export
\u2502   \u2514\u2500\u2500 utils.ts             # Helper functions (if needed)
\u251C\u2500\u2500 another-workflow/
\u2502   \u251C\u2500\u2500 types.ts
\u2502   \u251C\u2500\u2500 steps.ts
\u2502   \u251C\u2500\u2500 workflow.ts
\u2502   \u2514\u2500\u2500 utils.ts
\u2514\u2500\u2500 index.ts                 # Export all workflows
\`\`\`

**CRITICAL File Organization Rules:**
- **ALWAYS create a dedicated folder** for each workflow
- **Folder names MUST be kebab-case** version of workflow name
- **types.ts**: Define all input/output schemas, validation types, and interfaces
- **steps.ts**: Create all individual step definitions using createStep()
- **workflow.ts**: Compose steps into workflow using createWorkflow() and export the final workflow
- **utils.ts**: Any helper functions, constants, or utilities (create only if needed)
- **NEVER put everything in one file** - always separate concerns properly

**Workflow Registration:**
\`\`\`typescript
// src/mastra/index.ts
export const mastra = new Mastra({
  workflows: {
    sendEmailWorkflow,      // Use camelCase for keys
    dataProcessingWorkflow
  },
  storage: new LibSQLStore({ id: 'mastra-storage', url: 'file:./mastra.db' }), // Required for suspend/resume
});
\`\`\`

### **\u{1F4E6} ESSENTIAL DEPENDENCIES**

**Required Packages:**
\`\`\`json
{
  "dependencies": {
    "@mastra/core": "latest",
    "zod": "^3.25.67"
  }
}
\`\`\`

**Additional Packages (as needed):**
- \`@mastra/libsql\`: For workflow state persistence
- \`@ai-sdk/openai\`: For AI model integration
- \`ai\`: For AI SDK functionality

### **\u2705 WORKFLOW BEST PRACTICES**

**Schema Design:**
- Use descriptive property names in schemas
- Make schemas as specific as possible (avoid \`z.any()\`)
- Include validation for required business logic

**Error Handling:**
- Use \`try/catch\` blocks in step execute functions
- Return meaningful error messages
- Consider using \`bail()\` for early successful exits

**Step Organization:**
- Keep steps focused on single responsibilities
- Use descriptive step IDs (kebab-case recommended)
- Create reusable steps for common operations

**Data Flow:**
- Use \`.map()\` when schemas don't align between steps
- Access previous step results with \`getStepResult(stepInstance)\`
- Use \`getInitData()\` to access original workflow input

### **\u{1F680} EXECUTION PATTERNS**

**Running Workflows:**
\`\`\`typescript
// Create and start run
const run = await workflow.createRun();
const result = await run.start({ inputData: {...} });

// Stream execution for real-time monitoring
const stream = await run.streamVNext({ inputData: {...} });
for await (const chunk of stream) {
  console.log(chunk);
}

// Watch for events
run.watch((event) => console.log(event));
\`\`\`

**Workflow Status Types:**
- \`"success"\`: Completed successfully
- \`"suspended"\`: Paused awaiting input
- \`"failed"\`: Encountered error

### **\u{1F517} ADVANCED FEATURES**

**Nested Workflows:**
- Use workflows as steps: \`.then(otherWorkflow)\`
- Enable complex workflow composition

**Request Context:**
- Pass shared data across all steps
- Enable dependency injection patterns

**Streaming & Events:**
- Real-time workflow monitoring
- Integration with external event systems

**Cloning:**
- \`cloneWorkflow(original, {id: "new-id"})\`: Reuse workflow structure
- \`cloneStep(original, {id: "new-id"})\`: Reuse step logic

This comprehensive research provides the foundation for creating robust, maintainable Mastra workflows with proper typing, error handling, and architectural patterns.
`;
var workflowBuilderPrompts = {
  researchAgent: {
    instructions: `You are a Mastra workflow research expert. Your task is to gather relevant information about creating Mastra workflows.

RESEARCH OBJECTIVES:
1. **Core Concepts**: Understand how Mastra workflows work
2. **Best Practices**: Learn workflow patterns and conventions  
3. **Code Examples**: Find relevant implementation examples
4. **Technical Details**: Understand schemas, steps, and configuration

Use the available documentation and examples tools to gather comprehensive information about Mastra workflows.`,
    prompt: (context2) => `Research everything about Mastra workflows to help create or edit them effectively.

PROJECT CONTEXT:
- Project Structure: ${JSON.stringify(context2.projectStructure, null, 2)}
- Dependencies: ${JSON.stringify(context2.dependencies, null, 2)}
- Has Workflows Directory: ${context2.hasWorkflowsDir}

Focus on:
1. How to create workflows using createWorkflow()
2. How to create and chain workflow steps
3. Best practices for workflow organization
4. Common workflow patterns and examples
5. Schema definitions and types
6. Error handling and debugging

Use the docs and examples tools to gather comprehensive information.`
  },
  executionAgent: {
    instructions: (context2) => `You are executing a workflow ${context2.action} task for: "${context2.workflowName}"

CRITICAL WORKFLOW EXECUTION REQUIREMENTS:
1. **EXPLORE PROJECT STRUCTURE FIRST**: Use listDirectory and readFile tools to understand the existing project layout, folder structure, and conventions before creating any files
2. **FOLLOW PROJECT CONVENTIONS**: Look at existing workflows, agents, and file structures to understand where new files should be placed (typically src/mastra/workflows/, src/mastra/agents/, etc.)
3. **USE PRE-LOADED TASK LIST**: Your task list has been pre-populated in the taskManager tool. Use taskManager with action 'list' to see all tasks, and action 'update' to mark progress
4. **COMPLETE EVERY SINGLE TASK**: You MUST complete ALL ${context2.tasksLength} tasks that are already in the taskManager. Do not stop until every task is marked as 'completed'
5. **Follow Task Dependencies**: Execute tasks in the correct order, respecting dependencies
6. **Request User Input When Needed**: If you encounter choices (like email providers, databases, etc.) that require user decision, return questions for clarification
7. **STRICT WORKFLOW ORGANIZATION**: When creating or editing workflows, you MUST follow this exact structure

MANDATORY WORKFLOW FOLDER STRUCTURE:
When ${context2.action === "create" ? "creating a new workflow" : "editing a workflow"}, you MUST organize files as follows:

\u{1F4C1} src/mastra/workflows/${context2.workflowName?.toLowerCase().replace(/[^a-z0-9]/g, "-") || "new-workflow"}/
\u251C\u2500\u2500 \u{1F4C4} types.ts          # All Zod schemas and TypeScript types
\u251C\u2500\u2500 \u{1F4C4} steps.ts          # All individual step definitions  
\u251C\u2500\u2500 \u{1F4C4} workflow.ts       # Main workflow composition and export
\u2514\u2500\u2500 \u{1F4C4} utils.ts          # Helper functions (if needed)

CRITICAL FILE ORGANIZATION RULES:
- **ALWAYS create a dedicated folder** for the workflow in src/mastra/workflows/
- **Folder name MUST be kebab-case** version of workflow name
- **types.ts**: Define all input/output schemas, validation types, and interfaces
- **steps.ts**: Create all individual step definitions using createStep()
- **workflow.ts**: Compose steps into workflow using createWorkflow() and export the final workflow
- **utils.ts**: Any helper functions, constants, or utilities (create only if needed)
- **NEVER put everything in one file** - always separate concerns properly

CRITICAL COMPLETION REQUIREMENTS: 
- ALWAYS explore the directory structure before creating files to understand where they should go
- You MUST complete ALL ${context2.tasksLength} tasks before returning status='completed'
- Use taskManager tool with action 'list' to see your current task list and action 'update' to mark tasks as 'in_progress' or 'completed'
- If you need to make any decisions during implementation (choosing providers, configurations, etc.), return questions for user clarification
- DO NOT make assumptions about file locations - explore first!
- You cannot finish until ALL tasks in the taskManager are marked as 'completed'

PROJECT CONTEXT:
- Action: ${context2.action}
- Workflow Name: ${context2.workflowName}
- Project Path: ${context2.currentProjectPath}
- Discovered Workflows: ${JSON.stringify(context2.discoveredWorkflows, null, 2)}
- Project Structure: ${JSON.stringify(context2.projectStructure, null, 2)}

AVAILABLE RESEARCH:
${JSON.stringify(context2.research, null, 2)}

PRE-LOADED TASK LIST (${context2.tasksLength} tasks already in taskManager):
${context2.tasks.map((task) => `- ${task.id}: ${task.content} (Priority: ${task.priority})`).join("\n")}

${context2.resumeData ? `USER PROVIDED ANSWERS: ${JSON.stringify(context2.resumeData.answers, null, 2)}` : ""}

Start by exploring the project structure, then use 'taskManager' with action 'list' to see your pre-loaded tasks, and work through each task systematically.`,
    prompt: (context2) => context2.resumeData ? `Continue working on the task list. The user has provided answers to your questions: ${JSON.stringify(context2.resumeData.answers, null, 2)}. 

CRITICAL: You must complete ALL ${context2.tasks.length} tasks that are pre-loaded in the taskManager. Use the taskManager tool with action 'list' to check your progress and continue with the next tasks. Do not stop until every single task is marked as 'completed'.` : `Begin executing the pre-loaded task list to ${context2.action} the workflow "${context2.workflowName}". 

CRITICAL REQUIREMENTS:
- Your ${context2.tasks.length} tasks have been PRE-LOADED into the taskManager tool
- Start by exploring the project directory structure using listDirectory and readFile tools to understand:
  - Where workflows are typically stored (look for src/mastra/workflows/ or similar)
  - What the existing file structure looks like
  - How other workflows are organized and named
  - Where agent files are stored if needed
- Then use taskManager with action 'list' to see your pre-loaded tasks
- Use taskManager with action 'update' to mark tasks as 'in_progress' or 'completed'

CRITICAL FILE ORGANIZATION RULES:
- **ALWAYS create a dedicated folder** for the workflow in src/mastra/workflows/
- **Folder name MUST be kebab-case** version of workflow name  
- **NEVER put everything in one file** - separate types, steps, and workflow composition
- Follow the 4-file structure above for maximum maintainability and clarity

- DO NOT return status='completed' until ALL ${context2.tasks.length} tasks are marked as 'completed' in the taskManager

PRE-LOADED TASKS (${context2.tasks.length} total tasks in taskManager):
${context2.tasks.map((task, index) => `${index + 1}. [${task.id}] ${task.content}`).join("\n")}

Use taskManager with action 'list' to see the current status of all tasks. You must complete every single one before finishing.`,
    iterationPrompt: (context2) => `Continue working on the remaining tasks. You have already completed these tasks: [${context2.completedTasks.map((t) => t.id).join(", ")}]

REMAINING TASKS TO COMPLETE (${context2.pendingTasks.length} tasks):
${context2.pendingTasks.map((task, index) => `${index + 1}. [${task.id}] ${task.content}`).join("\n")}

CRITICAL: You must complete ALL of these remaining ${context2.pendingTasks.length} tasks. Use taskManager with action 'list' to check current status and action 'update' to mark tasks as completed.

${context2.resumeData ? `USER PROVIDED ANSWERS: ${JSON.stringify(context2.resumeData.answers, null, 2)}` : ""}`
  },
  validation: {
    instructions: `CRITICAL VALIDATION INSTRUCTIONS:
- When using the validateCode tool, ALWAYS pass the specific files you created or modified using the 'files' parameter
- The tool uses a hybrid validation approach: fast syntax checking \u2192 semantic type checking \u2192 ESLint
- This is much faster than full project compilation and only shows errors from your specific files
- Example: validateCode({ validationType: ['types', 'lint'], files: ['src/workflows/my-workflow.ts', 'src/agents/my-agent.ts'] })
- ALWAYS validate after creating or modifying files to ensure they compile correctly`
  }
};
var restrictedTaskManager = createTool({
  id: "task-manager",
  description: "View and update your pre-loaded task list. You can only mark tasks as in_progress or completed, not create new tasks.",
  inputSchema: z.object({
    action: z.enum(["list", "update", "complete"]).describe("List tasks, update status, or mark complete - tasks are pre-loaded"),
    tasks: z.array(
      z.object({
        id: z.string().describe("Task ID - must match existing task"),
        content: z.string().optional().describe("Task content (read-only)"),
        status: z.enum(["pending", "in_progress", "completed", "blocked"]).describe("Task status"),
        priority: z.enum(["high", "medium", "low"]).optional().describe("Task priority (read-only)"),
        dependencies: z.array(z.string()).optional().describe("Task dependencies (read-only)"),
        notes: z.string().optional().describe("Additional notes or progress updates")
      })
    ).optional().describe("Tasks to update (status and notes only)"),
    taskId: z.string().optional().describe("Specific task ID for single task operations")
  }),
  outputSchema: z.object({
    success: z.boolean(),
    tasks: z.array(
      z.object({
        id: z.string(),
        content: z.string(),
        status: z.string(),
        priority: z.string(),
        dependencies: z.array(z.string()).optional(),
        notes: z.string().optional(),
        createdAt: z.string(),
        updatedAt: z.string()
      })
    ),
    message: z.string()
  }),
  execute: async (input) => {
    const adaptedContext = {
      ...input,
      action: input.action,
      tasks: input.tasks?.map((task) => ({
        ...task,
        priority: task.priority || "medium"
      }))
    };
    return await AgentBuilderDefaults.manageTaskList(adaptedContext);
  }
});
var workflowDiscoveryStep = createStep({
  id: "workflow-discovery",
  description: "Discover existing workflows in the project",
  inputSchema: WorkflowBuilderInputSchema,
  outputSchema: WorkflowDiscoveryResultSchema,
  execute: async ({ inputData, requestContext: _requestContext }) => {
    console.info("Starting workflow discovery...");
    const { projectPath = process.cwd() } = inputData;
    try {
      const workflowsPath = join(projectPath, "src/mastra/workflows");
      if (!existsSync(workflowsPath)) {
        console.info("No workflows directory found");
        return {
          success: true,
          workflows: [],
          mastraIndexExists: existsSync(join(projectPath, "src/mastra/index.ts")),
          message: "No existing workflows found in the project"
        };
      }
      const workflowFiles = await readdir(workflowsPath);
      const workflows = [];
      for (const fileName of workflowFiles) {
        if (fileName.endsWith(".ts") && !fileName.endsWith(".test.ts")) {
          const filePath = join(workflowsPath, fileName);
          try {
            const content = await readFile(filePath, "utf-8");
            const nameMatch = content.match(/createWorkflow\s*\(\s*{\s*id:\s*['"]([^'"]+)['"]/);
            const descMatch = content.match(/description:\s*['"]([^'"]*)['"]/);
            if (nameMatch && nameMatch[1]) {
              workflows.push({
                name: nameMatch[1],
                file: filePath,
                description: descMatch?.[1] ?? "No description available"
              });
            }
          } catch (error) {
            console.warn(`Failed to read workflow file ${filePath}:`, error);
          }
        }
      }
      console.info(`Discovered ${workflows.length} existing workflows`);
      return {
        success: true,
        workflows,
        mastraIndexExists: existsSync(join(projectPath, "src/mastra/index.ts")),
        message: workflows.length > 0 ? `Found ${workflows.length} existing workflow(s): ${workflows.map((w) => w.name).join(", ")}` : "No existing workflows found in the project"
      };
    } catch (error) {
      console.error("Workflow discovery failed:", error);
      return {
        success: false,
        workflows: [],
        mastraIndexExists: false,
        message: `Workflow discovery failed: ${error instanceof Error ? error.message : String(error)}`,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var projectDiscoveryStep = createStep({
  id: "project-discovery",
  description: "Analyze the project structure and setup",
  inputSchema: WorkflowDiscoveryResultSchema,
  outputSchema: ProjectDiscoveryResultSchema,
  execute: async ({ inputData: _inputData, requestContext: _requestContext }) => {
    console.info("Starting project discovery...");
    try {
      const projectPath = process.cwd();
      const projectStructure = {
        hasPackageJson: existsSync(join(projectPath, "package.json")),
        hasMastraConfig: existsSync(join(projectPath, "mastra.config.js")) || existsSync(join(projectPath, "mastra.config.ts")),
        hasSrcDirectory: existsSync(join(projectPath, "src")),
        hasMastraDirectory: existsSync(join(projectPath, "src/mastra")),
        hasWorkflowsDirectory: existsSync(join(projectPath, "src/mastra/workflows")),
        hasToolsDirectory: existsSync(join(projectPath, "src/mastra/tools")),
        hasAgentsDirectory: existsSync(join(projectPath, "src/mastra/agents"))
      };
      let packageInfo = null;
      if (projectStructure.hasPackageJson) {
        try {
          const packageContent = await readFile(join(projectPath, "package.json"), "utf-8");
          packageInfo = JSON.parse(packageContent);
        } catch (error) {
          console.warn("Failed to read package.json:", error);
        }
      }
      console.info("Project discovery completed");
      return {
        success: true,
        structure: {
          hasWorkflowsDir: projectStructure.hasWorkflowsDirectory,
          hasAgentsDir: projectStructure.hasAgentsDirectory,
          hasToolsDir: projectStructure.hasToolsDirectory,
          hasMastraIndex: existsSync(join(projectPath, "src/mastra/index.ts")),
          existingWorkflows: [],
          existingAgents: [],
          existingTools: []
        },
        dependencies: packageInfo?.dependencies || {},
        message: "Project discovery completed successfully"
      };
    } catch (error) {
      console.error("Project discovery failed:", error);
      return {
        success: false,
        structure: {
          hasWorkflowsDir: false,
          hasAgentsDir: false,
          hasToolsDir: false,
          hasMastraIndex: false,
          existingWorkflows: [],
          existingAgents: [],
          existingTools: []
        },
        dependencies: {},
        message: "Project discovery failed",
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var workflowResearchStep = createStep({
  id: "workflow-research",
  description: "Research Mastra workflows and gather relevant documentation",
  inputSchema: ProjectDiscoveryResultSchema,
  outputSchema: WorkflowResearchResultSchema,
  execute: async ({ inputData, requestContext }) => {
    console.info("Starting workflow research...");
    try {
      const model = await resolveModel({ requestContext });
      const researchAgent = new Agent({
        id: "workflow-research-agent",
        model,
        instructions: workflowBuilderPrompts.researchAgent.instructions,
        name: "Workflow Research Agent"
        // tools: filteredMcpTools,
      });
      const researchPrompt = workflowBuilderPrompts.researchAgent.prompt({
        projectStructure: inputData.structure,
        dependencies: inputData.dependencies,
        hasWorkflowsDir: inputData.structure.hasWorkflowsDir
      });
      const result = await researchAgent.generate(researchPrompt, {
        structuredOutput: {
          schema: WorkflowResearchResultSchema
        }
        // stopWhen: stepCountIs(10),
      });
      const researchResult = await result.object;
      if (!researchResult) {
        return {
          success: false,
          documentation: {
            workflowPatterns: [],
            stepExamples: [],
            bestPractices: []
          },
          webResources: [],
          message: "Research agent failed to generate valid response",
          error: "Research agent failed to generate valid response"
        };
      }
      console.info("Research completed successfully");
      return {
        success: true,
        documentation: {
          workflowPatterns: researchResult.documentation.workflowPatterns,
          stepExamples: researchResult.documentation.stepExamples,
          bestPractices: researchResult.documentation.bestPractices
        },
        webResources: researchResult.webResources,
        message: "Research completed successfully"
      };
    } catch (error) {
      console.error("Workflow research failed:", error);
      return {
        success: false,
        documentation: {
          workflowPatterns: [],
          stepExamples: [],
          bestPractices: []
        },
        webResources: [],
        message: "Research failed",
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var taskExecutionStep = createStep({
  id: "task-execution",
  description: "Execute the approved task list to create or edit the workflow",
  inputSchema: TaskExecutionInputSchema,
  outputSchema: TaskExecutionResultSchema,
  suspendSchema: TaskExecutionSuspendSchema,
  resumeSchema: TaskExecutionResumeSchema,
  execute: async ({ inputData, resumeData, suspend, requestContext }) => {
    const {
      action,
      workflowName,
      tasks,
      discoveredWorkflows,
      projectStructure,
      research,
      projectPath
    } = inputData;
    console.info(`Starting task execution for ${action}ing workflow: ${workflowName}`);
    console.info(`Executing ${tasks.length} tasks using AgentBuilder stream...`);
    try {
      const model = await resolveModel({ requestContext });
      const currentProjectPath = projectPath || process.cwd();
      console.info("Pre-populating taskManager with planned tasks...");
      const taskManagerContext = {
        action: "create",
        tasks: tasks.map((task) => ({
          id: task.id,
          content: task.content,
          status: "pending",
          priority: task.priority,
          dependencies: task.dependencies,
          notes: task.notes
        }))
      };
      const taskManagerResult = await AgentBuilderDefaults.manageTaskList(taskManagerContext);
      console.info(`Task manager initialized with ${taskManagerResult.tasks.length} tasks`);
      if (!taskManagerResult.success) {
        throw new Error(`Failed to initialize task manager: ${taskManagerResult.message}`);
      }
      const executionAgent = new AgentBuilder({
        projectPath: currentProjectPath,
        model,
        tools: {
          "task-manager": restrictedTaskManager
        },
        instructions: `${workflowBuilderPrompts.executionAgent.instructions({
          action,
          workflowName,
          tasksLength: tasks.length,
          currentProjectPath,
          discoveredWorkflows,
          projectStructure,
          research,
          tasks,
          resumeData
        })}

${workflowBuilderPrompts.validation.instructions}`
      });
      const executionPrompt = workflowBuilderPrompts.executionAgent.prompt({
        action,
        workflowName,
        tasks,
        resumeData
      });
      const originalInstructions = await executionAgent.getInstructions({ requestContext });
      const enhancedOptions = {
        stopWhen: stepCountIs(100),
        temperature: 0.3,
        instructions: originalInstructions
      };
      let finalResult = null;
      let allTasksCompleted = false;
      let iterationCount = 0;
      const maxIterations = 5;
      const expectedTaskIds = tasks.map((task) => task.id);
      while (!allTasksCompleted && iterationCount < maxIterations) {
        iterationCount++;
        const currentTaskStatus = await AgentBuilderDefaults.manageTaskList({ action: "list" });
        const completedTasks = currentTaskStatus.tasks.filter((task) => task.status === "completed");
        const pendingTasks = currentTaskStatus.tasks.filter((task) => task.status !== "completed");
        console.info(`
=== EXECUTION ITERATION ${iterationCount} ===`);
        console.info(`Completed tasks: ${completedTasks.length}/${expectedTaskIds.length}`);
        console.info(`Remaining tasks: ${pendingTasks.map((t) => t.id).join(", ")}`);
        allTasksCompleted = pendingTasks.length === 0;
        if (allTasksCompleted) {
          console.info("All tasks completed! Breaking execution loop.");
          break;
        }
        const iterationPrompt = iterationCount === 1 ? executionPrompt : `${workflowBuilderPrompts.executionAgent.iterationPrompt({
          completedTasks,
          pendingTasks,
          workflowName,
          resumeData
        })}

${workflowBuilderPrompts.validation.instructions}`;
        const stream = await executionAgent.stream(iterationPrompt, {
          structuredOutput: {
            schema: TaskExecutionIterationInputSchema(tasks.length),
            model
          },
          ...enhancedOptions
        });
        let finalMessage = "";
        for await (const chunk of stream.fullStream) {
          if (chunk.type === "text-delta") {
            finalMessage += chunk.payload.text;
          }
          if (chunk.type === "step-finish") {
            console.info(finalMessage);
            finalMessage = "";
          }
          if (chunk.type === "tool-result") {
            console.info(JSON.stringify(chunk, null, 2));
          }
          if (chunk.type === "finish") {
            console.info(chunk);
          }
        }
        await stream.consumeStream();
        finalResult = await stream.object;
        console.info(`Iteration ${iterationCount} result:`, { finalResult });
        if (!finalResult) {
          throw new Error(`No result received from agent execution on iteration ${iterationCount}`);
        }
        const postIterationTaskStatus = await AgentBuilderDefaults.manageTaskList({ action: "list" });
        const postCompletedTasks = postIterationTaskStatus.tasks.filter((task) => task.status === "completed");
        const postPendingTasks = postIterationTaskStatus.tasks.filter((task) => task.status !== "completed");
        allTasksCompleted = postPendingTasks.length === 0;
        console.info(
          `After iteration ${iterationCount}: ${postCompletedTasks.length}/${expectedTaskIds.length} tasks completed in taskManager`
        );
        if (finalResult.status === "needs_clarification" && finalResult.questions && finalResult.questions.length > 0) {
          console.info(
            `Agent needs clarification on iteration ${iterationCount}: ${finalResult.questions.length} questions`
          );
          break;
        }
        if (finalResult.status === "completed" && !allTasksCompleted) {
          console.info(
            `Agent claimed completion but taskManager shows pending tasks: ${postPendingTasks.map((t) => t.id).join(", ")}`
          );
        }
      }
      if (iterationCount >= maxIterations && !allTasksCompleted) {
        finalResult.error = `Maximum iterations (${maxIterations}) reached but not all tasks completed`;
        finalResult.status = "in_progress";
      }
      if (!finalResult) {
        throw new Error("No result received from agent execution");
      }
      if (finalResult.status === "needs_clarification" && finalResult.questions && finalResult.questions.length > 0) {
        console.info(`Agent needs clarification: ${finalResult.questions.length} questions`);
        console.info("finalResult", JSON.stringify(finalResult, null, 2));
        return suspend({
          questions: finalResult.questions,
          currentProgress: finalResult.progress,
          completedTasks: finalResult.completedTasks || [],
          message: finalResult.message
        });
      }
      const finalTaskStatus = await AgentBuilderDefaults.manageTaskList({ action: "list" });
      const finalCompletedTasks = finalTaskStatus.tasks.filter((task) => task.status === "completed");
      const finalPendingTasks = finalTaskStatus.tasks.filter((task) => task.status !== "completed");
      const tasksCompleted = finalCompletedTasks.length;
      const tasksExpected = expectedTaskIds.length;
      const finalAllTasksCompleted = finalPendingTasks.length === 0;
      const success = finalAllTasksCompleted && !finalResult.error;
      const message = success ? `Successfully completed workflow ${action} - all ${tasksExpected} tasks completed after ${iterationCount} iteration(s): ${finalResult.message}` : `Workflow execution finished with issues after ${iterationCount} iteration(s): ${finalResult.message}. Completed: ${tasksCompleted}/${tasksExpected} tasks`;
      console.info(message);
      const missingTasks = finalPendingTasks.map((task) => task.id);
      const validationErrors = [];
      if (finalResult.error) {
        validationErrors.push(finalResult.error);
      }
      if (!finalAllTasksCompleted) {
        validationErrors.push(
          `Incomplete tasks: ${missingTasks.join(", ")} (${tasksCompleted}/${tasksExpected} completed)`
        );
      }
      return {
        success,
        completedTasks: finalCompletedTasks.map((task) => task.id),
        filesModified: finalResult.filesModified || [],
        validationResults: {
          passed: success,
          errors: validationErrors,
          warnings: finalAllTasksCompleted ? [] : [`Missing ${missingTasks.length} tasks: ${missingTasks.join(", ")}`]
        },
        message,
        error: finalResult.error
      };
    } catch (error) {
      console.error("Task execution failed:", error);
      return {
        success: false,
        completedTasks: [],
        filesModified: [],
        validationResults: {
          passed: false,
          errors: [`Task execution failed: ${error instanceof Error ? error.message : String(error)}`],
          warnings: []
        },
        message: `Task execution failed: ${error instanceof Error ? error.message : String(error)}`,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var workflowBuilderWorkflow = createWorkflow({
  id: "workflow-builder",
  description: "Create or edit Mastra workflows using AI-powered assistance with iterative planning",
  inputSchema: WorkflowBuilderInputSchema,
  outputSchema: WorkflowBuilderResultSchema,
  steps: [
    workflowDiscoveryStep,
    projectDiscoveryStep,
    workflowResearchStep,
    planningAndApprovalWorkflow,
    taskExecutionStep
  ]
}).then(workflowDiscoveryStep).then(projectDiscoveryStep).then(workflowResearchStep).map(async ({ getStepResult, getInitData }) => {
  const initData = getInitData();
  const discoveryResult = getStepResult(workflowDiscoveryStep);
  const projectResult = getStepResult(projectDiscoveryStep);
  return {
    action: initData.action,
    workflowName: initData.workflowName,
    description: initData.description,
    requirements: initData.requirements,
    discoveredWorkflows: discoveryResult.workflows,
    projectStructure: projectResult,
    // research: researchResult,
    research: workflowResearch,
    userAnswers: void 0
  };
}).dountil(planningAndApprovalWorkflow, async ({ inputData }) => {
  console.info(`Sub-workflow check: approved=${inputData.approved}`);
  return inputData.approved === true;
}).map(async ({ getStepResult, getInitData }) => {
  const initData = getInitData();
  const discoveryResult = getStepResult(workflowDiscoveryStep);
  const projectResult = getStepResult(projectDiscoveryStep);
  const subWorkflowResult = getStepResult(planningAndApprovalWorkflow);
  return {
    action: initData.action,
    workflowName: initData.workflowName,
    description: initData.description,
    requirements: initData.requirements,
    tasks: subWorkflowResult.tasks,
    discoveredWorkflows: discoveryResult.workflows,
    projectStructure: projectResult,
    // research: researchResult,
    research: workflowResearch,
    projectPath: initData.projectPath || process.cwd()
  };
}).then(taskExecutionStep).commit();
var agentBuilderWorkflows = {
  "merge-template": agentBuilderTemplateWorkflow,
  "workflow-builder": workflowBuilderWorkflow
};
var actionIdPathParams = z$1.object({
  actionId: z$1.string().describe("Unique identifier for the agent-builder action")
});
var actionRunPathParams = z$1.object({
  actionId: z$1.string().describe("Unique identifier for the agent-builder action"),
  runId: z$1.string().describe("Unique identifier for the action run")
});
var streamAgentBuilderBodySchema = streamWorkflowBodySchema;
var streamLegacyAgentBuilderBodySchema = streamLegacyWorkflowBodySchema;
var resumeAgentBuilderBodySchema = resumeBodySchema;
var startAsyncAgentBuilderBodySchema = startAsyncWorkflowBodySchema;

// src/server/handlers/agent-builder.ts
var LIST_AGENT_BUILDER_ACTIONS_ROUTE = createRoute({
  method: "GET",
  path: "/agent-builder",
  responseType: "json",
  responseSchema: listWorkflowsResponseSchema,
  summary: "List agent-builder actions",
  description: "Returns a list of all available agent-builder actions",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      logger.info("Listing agent builder actions");
      return await LIST_WORKFLOWS_ROUTE.handler(ctx);
    } catch (error) {
      logger.error("Error listing agent builder actions", { error });
      return handleError$1(error, "Error getting agent builder workflows");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var GET_AGENT_BUILDER_ACTION_BY_ID_ROUTE = createRoute({
  method: "GET",
  path: "/agent-builder/:actionId",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  responseSchema: workflowInfoSchema,
  summary: "Get action by ID",
  description: "Returns details for a specific agent-builder action",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, {
          message: `Invalid agent-builder action: ${actionId}. Valid actions are: ${Object.keys(agentBuilderWorkflows).join(", ")}`
        });
      }
      logger.info("Getting agent builder action by ID", { actionId });
      return await GET_WORKFLOW_BY_ID_ROUTE.handler({ ...ctx, workflowId: actionId });
    } catch (error) {
      logger.error("Error getting agent builder action by ID", { error, actionId });
      return handleError$1(error, "Error getting agent builder action");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var LIST_AGENT_BUILDER_ACTION_RUNS_ROUTE = createRoute({
  method: "GET",
  path: "/agent-builder/:actionId/runs",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: listWorkflowRunsQuerySchema,
  responseSchema: workflowRunsResponseSchema,
  summary: "List action runs",
  description: "Returns a paginated list of execution runs for the specified action",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Listing agent builder action runs", { actionId });
      return await LIST_WORKFLOW_RUNS_ROUTE.handler({
        ...ctx,
        workflowId: actionId
      });
    } catch (error) {
      logger.error("Error listing agent builder action runs", { error, actionId });
      return handleError$1(error, "Error getting agent builder action runs");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var GET_AGENT_BUILDER_ACTION_RUN_BY_ID_ROUTE = createRoute({
  method: "GET",
  path: "/agent-builder/:actionId/runs/:runId",
  responseType: "json",
  pathParamSchema: actionRunPathParams,
  queryParamSchema: workflowRunResultQuerySchema,
  responseSchema: workflowRunResultSchema,
  summary: "Get action run by ID",
  description: "Returns details for a specific action run with metadata and processed execution state. Use the fields query parameter to reduce payload size.",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId, runId } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Getting agent builder action run by ID", { actionId, runId });
      return await GET_WORKFLOW_RUN_BY_ID_ROUTE.handler({
        ...ctx,
        workflowId: actionId
      });
    } catch (error) {
      logger.error("Error getting agent builder action run", { error, actionId, runId });
      return handleError$1(error, "Error getting agent builder action run");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var CREATE_AGENT_BUILDER_ACTION_RUN_ROUTE = createRoute({
  method: "POST",
  path: "/agent-builder/:actionId/create-run",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: optionalRunIdSchema,
  responseSchema: createWorkflowRunResponseSchema,
  summary: "Create action run",
  description: "Creates a new action execution instance with an optional custom run ID",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId, runId } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Creating agent builder action run", { actionId, runId });
      return await CREATE_WORKFLOW_RUN_ROUTE.handler({
        ...ctx,
        workflowId: actionId
      });
    } catch (error) {
      logger.error("Error creating agent builder action run", { error, actionId });
      return handleError$1(error, "Error creating agent builder action run");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var STREAM_AGENT_BUILDER_ACTION_ROUTE = createRoute({
  method: "POST",
  path: "/agent-builder/:actionId/stream",
  responseType: "stream",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: streamAgentBuilderBodySchema,
  responseSchema: streamResponseSchema,
  summary: "Stream action execution",
  description: "Executes an action and streams the results in real-time",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId, runId, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Streaming agent builder action", { actionId, runId });
      return await STREAM_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error streaming agent builder action", { error, actionId });
      return handleError$1(error, "Error streaming agent builder action");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var START_ASYNC_AGENT_BUILDER_ACTION_ROUTE = createRoute({
  method: "POST",
  path: "/agent-builder/:actionId/start-async",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: optionalRunIdSchema,
  bodySchema: startAsyncAgentBuilderBodySchema,
  responseSchema: workflowExecutionResultSchema,
  summary: "Start action asynchronously",
  description: "Starts an action execution asynchronously without streaming results",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId, runId, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Starting agent builder action asynchronously", { actionId, runId });
      return await START_ASYNC_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error starting agent builder action asynchronously", { error, actionId });
      return handleError$1(error, "Error starting agent builder action");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var START_AGENT_BUILDER_ACTION_RUN_ROUTE = createRoute({
  method: "POST",
  path: "/agent-builder/:actionId/start",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: startAsyncAgentBuilderBodySchema,
  responseSchema: workflowControlResponseSchema,
  summary: "Start specific action run",
  description: "Starts execution of a specific action run by ID",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId, runId, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Starting specific agent builder action run", { actionId, runId });
      return await START_WORKFLOW_RUN_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error starting agent builder action run", { error, actionId });
      return handleError$1(error, "Error starting agent builder action run");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var OBSERVE_STREAM_AGENT_BUILDER_ACTION_ROUTE = createRoute({
  method: "POST",
  path: "/agent-builder/:actionId/observe",
  responseType: "stream",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: runIdSchema,
  responseSchema: streamResponseSchema,
  summary: "Observe action stream",
  description: "Observes and streams updates from an already running action execution",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId, runId } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Observing agent builder action stream", { actionId, runId });
      return await OBSERVE_STREAM_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId
      });
    } catch (error) {
      logger.error("Error observing agent builder action stream", { error, actionId });
      return handleError$1(error, "Error observing agent builder action stream");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var RESUME_ASYNC_AGENT_BUILDER_ACTION_ROUTE = createRoute({
  method: "POST",
  path: "/agent-builder/:actionId/resume-async",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: resumeAgentBuilderBodySchema,
  responseSchema: workflowExecutionResultSchema,
  summary: "Resume action asynchronously",
  description: "Resumes a suspended action execution asynchronously without streaming",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId, runId, step, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Resuming agent builder action asynchronously", { actionId, runId, step });
      return await RESUME_ASYNC_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error resuming agent builder action asynchronously", { error, actionId });
      return handleError$1(error, "Error resuming agent builder action");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var RESUME_AGENT_BUILDER_ACTION_ROUTE = createRoute({
  method: "POST",
  path: "/agent-builder/:actionId/resume",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: resumeAgentBuilderBodySchema,
  responseSchema: workflowControlResponseSchema,
  summary: "Resume action",
  description: "Resumes a suspended action execution from a specific step",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId, runId, step, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Resuming agent builder action", { actionId, runId, step });
      return await RESUME_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error resuming agent builder action", { error, actionId });
      return handleError$1(error, "Error resuming agent builder action");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var RESUME_STREAM_AGENT_BUILDER_ACTION_ROUTE = createRoute({
  method: "POST",
  path: "/agent-builder/:actionId/resume-stream",
  responseType: "stream",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: resumeAgentBuilderBodySchema,
  responseSchema: streamResponseSchema,
  summary: "Resume action stream",
  description: "Resumes a suspended action execution and continues streaming results",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId, runId, step, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Resuming agent builder action stream", { actionId, runId, step });
      return await RESUME_STREAM_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error resuming agent builder action stream", { error, actionId });
      return handleError$1(error, "Error resuming agent builder action stream");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var CANCEL_AGENT_BUILDER_ACTION_RUN_ROUTE = createRoute({
  method: "POST",
  path: "/agent-builder/:actionId/runs/:runId/cancel",
  responseType: "json",
  pathParamSchema: actionRunPathParams,
  responseSchema: workflowControlResponseSchema,
  summary: "Cancel action run",
  description: "Cancels an in-progress action execution",
  tags: ["Agent Builder"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId, runId } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Cancelling agent builder action run", { actionId, runId });
      return await CANCEL_WORKFLOW_RUN_ROUTE.handler({
        ...ctx,
        workflowId: actionId
      });
    } catch (error) {
      logger.error("Error cancelling agent builder action run", { error, actionId });
      return handleError$1(error, "Error cancelling agent builder action run");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE = createRoute({
  method: "POST",
  path: "/agent-builder/:actionId/stream-legacy",
  responseType: "stream",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: runIdSchema,
  bodySchema: streamLegacyAgentBuilderBodySchema,
  responseSchema: streamResponseSchema,
  summary: "[DEPRECATED] Stream agent-builder action with legacy format",
  description: "Legacy endpoint for streaming agent-builder action execution. Use /agent-builder/:actionId/stream instead.",
  tags: ["Agent Builder", "Legacy"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId, runId, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Streaming agent builder action (legacy)", { actionId, runId });
      return await STREAM_LEGACY_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error streaming agent builder action (legacy)", { error, actionId });
      return handleError$1(error, "Error streaming agent builder action");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});
var OBSERVE_STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE = createRoute({
  method: "POST",
  path: "/agent-builder/:actionId/observe-stream-legacy",
  responseType: "stream",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: runIdSchema,
  responseSchema: streamResponseSchema,
  summary: "[DEPRECATED] Observe agent-builder action stream with legacy format",
  description: "Legacy endpoint for observing agent-builder action stream. Use /agent-builder/:actionId/observe instead.",
  tags: ["Agent Builder", "Legacy"],
  requiresAuth: true,
  handler: async (ctx) => {
    const { mastra, actionId, runId } = ctx;
    const logger = mastra.getLogger();
    try {
      WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new HTTPException$2(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Observing agent builder action stream (legacy)", { actionId, runId });
      return await OBSERVE_STREAM_LEGACY_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId
      });
    } catch (error) {
      logger.error("Error observing agent builder action stream (legacy)", { error, actionId });
      return handleError$1(error, "Error observing agent builder action stream");
    } finally {
      WorkflowRegistry.cleanup();
    }
  }
});

// src/compose.ts
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || void 0;
      }
      if (handler) {
        try {
          res = await handler(context, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// src/http-exception.ts
var HTTPException$1 = class HTTPException extends Error {
  res;
  status;
  /**
   * Creates an instance of `HTTPException`.
   * @param status - HTTP status code for the exception. Defaults to 500.
   * @param options - Additional options for the exception.
   */
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  /**
   * Returns the response object associated with the exception.
   * If a response object is not provided, a new response is created with the error message and status code.
   * @returns The response object.
   */
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// src/request/constants.ts
var GET_MATCH_RESULT = /* @__PURE__ */ Symbol();

// src/utils/body.ts
var parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
};
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
var handleParsingAllValues = (form, key, value) => {
  if (form[key] !== void 0) {
    if (Array.isArray(form[key])) {
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
};
var handleParsingNestedValues = (form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
};

// src/utils/url.ts
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
};
var replaceGroupMarks = (paths, groups) => {
  for (let i = groups.length - 1; i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1; j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label, next) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
};
var tryDecode = (str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder(match);
      } catch {
        return match;
      }
    });
  }
};
var tryDecodeURI = (str) => tryDecode(str, decodeURI);
var getPath = (request) => {
  const url = request.url;
  const start = url.indexOf("/", url.indexOf(":") + 4);
  let i = start;
  for (; i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const hashIndex = url.indexOf("#", i);
      const end = queryIndex === -1 ? hashIndex === -1 ? void 0 : hashIndex : hashIndex === -1 ? queryIndex : Math.min(queryIndex, hashIndex);
      const path = url.slice(start, end);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63 || charCode === 35) {
      break;
    }
  }
  return url.slice(start, i);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
};
var mergePath = (base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
};
var checkOptionalParameter = (path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf("?", 8);
    if (keyIndex2 === -1) {
      return void 0;
    }
    if (!url.startsWith(key, keyIndex2 + 1)) {
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// src/request.ts
var tryDecodeURIComponent = (str) => tryDecode(str, decodeURIComponent_);
var HonoRequest = class {
  /**
   * `.raw` can get the raw Request object.
   *
   * @see {@link https://hono.dev/docs/api/request#raw}
   *
   * @example
   * ```ts
   * // For Cloudflare Workers
   * app.post('/', async (c) => {
   *   const metadata = c.req.raw.cf?.hostMetadata?
   *   ...
   * })
   * ```
   */
  raw;
  #validatedData;
  // Short name of validatedData
  #matchResult;
  routeIndex = 0;
  /**
   * `.path` can get the pathname of the request.
   *
   * @see {@link https://hono.dev/docs/api/request#path}
   *
   * @example
   * ```ts
   * app.get('/about/me', (c) => {
   *   const pathname = c.req.path // `/about/me`
   * })
   * ```
   */
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param && /\%/.test(param) ? tryDecodeURIComponent(param) : param;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value !== void 0) {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? void 0;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = (key) => {
    const { bodyCache, raw } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw[key]();
  };
  /**
   * `.json()` can parse Request body of type `application/json`
   *
   * @see {@link https://hono.dev/docs/api/request#json}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.json()
   * })
   * ```
   */
  json() {
    return this.#cachedBody("text").then((text) => JSON.parse(text));
  }
  /**
   * `.text()` can parse Request body of type `text/plain`
   *
   * @see {@link https://hono.dev/docs/api/request#text}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.text()
   * })
   * ```
   */
  text() {
    return this.#cachedBody("text");
  }
  /**
   * `.arrayBuffer()` parse Request body as an `ArrayBuffer`
   *
   * @see {@link https://hono.dev/docs/api/request#arraybuffer}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.arrayBuffer()
   * })
   * ```
   */
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  /**
   * Parses the request body as a `Blob`.
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.blob();
   * });
   * ```
   * @see https://hono.dev/docs/api/request#blob
   */
  blob() {
    return this.#cachedBody("blob");
  }
  /**
   * Parses the request body as `FormData`.
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.formData();
   * });
   * ```
   * @see https://hono.dev/docs/api/request#formdata
   */
  formData() {
    return this.#cachedBody("formData");
  }
  /**
   * Adds validated data to the request.
   *
   * @param target - The target of the validation.
   * @param data - The validated data to add.
   */
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  /**
   * `.url()` can get the request url strings.
   *
   * @see {@link https://hono.dev/docs/api/request#url}
   *
   * @example
   * ```ts
   * app.get('/about/me', (c) => {
   *   const url = c.req.url // `http://localhost:8787/about/me`
   *   ...
   * })
   * ```
   */
  get url() {
    return this.raw.url;
  }
  /**
   * `.method()` can get the method name of the request.
   *
   * @see {@link https://hono.dev/docs/api/request#method}
   *
   * @example
   * ```ts
   * app.get('/about/me', (c) => {
   *   const method = c.req.method // `GET`
   * })
   * ```
   */
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  /**
   * `.matchedRoutes()` can return a matched route in the handler
   *
   * @deprecated
   *
   * Use matchedRoutes helper defined in "hono/route" instead.
   *
   * @see {@link https://hono.dev/docs/api/request#matchedroutes}
   *
   * @example
   * ```ts
   * app.use('*', async function logger(c, next) {
   *   await next()
   *   c.req.matchedRoutes.forEach(({ handler, method, path }, i) => {
   *     const name = handler.name || (handler.length < 2 ? '[handler]' : '[middleware]')
   *     console.log(
   *       method,
   *       ' ',
   *       path,
   *       ' '.repeat(Math.max(10 - path.length, 0)),
   *       name,
   *       i === c.req.routeIndex ? '<- respond from here' : ''
   *     )
   *   })
   * })
   * ```
   */
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  /**
   * `routePath()` can retrieve the path registered within the handler
   *
   * @deprecated
   *
   * Use routePath helper defined in "hono/route" instead.
   *
   * @see {@link https://hono.dev/docs/api/request#routepath}
   *
   * @example
   * ```ts
   * app.get('/posts/:id', (c) => {
   *   return c.json({ path: c.req.routePath })
   * })
   * ```
   */
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// src/context.ts
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = (contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
};
var Context = class {
  #rawRequest;
  #req;
  /**
   * `.env` can get bindings (environment variables, secrets, KV namespaces, D1 database, R2 bucket etc.) in Cloudflare Workers.
   *
   * @see {@link https://hono.dev/docs/api/context#env}
   *
   * @example
   * ```ts
   * // Environment object for Cloudflare Workers
   * app.get('*', async c => {
   *   const counter = c.env.COUNTER
   * })
   * ```
   */
  env = {};
  #var;
  finalized = false;
  /**
   * `.error` can get the error object from the middleware if the Handler throws an error.
   *
   * @see {@link https://hono.dev/docs/api/context#error}
   *
   * @example
   * ```ts
   * app.use('*', async (c, next) => {
   *   await next()
   *   if (c.error) {
   *     // do something...
   *   }
   * })
   * ```
   */
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  /**
   * Creates an instance of the Context class.
   *
   * @param req - The Request object.
   * @param options - Optional configuration options for the context.
   */
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  /**
   * `.req` is the instance of {@link HonoRequest}.
   */
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  /**
   * @see {@link https://hono.dev/docs/api/context#event}
   * The FetchEvent associated with the current request.
   *
   * @throws Will throw an error if the context does not have a FetchEvent.
   */
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  /**
   * @see {@link https://hono.dev/docs/api/context#executionctx}
   * The ExecutionContext associated with the current request.
   *
   * @throws Will throw an error if the context does not have an ExecutionContext.
   */
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  /**
   * @see {@link https://hono.dev/docs/api/context#res}
   * The Response object for the current request.
   */
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers()
    });
  }
  /**
   * Sets the Response object for the current request.
   *
   * @param _res - The Response object to set.
   */
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  /**
   * `.render()` can create a response within a layout.
   *
   * @see {@link https://hono.dev/docs/api/context#render-setrenderer}
   *
   * @example
   * ```ts
   * app.get('/', (c) => {
   *   return c.render('Hello!')
   * })
   * ```
   */
  render = (...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  };
  /**
   * Sets the layout for the response.
   *
   * @param layout - The layout to set.
   * @returns The layout function.
   */
  setLayout = (layout) => this.#layout = layout;
  /**
   * Gets the current layout for the response.
   *
   * @returns The current layout function.
   */
  getLayout = () => this.#layout;
  /**
   * `.setRenderer()` can set the layout in the custom middleware.
   *
   * @see {@link https://hono.dev/docs/api/context#render-setrenderer}
   *
   * @example
   * ```tsx
   * app.use('*', async (c, next) => {
   *   c.setRenderer((content) => {
   *     return c.html(
   *       <html>
   *         <body>
   *           <p>{content}</p>
   *         </body>
   *       </html>
   *     )
   *   })
   *   await next()
   * })
   * ```
   */
  setRenderer = (renderer) => {
    this.#renderer = renderer;
  };
  /**
   * `.header()` can set headers.
   *
   * @see {@link https://hono.dev/docs/api/context#header}
   *
   * @example
   * ```ts
   * app.get('/welcome', (c) => {
   *   // Set headers
   *   c.header('X-Message', 'Hello!')
   *   c.header('Content-Type', 'text/plain')
   *
   *   return c.body('Thank you for coming')
   * })
   * ```
   */
  header = (name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers();
    if (value === void 0) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  };
  status = (status) => {
    this.#status = status;
  };
  /**
   * `.set()` can set the value specified by the key.
   *
   * @see {@link https://hono.dev/docs/api/context#set-get}
   *
   * @example
   * ```ts
   * app.use('*', async (c, next) => {
   *   c.set('message', 'Hono is hot!!')
   *   await next()
   * })
   * ```
   */
  set = (key, value) => {
    this.#var ??= /* @__PURE__ */ new Map();
    this.#var.set(key, value);
  };
  /**
   * `.get()` can use the value specified by the key.
   *
   * @see {@link https://hono.dev/docs/api/context#set-get}
   *
   * @example
   * ```ts
   * app.get('/', (c) => {
   *   const message = c.get('message')
   *   return c.text(`The message is "${message}"`)
   * })
   * ```
   */
  get = (key) => {
    return this.#var ? this.#var.get(key) : void 0;
  };
  /**
   * `.var` can access the value of a variable.
   *
   * @see {@link https://hono.dev/docs/api/context#var}
   *
   * @example
   * ```ts
   * const result = c.var.client.oneMethod()
   * ```
   */
  // c.var.propName is a read-only
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers();
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = (...args) => this.#newResponse(...args);
  /**
   * `.body()` can return the HTTP response.
   * You can set headers with `.header()` and set HTTP status code with `.status`.
   * This can also be set in `.text()`, `.json()` and so on.
   *
   * @see {@link https://hono.dev/docs/api/context#body}
   *
   * @example
   * ```ts
   * app.get('/welcome', (c) => {
   *   // Set headers
   *   c.header('X-Message', 'Hello!')
   *   c.header('Content-Type', 'text/plain')
   *   // Set HTTP status code
   *   c.status(201)
   *
   *   // Return the response body
   *   return c.body('Thank you for coming')
   * })
   * ```
   */
  body = (data, arg, headers) => this.#newResponse(data, arg, headers);
  /**
   * `.text()` can render text as `Content-Type:text/plain`.
   *
   * @see {@link https://hono.dev/docs/api/context#text}
   *
   * @example
   * ```ts
   * app.get('/say', (c) => {
   *   return c.text('Hello!')
   * })
   * ```
   */
  text = (text, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(
      text,
      arg,
      setDefaultContentType(TEXT_PLAIN, headers)
    );
  };
  /**
   * `.json()` can render JSON as `Content-Type:application/json`.
   *
   * @see {@link https://hono.dev/docs/api/context#json}
   *
   * @example
   * ```ts
   * app.get('/api', (c) => {
   *   return c.json({ message: 'Hello!' })
   * })
   * ```
   */
  json = (object, arg, headers) => {
    return this.#newResponse(
      JSON.stringify(object),
      arg,
      setDefaultContentType("application/json", headers)
    );
  };
  html = (html, arg, headers) => {
    const res = (html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers));
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  };
  /**
   * `.redirect()` can Redirect, default status code is 302.
   *
   * @see {@link https://hono.dev/docs/api/context#redirect}
   *
   * @example
   * ```ts
   * app.get('/redirect', (c) => {
   *   return c.redirect('/')
   * })
   * app.get('/redirect-permanently', (c) => {
   *   return c.redirect('/', 301)
   * })
   * ```
   */
  redirect = (location, status) => {
    const locationString = String(location);
    this.header(
      "Location",
      // Multibyes should be encoded
      // eslint-disable-next-line no-control-regex
      !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString)
    );
    return this.newResponse(null, status ?? 302);
  };
  /**
   * `.notFound()` can return the Not Found Response.
   *
   * @see {@link https://hono.dev/docs/api/context#notfound}
   *
   * @example
   * ```ts
   * app.get('/notfound', (c) => {
   *   return c.notFound()
   * })
   * ```
   */
  notFound = () => {
    this.#notFoundHandler ??= () => new Response();
    return this.#notFoundHandler(this);
  };
};

// src/router.ts
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// src/utils/constants.ts
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// src/hono-base.ts
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler$1 = (err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
};
var Hono$1 = class _Hono {
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  /*
    This class is like an abstract class and does not have a router.
    To use it, inherit the class and implement router in the constructor.
  */
  router;
  getPath;
  // Cannot use `#` because it requires visibility at JavaScript runtime.
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p of [path].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new _Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.errorHandler = this.errorHandler;
    clone.#notFoundHandler = this.#notFoundHandler;
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  // Cannot use `#` because it requires visibility at JavaScript runtime.
  errorHandler = errorHandler$1;
  /**
   * `.route()` allows grouping other Hono instance in routes.
   *
   * @see {@link https://hono.dev/docs/api/routing#grouping}
   *
   * @param {string} path - base Path
   * @param {Hono} app - other Hono instance
   * @returns {Hono} routed Hono instance
   *
   * @example
   * ```ts
   * const app = new Hono()
   * const app2 = new Hono()
   *
   * app2.get("/user", (c) => c.text("user"))
   * app.route("/api", app2) // GET /api/user
   * ```
   */
  route(path, app) {
    const subApp = this.basePath(path);
    app.routes.map((r) => {
      let handler;
      if (app.errorHandler === errorHandler$1) {
        handler = r.handler;
      } else {
        handler = async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  /**
   * `.basePath()` allows base paths to be specified.
   *
   * @see {@link https://hono.dev/docs/api/routing#base-path}
   *
   * @param {string} path - base Path
   * @returns {Hono} changed Hono instance
   *
   * @example
   * ```ts
   * const api = new Hono().basePath('/api')
   * ```
   */
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  /**
   * `.onError()` handles an error and returns a customized Response.
   *
   * @see {@link https://hono.dev/docs/api/hono#error-handling}
   *
   * @param {ErrorHandler} handler - request Handler for error
   * @returns {Hono} changed Hono instance
   *
   * @example
   * ```ts
   * app.onError((err, c) => {
   *   console.error(`${err}`)
   *   return c.text('Custom Error Message', 500)
   * })
   * ```
   */
  onError = (handler) => {
    this.errorHandler = handler;
    return this;
  };
  /**
   * `.notFound()` allows you to customize a Not Found Response.
   *
   * @see {@link https://hono.dev/docs/api/hono#not-found}
   *
   * @param {NotFoundHandler} handler - request handler for not-found
   * @returns {Hono} changed Hono instance
   *
   * @example
   * ```ts
   * app.notFound((c) => {
   *   return c.text('Custom 404 Message', 404)
   * })
   * ```
   */
  notFound = (handler) => {
    this.#notFoundHandler = handler;
    return this;
  };
  /**
   * `.mount()` allows you to mount applications built with other frameworks into your Hono application.
   *
   * @see {@link https://hono.dev/docs/api/hono#mount}
   *
   * @param {string} path - base Path
   * @param {Function} applicationHandler - other Request Handler
   * @param {MountOptions} [options] - options of `.mount()`
   * @returns {Hono} mounted Hono instance
   *
   * @example
   * ```ts
   * import { Router as IttyRouter } from 'itty-router'
   * import { Hono } from 'hono'
   * // Create itty-router application
   * const ittyRouter = IttyRouter()
   * // GET /itty-router/hello
   * ittyRouter.get('/hello', () => new Response('Hello from itty-router'))
   *
   * const app = new Hono()
   * app.mount('/itty-router', ittyRouter.handle)
   * ```
   *
   * @example
   * ```ts
   * const app = new Hono()
   * // Send the request to another application without modification.
   * app.mount('/app', anotherApp, {
   *   replaceRequest: (req) => req,
   * })
   * ```
   */
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = (request) => request;
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = void 0;
      try {
        executionContext = c.executionCtx;
      } catch {
      }
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    };
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request, { env });
    const matchResult = this.router.match(method, path);
    const c = new Context(request, {
      path,
      matchResult,
      env,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))
      ).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error(
            "Context is not finalized. Did you forget to return a Response object or `await next()`?"
          );
        }
        return context.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  /**
   * `.fetch()` will be entry point of your app.
   *
   * @see {@link https://hono.dev/docs/api/hono#fetch}
   *
   * @param {Request} request - request Object of request
   * @param {Env} Env - env Object
   * @param {ExecutionContext} - context of execution
   * @returns {Response | Promise<Response>} response of request
   *
   */
  fetch = (request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  };
  /**
   * `.request()` is a useful method for testing.
   * You can pass a URL or pathname to send a GET request.
   * app will return a Response object.
   * ```ts
   * test('GET /hello is ok', async () => {
   *   const res = await app.request('/hello')
   *   expect(res.status).toBe(200)
   * })
   * ```
   * @see https://hono.dev/docs/api/hono#request
   */
  request = (input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(
      new Request(
        /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`,
        requestInit
      ),
      Env,
      executionCtx
    );
  };
  /**
   * `.fire()` automatically adds a global fetch event listener.
   * This can be useful for environments that adhere to the Service Worker API, such as non-ES module Cloudflare Workers.
   * @deprecated
   * Use `fire` from `hono/service-worker` instead.
   * ```ts
   * import { Hono } from 'hono'
   * import { fire } from 'hono/service-worker'
   *
   * const app = new Hono()
   * // ...
   * fire(app)
   * ```
   * @see https://hono.dev/docs/api/hono#fire
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
   * @see https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/
   */
  fire = () => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));
    });
  };
};

// src/router/reg-exp-router/matcher.ts
var emptyParam = [];
function match(method, path) {
  const matchers = this.buildAllMatchers();
  const match2 = ((method2, path2) => {
    const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
    const staticMatch = matcher[2][path2];
    if (staticMatch) {
      return staticMatch;
    }
    const match3 = path2.match(matcher[0]);
    if (!match3) {
      return [[], emptyParam];
    }
    const index = match3.indexOf("", 1);
    return [matcher[1][index], match3];
  });
  this.match = match2;
  return match2(method, path);
}

// src/router/reg-exp-router/node.ts
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = /* @__PURE__ */ Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var Node$1 = class _Node {
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        if (regexpStr === ".*") {
          throw PATH_ERROR;
        }
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new _Node();
        if (name !== "") {
          node.#varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new _Node();
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// src/router/reg-exp-router/trie.ts
var Trie = class {
  #context = { varIndex: 0 };
  #root = new Node$1();
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0; ; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1; i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1; j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== void 0) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== void 0) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// src/router/reg-exp-router/router.ts
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(
    path === "*" ? "" : `^${path.replace(
      /\/\*$|([.\\+*[^\]$()])/g,
      (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)"
    )}$`
  );
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length; k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return void 0;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return void 0;
}
var RegExpRouter = class {
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach(
            (p) => re.test(p) && routes[m][p].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length; i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path2] ||= [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match = match;
  buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = void 0;
    clearWildcardRegExpCache();
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// src/router/smart-router/router.ts
var SmartRouter = class {
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (; i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = void 0;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// src/router/trie-router/node.ts
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node = class _Node {
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new _Node();
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length; i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== void 0) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length; j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(
                ...this.#getHandlerSets(nextNode.#children["*"], method, node.#params)
              );
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length; k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          const [key, name, matcher] = pattern;
          if (!part && !(matcher instanceof RegExp)) {
            continue;
          }
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(
                  ...this.#getHandlerSets(child.#children["*"], method, params, node.#params)
                );
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// src/router/trie-router/router.ts
var TrieRouter = class {
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node();
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length; i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// src/hono.ts
var Hono = class extends Hono$1 {
  /**
   * Creates an instance of the Hono class.
   *
   * @param options - Optional configuration options for the Hono instance.
   */
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// src/server/server-adapter/routes/a2a.ts
var A2A_ROUTES = [GET_AGENT_CARD_ROUTE, AGENT_EXECUTION_ROUTE];

// src/server/server-adapter/routes/agent-builder.ts
var AGENT_BUILDER_ROUTES = [
  LIST_AGENT_BUILDER_ACTIONS_ROUTE,
  GET_AGENT_BUILDER_ACTION_BY_ID_ROUTE,
  LIST_AGENT_BUILDER_ACTION_RUNS_ROUTE,
  GET_AGENT_BUILDER_ACTION_RUN_BY_ID_ROUTE,
  CREATE_AGENT_BUILDER_ACTION_RUN_ROUTE,
  STREAM_AGENT_BUILDER_ACTION_ROUTE,
  START_ASYNC_AGENT_BUILDER_ACTION_ROUTE,
  START_AGENT_BUILDER_ACTION_RUN_ROUTE,
  OBSERVE_STREAM_AGENT_BUILDER_ACTION_ROUTE,
  RESUME_ASYNC_AGENT_BUILDER_ACTION_ROUTE,
  RESUME_AGENT_BUILDER_ACTION_ROUTE,
  RESUME_STREAM_AGENT_BUILDER_ACTION_ROUTE,
  CANCEL_AGENT_BUILDER_ACTION_RUN_ROUTE
];

// src/server/server-adapter/routes/agents.ts
var AGENTS_ROUTES = [
  // ============================================================================
  // Agent Core Routes
  // ============================================================================
  LIST_AGENTS_ROUTE,
  GET_PROVIDERS_ROUTE,
  GET_AGENT_BY_ID_ROUTE,
  CLONE_AGENT_ROUTE,
  // ============================================================================
  // Voice Routes
  // ============================================================================
  GET_SPEAKERS_ROUTE,
  GET_SPEAKERS_DEPRECATED_ROUTE,
  // ============================================================================
  // Agent Execution Routes
  // ============================================================================
  GENERATE_AGENT_ROUTE,
  GENERATE_AGENT_VNEXT_ROUTE,
  STREAM_GENERATE_ROUTE,
  STREAM_GENERATE_VNEXT_DEPRECATED_ROUTE,
  // ============================================================================
  // Tool Routes
  // ============================================================================
  EXECUTE_AGENT_TOOL_ROUTE,
  APPROVE_TOOL_CALL_ROUTE,
  DECLINE_TOOL_CALL_ROUTE,
  APPROVE_TOOL_CALL_GENERATE_ROUTE,
  DECLINE_TOOL_CALL_GENERATE_ROUTE,
  APPROVE_NETWORK_TOOL_CALL_ROUTE,
  DECLINE_NETWORK_TOOL_CALL_ROUTE,
  // ============================================================================
  // Network Routes
  // ============================================================================
  STREAM_NETWORK_ROUTE,
  // ============================================================================
  // Model Management Routes
  // ============================================================================
  UPDATE_AGENT_MODEL_ROUTE,
  RESET_AGENT_MODEL_ROUTE,
  REORDER_AGENT_MODEL_LIST_ROUTE,
  UPDATE_AGENT_MODEL_IN_MODEL_LIST_ROUTE,
  // ============================================================================
  // Instruction Enhancement Routes
  // ============================================================================
  ENHANCE_INSTRUCTIONS_ROUTE,
  // ============================================================================
  // Agent Tool Routes
  // ============================================================================
  GET_AGENT_TOOL_ROUTE,
  // ============================================================================
  // Agent Skill Routes
  // ============================================================================
  GET_AGENT_SKILL_ROUTE,
  // ============================================================================
  // Voice/Speech Routes
  // ============================================================================
  GENERATE_SPEECH_ROUTE,
  GENERATE_SPEECH_DEPRECATED_ROUTE,
  TRANSCRIBE_SPEECH_ROUTE,
  TRANSCRIBE_SPEECH_DEPRECATED_ROUTE,
  GET_LISTENER_ROUTE,
  // ============================================================================
  // Deprecated Routes
  // ============================================================================
  STREAM_VNEXT_DEPRECATED_ROUTE,
  STREAM_UI_MESSAGE_VNEXT_DEPRECATED_ROUTE,
  STREAM_UI_MESSAGE_DEPRECATED_ROUTE
];

// src/server/server-adapter/routes/datasets.ts
var DATASETS_ROUTES = [
  // Dataset CRUD
  LIST_DATASETS_ROUTE,
  CREATE_DATASET_ROUTE,
  GET_DATASET_ROUTE,
  UPDATE_DATASET_ROUTE,
  DELETE_DATASET_ROUTE,
  // Item list and add
  LIST_ITEMS_ROUTE,
  ADD_ITEM_ROUTE,
  // Batch operations - MUST come before item-specific routes to avoid /items/batch matching /items/:itemId
  BATCH_INSERT_ITEMS_ROUTE,
  BATCH_DELETE_ITEMS_ROUTE,
  // Item-specific CRUD (uses :itemId param)
  GET_ITEM_ROUTE,
  UPDATE_ITEM_ROUTE,
  DELETE_ITEM_ROUTE,
  // Version operations
  LIST_DATASET_VERSIONS_ROUTE,
  LIST_ITEM_VERSIONS_ROUTE,
  GET_ITEM_VERSION_ROUTE,
  // Experiment operations
  LIST_EXPERIMENTS_ROUTE,
  TRIGGER_EXPERIMENT_ROUTE,
  GET_EXPERIMENT_ROUTE,
  LIST_EXPERIMENT_RESULTS_ROUTE,
  // Analytics
  COMPARE_EXPERIMENTS_ROUTE
];

// src/server/server-adapter/routes/legacy.ts
var LEGACY_ROUTES = [
  // ============================================================================
  // Legacy Agent Routes
  // ============================================================================
  GENERATE_LEGACY_ROUTE,
  STREAM_GENERATE_LEGACY_ROUTE,
  // ============================================================================
  // Legacy Workflow Routes
  // ============================================================================
  STREAM_LEGACY_WORKFLOW_ROUTE,
  OBSERVE_STREAM_LEGACY_WORKFLOW_ROUTE,
  // ============================================================================
  // Legacy Agent Builder Routes
  // ============================================================================
  STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE,
  OBSERVE_STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE
];

// src/server/server-adapter/routes/logs.ts
var LOGS_ROUTES = [
  LIST_LOG_TRANSPORTS_ROUTE,
  LIST_LOGS_ROUTE,
  LIST_LOGS_BY_RUN_ID_ROUTE
];

// src/server/server-adapter/routes/mcp.ts
var MCP_ROUTES = [
  // ============================================================================
  // MCP Server Registry Routes
  // ============================================================================
  LIST_MCP_SERVERS_ROUTE,
  GET_MCP_SERVER_DETAIL_ROUTE,
  // ============================================================================
  // MCP Server Tool Routes
  // ============================================================================
  LIST_MCP_SERVER_TOOLS_ROUTE,
  GET_MCP_SERVER_TOOL_DETAIL_ROUTE,
  EXECUTE_MCP_SERVER_TOOL_ROUTE,
  // ============================================================================
  // MCP Transport Routes (handled by adapters)
  // ============================================================================
  MCP_HTTP_TRANSPORT_ROUTE,
  MCP_SSE_TRANSPORT_ROUTE,
  MCP_SSE_MESSAGES_ROUTE
];

// src/server/server-adapter/routes/memory.ts
var MEMORY_ROUTES = [
  GET_MEMORY_STATUS_ROUTE,
  GET_MEMORY_CONFIG_ROUTE,
  GET_OBSERVATIONAL_MEMORY_ROUTE,
  AWAIT_BUFFER_STATUS_ROUTE,
  LIST_THREADS_ROUTE,
  GET_THREAD_BY_ID_ROUTE,
  LIST_MESSAGES_ROUTE,
  GET_WORKING_MEMORY_ROUTE,
  SAVE_MESSAGES_ROUTE,
  CREATE_THREAD_ROUTE,
  UPDATE_THREAD_ROUTE,
  DELETE_THREAD_ROUTE,
  CLONE_THREAD_ROUTE,
  UPDATE_WORKING_MEMORY_ROUTE,
  DELETE_MESSAGES_ROUTE,
  SEARCH_MEMORY_ROUTE,
  GET_MEMORY_STATUS_NETWORK_ROUTE,
  LIST_THREADS_NETWORK_ROUTE,
  GET_THREAD_BY_ID_NETWORK_ROUTE,
  LIST_MESSAGES_NETWORK_ROUTE,
  SAVE_MESSAGES_NETWORK_ROUTE,
  CREATE_THREAD_NETWORK_ROUTE,
  UPDATE_THREAD_NETWORK_ROUTE,
  DELETE_THREAD_NETWORK_ROUTE,
  DELETE_MESSAGES_NETWORK_ROUTE
];

// src/server/server-adapter/routes/observability.ts
var OBSERVABILITY_ROUTES = [
  LIST_TRACES_ROUTE,
  GET_TRACE_ROUTE,
  SCORE_TRACES_ROUTE,
  LIST_SCORES_BY_SPAN_ROUTE
];

// src/server/server-adapter/routes/processors.ts
var PROCESSORS_ROUTES = [
  LIST_PROCESSORS_ROUTE,
  GET_PROCESSOR_BY_ID_ROUTE,
  EXECUTE_PROCESSOR_ROUTE
];

// src/server/server-adapter/routes/scorers.ts
var SCORES_ROUTES = [
  LIST_SCORERS_ROUTE,
  GET_SCORER_ROUTE,
  LIST_SCORES_BY_RUN_ID_ROUTE,
  LIST_SCORES_BY_SCORER_ID_ROUTE,
  LIST_SCORES_BY_ENTITY_ID_ROUTE,
  SAVE_SCORE_ROUTE
];

// src/server/server-adapter/routes/stored-agents.ts
var STORED_AGENTS_ROUTES = [
  // ============================================================================
  // Stored Agents CRUD Routes
  // IMPORTANT: Routes with literal paths (e.g., /preview-instructions) must come
  // BEFORE routes with path parameters (e.g., /:storedAgentId) to ensure correct matching.
  // ============================================================================
  LIST_STORED_AGENTS_ROUTE,
  PREVIEW_INSTRUCTIONS_ROUTE,
  // Must be before GET_STORED_AGENT_ROUTE
  GET_STORED_AGENT_ROUTE,
  CREATE_STORED_AGENT_ROUTE,
  UPDATE_STORED_AGENT_ROUTE,
  DELETE_STORED_AGENT_ROUTE,
  // ============================================================================
  // Agent Versions Routes
  // IMPORTANT: Routes with literal paths (e.g., /compare) must come BEFORE
  // routes with path parameters (e.g., /:versionId) to ensure correct matching.
  // ============================================================================
  LIST_AGENT_VERSIONS_ROUTE,
  CREATE_AGENT_VERSION_ROUTE,
  COMPARE_AGENT_VERSIONS_ROUTE,
  // Must be before GET_AGENT_VERSION_ROUTE
  GET_AGENT_VERSION_ROUTE,
  ACTIVATE_AGENT_VERSION_ROUTE,
  RESTORE_AGENT_VERSION_ROUTE,
  DELETE_AGENT_VERSION_ROUTE
];

// src/server/server-adapter/routes/stored-mcp-clients.ts
var STORED_MCP_CLIENTS_ROUTES = [
  // Stored MCP Clients CRUD Routes
  LIST_STORED_MCP_CLIENTS_ROUTE,
  GET_STORED_MCP_CLIENT_ROUTE,
  CREATE_STORED_MCP_CLIENT_ROUTE,
  UPDATE_STORED_MCP_CLIENT_ROUTE,
  DELETE_STORED_MCP_CLIENT_ROUTE
];

// src/server/server-adapter/routes/stored-scorers.ts
var STORED_SCORERS_ROUTES = [
  // Stored Scorers CRUD Routes
  LIST_STORED_SCORERS_ROUTE,
  GET_STORED_SCORER_ROUTE,
  CREATE_STORED_SCORER_ROUTE,
  UPDATE_STORED_SCORER_ROUTE,
  DELETE_STORED_SCORER_ROUTE
];

// src/server/server-adapter/routes/system.ts
var SYSTEM_ROUTES = [GET_SYSTEM_PACKAGES_ROUTE];

// src/server/server-adapter/routes/tool-providers.ts
var TOOL_PROVIDER_ROUTES = [
  LIST_TOOL_PROVIDERS_ROUTE,
  LIST_TOOL_PROVIDER_TOOLKITS_ROUTE,
  LIST_TOOL_PROVIDER_TOOLS_ROUTE,
  GET_TOOL_PROVIDER_TOOL_SCHEMA_ROUTE
];

// src/server/server-adapter/routes/tools.ts
var TOOLS_ROUTES = [LIST_TOOLS_ROUTE, GET_TOOL_BY_ID_ROUTE, EXECUTE_TOOL_ROUTE];

// src/server/server-adapter/routes/vectors.ts
var VECTORS_ROUTES = [
  UPSERT_VECTORS_ROUTE,
  CREATE_INDEX_ROUTE,
  QUERY_VECTORS_ROUTE,
  LIST_INDEXES_ROUTE,
  DESCRIBE_INDEX_ROUTE,
  DELETE_INDEX_ROUTE,
  LIST_VECTORS_ROUTE,
  LIST_EMBEDDERS_ROUTE
];

// src/server/server-adapter/routes/workflows.ts
var WORKFLOWS_ROUTES = [
  LIST_WORKFLOWS_ROUTE,
  GET_WORKFLOW_BY_ID_ROUTE,
  LIST_WORKFLOW_RUNS_ROUTE,
  GET_WORKFLOW_RUN_BY_ID_ROUTE,
  DELETE_WORKFLOW_RUN_BY_ID_ROUTE,
  CREATE_WORKFLOW_RUN_ROUTE,
  STREAM_WORKFLOW_ROUTE,
  RESUME_STREAM_WORKFLOW_ROUTE,
  START_ASYNC_WORKFLOW_ROUTE,
  START_WORKFLOW_RUN_ROUTE,
  OBSERVE_STREAM_WORKFLOW_ROUTE,
  RESUME_ASYNC_WORKFLOW_ROUTE,
  RESUME_WORKFLOW_ROUTE,
  CANCEL_WORKFLOW_RUN_ROUTE,
  TIME_TRAVEL_WORKFLOW_ROUTE,
  TIME_TRAVEL_ASYNC_WORKFLOW_ROUTE,
  TIME_TRAVEL_STREAM_WORKFLOW_ROUTE,
  RESTART_WORKFLOW_ROUTE,
  RESTART_ASYNC_WORKFLOW_ROUTE,
  RESTART_ALL_ACTIVE_WORKFLOW_RUNS_ROUTE,
  RESTART_ALL_ACTIVE_WORKFLOW_RUNS_ASYNC_ROUTE
];

// src/server/server-adapter/routes/workspace.ts
var WORKSPACE_ROUTES = [
  // List all workspaces route (at /api/workspaces)
  LIST_WORKSPACES_ROUTE,
  // Get workspace route (at /api/workspaces/:workspaceId)
  GET_WORKSPACE_ROUTE,
  // Filesystem routes (at /api/workspaces/:workspaceId/fs/*)
  ...WORKSPACE_FS_ROUTES,
  // Search routes (at /api/workspaces/:workspaceId/search, /api/workspaces/:workspaceId/index)
  ...WORKSPACE_SEARCH_ROUTES,
  // Skills routes (search must come before parameterized routes)
  ...WORKSPACE_SKILLS_ROUTES,
  // skills.sh proxy routes (at /api/workspaces/:workspaceId/skills-sh/*)
  ...WORKSPACE_SKILLS_SH_ROUTES
];

// src/server/server-adapter/routes/index.ts
var SERVER_ROUTES = [
  ...AGENTS_ROUTES,
  ...WORKFLOWS_ROUTES,
  ...TOOLS_ROUTES,
  ...PROCESSORS_ROUTES,
  ...MEMORY_ROUTES,
  ...SCORES_ROUTES,
  ...OBSERVABILITY_ROUTES,
  ...LOGS_ROUTES,
  ...VECTORS_ROUTES,
  ...A2A_ROUTES,
  ...AGENT_BUILDER_ROUTES,
  ...WORKSPACE_ROUTES,
  ...LEGACY_ROUTES,
  ...MCP_ROUTES,
  ...STORED_AGENTS_ROUTES,
  ...STORED_MCP_CLIENTS_ROUTES,
  ...STORED_SCORERS_ROUTES,
  ...TOOL_PROVIDER_ROUTES,
  ...SYSTEM_ROUTES,
  ...DATASETS_ROUTES
];

// src/server/server-adapter/redact.ts
function redactV2Payload(payload) {
  const redactedPayload = { ...payload };
  if (redactedPayload.metadata && typeof redactedPayload.metadata === "object") {
    const { request, ...metadataRest } = redactedPayload.metadata;
    redactedPayload.metadata = metadataRest;
  }
  if (redactedPayload.output && typeof redactedPayload.output === "object") {
    const output = { ...redactedPayload.output };
    if (Array.isArray(output.steps)) {
      output.steps = output.steps.map((step) => {
        if (step && typeof step === "object") {
          const { request, ...stepRest } = step;
          return stepRest;
        }
        return step;
      });
    }
    redactedPayload.output = output;
  }
  return redactedPayload;
}
function redactStreamChunk(chunk) {
  if (!chunk || typeof chunk !== "object") {
    return chunk;
  }
  const typedChunk = chunk;
  switch (chunk.type) {
    case "step-start": {
      if ("payload" in typedChunk && typedChunk.payload && typeof typedChunk.payload === "object") {
        const { payload, ...rest } = typedChunk;
        const { request, ...payloadRest } = payload;
        return {
          ...rest,
          type: "step-start",
          payload: {
            ...payloadRest,
            // Keep an empty request object to maintain structure but remove body
            request: {}
          }
        };
      } else if ("request" in typedChunk) {
        const { request, ...rest } = typedChunk;
        return {
          ...rest,
          type: "step-start",
          // Keep an empty request object to maintain structure
          request: {}
        };
      }
      return chunk;
    }
    case "step-finish": {
      if ("payload" in typedChunk && typedChunk.payload && typeof typedChunk.payload === "object") {
        const { payload, ...rest } = typedChunk;
        return {
          ...rest,
          type: "step-finish",
          payload: redactV2Payload(payload)
        };
      } else if ("request" in typedChunk) {
        const { request, ...rest } = typedChunk;
        return {
          ...rest,
          type: "step-finish"
        };
      }
      return chunk;
    }
    case "finish": {
      if ("payload" in typedChunk && typedChunk.payload && typeof typedChunk.payload === "object") {
        const { payload, ...rest } = typedChunk;
        return {
          ...rest,
          type: "finish",
          payload: redactV2Payload(payload)
        };
      } else if ("request" in typedChunk) {
        const { request, ...rest } = typedChunk;
        return {
          ...rest,
          type: "finish"
        };
      }
      return chunk;
    }
    default:
      return chunk;
  }
}

// src/server/server-adapter/index.ts
function normalizeQueryParams(rawQuery) {
  const queryParams = {};
  const bracketGroups = {};
  for (const [key, value] of Object.entries(rawQuery)) {
    const bracketMatch = key.match(/^([^[]+)\[([^\]]+)\]$/);
    if (bracketMatch) {
      const parent = bracketMatch[1];
      const child = bracketMatch[2];
      const strValue = Array.isArray(value) ? value.filter((v) => typeof v === "string")[0] : typeof value === "string" ? value : void 0;
      if (strValue !== void 0) {
        if (!bracketGroups[parent]) {
          bracketGroups[parent] = {};
        }
        bracketGroups[parent][child] = strValue;
      }
    } else if (typeof value === "string") {
      queryParams[key] = value;
    } else if (Array.isArray(value)) {
      const stringValues = value.filter((v) => typeof v === "string");
      queryParams[key] = stringValues.length === 1 ? stringValues[0] : stringValues;
    }
  }
  for (const [parent, children] of Object.entries(bracketGroups)) {
    if (!(parent in queryParams)) {
      queryParams[parent] = JSON.stringify(children);
    }
  }
  return queryParams;
}
var MastraServer$1 = class MastraServer extends MastraServerBase {
  mastra;
  bodyLimitOptions;
  tools;
  prefix;
  openapiPath;
  taskStore;
  customRouteAuthConfig;
  streamOptions;
  customApiRoutes;
  mcpOptions;
  customRouteHandler = null;
  constructor({
    app,
    mastra,
    bodyLimitOptions,
    tools,
    prefix = "/api",
    openapiPath = "",
    taskStore,
    customRouteAuthConfig,
    streamOptions,
    customApiRoutes,
    mcpOptions
  }) {
    super({ app, name: "MastraServer" });
    this.mastra = mastra;
    this.bodyLimitOptions = bodyLimitOptions;
    this.tools = tools;
    this.prefix = normalizeRoutePath(prefix);
    this.openapiPath = openapiPath;
    this.taskStore = taskStore;
    this.customRouteAuthConfig = customRouteAuthConfig;
    this.streamOptions = { redact: true, ...streamOptions };
    this.customApiRoutes = customApiRoutes;
    this.mcpOptions = mcpOptions;
    mastra.setMastraServer(this);
  }
  mergeRequestContext({
    paramsRequestContext,
    bodyRequestContext
  }) {
    const requestContext = new RequestContext();
    if (bodyRequestContext) {
      for (const [key, value] of Object.entries(bodyRequestContext)) {
        requestContext.set(key, value);
      }
    }
    if (paramsRequestContext) {
      for (const [key, value] of Object.entries(paramsRequestContext)) {
        requestContext.set(key, value);
      }
    }
    return requestContext;
  }
  /**
   * Check if the current request should be authenticated/authorized.
   * Returns null if auth passes, or an error response if it fails.
   *
   * This method encapsulates the complete auth flow:
   * 1. Check if route requires auth (route.requiresAuth)
   * 2. Check if it's a dev playground request
   * 3. Check if path is publicly accessible
   * 4. Perform authentication (verify token)
   * 5. Perform authorization (check rules, authorizeUser, authorize)
   */
  async checkRouteAuth(route, context) {
    const authConfig = this.mastra.getServer()?.auth;
    if (!authConfig) {
      return null;
    }
    if (route.requiresAuth === false) {
      return null;
    }
    if (isDevPlaygroundRequest(context.path, context.method, context.getHeader, authConfig)) {
      return null;
    }
    if (canAccessPublicly(context.path, context.method, authConfig)) {
      return null;
    }
    const authHeader = context.getHeader("authorization");
    let token = authHeader ? authHeader.replace("Bearer ", "") : null;
    if (!token) {
      token = context.getQuery("apiKey") || null;
    }
    if (!token) {
      return { status: 401, error: "Authentication required" };
    }
    let user;
    try {
      if (typeof authConfig.authenticateToken === "function") {
        user = await authConfig.authenticateToken(token, null);
      } else {
        return { status: 401, error: "No token verification method configured" };
      }
      if (!user) {
        return { status: 401, error: "Invalid or expired token" };
      }
      context.requestContext.set("user", user);
    } catch (err) {
      this.mastra.getLogger()?.error("Authentication error", {
        error: err instanceof Error ? { message: err.message, stack: err.stack } : err
      });
      return { status: 401, error: "Invalid or expired token" };
    }
    if ("authorizeUser" in authConfig && typeof authConfig.authorizeUser === "function") {
      try {
        const isAuthorized = await authConfig.authorizeUser(user, null);
        if (!isAuthorized) {
          return { status: 403, error: "Access denied" };
        }
        return null;
      } catch (err) {
        this.mastra.getLogger()?.error("Authorization error in authorizeUser", {
          error: err instanceof Error ? { message: err.message, stack: err.stack } : err
        });
        return { status: 500, error: "Authorization error" };
      }
    }
    if ("authorize" in authConfig && typeof authConfig.authorize === "function") {
      try {
        const isAuthorized = await authConfig.authorize(context.path, context.method, user, null);
        if (!isAuthorized) {
          return { status: 403, error: "Access denied" };
        }
        return null;
      } catch (err) {
        this.mastra.getLogger()?.error("Authorization error in authorize", {
          error: err instanceof Error ? { message: err.message, stack: err.stack } : err,
          path: context.path,
          method: context.method
        });
        return { status: 500, error: "Authorization error" };
      }
    }
    if ("rules" in authConfig && authConfig.rules && authConfig.rules.length > 0) {
      const isAuthorized = await checkRules(authConfig.rules, context.path, context.method, user);
      if (isAuthorized) {
        return null;
      }
      return { status: 403, error: "Access denied" };
    }
    if (defaultAuthConfig.rules && defaultAuthConfig.rules.length > 0) {
      const isAuthorized = await checkRules(defaultAuthConfig.rules, context.path, context.method, user);
      if (isAuthorized) {
        return null;
      }
    }
    return { status: 403, error: "Access denied" };
  }
  async init() {
    this.registerContextMiddleware();
    this.registerAuthMiddleware();
    await this.registerCustomApiRoutes();
    await this.registerRoutes();
  }
  /**
   * Override in adapters to register custom API routes defined via registerApiRoute().
   * Called by init() between registerAuthMiddleware() and registerRoutes().
   */
  async registerCustomApiRoutes() {
  }
  /**
   * Creates an internal Hono sub-app with all custom API routes registered.
   * Stores the handler on this instance for use by handleCustomRouteRequest().
   * Returns true if custom routes were found and registered.
   */
  async buildCustomRouteHandler() {
    const routes = this.customApiRoutes ?? this.mastra.getServer()?.apiRoutes;
    if (!routes || routes.length === 0) return false;
    const NOT_FOUND_HEADER = "x-mastra-custom-route-not-found";
    const mastra = this.mastra;
    const app = new Hono();
    app.use("*", async (c, next) => {
      c.set("mastra", mastra);
      c.set("requestContext", c.env?.requestContext ?? new RequestContext());
      await next();
    });
    for (const route of routes) {
      const handler = "handler" in route && route.handler ? route.handler : "createHandler" in route ? await route.createHandler({ mastra }) : void 0;
      if (!handler) continue;
      const middlewares = [];
      if (route.middleware) {
        middlewares.push(...Array.isArray(route.middleware) ? route.middleware : [route.middleware]);
      }
      const allHandlers = [...middlewares, handler];
      if (route.method === "ALL") {
        app.all(route.path, allHandlers[0], ...allHandlers.slice(1));
      } else {
        app.on(route.method, route.path, allHandlers[0], ...allHandlers.slice(1));
      }
    }
    app.notFound(() => new Response(null, { status: 404, headers: { [NOT_FOUND_HEADER]: "true" } }));
    this.customRouteHandler = async (request, env) => app.fetch(request, env);
    return true;
  }
  /**
   * Forwards a request to the internal custom route handler.
   * Returns the Response if a custom route matched, or null to fall through.
   * Used by non-Hono adapter bridges.
   */
  async handleCustomRouteRequest(url, method, headers, body, requestContext) {
    if (!this.customRouteHandler) return null;
    const fetchHeaders = new Headers();
    for (const [key, value] of Object.entries(headers)) {
      if (typeof value === "string") fetchHeaders.set(key, value);
      else if (Array.isArray(value))
        value.forEach((v) => {
          fetchHeaders.append(key, v);
        });
    }
    const init = { method, headers: fetchHeaders };
    if (["POST", "PUT", "PATCH"].includes(method) && body !== void 0) {
      const contentType = (typeof headers["content-type"] === "string" ? headers["content-type"] : "") || "";
      if (contentType.includes("application/json")) {
        init.body = JSON.stringify(body);
      } else if (typeof body === "string") {
        init.body = body;
      } else if (body instanceof ArrayBuffer || body instanceof Uint8Array || body instanceof ReadableStream) {
        init.body = body;
      }
    }
    const request = new globalThis.Request(url, init);
    const response = await this.customRouteHandler(request, { requestContext });
    if (response.headers.get("x-mastra-custom-route-not-found") === "true") return null;
    return response;
  }
  /**
   * Pipes a custom route Response to a Node.js ServerResponse (http.ServerResponse).
   * Works with Koa (ctx.res), Express (res), and Fastify (reply.raw).
   */
  async writeCustomRouteResponse(response, nodeRes) {
    const headers = {};
    response.headers.forEach((value, key) => {
      if (key.toLowerCase() !== "set-cookie") {
        headers[key] = value;
      }
    });
    const setCookies = response.headers.getSetCookie?.();
    if (setCookies && setCookies.length > 0) {
      headers["set-cookie"] = setCookies;
    }
    nodeRes.writeHead(response.status, headers);
    if (response.body) {
      const reader = response.body.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          nodeRes.write(value);
        }
      } finally {
        nodeRes.end();
      }
    } else {
      nodeRes.end(await response.text());
    }
  }
  async registerOpenAPIRoute(app, config = {}, { prefix }) {
    const {
      title = "Mastra API",
      version = "1.0.0",
      description = "Mastra Server API",
      path = "/openapi.json"
    } = config;
    const openApiSpec = generateOpenAPIDocument(SERVER_ROUTES, {
      title,
      version,
      description
    });
    if (prefix) {
      openApiSpec.servers = [{ url: prefix }];
    }
    if (this.customApiRoutes && this.customApiRoutes.length > 0) {
      const customPaths = convertCustomRoutesToOpenAPIPaths(this.customApiRoutes);
      openApiSpec.paths = { ...openApiSpec.paths, ...customPaths };
    }
    const openApiRoute = {
      method: "GET",
      path,
      responseType: "json",
      handler: async () => openApiSpec
    };
    await this.registerRoute(app, openApiRoute, { prefix });
  }
  async registerRoutes() {
    for (const route of SERVER_ROUTES) {
      await this.registerRoute(this.app, route, { prefix: this.prefix });
    }
    if (this.openapiPath) {
      await this.registerOpenAPIRoute(
        this.app,
        {
          title: "Mastra API",
          version: "1.0.0",
          description: "Mastra Server API",
          path: this.openapiPath
        },
        { prefix: this.prefix }
      );
    }
  }
  async parsePathParams(route, params) {
    const pathParamSchema = route.pathParamSchema;
    if (!pathParamSchema) {
      return params;
    }
    return pathParamSchema.parseAsync(params);
  }
  async parseQueryParams(route, params) {
    const queryParamSchema = route.queryParamSchema;
    if (!queryParamSchema) {
      return params;
    }
    return queryParamSchema.parseAsync(params);
  }
  async parseBody(route, body) {
    const bodySchema = route.bodySchema;
    if (!bodySchema) {
      return body;
    }
    return bodySchema.parseAsync(body);
  }
};

// src/server/a2a/store.ts
var InMemoryTaskStore = class {
  store = /* @__PURE__ */ new Map();
  activeCancellations = /* @__PURE__ */ new Set();
  async load({ agentId, taskId }) {
    const entry = this.store.get(`${agentId}-${taskId}`);
    if (!entry) {
      return null;
    }
    return { ...entry };
  }
  async save({ agentId, data }) {
    const key = `${agentId}-${data.id}`;
    if (!data.id) {
      throw new Error("Task ID is required");
    }
    this.store.set(key, { ...data });
  }
};

// src/middleware/cors/index.ts
var cors = (options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      if (optsOrigin === "*") {
        return () => optsOrigin;
      } else {
        return (origin) => optsOrigin === origin ? origin : null;
      }
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : null;
    }
  })(opts.origin);
  const findAllowMethods = ((optsAllowMethods) => {
    if (typeof optsAllowMethods === "function") {
      return optsAllowMethods;
    } else if (Array.isArray(optsAllowMethods)) {
      return () => optsAllowMethods;
    } else {
      return () => [];
    }
  })(opts.allowMethods);
  return async function cors2(c, next) {
    function set(key, value) {
      c.res.headers.set(key, value);
    }
    const allowOrigin = await findAllowOrigin(c.req.header("origin") || "", c);
    if (allowOrigin) {
      set("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.credentials) {
      set("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c.req.method === "OPTIONS") {
      if (opts.origin !== "*") {
        set("Vary", "Origin");
      }
      if (opts.maxAge != null) {
        set("Access-Control-Max-Age", opts.maxAge.toString());
      }
      const allowMethods = await findAllowMethods(c.req.header("origin") || "", c);
      if (allowMethods.length) {
        set("Access-Control-Allow-Methods", allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set("Access-Control-Allow-Headers", headers.join(","));
        c.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c.res.headers.delete("Content-Length");
      c.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: "No Content"
      });
    }
    await next();
    if (opts.origin !== "*") {
      c.header("Vary", "Origin", { append: true });
    }
  };
};

// src/utils/color.ts
function getColorEnabled() {
  const { process, Deno } = globalThis;
  const isNoColor = typeof Deno?.noColor === "boolean" ? Deno.noColor : process !== void 0 ? (
    // eslint-disable-next-line no-unsafe-optional-chaining
    "NO_COLOR" in process?.env
  ) : false;
  return !isNoColor;
}
async function getColorEnabledAsync() {
  const { navigator } = globalThis;
  const cfWorkers = "cloudflare:workers";
  const isNoColor = navigator !== void 0 && navigator.userAgent === "Cloudflare-Workers" ? await (async () => {
    try {
      return "NO_COLOR" in ((await import(cfWorkers)).env ?? {});
    } catch {
      return false;
    }
  })() : !getColorEnabled();
  return !isNoColor;
}

// src/middleware/logger/index.ts
var humanize = (times) => {
  const [delimiter, separator] = [",", "."];
  const orderTimes = times.map((v) => v.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1" + delimiter));
  return orderTimes.join(separator);
};
var time = (start) => {
  const delta = Date.now() - start;
  return humanize([delta < 1e3 ? delta + "ms" : Math.round(delta / 1e3) + "s"]);
};
var colorStatus = async (status) => {
  const colorEnabled = await getColorEnabledAsync();
  if (colorEnabled) {
    switch (status / 100 | 0) {
      case 5:
        return `\x1B[31m${status}\x1B[0m`;
      case 4:
        return `\x1B[33m${status}\x1B[0m`;
      case 3:
        return `\x1B[36m${status}\x1B[0m`;
      case 2:
        return `\x1B[32m${status}\x1B[0m`;
    }
  }
  return `${status}`;
};
async function log(fn, prefix, method, path, status = 0, elapsed) {
  const out = prefix === "<--" /* Incoming */ ? `${prefix} ${method} ${path}` : `${prefix} ${method} ${path} ${await colorStatus(status)} ${elapsed}`;
  fn(out);
}
var logger = (fn = console.log) => {
  return async function logger2(c, next) {
    const { method, url } = c.req;
    const path = url.slice(url.indexOf("/", 8));
    await log(fn, "<--" /* Incoming */, method, path);
    const start = Date.now();
    await next();
    await log(fn, "-->" /* Outgoing */, method, path, c.res.status, time(start));
  };
};

// src/middleware/timeout/index.ts
var defaultTimeoutException = new HTTPException$1(504, {
  message: "Gateway Timeout"
});
var timeout = (duration, exception = defaultTimeoutException) => {
  return async function timeout2(context, next) {
    let timer;
    const timeoutPromise = new Promise((_, reject) => {
      timer = setTimeout(() => {
        reject(typeof exception === "function" ? exception(context) : exception);
      }, duration);
    });
    try {
      await Promise.race([next(), timeoutPromise]);
    } finally {
      if (timer !== void 0) {
        clearTimeout(timer);
      }
    }
  };
};

var RequestError = class extends Error {
  constructor(message, options) {
    super(message, options);
    this.name = "RequestError";
  }
};
var toRequestError = (e) => {
  if (e instanceof RequestError) {
    return e;
  }
  return new RequestError(e.message, { cause: e });
};
var GlobalRequest = global.Request;
var Request2 = class extends GlobalRequest {
  constructor(input, options) {
    if (typeof input === "object" && getRequestCache in input) {
      input = input[getRequestCache]();
    }
    if (typeof options?.body?.getReader !== "undefined") {
      options.duplex ??= "half";
    }
    super(input, options);
  }
};
var newHeadersFromIncoming = (incoming) => {
  const headerRecord = [];
  const rawHeaders = incoming.rawHeaders;
  for (let i = 0; i < rawHeaders.length; i += 2) {
    const { [i]: key, [i + 1]: value } = rawHeaders;
    if (key.charCodeAt(0) !== /*:*/
    58) {
      headerRecord.push([key, value]);
    }
  }
  return new Headers(headerRecord);
};
var wrapBodyStream = /* @__PURE__ */ Symbol("wrapBodyStream");
var newRequestFromIncoming = (method, url, headers, incoming, abortController) => {
  const init = {
    method,
    headers,
    signal: abortController.signal
  };
  if (method === "TRACE") {
    init.method = "GET";
    const req = new Request2(url, init);
    Object.defineProperty(req, "method", {
      get() {
        return "TRACE";
      }
    });
    return req;
  }
  if (!(method === "GET" || method === "HEAD")) {
    if ("rawBody" in incoming && incoming.rawBody instanceof Buffer) {
      init.body = new ReadableStream({
        start(controller) {
          controller.enqueue(incoming.rawBody);
          controller.close();
        }
      });
    } else if (incoming[wrapBodyStream]) {
      let reader;
      init.body = new ReadableStream({
        async pull(controller) {
          try {
            reader ||= Readable.toWeb(incoming).getReader();
            const { done, value } = await reader.read();
            if (done) {
              controller.close();
            } else {
              controller.enqueue(value);
            }
          } catch (error) {
            controller.error(error);
          }
        }
      });
    } else {
      init.body = Readable.toWeb(incoming);
    }
  }
  return new Request2(url, init);
};
var getRequestCache = /* @__PURE__ */ Symbol("getRequestCache");
var requestCache = /* @__PURE__ */ Symbol("requestCache");
var incomingKey = /* @__PURE__ */ Symbol("incomingKey");
var urlKey = /* @__PURE__ */ Symbol("urlKey");
var headersKey = /* @__PURE__ */ Symbol("headersKey");
var abortControllerKey = /* @__PURE__ */ Symbol("abortControllerKey");
var getAbortController = /* @__PURE__ */ Symbol("getAbortController");
var requestPrototype = {
  get method() {
    return this[incomingKey].method || "GET";
  },
  get url() {
    return this[urlKey];
  },
  get headers() {
    return this[headersKey] ||= newHeadersFromIncoming(this[incomingKey]);
  },
  [getAbortController]() {
    this[getRequestCache]();
    return this[abortControllerKey];
  },
  [getRequestCache]() {
    this[abortControllerKey] ||= new AbortController();
    return this[requestCache] ||= newRequestFromIncoming(
      this.method,
      this[urlKey],
      this.headers,
      this[incomingKey],
      this[abortControllerKey]
    );
  }
};
[
  "body",
  "bodyUsed",
  "cache",
  "credentials",
  "destination",
  "integrity",
  "mode",
  "redirect",
  "referrer",
  "referrerPolicy",
  "signal",
  "keepalive"
].forEach((k) => {
  Object.defineProperty(requestPrototype, k, {
    get() {
      return this[getRequestCache]()[k];
    }
  });
});
["arrayBuffer", "blob", "clone", "formData", "json", "text"].forEach((k) => {
  Object.defineProperty(requestPrototype, k, {
    value: function() {
      return this[getRequestCache]()[k]();
    }
  });
});
Object.setPrototypeOf(requestPrototype, Request2.prototype);
var newRequest = (incoming, defaultHostname) => {
  const req = Object.create(requestPrototype);
  req[incomingKey] = incoming;
  const incomingUrl = incoming.url || "";
  if (incomingUrl[0] !== "/" && // short-circuit for performance. most requests are relative URL.
  (incomingUrl.startsWith("http://") || incomingUrl.startsWith("https://"))) {
    if (incoming instanceof Http2ServerRequest) {
      throw new RequestError("Absolute URL for :path is not allowed in HTTP/2");
    }
    try {
      const url2 = new URL(incomingUrl);
      req[urlKey] = url2.href;
    } catch (e) {
      throw new RequestError("Invalid absolute URL", { cause: e });
    }
    return req;
  }
  const host = (incoming instanceof Http2ServerRequest ? incoming.authority : incoming.headers.host) || defaultHostname;
  if (!host) {
    throw new RequestError("Missing host header");
  }
  let scheme;
  if (incoming instanceof Http2ServerRequest) {
    scheme = incoming.scheme;
    if (!(scheme === "http" || scheme === "https")) {
      throw new RequestError("Unsupported scheme");
    }
  } else {
    scheme = incoming.socket && incoming.socket.encrypted ? "https" : "http";
  }
  const url = new URL(`${scheme}://${host}${incomingUrl}`);
  if (url.hostname.length !== host.length && url.hostname !== host.replace(/:\d+$/, "")) {
    throw new RequestError("Invalid host header");
  }
  req[urlKey] = url.href;
  return req;
};
var responseCache = /* @__PURE__ */ Symbol("responseCache");
var getResponseCache = /* @__PURE__ */ Symbol("getResponseCache");
var cacheKey = /* @__PURE__ */ Symbol("cache");
var GlobalResponse = global.Response;
var Response2 = class _Response {
  #body;
  #init;
  [getResponseCache]() {
    delete this[cacheKey];
    return this[responseCache] ||= new GlobalResponse(this.#body, this.#init);
  }
  constructor(body, init) {
    let headers;
    this.#body = body;
    if (init instanceof _Response) {
      const cachedGlobalResponse = init[responseCache];
      if (cachedGlobalResponse) {
        this.#init = cachedGlobalResponse;
        this[getResponseCache]();
        return;
      } else {
        this.#init = init.#init;
        headers = new Headers(init.#init.headers);
      }
    } else {
      this.#init = init;
    }
    if (typeof body === "string" || typeof body?.getReader !== "undefined" || body instanceof Blob || body instanceof Uint8Array) {
      headers ||= init?.headers || { "content-type": "text/plain; charset=UTF-8" };
      this[cacheKey] = [init?.status || 200, body, headers];
    }
  }
  get headers() {
    const cache = this[cacheKey];
    if (cache) {
      if (!(cache[2] instanceof Headers)) {
        cache[2] = new Headers(cache[2]);
      }
      return cache[2];
    }
    return this[getResponseCache]().headers;
  }
  get status() {
    return this[cacheKey]?.[0] ?? this[getResponseCache]().status;
  }
  get ok() {
    const status = this.status;
    return status >= 200 && status < 300;
  }
};
["body", "bodyUsed", "redirected", "statusText", "trailers", "type", "url"].forEach((k) => {
  Object.defineProperty(Response2.prototype, k, {
    get() {
      return this[getResponseCache]()[k];
    }
  });
});
["arrayBuffer", "blob", "clone", "formData", "json", "text"].forEach((k) => {
  Object.defineProperty(Response2.prototype, k, {
    value: function() {
      return this[getResponseCache]()[k]();
    }
  });
});
Object.setPrototypeOf(Response2, GlobalResponse);
Object.setPrototypeOf(Response2.prototype, GlobalResponse.prototype);
async function readWithoutBlocking(readPromise) {
  return Promise.race([readPromise, Promise.resolve().then(() => Promise.resolve(void 0))]);
}
function writeFromReadableStreamDefaultReader(reader, writable, currentReadPromise) {
  const cancel = (error) => {
    reader.cancel(error).catch(() => {
    });
  };
  writable.on("close", cancel);
  writable.on("error", cancel);
  (currentReadPromise ?? reader.read()).then(flow, handleStreamError);
  return reader.closed.finally(() => {
    writable.off("close", cancel);
    writable.off("error", cancel);
  });
  function handleStreamError(error) {
    if (error) {
      writable.destroy(error);
    }
  }
  function onDrain() {
    reader.read().then(flow, handleStreamError);
  }
  function flow({ done, value }) {
    try {
      if (done) {
        writable.end();
      } else if (!writable.write(value)) {
        writable.once("drain", onDrain);
      } else {
        return reader.read().then(flow, handleStreamError);
      }
    } catch (e) {
      handleStreamError(e);
    }
  }
}
function writeFromReadableStream(stream2, writable) {
  if (stream2.locked) {
    throw new TypeError("ReadableStream is locked.");
  } else if (writable.destroyed) {
    return;
  }
  return writeFromReadableStreamDefaultReader(stream2.getReader(), writable);
}
var buildOutgoingHttpHeaders = (headers) => {
  const res = {};
  if (!(headers instanceof Headers)) {
    headers = new Headers(headers ?? void 0);
  }
  const cookies = [];
  for (const [k, v] of headers) {
    if (k === "set-cookie") {
      cookies.push(v);
    } else {
      res[k] = v;
    }
  }
  if (cookies.length > 0) {
    res["set-cookie"] = cookies;
  }
  res["content-type"] ??= "text/plain; charset=UTF-8";
  return res;
};
var X_ALREADY_SENT = "x-hono-already-sent";
if (typeof global.crypto === "undefined") {
  global.crypto = crypto$1;
}
var outgoingEnded = /* @__PURE__ */ Symbol("outgoingEnded");
var handleRequestError = () => new Response(null, {
  status: 400
});
var handleFetchError = (e) => new Response(null, {
  status: e instanceof Error && (e.name === "TimeoutError" || e.constructor.name === "TimeoutError") ? 504 : 500
});
var handleResponseError = (e, outgoing) => {
  const err = e instanceof Error ? e : new Error("unknown error", { cause: e });
  if (err.code === "ERR_STREAM_PREMATURE_CLOSE") {
    console.info("The user aborted a request.");
  } else {
    console.error(e);
    if (!outgoing.headersSent) {
      outgoing.writeHead(500, { "Content-Type": "text/plain" });
    }
    outgoing.end(`Error: ${err.message}`);
    outgoing.destroy(err);
  }
};
var flushHeaders = (outgoing) => {
  if ("flushHeaders" in outgoing && outgoing.writable) {
    outgoing.flushHeaders();
  }
};
var responseViaCache = async (res, outgoing) => {
  let [status, body, header] = res[cacheKey];
  if (header instanceof Headers) {
    header = buildOutgoingHttpHeaders(header);
  }
  if (typeof body === "string") {
    header["Content-Length"] = Buffer.byteLength(body);
  } else if (body instanceof Uint8Array) {
    header["Content-Length"] = body.byteLength;
  } else if (body instanceof Blob) {
    header["Content-Length"] = body.size;
  }
  outgoing.writeHead(status, header);
  if (typeof body === "string" || body instanceof Uint8Array) {
    outgoing.end(body);
  } else if (body instanceof Blob) {
    outgoing.end(new Uint8Array(await body.arrayBuffer()));
  } else {
    flushHeaders(outgoing);
    await writeFromReadableStream(body, outgoing)?.catch(
      (e) => handleResponseError(e, outgoing)
    );
  }
  outgoing[outgoingEnded]?.();
};
var isPromise = (res) => typeof res.then === "function";
var responseViaResponseObject = async (res, outgoing, options = {}) => {
  if (isPromise(res)) {
    if (options.errorHandler) {
      try {
        res = await res;
      } catch (err) {
        const errRes = await options.errorHandler(err);
        if (!errRes) {
          return;
        }
        res = errRes;
      }
    } else {
      res = await res.catch(handleFetchError);
    }
  }
  if (cacheKey in res) {
    return responseViaCache(res, outgoing);
  }
  const resHeaderRecord = buildOutgoingHttpHeaders(res.headers);
  if (res.body) {
    const reader = res.body.getReader();
    const values = [];
    let done = false;
    let currentReadPromise = void 0;
    if (resHeaderRecord["transfer-encoding"] !== "chunked") {
      let maxReadCount = 2;
      for (let i = 0; i < maxReadCount; i++) {
        currentReadPromise ||= reader.read();
        const chunk = await readWithoutBlocking(currentReadPromise).catch((e) => {
          console.error(e);
          done = true;
        });
        if (!chunk) {
          if (i === 1) {
            await new Promise((resolve) => setTimeout(resolve));
            maxReadCount = 3;
            continue;
          }
          break;
        }
        currentReadPromise = void 0;
        if (chunk.value) {
          values.push(chunk.value);
        }
        if (chunk.done) {
          done = true;
          break;
        }
      }
      if (done && !("content-length" in resHeaderRecord)) {
        resHeaderRecord["content-length"] = values.reduce((acc, value) => acc + value.length, 0);
      }
    }
    outgoing.writeHead(res.status, resHeaderRecord);
    values.forEach((value) => {
      outgoing.write(value);
    });
    if (done) {
      outgoing.end();
    } else {
      if (values.length === 0) {
        flushHeaders(outgoing);
      }
      await writeFromReadableStreamDefaultReader(reader, outgoing, currentReadPromise);
    }
  } else if (resHeaderRecord[X_ALREADY_SENT]) ; else {
    outgoing.writeHead(res.status, resHeaderRecord);
    outgoing.end();
  }
  outgoing[outgoingEnded]?.();
};
var getRequestListener = (fetchCallback, options = {}) => {
  const autoCleanupIncoming = options.autoCleanupIncoming ?? true;
  if (options.overrideGlobalObjects !== false && global.Request !== Request2) {
    Object.defineProperty(global, "Request", {
      value: Request2
    });
    Object.defineProperty(global, "Response", {
      value: Response2
    });
  }
  return async (incoming, outgoing) => {
    let res, req;
    try {
      req = newRequest(incoming, options.hostname);
      let incomingEnded = !autoCleanupIncoming || incoming.method === "GET" || incoming.method === "HEAD";
      if (!incomingEnded) {
        incoming[wrapBodyStream] = true;
        incoming.on("end", () => {
          incomingEnded = true;
        });
        if (incoming instanceof Http2ServerRequest) {
          outgoing[outgoingEnded] = () => {
            if (!incomingEnded) {
              setTimeout(() => {
                if (!incomingEnded) {
                  setTimeout(() => {
                    incoming.destroy();
                    outgoing.destroy();
                  });
                }
              });
            }
          };
        }
      }
      outgoing.on("close", () => {
        const abortController = req[abortControllerKey];
        if (abortController) {
          if (incoming.errored) {
            req[abortControllerKey].abort(incoming.errored.toString());
          } else if (!outgoing.writableFinished) {
            req[abortControllerKey].abort("Client connection prematurely closed.");
          }
        }
        if (!incomingEnded) {
          setTimeout(() => {
            if (!incomingEnded) {
              setTimeout(() => {
                incoming.destroy();
              });
            }
          });
        }
      });
      res = fetchCallback(req, { incoming, outgoing });
      if (cacheKey in res) {
        return responseViaCache(res, outgoing);
      }
    } catch (e) {
      if (!res) {
        if (options.errorHandler) {
          res = await options.errorHandler(req ? e : toRequestError(e));
          if (!res) {
            return;
          }
        } else if (!req) {
          res = handleRequestError();
        } else {
          res = handleFetchError(e);
        }
      } else {
        return handleResponseError(e, outgoing);
      }
    }
    try {
      return await responseViaResponseObject(res, outgoing, options);
    } catch (e) {
      return handleResponseError(e, outgoing);
    }
  };
};
var createAdaptorServer = (options) => {
  const fetchCallback = options.fetch;
  const requestListener = getRequestListener(fetchCallback, {
    hostname: options.hostname,
    overrideGlobalObjects: options.overrideGlobalObjects,
    autoCleanupIncoming: options.autoCleanupIncoming
  });
  const createServer2 = options.createServer || createServer;
  const server = createServer2(options.serverOptions || {}, requestListener);
  return server;
};
var serve = (options, listeningListener) => {
  const server = createAdaptorServer(options);
  server.listen(options?.port ?? 3e3, options.hostname, () => {
    const serverInfo = server.address();
    listeningListener && listeningListener(serverInfo);
  });
  return server;
};
var COMPRESSIBLE_CONTENT_TYPE_REGEX = /^\s*(?:text\/[^;\s]+|application\/(?:javascript|json|xml|xml-dtd|ecmascript|dart|postscript|rtf|tar|toml|vnd\.dart|vnd\.ms-fontobject|vnd\.ms-opentype|wasm|x-httpd-php|x-javascript|x-ns-proxy-autoconfig|x-sh|x-tar|x-virtualbox-hdd|x-virtualbox-ova|x-virtualbox-ovf|x-virtualbox-vbox|x-virtualbox-vdi|x-virtualbox-vhd|x-virtualbox-vmdk|x-www-form-urlencoded)|font\/(?:otf|ttf)|image\/(?:bmp|vnd\.adobe\.photoshop|vnd\.microsoft\.icon|vnd\.ms-dds|x-icon|x-ms-bmp)|message\/rfc822|model\/gltf-binary|x-shader\/x-fragment|x-shader\/x-vertex|[^;\s]+?\+(?:json|text|xml|yaml))(?:[;\s]|$)/i;
var ENCODINGS = {
  br: ".br",
  zstd: ".zst",
  gzip: ".gz"
};
var ENCODINGS_ORDERED_KEYS = Object.keys(ENCODINGS);
var pr54206Applied = () => {
  const [major, minor] = versions.node.split(".").map((component) => parseInt(component));
  return major >= 23 || major === 22 && minor >= 7 || major === 20 && minor >= 18;
};
var useReadableToWeb = pr54206Applied();
var createStreamBody = (stream2) => {
  if (useReadableToWeb) {
    return Readable.toWeb(stream2);
  }
  const body = new ReadableStream({
    start(controller) {
      stream2.on("data", (chunk) => {
        controller.enqueue(chunk);
      });
      stream2.on("error", (err) => {
        controller.error(err);
      });
      stream2.on("end", () => {
        controller.close();
      });
    },
    cancel() {
      stream2.destroy();
    }
  });
  return body;
};
var getStats = (path) => {
  let stats;
  try {
    stats = statSync(path);
  } catch {
  }
  return stats;
};
var serveStatic = (options = { root: "" }) => {
  const root = options.root || "";
  const optionPath = options.path;
  if (root !== "" && !existsSync(root)) {
    console.error(`serveStatic: root path '${root}' is not found, are you sure it's correct?`);
  }
  return async (c, next) => {
    if (c.finalized) {
      return next();
    }
    let filename;
    if (optionPath) {
      filename = optionPath;
    } else {
      try {
        filename = decodeURIComponent(c.req.path);
        if (/(?:^|[\/\\])\.\.(?:$|[\/\\])/.test(filename)) {
          throw new Error();
        }
      } catch {
        await options.onNotFound?.(c.req.path, c);
        return next();
      }
    }
    let path = join(
      root,
      !optionPath && options.rewriteRequestPath ? options.rewriteRequestPath(filename, c) : filename
    );
    let stats = getStats(path);
    if (stats && stats.isDirectory()) {
      const indexFile = options.index ?? "index.html";
      path = join(path, indexFile);
      stats = getStats(path);
    }
    if (!stats) {
      await options.onNotFound?.(path, c);
      return next();
    }
    const mimeType = getMimeType(path);
    c.header("Content-Type", mimeType || "application/octet-stream");
    if (options.precompressed && (!mimeType || COMPRESSIBLE_CONTENT_TYPE_REGEX.test(mimeType))) {
      const acceptEncodingSet = new Set(
        c.req.header("Accept-Encoding")?.split(",").map((encoding) => encoding.trim())
      );
      for (const encoding of ENCODINGS_ORDERED_KEYS) {
        if (!acceptEncodingSet.has(encoding)) {
          continue;
        }
        const precompressedStats = getStats(path + ENCODINGS[encoding]);
        if (precompressedStats) {
          c.header("Content-Encoding", encoding);
          c.header("Vary", "Accept-Encoding", { append: true });
          stats = precompressedStats;
          path = path + ENCODINGS[encoding];
          break;
        }
      }
    }
    let result;
    const size = stats.size;
    const range = c.req.header("range") || "";
    if (c.req.method == "HEAD" || c.req.method == "OPTIONS") {
      c.header("Content-Length", size.toString());
      c.status(200);
      result = c.body(null);
    } else if (!range) {
      c.header("Content-Length", size.toString());
      result = c.body(createStreamBody(createReadStream(path)), 200);
    } else {
      c.header("Accept-Ranges", "bytes");
      c.header("Date", stats.birthtime.toUTCString());
      const parts = range.replace(/bytes=/, "").split("-", 2);
      const start = parseInt(parts[0], 10) || 0;
      let end = parseInt(parts[1], 10) || size - 1;
      if (size < end - start + 1) {
        end = size - 1;
      }
      const chunksize = end - start + 1;
      const stream2 = createReadStream(path, { start, end });
      c.header("Content-Length", chunksize.toString());
      c.header("Content-Range", `bytes ${start}-${end}/${stats.size}`);
      result = c.body(createStreamBody(stream2), 206);
    }
    await options.onFound?.(path, c);
    return result;
  };
};
var RENDER_TYPE = {
  STRING_ARRAY: "string_array",
  STRING: "string",
  JSON_STRING: "json_string",
  RAW: "raw"
};
var RENDER_TYPE_MAP = {
  configUrl: RENDER_TYPE.STRING,
  deepLinking: RENDER_TYPE.RAW,
  presets: RENDER_TYPE.STRING_ARRAY,
  plugins: RENDER_TYPE.STRING_ARRAY,
  spec: RENDER_TYPE.JSON_STRING,
  url: RENDER_TYPE.STRING,
  urls: RENDER_TYPE.JSON_STRING,
  layout: RENDER_TYPE.STRING,
  docExpansion: RENDER_TYPE.STRING,
  maxDisplayedTags: RENDER_TYPE.RAW,
  operationsSorter: RENDER_TYPE.RAW,
  requestInterceptor: RENDER_TYPE.RAW,
  responseInterceptor: RENDER_TYPE.RAW,
  persistAuthorization: RENDER_TYPE.RAW,
  defaultModelsExpandDepth: RENDER_TYPE.RAW,
  defaultModelExpandDepth: RENDER_TYPE.RAW,
  defaultModelRendering: RENDER_TYPE.STRING,
  displayRequestDuration: RENDER_TYPE.RAW,
  filter: RENDER_TYPE.RAW,
  showExtensions: RENDER_TYPE.RAW,
  showCommonExtensions: RENDER_TYPE.RAW,
  queryConfigEnabled: RENDER_TYPE.RAW,
  displayOperationId: RENDER_TYPE.RAW,
  tagsSorter: RENDER_TYPE.RAW,
  onComplete: RENDER_TYPE.RAW,
  syntaxHighlight: RENDER_TYPE.JSON_STRING,
  tryItOutEnabled: RENDER_TYPE.RAW,
  requestSnippetsEnabled: RENDER_TYPE.RAW,
  requestSnippets: RENDER_TYPE.JSON_STRING,
  oauth2RedirectUrl: RENDER_TYPE.STRING,
  showMutabledRequest: RENDER_TYPE.RAW,
  request: RENDER_TYPE.JSON_STRING,
  supportedSubmitMethods: RENDER_TYPE.JSON_STRING,
  validatorUrl: RENDER_TYPE.STRING,
  withCredentials: RENDER_TYPE.RAW,
  modelPropertyMacro: RENDER_TYPE.RAW,
  parameterMacro: RENDER_TYPE.RAW
};
var renderSwaggerUIOptions = (options) => {
  return Object.entries(options).map(([k, v]) => {
    const key = k;
    if (!RENDER_TYPE_MAP[key] || v === void 0) return "";
    switch (RENDER_TYPE_MAP[key]) {
      case RENDER_TYPE.STRING:
        return `${key}: '${v}'`;
      case RENDER_TYPE.STRING_ARRAY:
        if (!Array.isArray(v)) return "";
        return `${key}: [${v.map((ve) => `${ve}`).join(",")}]`;
      case RENDER_TYPE.JSON_STRING:
        return `${key}: ${JSON.stringify(v)}`;
      case RENDER_TYPE.RAW:
        return `${key}: ${v}`;
      default:
        return "";
    }
  }).filter((item) => item !== "").join(",");
};
var remoteAssets = ({ version }) => {
  const url = `https://cdn.jsdelivr.net/npm/swagger-ui-dist${version !== void 0 ? `@${version}` : ""}`;
  return {
    css: [`${url}/swagger-ui.css`],
    js: [`${url}/swagger-ui-bundle.js`]
  };
};
var SwaggerUI = (options) => {
  const asset = remoteAssets({ version: options?.version });
  delete options.version;
  if (options.manuallySwaggerUIHtml) return options.manuallySwaggerUIHtml(asset);
  const optionsStrings = renderSwaggerUIOptions(options);
  return `
    <div>
      <div id="swagger-ui"></div>
      ${asset.css.map((url) => html`<link rel="stylesheet" href="${url}" />`)}
      ${asset.js.map((url) => html`<script src="${url}" crossorigin="anonymous"><\/script>`)}
      <script>
        window.onload = () => {
          window.ui = SwaggerUIBundle({
            dom_id: '#swagger-ui',${optionsStrings},
          })
        }
      </script>
    </div>
  `;
};
var middleware = (options) => async (c) => {
  const title = options?.title ?? "SwaggerUI";
  return c.html(`
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <meta name="description" content="SwaggerUI" />
          <title>${title}</title>
        </head>
        <body>
          ${SwaggerUI(options)}
        </body>
      </html>
    `);
};
var classRegExp = /^([A-Z][a-z0-9]*)+$/;
var kTypes = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
];
function determineSpecificType(value) {
  if (value == null) {
    return "" + value;
  }
  if (typeof value === "function" && value.name) {
    return `function ${value.name}`;
  }
  if (typeof value === "object") {
    if (value.constructor?.name) {
      return `an instance of ${value.constructor.name}`;
    }
    return `${util.inspect(value, { depth: -1 })}`;
  }
  let inspected = util.inspect(value, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value} (${inspected})`;
}
var ERR_HTTP_BODY_NOT_ALLOWED = class extends Error {
  constructor() {
    super("Adding content for this request method or response status is not allowed.");
  }
};
var ERR_HTTP_CONTENT_LENGTH_MISMATCH = class extends Error {
  constructor(actual, expected) {
    super(`Response body's content-length of ${actual} byte(s) does not match the content-length of ${expected} byte(s) set in header`);
  }
};
var ERR_HTTP_HEADERS_SENT = class extends Error {
  constructor(arg) {
    super(`Cannot ${arg} headers after they are sent to the client`);
  }
};
var ERR_INVALID_ARG_VALUE = class extends TypeError {
  constructor(name, value, reason = "is invalid") {
    let inspected = util.inspect(value);
    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name.includes(".") ? "property" : "argument";
    super(`The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
var ERR_INVALID_CHAR = class extends TypeError {
  constructor(name, field) {
    let msg = `Invalid character in ${name}`;
    if (field !== void 0) {
      msg += ` ["${field}"]`;
    }
    super(msg);
  }
};
var ERR_HTTP_INVALID_HEADER_VALUE = class extends TypeError {
  constructor(value, name) {
    super(`Invalid value "${value}" for header "${name}"`);
  }
};
var ERR_HTTP_INVALID_STATUS_CODE = class extends RangeError {
  originalStatusCode;
  constructor(originalStatusCode) {
    super(`Invalid status code: ${originalStatusCode}`);
    this.originalStatusCode = originalStatusCode;
  }
};
var ERR_HTTP_TRAILER_INVALID = class extends Error {
  constructor() {
    super(`Trailers are invalid with this transfer encoding`);
  }
};
var ERR_INVALID_ARG_TYPE = class extends TypeError {
  constructor(name, expected, actual) {
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let msg = "The ";
    if (name.endsWith(" argument")) {
      msg += `${name} `;
    } else {
      const type = name.includes(".") ? "property" : "argument";
      msg += `"${name}" ${type} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected) {
      if (kTypes.includes(value)) {
        types.push(value.toLowerCase());
      } else if (classRegExp.exec(value) !== null) {
        instances.push(value);
      } else {
        other.push(value);
      }
    }
    if (instances.length > 0) {
      const pos = types.indexOf("object");
      if (pos !== -1) {
        types.splice(pos, 1);
        instances.push("Object");
      }
    }
    if (types.length > 0) {
      if (types.length > 2) {
        const last = types.pop();
        msg += `one of type ${types.join(", ")}, or ${last}`;
      } else if (types.length === 2) {
        msg += `one of type ${types[0]} or ${types[1]}`;
      } else {
        msg += `of type ${types[0]}`;
      }
      if (instances.length > 0 || other.length > 0)
        msg += " or ";
    }
    if (instances.length > 0) {
      if (instances.length > 2) {
        const last = instances.pop();
        msg += `an instance of ${instances.join(", ")}, or ${last}`;
      } else {
        msg += `an instance of ${instances[0]}`;
        if (instances.length === 2) {
          msg += ` or ${instances[1]}`;
        }
      }
      if (other.length > 0)
        msg += " or ";
    }
    if (other.length > 0) {
      if (other.length > 2) {
        const last = other.pop();
        msg += `one of ${other.join(", ")}, or ${last}`;
      } else if (other.length === 2) {
        msg += `one of ${other[0]} or ${other[1]}`;
      } else {
        if (other[0].toLowerCase() !== other[0])
          msg += "an ";
        msg += `${other[0]}`;
      }
    }
    msg += `. Received ${determineSpecificType(actual)}`;
    super(msg);
  }
};
var ERR_INVALID_HTTP_TOKEN = class extends TypeError {
  constructor(name, field) {
    super(`${name} must be a valid HTTP token ["${field}"]`);
  }
};
var ERR_METHOD_NOT_IMPLEMENTED = class extends Error {
  constructor(methodName) {
    super(`The ${methodName} method is not implemented`);
  }
};
var ERR_STREAM_ALREADY_FINISHED = class extends Error {
  constructor(methodName) {
    super(`Cannot call ${methodName} after a stream was finished`);
  }
};
var ERR_STREAM_CANNOT_PIPE = class extends Error {
  constructor() {
    super(`Cannot pipe, not readable`);
  }
};
var ERR_STREAM_DESTROYED = class extends Error {
  constructor(methodName) {
    super(`Cannot call ${methodName} after a stream was destroyed`);
  }
};
var ERR_STREAM_NULL_VALUES = class extends TypeError {
  constructor() {
    super(`May not write null values to stream`);
  }
};
var ERR_STREAM_WRITE_AFTER_END = class extends Error {
  constructor() {
    super(`write after end`);
  }
};

// ../../node_modules/.pnpm/fetch-to-node@2.1.0/node_modules/fetch-to-node/dist/fetch-to-node/http-incoming.js
var kHeaders = /* @__PURE__ */ Symbol("kHeaders");
var kHeadersDistinct = /* @__PURE__ */ Symbol("kHeadersDistinct");
var kHeadersCount = /* @__PURE__ */ Symbol("kHeadersCount");
var kTrailers = /* @__PURE__ */ Symbol("kTrailers");
var kTrailersDistinct = /* @__PURE__ */ Symbol("kTrailersDistinct");
var kTrailersCount = /* @__PURE__ */ Symbol("kTrailersCount");
var FetchIncomingMessage = class extends Readable {
  get socket() {
    return null;
  }
  set socket(_val) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("socket");
  }
  httpVersionMajor;
  httpVersionMinor;
  httpVersion;
  complete = false;
  [kHeaders] = null;
  [kHeadersDistinct] = null;
  [kHeadersCount] = 0;
  rawHeaders = [];
  [kTrailers] = null;
  [kTrailersDistinct] = null;
  [kTrailersCount] = 0;
  rawTrailers = [];
  joinDuplicateHeaders = false;
  aborted = false;
  upgrade = false;
  // request (server) only
  url = "";
  method;
  // TODO: Support ClientRequest
  // statusCode = null;
  // statusMessage = null;
  // client = socket;
  _consuming;
  _dumped;
  // The underlying ReadableStream
  _stream = null;
  constructor() {
    const streamOptions = {};
    super(streamOptions);
    this._readableState.readingMore = true;
    this._consuming = false;
    this._dumped = false;
  }
  get connection() {
    return null;
  }
  set connection(_socket) {
    console.error("No support for IncomingMessage.connection");
  }
  get headers() {
    if (!this[kHeaders]) {
      this[kHeaders] = {};
      const src = this.rawHeaders;
      const dst = this[kHeaders];
      for (let n = 0; n < this[kHeadersCount]; n += 2) {
        this._addHeaderLine(src[n], src[n + 1], dst);
      }
    }
    return this[kHeaders];
  }
  set headers(val) {
    this[kHeaders] = val;
  }
  get headersDistinct() {
    if (!this[kHeadersDistinct]) {
      this[kHeadersDistinct] = {};
      const src = this.rawHeaders;
      const dst = this[kHeadersDistinct];
      for (let n = 0; n < this[kHeadersCount]; n += 2) {
        this._addHeaderLineDistinct(src[n], src[n + 1], dst);
      }
    }
    return this[kHeadersDistinct];
  }
  set headersDistinct(val) {
    this[kHeadersDistinct] = val;
  }
  get trailers() {
    if (!this[kTrailers]) {
      this[kTrailers] = {};
      const src = this.rawTrailers;
      const dst = this[kTrailers];
      for (let n = 0; n < this[kTrailersCount]; n += 2) {
        this._addHeaderLine(src[n], src[n + 1], dst);
      }
    }
    return this[kTrailers];
  }
  set trailers(val) {
    this[kTrailers] = val;
  }
  get trailersDistinct() {
    if (!this[kTrailersDistinct]) {
      this[kTrailersDistinct] = {};
      const src = this.rawTrailers;
      const dst = this[kTrailersDistinct];
      for (let n = 0; n < this[kTrailersCount]; n += 2) {
        this._addHeaderLineDistinct(src[n], src[n + 1], dst);
      }
    }
    return this[kTrailersDistinct];
  }
  set trailersDistinct(val) {
    this[kTrailersDistinct] = val;
  }
  setTimeout(msecs, callback) {
    return this;
  }
  async _read(n) {
    if (!this._consuming) {
      this._readableState.readingMore = false;
      this._consuming = true;
    }
    if (this._stream == null) {
      this.complete = true;
      this.push(null);
      return;
    }
    const reader = this._stream.getReader();
    try {
      const data = await reader.read();
      if (data.done) {
        this.complete = true;
        this.push(null);
      } else {
        this.push(data.value);
      }
    } catch (e) {
      this.destroy(e);
    } finally {
      reader.releaseLock();
    }
  }
  _destroy(err, cb) {
    if (!this.readableEnded || !this.complete) {
      this.aborted = true;
      this.emit("aborted");
    }
    setTimeout(onError, 0, this, err, cb);
  }
  _addHeaderLines(headers, n) {
    if (headers?.length) {
      let dest;
      if (this.complete) {
        this.rawTrailers = headers;
        this[kTrailersCount] = n;
        dest = this[kTrailers];
      } else {
        this.rawHeaders = headers;
        this[kHeadersCount] = n;
        dest = this[kHeaders];
      }
      if (dest) {
        for (let i = 0; i < n; i += 2) {
          this._addHeaderLine(headers[i], headers[i + 1], dest);
        }
      }
    }
  }
  // Add the given (field, value) pair to the message
  //
  // Per RFC2616, section 4.2 it is acceptable to join multiple instances of the
  // same header with a ', ' if the header in question supports specification of
  // multiple values this way. The one exception to this is the Cookie header,
  // which has multiple values joined with a '; ' instead. If a header's values
  // cannot be joined in either of these ways, we declare the first instance the
  // winner and drop the second. Extended header fields (those beginning with
  // 'x-') are always joined.
  _addHeaderLine(field, value, dest) {
    field = matchKnownFields(field);
    const flag = field.charCodeAt(0);
    if (flag === 0 || flag === 2) {
      field = field.slice(1);
      if (typeof dest[field] === "string") {
        dest[field] += (flag === 0 ? ", " : "; ") + value;
      } else {
        dest[field] = value;
      }
    } else if (flag === 1) {
      if (dest["set-cookie"] !== void 0) {
        dest["set-cookie"].push(value);
      } else {
        dest["set-cookie"] = [value];
      }
    } else if (this.joinDuplicateHeaders) {
      if (dest[field] === void 0) {
        dest[field] = value;
      } else {
        dest[field] += ", " + value;
      }
    } else if (dest[field] === void 0) {
      dest[field] = value;
    }
  }
  _addHeaderLineDistinct(field, value, dest) {
    field = field.toLowerCase();
    if (!dest[field]) {
      dest[field] = [value];
    } else {
      dest[field].push(value);
    }
  }
  // Call this instead of resume() if we want to just
  // dump all the data to /dev/null
  _dump() {
    if (!this._dumped) {
      this._dumped = true;
      this.removeAllListeners("data");
      this.resume();
    }
  }
};
function matchKnownFields(field, lowercased = false) {
  switch (field.length) {
    case 3:
      if (field === "Age" || field === "age")
        return "age";
      break;
    case 4:
      if (field === "Host" || field === "host")
        return "host";
      if (field === "From" || field === "from")
        return "from";
      if (field === "ETag" || field === "etag")
        return "etag";
      if (field === "Date" || field === "date")
        return "\0date";
      if (field === "Vary" || field === "vary")
        return "\0vary";
      break;
    case 6:
      if (field === "Server" || field === "server")
        return "server";
      if (field === "Cookie" || field === "cookie")
        return "cookie";
      if (field === "Origin" || field === "origin")
        return "\0origin";
      if (field === "Expect" || field === "expect")
        return "\0expect";
      if (field === "Accept" || field === "accept")
        return "\0accept";
      break;
    case 7:
      if (field === "Referer" || field === "referer")
        return "referer";
      if (field === "Expires" || field === "expires")
        return "expires";
      if (field === "Upgrade" || field === "upgrade")
        return "\0upgrade";
      break;
    case 8:
      if (field === "Location" || field === "location")
        return "location";
      if (field === "If-Match" || field === "if-match")
        return "\0if-match";
      break;
    case 10:
      if (field === "User-Agent" || field === "user-agent")
        return "user-agent";
      if (field === "Set-Cookie" || field === "set-cookie")
        return "";
      if (field === "Connection" || field === "connection")
        return "\0connection";
      break;
    case 11:
      if (field === "Retry-After" || field === "retry-after")
        return "retry-after";
      break;
    case 12:
      if (field === "Content-Type" || field === "content-type")
        return "content-type";
      if (field === "Max-Forwards" || field === "max-forwards")
        return "max-forwards";
      break;
    case 13:
      if (field === "Authorization" || field === "authorization")
        return "authorization";
      if (field === "Last-Modified" || field === "last-modified")
        return "last-modified";
      if (field === "Cache-Control" || field === "cache-control")
        return "\0cache-control";
      if (field === "If-None-Match" || field === "if-none-match")
        return "\0if-none-match";
      break;
    case 14:
      if (field === "Content-Length" || field === "content-length")
        return "content-length";
      break;
    case 15:
      if (field === "Accept-Encoding" || field === "accept-encoding")
        return "\0accept-encoding";
      if (field === "Accept-Language" || field === "accept-language")
        return "\0accept-language";
      if (field === "X-Forwarded-For" || field === "x-forwarded-for")
        return "\0x-forwarded-for";
      break;
    case 16:
      if (field === "Content-Encoding" || field === "content-encoding")
        return "\0content-encoding";
      if (field === "X-Forwarded-Host" || field === "x-forwarded-host")
        return "\0x-forwarded-host";
      break;
    case 17:
      if (field === "If-Modified-Since" || field === "if-modified-since")
        return "if-modified-since";
      if (field === "Transfer-Encoding" || field === "transfer-encoding")
        return "\0transfer-encoding";
      if (field === "X-Forwarded-Proto" || field === "x-forwarded-proto")
        return "\0x-forwarded-proto";
      break;
    case 19:
      if (field === "Proxy-Authorization" || field === "proxy-authorization")
        return "proxy-authorization";
      if (field === "If-Unmodified-Since" || field === "if-unmodified-since")
        return "if-unmodified-since";
      break;
  }
  if (lowercased) {
    return "\0" + field;
  }
  return matchKnownFields(field.toLowerCase(), true);
}
function onError(self, error, cb) {
  if (self.listenerCount("error") === 0) {
    cb();
  } else {
    cb(error);
  }
}

// ../../node_modules/.pnpm/fetch-to-node@2.1.0/node_modules/fetch-to-node/dist/utils/types.js
function validateString(value, name) {
  if (typeof value !== "string")
    throw new ERR_INVALID_ARG_TYPE(name, "string", value);
}
var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function validateLinkHeaderFormat(value, name) {
  if (typeof value === "undefined" || !linkValueRegExp.exec(value)) {
    throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
  }
}
function validateLinkHeaderValue(hints) {
  if (typeof hints === "string") {
    validateLinkHeaderFormat(hints, "hints");
    return hints;
  } else if (Array.isArray(hints)) {
    const hintsLength = hints.length;
    let result = "";
    if (hintsLength === 0) {
      return result;
    }
    for (let i = 0; i < hintsLength; i++) {
      const link = hints[i];
      validateLinkHeaderFormat(link, "hints");
      result += link;
      if (i !== hintsLength - 1) {
        result += ", ";
      }
    }
    return result;
  }
  throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
}
function isUint8Array(value) {
  return value != null && value[Symbol.toStringTag] === "Uint8Array";
}

// ../../node_modules/.pnpm/fetch-to-node@2.1.0/node_modules/fetch-to-node/dist/fetch-to-node/internal-http.js
var kNeedDrain = /* @__PURE__ */ Symbol("kNeedDrain");
var kOutHeaders = /* @__PURE__ */ Symbol("kOutHeaders");
function utcDate() {
  return (/* @__PURE__ */ new Date()).toUTCString();
}

// ../../node_modules/.pnpm/fetch-to-node@2.1.0/node_modules/fetch-to-node/dist/fetch-to-node/internal-streams-state.js
function getDefaultHighWaterMark(objectMode) {
  return objectMode ? 16 : 64 * 1024;
}

// ../../node_modules/.pnpm/fetch-to-node@2.1.0/node_modules/fetch-to-node/dist/fetch-to-node/http-common.js
var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
function checkIsHttpToken(val) {
  return tokenRegExp.test(val);
}
var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function checkInvalidHeaderChar(val) {
  return headerCharRegex.test(val);
}
var chunkExpression = /(?:^|\W)chunked(?:$|\W)/i;
var kCorked = /* @__PURE__ */ Symbol("corked");
var kChunkedBuffer = /* @__PURE__ */ Symbol("kChunkedBuffer");
var kChunkedLength = /* @__PURE__ */ Symbol("kChunkedLength");
var kUniqueHeaders = /* @__PURE__ */ Symbol("kUniqueHeaders");
var kBytesWritten = /* @__PURE__ */ Symbol("kBytesWritten");
var kErrored = /* @__PURE__ */ Symbol("errored");
var kHighWaterMark = /* @__PURE__ */ Symbol("kHighWaterMark");
var kRejectNonStandardBodyWrites = /* @__PURE__ */ Symbol("kRejectNonStandardBodyWrites");
var nop = () => {
};
var RE_CONN_CLOSE = /(?:^|\W)close(?:$|\W)/i;
function isCookieField(s) {
  return s.length === 6 && s.toLowerCase() === "cookie";
}
function isContentDispositionField(s) {
  return s.length === 19 && s.toLowerCase() === "content-disposition";
}
var WrittenDataBuffer = class {
  [kCorked] = 0;
  [kHighWaterMark] = getDefaultHighWaterMark();
  entries = [];
  onWrite;
  constructor(params = {}) {
    this.onWrite = params.onWrite;
  }
  write(data, encoding, callback) {
    this.entries.push({
      data,
      length: data.length,
      encoding,
      callback,
      written: false
    });
    this._flush();
    return true;
  }
  cork() {
    this[kCorked]++;
  }
  uncork() {
    this[kCorked]--;
    this._flush();
  }
  _flush() {
    if (this[kCorked] <= 0) {
      for (const [index, entry] of this.entries.entries()) {
        if (!entry.written) {
          entry.written = true;
          if (this.onWrite != null) {
            this.onWrite(index, entry);
          }
          if (entry.callback != null) {
            entry.callback.call(void 0);
          }
        }
      }
    }
  }
  get writableLength() {
    return this.entries.reduce((acc, entry) => {
      return acc + (entry.written && entry.length ? entry.length : 0);
    }, 0);
  }
  get writableHighWaterMark() {
    return this[kHighWaterMark];
  }
  get writableCorked() {
    return this[kCorked];
  }
};
var FetchOutgoingMessage = class extends Writable {
  req;
  outputData;
  outputSize;
  // Difference from Node.js -
  // `writtenHeaderBytes` is the number of bytes the header has taken.
  // Since Node.js writes both the headers and body into the same outgoing
  // stream, it helps to keep track of this so that we can skip that many bytes
  // from the beginning of the stream when providing the outgoing stream.
  writtenHeaderBytes = 0;
  _last;
  chunkedEncoding;
  shouldKeepAlive;
  maxRequestsOnConnectionReached;
  _defaultKeepAlive;
  useChunkedEncodingByDefault;
  sendDate;
  _removedConnection;
  _removedContLen;
  _removedTE;
  strictContentLength;
  [kBytesWritten];
  _contentLength;
  _hasBody;
  _trailer;
  [kNeedDrain];
  finished;
  _headerSent;
  [kCorked];
  [kChunkedBuffer];
  [kChunkedLength];
  _closed;
  // Difference from Node.js -
  // In Node.js, this is a socket object.
  // [kSocket]: null;
  _header;
  [kOutHeaders];
  _keepAliveTimeout;
  _maxRequestsPerSocket;
  _onPendingData;
  [kUniqueHeaders];
  [kErrored];
  [kHighWaterMark];
  [kRejectNonStandardBodyWrites];
  _writtenDataBuffer = new WrittenDataBuffer({
    onWrite: this._onDataWritten.bind(this)
  });
  constructor(req, options) {
    super();
    this.req = req;
    this.outputData = [];
    this.outputSize = 0;
    this.destroyed = false;
    this._last = false;
    this.chunkedEncoding = false;
    this.shouldKeepAlive = true;
    this.maxRequestsOnConnectionReached = false;
    this._defaultKeepAlive = true;
    this.useChunkedEncodingByDefault = true;
    this.sendDate = false;
    this._removedConnection = false;
    this._removedContLen = false;
    this._removedTE = false;
    this.strictContentLength = false;
    this[kBytesWritten] = 0;
    this._contentLength = null;
    this._hasBody = true;
    this._trailer = "";
    this[kNeedDrain] = false;
    this.finished = false;
    this._headerSent = false;
    this[kCorked] = 0;
    this[kChunkedBuffer] = [];
    this[kChunkedLength] = 0;
    this._closed = false;
    this._header = null;
    this[kOutHeaders] = null;
    this._keepAliveTimeout = 0;
    this._onPendingData = nop;
    this[kErrored] = null;
    this[kHighWaterMark] = options?.highWaterMark ?? getDefaultHighWaterMark();
    this[kRejectNonStandardBodyWrites] = options?.rejectNonStandardBodyWrites ?? false;
    this[kUniqueHeaders] = null;
  }
  _renderHeaders() {
    if (this._header) {
      throw new ERR_HTTP_HEADERS_SENT("render");
    }
    const headersMap = this[kOutHeaders];
    const headers = {};
    if (headersMap !== null) {
      const keys = Object.keys(headersMap);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        headers[headersMap[key][0]] = headersMap[key][1];
      }
    }
    return headers;
  }
  cork() {
    this[kCorked]++;
    if (this._writtenDataBuffer != null) {
      this._writtenDataBuffer.cork();
    }
  }
  uncork() {
    this[kCorked]--;
    if (this._writtenDataBuffer != null) {
      this._writtenDataBuffer.uncork();
    }
    if (this[kCorked] || this[kChunkedBuffer].length === 0) {
      return;
    }
    const buf = this[kChunkedBuffer];
    for (const { data, encoding, callback } of buf) {
      this._send(data ?? "", encoding, callback);
    }
    this[kChunkedBuffer].length = 0;
    this[kChunkedLength] = 0;
  }
  setTimeout(msecs, callback) {
    return this;
  }
  destroy(error) {
    if (this.destroyed) {
      return this;
    }
    this.destroyed = true;
    this[kErrored] = error;
    return this;
  }
  _send(data, encoding, callback, byteLength) {
    if (!this._headerSent) {
      const header = this._header;
      if (typeof data === "string" && (encoding === "utf8" || encoding === "latin1" || !encoding)) {
        data = header + data;
      } else {
        this.outputData.unshift({
          data: header,
          encoding: "latin1",
          callback: void 0
        });
        this.outputSize += header.length;
        this._onPendingData(header.length);
      }
      this._headerSent = true;
      this.writtenHeaderBytes = header.length;
      const [statusLine, ...headerLines] = this._header.split("\r\n");
      const STATUS_LINE_REGEXP = /^HTTP\/1\.1 (?<statusCode>\d+) (?<statusMessage>.*)$/;
      const statusLineResult = STATUS_LINE_REGEXP.exec(statusLine);
      if (statusLineResult == null) {
        throw new Error("Unexpected! Status line was " + statusLine);
      }
      const { statusCode: statusCodeText, statusMessage } = statusLineResult.groups ?? {};
      const statusCode = parseInt(statusCodeText, 10);
      const headers = [];
      for (const headerLine of headerLines) {
        if (headerLine !== "") {
          const pos = headerLine.indexOf(": ");
          const k = headerLine.slice(0, pos);
          const v = headerLine.slice(pos + 2);
          headers.push([k, v]);
        }
      }
      const event = {
        statusCode,
        statusMessage,
        headers
      };
      this.emit("_headersSent", event);
    }
    return this._writeRaw(data, encoding, callback, byteLength);
  }
  _writeRaw(data, encoding, callback, size) {
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = null;
    }
    if (this._writtenDataBuffer != null) {
      if (this.outputData.length) {
        this._flushOutput(this._writtenDataBuffer);
      }
      return this._writtenDataBuffer.write(data, encoding, callback);
    }
    this.outputData.push({ data, encoding, callback });
    this.outputSize += data.length;
    this._onPendingData(data.length);
    return this.outputSize < this[kHighWaterMark];
  }
  _onDataWritten(index, entry) {
    const event = { index, entry };
    this.emit("_dataWritten", event);
  }
  _storeHeader(firstLine, headers) {
    const state = {
      connection: false,
      contLen: false,
      te: false,
      date: false,
      expect: false,
      trailer: false,
      header: firstLine
    };
    if (headers) {
      if (headers === this[kOutHeaders]) {
        for (const key in headers) {
          const entry = headers[key];
          processHeader(this, state, entry[0], entry[1], false);
        }
      } else if (Array.isArray(headers)) {
        if (headers.length && Array.isArray(headers[0])) {
          for (let i = 0; i < headers.length; i++) {
            const entry = headers[i];
            processHeader(this, state, entry[0], entry[1], true);
          }
        } else {
          if (headers.length % 2 !== 0) {
            throw new ERR_INVALID_ARG_VALUE("headers", headers);
          }
          for (let n = 0; n < headers.length; n += 2) {
            processHeader(this, state, headers[n], headers[n + 1], true);
          }
        }
      } else {
        for (const key in headers) {
          if (headers.hasOwnProperty(key)) {
            const _headers = headers;
            processHeader(this, state, key, _headers[key], true);
          }
        }
      }
    }
    let { header } = state;
    if (this.sendDate && !state.date) {
      header += "Date: " + utcDate() + "\r\n";
    }
    if (this.chunkedEncoding && (this.statusCode === 204 || this.statusCode === 304)) {
      this.chunkedEncoding = false;
      this.shouldKeepAlive = false;
    }
    if (this._removedConnection) {
      this._last = !this.shouldKeepAlive;
    } else if (!state.connection) {
      const shouldSendKeepAlive = this.shouldKeepAlive && (state.contLen || this.useChunkedEncodingByDefault);
      if (shouldSendKeepAlive && this.maxRequestsOnConnectionReached) {
        header += "Connection: close\r\n";
      } else if (shouldSendKeepAlive) {
        header += "Connection: keep-alive\r\n";
        if (this._keepAliveTimeout && this._defaultKeepAlive) {
          const timeoutSeconds = Math.floor(this._keepAliveTimeout / 1e3);
          let max = "";
          if (this._maxRequestsPerSocket && ~~this._maxRequestsPerSocket > 0) {
            max = `, max=${this._maxRequestsPerSocket}`;
          }
          header += `Keep-Alive: timeout=${timeoutSeconds}${max}\r
`;
        }
      } else {
        this._last = true;
        header += "Connection: close\r\n";
      }
    }
    if (!state.contLen && !state.te) {
      if (!this._hasBody) {
        this.chunkedEncoding = false;
      } else if (!this.useChunkedEncodingByDefault) {
        this._last = true;
      } else if (!state.trailer && !this._removedContLen && typeof this._contentLength === "number") {
        header += "Content-Length: " + this._contentLength + "\r\n";
      } else if (!this._removedTE) {
        header += "Transfer-Encoding: chunked\r\n";
        this.chunkedEncoding = true;
      } else {
        this._last = true;
      }
    }
    if (this.chunkedEncoding !== true && state.trailer) {
      throw new ERR_HTTP_TRAILER_INVALID();
    }
    this._header = header + "\r\n";
    this._headerSent = false;
    if (state.expect) {
      this._send("");
    }
  }
  get _headers() {
    console.warn("DEP0066: OutgoingMessage.prototype._headers is deprecated");
    return this.getHeaders();
  }
  set _headers(val) {
    console.warn("DEP0066: OutgoingMessage.prototype._headers is deprecated");
    if (val == null) {
      this[kOutHeaders] = null;
    } else if (typeof val === "object") {
      const headers = this[kOutHeaders] = /* @__PURE__ */ Object.create(null);
      const keys = Object.keys(val);
      for (let i = 0; i < keys.length; ++i) {
        const name = keys[i];
        headers[name.toLowerCase()] = [name, val[name]];
      }
    }
  }
  get connection() {
    return null;
  }
  set connection(_socket) {
    console.error("No support for OutgoingMessage.connection");
  }
  get socket() {
    return null;
  }
  set socket(_socket) {
    console.error("No support for OutgoingMessage.socket");
  }
  get _headerNames() {
    console.warn("DEP0066: OutgoingMessage.prototype._headerNames is deprecated");
    const headers = this[kOutHeaders];
    if (headers !== null) {
      const out = /* @__PURE__ */ Object.create(null);
      const keys = Object.keys(headers);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const val = headers[key][0];
        out[key] = val;
      }
      return out;
    }
    return null;
  }
  set _headerNames(val) {
    console.warn("DEP0066: OutgoingMessage.prototype._headerNames is deprecated");
    if (typeof val === "object" && val !== null) {
      const headers = this[kOutHeaders];
      if (!headers)
        return;
      const keys = Object.keys(val);
      for (let i = 0; i < keys.length; ++i) {
        const header = headers[keys[i]];
        if (header)
          header[0] = val[keys[i]];
      }
    }
  }
  setHeader(name, value) {
    if (this._header) {
      throw new ERR_HTTP_HEADERS_SENT("set");
    }
    validateHeaderName(name);
    validateHeaderValue(name, value);
    let headers = this[kOutHeaders];
    if (headers === null) {
      this[kOutHeaders] = headers = { __proto__: null };
    }
    headers[name.toLowerCase()] = [name, value];
    return this;
  }
  setHeaders(headers) {
    if (this._header) {
      throw new ERR_HTTP_HEADERS_SENT("set");
    }
    if (!headers || Array.isArray(headers) || typeof headers.keys !== "function" || typeof headers.get !== "function") {
      throw new ERR_INVALID_ARG_TYPE("headers", ["Headers", "Map"], headers);
    }
    const cookies = [];
    for (const { 0: key, 1: value } of headers) {
      if (key === "set-cookie") {
        if (Array.isArray(value)) {
          cookies.push(...value);
        } else {
          cookies.push(value);
        }
        continue;
      }
      this.setHeader(key, value);
    }
    if (cookies.length) {
      this.setHeader("set-cookie", cookies);
    }
    return this;
  }
  appendHeader(name, value) {
    if (this._header) {
      throw new ERR_HTTP_HEADERS_SENT("append");
    }
    validateHeaderName(name);
    validateHeaderValue(name, value);
    const field = name.toLowerCase();
    const headers = this[kOutHeaders];
    if (headers === null || !headers[field]) {
      return this.setHeader(name, value);
    }
    if (!Array.isArray(headers[field][1])) {
      headers[field][1] = [headers[field][1]];
    }
    const existingValues = headers[field][1];
    if (Array.isArray(value)) {
      for (let i = 0, length = value.length; i < length; i++) {
        existingValues.push(value[i]);
      }
    } else {
      existingValues.push(value);
    }
    return this;
  }
  getHeader(name) {
    validateString(name, "name");
    const headers = this[kOutHeaders];
    if (headers === null) {
      return;
    }
    const entry = headers[name.toLowerCase()];
    return entry?.[1];
  }
  getHeaderNames() {
    return this[kOutHeaders] !== null ? Object.keys(this[kOutHeaders]) : [];
  }
  getRawHeaderNames() {
    const headersMap = this[kOutHeaders];
    if (headersMap === null)
      return [];
    const values = Object.values(headersMap);
    const headers = Array(values.length);
    for (let i = 0, l = values.length; i < l; i++) {
      headers[i] = values[i][0];
    }
    return headers;
  }
  getHeaders() {
    const headers = this[kOutHeaders];
    const ret = { __proto__: null };
    if (headers) {
      const keys = Object.keys(headers);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const val = headers[key][1];
        ret[key] = val;
      }
    }
    return ret;
  }
  hasHeader(name) {
    validateString(name, "name");
    return this[kOutHeaders] !== null && !!this[kOutHeaders][name.toLowerCase()];
  }
  removeHeader(name) {
    validateString(name, "name");
    if (this._header) {
      throw new ERR_HTTP_HEADERS_SENT("remove");
    }
    const key = name.toLowerCase();
    switch (key) {
      case "connection":
        this._removedConnection = true;
        break;
      case "content-length":
        this._removedContLen = true;
        break;
      case "transfer-encoding":
        this._removedTE = true;
        break;
      case "date":
        this.sendDate = false;
        break;
    }
    if (this[kOutHeaders] !== null) {
      delete this[kOutHeaders][key];
    }
  }
  _implicitHeader() {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_implicitHeader()");
  }
  get headersSent() {
    return !!this._header;
  }
  write(chunk, encoding, callback) {
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = null;
    }
    const ret = write_(this, chunk, encoding, callback, false);
    if (!ret) {
      this[kNeedDrain] = true;
    }
    return ret;
  }
  addTrailers(headers) {
    this._trailer = "";
    const isArray = Array.isArray(headers);
    const keys = isArray ? [...headers.keys()] : Object.keys(headers);
    for (let i = 0, l = keys.length; i < l; i++) {
      let field, value;
      if (isArray) {
        const _headers = headers;
        const key = keys[i];
        field = _headers[key][0];
        value = _headers[key][1];
      } else {
        const _headers = headers;
        const key = keys[i];
        field = key;
        value = _headers[key];
      }
      validateHeaderName(field, "Trailer name");
      if (Array.isArray(value) && value.length > 1 && (!this[kUniqueHeaders] || !this[kUniqueHeaders].has(field.toLowerCase()))) {
        for (let j = 0, l2 = value.length; j < l2; j++) {
          if (checkInvalidHeaderChar(value[j])) {
            throw new ERR_INVALID_CHAR("trailer content", field);
          }
          this._trailer += field + ": " + value[j] + "\r\n";
        }
      } else {
        if (Array.isArray(value)) {
          value = value.join("; ");
        }
        if (checkInvalidHeaderChar(String(value))) {
          throw new ERR_INVALID_CHAR("trailer content", field);
        }
        this._trailer += field + ": " + value + "\r\n";
      }
    }
  }
  end(chunk, encoding, callback) {
    if (typeof chunk === "function") {
      callback = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      callback = encoding;
      encoding = null;
    }
    if (chunk) {
      if (this.finished) {
        onError2(this, new ERR_STREAM_WRITE_AFTER_END(), typeof callback !== "function" ? nop : callback);
        return this;
      }
      if (this._writtenDataBuffer != null) {
        this._writtenDataBuffer.cork();
      }
      write_(this, chunk, encoding, null, true);
    } else if (this.finished) {
      if (typeof callback === "function") {
        if (!this.writableFinished) {
          this.on("finish", callback);
        } else {
          callback(new ERR_STREAM_ALREADY_FINISHED("end"));
        }
      }
      return this;
    } else if (!this._header) {
      if (this._writtenDataBuffer != null) {
        this._writtenDataBuffer.cork();
      }
      this._contentLength = 0;
      this._implicitHeader();
    }
    if (typeof callback === "function")
      this.once("finish", callback);
    if (strictContentLength(this) && this[kBytesWritten] !== this._contentLength) {
      throw new ERR_HTTP_CONTENT_LENGTH_MISMATCH(this[kBytesWritten], this._contentLength);
    }
    const finish = onFinish.bind(void 0, this);
    if (this._hasBody && this.chunkedEncoding) {
      this._send("", "latin1", finish);
    } else if (!this._headerSent || this.writableLength || chunk) {
      this._send("", "latin1", finish);
    } else {
      setTimeout(finish, 0);
    }
    if (this._writtenDataBuffer != null) {
      this._writtenDataBuffer.uncork();
    }
    this[kCorked] = 1;
    this.uncork();
    this.finished = true;
    if (this.outputData.length === 0 && this._writtenDataBuffer != null) {
      this._finish();
    }
    return this;
  }
  _finish() {
    this.emit("prefinish");
  }
  // No _flush() implementation?
  _flush() {
    if (this._writtenDataBuffer != null) {
      const ret = this._flushOutput(this._writtenDataBuffer);
      if (this.finished) {
        this._finish();
      } else if (ret && this[kNeedDrain]) {
        this[kNeedDrain] = false;
        this.emit("drain");
      }
    }
  }
  _flushOutput(dataBuffer) {
    while (this[kCorked]) {
      this[kCorked]--;
      dataBuffer.cork();
    }
    const outputLength = this.outputData.length;
    if (outputLength <= 0) {
      return void 0;
    }
    const outputData = this.outputData;
    dataBuffer.cork();
    let ret;
    for (let i = 0; i < outputLength; i++) {
      const { data, encoding, callback } = outputData[i];
      outputData[i].data = null;
      ret = dataBuffer.write(data ?? "", encoding, callback);
    }
    dataBuffer.uncork();
    this.outputData = [];
    this._onPendingData(-this.outputSize);
    this.outputSize = 0;
    return ret;
  }
  flushHeaders() {
    if (!this._header) {
      this._implicitHeader();
    }
    this._send("");
  }
  pipe(destination) {
    this.emit("error", new ERR_STREAM_CANNOT_PIPE());
    return destination;
  }
};
function processHeader(self, state, key, value, validate) {
  if (validate) {
    validateHeaderName(key);
  }
  if (isContentDispositionField(key) && self._contentLength) {
    if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        value[i] = String(Buffer$1.from(String(value[i]), "latin1"));
      }
    } else {
      value = String(Buffer$1.from(String(value), "latin1"));
    }
  }
  if (Array.isArray(value)) {
    if ((value.length < 2 || !isCookieField(key)) && (!self[kUniqueHeaders] || !self[kUniqueHeaders].has(key.toLowerCase()))) {
      for (let i = 0; i < value.length; i++) {
        storeHeader(self, state, key, value[i], validate);
      }
      return;
    }
    value = value.join("; ");
  }
  storeHeader(self, state, key, String(value), validate);
}
function storeHeader(self, state, key, value, validate) {
  if (validate) {
    validateHeaderValue(key, value);
  }
  state.header += key + ": " + value + "\r\n";
  matchHeader(self, state, key, value);
}
function validateHeaderName(name, label) {
  if (typeof name !== "string" || !name || !checkIsHttpToken(name)) {
    throw new ERR_INVALID_HTTP_TOKEN(label || "Header name", name);
  }
}
function validateHeaderValue(name, value) {
  if (value === void 0) {
    throw new ERR_HTTP_INVALID_HEADER_VALUE(String(value), name);
  }
  if (checkInvalidHeaderChar(String(value))) {
    throw new ERR_INVALID_CHAR("header content", name);
  }
}
function matchHeader(self, state, field, value) {
  if (field.length < 4 || field.length > 17)
    return;
  field = field.toLowerCase();
  switch (field) {
    case "connection":
      state.connection = true;
      self._removedConnection = false;
      if (RE_CONN_CLOSE.exec(value) !== null)
        self._last = true;
      else
        self.shouldKeepAlive = true;
      break;
    case "transfer-encoding":
      state.te = true;
      self._removedTE = false;
      if (chunkExpression.exec(value) !== null)
        self.chunkedEncoding = true;
      break;
    case "content-length":
      state.contLen = true;
      self._contentLength = +value;
      self._removedContLen = false;
      break;
    case "date":
    case "expect":
    case "trailer":
      state[field] = true;
      break;
    case "keep-alive":
      self._defaultKeepAlive = false;
      break;
  }
}
function onError2(msg, err, callback) {
  if (msg.destroyed) {
    return;
  }
  setTimeout(emitErrorNt, 0, msg, err, callback);
}
function emitErrorNt(msg, err, callback) {
  callback(err);
  if (typeof msg.emit === "function" && !msg.destroyed) {
    msg.emit("error", err);
  }
}
function strictContentLength(msg) {
  return msg.strictContentLength && msg._contentLength != null && msg._hasBody && !msg._removedContLen && !msg.chunkedEncoding && !msg.hasHeader("transfer-encoding");
}
function write_(msg, chunk, encoding, callback, fromEnd) {
  if (typeof callback !== "function") {
    callback = nop;
  }
  if (chunk === null) {
    throw new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== "string" && !isUint8Array(chunk)) {
    throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
  }
  let err = void 0;
  if (msg.finished) {
    err = new ERR_STREAM_WRITE_AFTER_END();
  } else if (msg.destroyed) {
    err = new ERR_STREAM_DESTROYED("write");
  }
  if (err) {
    if (!msg.destroyed) {
      onError2(msg, err, callback);
    } else {
      setTimeout(callback, 0, err);
    }
    return false;
  }
  let len = void 0;
  if (msg.strictContentLength) {
    len ??= typeof chunk === "string" ? Buffer$1.byteLength(chunk, encoding ?? void 0) : chunk.byteLength;
    if (strictContentLength(msg) && (fromEnd ? msg[kBytesWritten] + len !== msg._contentLength : msg[kBytesWritten] + len > (msg._contentLength ?? 0))) {
      throw new ERR_HTTP_CONTENT_LENGTH_MISMATCH(len + msg[kBytesWritten], msg._contentLength);
    }
    msg[kBytesWritten] += len;
  }
  if (!msg._header) {
    if (fromEnd) {
      len ??= typeof chunk === "string" ? Buffer$1.byteLength(chunk, encoding ?? void 0) : chunk.byteLength;
      msg._contentLength = len;
    }
    msg._implicitHeader();
  }
  if (!msg._hasBody) {
    if (msg[kRejectNonStandardBodyWrites]) {
      throw new ERR_HTTP_BODY_NOT_ALLOWED();
    } else {
      setTimeout(callback, 0);
      return true;
    }
  }
  if (!fromEnd && msg._writtenDataBuffer != null && !msg._writtenDataBuffer.writableCorked) {
    msg._writtenDataBuffer.cork();
    setTimeout(connectionCorkNT, 0, msg._writtenDataBuffer);
  }
  let ret;
  if (msg.chunkedEncoding && chunk.length !== 0) {
    len ??= typeof chunk === "string" ? Buffer$1.byteLength(chunk, encoding ?? void 0) : chunk.byteLength;
    if (msg[kCorked] && msg._headerSent) {
      msg[kChunkedBuffer].push({ data: chunk, encoding, callback });
      msg[kChunkedLength] += len;
      ret = msg[kChunkedLength] < msg[kHighWaterMark];
    } else {
      ret = msg._send(chunk, encoding, callback, len);
    }
  } else {
    ret = msg._send(chunk, encoding, callback, len);
  }
  return ret;
}
function connectionCorkNT(dataBuffer) {
  dataBuffer.uncork();
}
function onFinish(outmsg) {
  outmsg.emit("finish");
}
Object.defineProperties(FetchOutgoingMessage.prototype, {
  errored: {
    get() {
      return this[kErrored];
    }
  },
  closed: {
    get() {
      return this._closed;
    }
  },
  writableFinished: {
    get() {
      return this.finished && this.outputSize === 0 && (this._writtenDataBuffer == null || this._writtenDataBuffer.writableLength === 0);
    }
  },
  writableObjectMode: {
    get() {
      return false;
    }
  },
  writableLength: {
    get() {
      return this.outputSize + this[kChunkedLength] + (this._writtenDataBuffer != null ? this._writtenDataBuffer.writableLength : 0);
    }
  },
  writableHighWaterMark: {
    get() {
      return this._writtenDataBuffer != null ? this._writtenDataBuffer.writableHighWaterMark : this[kHighWaterMark];
    }
  },
  writableCorked: {
    get() {
      return this[kCorked];
    }
  },
  writableEnded: {
    get() {
      return this.finished;
    }
  },
  writableNeedDrain: {
    get() {
      return !this.destroyed && !this.finished && this[kNeedDrain];
    }
  }
});
var headerCharRegex2 = /[^\t\x20-\x7e\x80-\xff]/;
function checkInvalidHeaderChar2(val) {
  return headerCharRegex2.test(val);
}
var STATUS_CODES = {
  100: "Continue",
  // RFC 7231 6.2.1
  101: "Switching Protocols",
  // RFC 7231 6.2.2
  102: "Processing",
  // RFC 2518 10.1 (obsoleted by RFC 4918)
  103: "Early Hints",
  // RFC 8297 2
  200: "OK",
  // RFC 7231 6.3.1
  201: "Created",
  // RFC 7231 6.3.2
  202: "Accepted",
  // RFC 7231 6.3.3
  203: "Non-Authoritative Information",
  // RFC 7231 6.3.4
  204: "No Content",
  // RFC 7231 6.3.5
  205: "Reset Content",
  // RFC 7231 6.3.6
  206: "Partial Content",
  // RFC 7233 4.1
  207: "Multi-Status",
  // RFC 4918 11.1
  208: "Already Reported",
  // RFC 5842 7.1
  226: "IM Used",
  // RFC 3229 10.4.1
  300: "Multiple Choices",
  // RFC 7231 6.4.1
  301: "Moved Permanently",
  // RFC 7231 6.4.2
  302: "Found",
  // RFC 7231 6.4.3
  303: "See Other",
  // RFC 7231 6.4.4
  304: "Not Modified",
  // RFC 7232 4.1
  305: "Use Proxy",
  // RFC 7231 6.4.5
  307: "Temporary Redirect",
  // RFC 7231 6.4.7
  308: "Permanent Redirect",
  // RFC 7238 3
  400: "Bad Request",
  // RFC 7231 6.5.1
  401: "Unauthorized",
  // RFC 7235 3.1
  402: "Payment Required",
  // RFC 7231 6.5.2
  403: "Forbidden",
  // RFC 7231 6.5.3
  404: "Not Found",
  // RFC 7231 6.5.4
  405: "Method Not Allowed",
  // RFC 7231 6.5.5
  406: "Not Acceptable",
  // RFC 7231 6.5.6
  407: "Proxy Authentication Required",
  // RFC 7235 3.2
  408: "Request Timeout",
  // RFC 7231 6.5.7
  409: "Conflict",
  // RFC 7231 6.5.8
  410: "Gone",
  // RFC 7231 6.5.9
  411: "Length Required",
  // RFC 7231 6.5.10
  412: "Precondition Failed",
  // RFC 7232 4.2
  413: "Payload Too Large",
  // RFC 7231 6.5.11
  414: "URI Too Long",
  // RFC 7231 6.5.12
  415: "Unsupported Media Type",
  // RFC 7231 6.5.13
  416: "Range Not Satisfiable",
  // RFC 7233 4.4
  417: "Expectation Failed",
  // RFC 7231 6.5.14
  418: "I'm a Teapot",
  // RFC 7168 2.3.3
  421: "Misdirected Request",
  // RFC 7540 9.1.2
  422: "Unprocessable Entity",
  // RFC 4918 11.2
  423: "Locked",
  // RFC 4918 11.3
  424: "Failed Dependency",
  // RFC 4918 11.4
  425: "Too Early",
  // RFC 8470 5.2
  426: "Upgrade Required",
  // RFC 2817 and RFC 7231 6.5.15
  428: "Precondition Required",
  // RFC 6585 3
  429: "Too Many Requests",
  // RFC 6585 4
  431: "Request Header Fields Too Large",
  // RFC 6585 5
  451: "Unavailable For Legal Reasons",
  // RFC 7725 3
  500: "Internal Server Error",
  // RFC 7231 6.6.1
  501: "Not Implemented",
  // RFC 7231 6.6.2
  502: "Bad Gateway",
  // RFC 7231 6.6.3
  503: "Service Unavailable",
  // RFC 7231 6.6.4
  504: "Gateway Timeout",
  // RFC 7231 6.6.5
  505: "HTTP Version Not Supported",
  // RFC 7231 6.6.6
  506: "Variant Also Negotiates",
  // RFC 2295 8.1
  507: "Insufficient Storage",
  // RFC 4918 11.5
  508: "Loop Detected",
  // RFC 5842 7.2
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  // RFC 2774 7
  511: "Network Authentication Required"
  // RFC 6585 6
};
var FetchServerResponse = class _FetchServerResponse extends FetchOutgoingMessage {
  static encoder = new TextEncoder();
  statusCode = 200;
  statusMessage;
  _sent100;
  _expect_continue;
  [kOutHeaders] = null;
  constructor(req, options) {
    super(req, options);
    if (req.method === "HEAD") {
      this._hasBody = false;
    }
    this.sendDate = true;
    this._sent100 = false;
    this._expect_continue = false;
    if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {
      this.useChunkedEncodingByDefault = chunkExpression.exec(String(req.headers.te)) !== null;
      this.shouldKeepAlive = false;
    }
    this.fetchResponse = new Promise((resolve) => {
      let finished = false;
      this.on("finish", () => {
        finished = true;
      });
      const initialDataChunks = [];
      const initialDataWrittenHandler = (e) => {
        if (finished) {
          return;
        }
        initialDataChunks[e.index] = this.dataFromDataWrittenEvent(e);
      };
      this.on("_dataWritten", initialDataWrittenHandler);
      this.on("_headersSent", (e) => {
        this.off("_dataWritten", initialDataWrittenHandler);
        const { statusCode, statusMessage, headers } = e;
        resolve(this._toFetchResponse(statusCode, statusMessage, headers, initialDataChunks, finished));
      });
    });
  }
  dataFromDataWrittenEvent(e) {
    const { index, entry } = e;
    let { data, encoding } = entry;
    if (index === 0) {
      if (typeof data !== "string") {
        console.error("First chunk should be string, not sure what happened.");
        throw new ERR_INVALID_ARG_TYPE("packet.data", ["string", "Buffer", "Uint8Array"], data);
      }
      data = data.slice(this.writtenHeaderBytes);
    }
    if (typeof data === "string") {
      if (encoding === void 0 || encoding === "utf8" || encoding === "utf-8") {
        data = _FetchServerResponse.encoder.encode(data);
      } else {
        data = Buffer$1.from(data, encoding ?? void 0);
      }
    }
    return data ?? Buffer$1.from([]);
  }
  _finish() {
    super._finish();
  }
  assignSocket(socket) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("assignSocket");
  }
  detachSocket(socket) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("detachSocket");
  }
  writeContinue(callback) {
    this._writeRaw("HTTP/1.1 100 Continue\r\n\r\n", "ascii", callback);
    this._sent100 = true;
  }
  writeProcessing(callback) {
    this._writeRaw("HTTP/1.1 102 Processing\r\n\r\n", "ascii", callback);
  }
  writeEarlyHints(hints, callback) {
    let head = "HTTP/1.1 103 Early Hints\r\n";
    if (hints.link === null || hints.link === void 0) {
      return;
    }
    const link = validateLinkHeaderValue(hints.link);
    if (link.length === 0) {
      return;
    }
    head += "Link: " + link + "\r\n";
    for (const key of Object.keys(hints)) {
      if (key !== "link") {
        head += key + ": " + hints[key] + "\r\n";
      }
    }
    head += "\r\n";
    this._writeRaw(head, "ascii", callback);
  }
  _implicitHeader() {
    this.writeHead(this.statusCode);
  }
  writeHead(statusCode, reason, obj) {
    if (this._header) {
      throw new ERR_HTTP_HEADERS_SENT("write");
    }
    const originalStatusCode = statusCode;
    statusCode |= 0;
    if (statusCode < 100 || statusCode > 999) {
      throw new ERR_HTTP_INVALID_STATUS_CODE(originalStatusCode);
    }
    if (typeof reason === "string") {
      this.statusMessage = reason;
    } else {
      this.statusMessage ||= STATUS_CODES[statusCode] || "unknown";
      obj ??= reason;
    }
    this.statusCode = statusCode;
    let headers;
    if (this[kOutHeaders]) {
      let k;
      if (Array.isArray(obj)) {
        if (obj.length % 2 !== 0) {
          throw new ERR_INVALID_ARG_VALUE("headers", obj);
        }
        for (let n = 0; n < obj.length; n += 2) {
          k = obj[n + 0];
          this.removeHeader(String(k));
        }
        for (let n = 0; n < obj.length; n += 2) {
          k = obj[n];
          if (k) {
            this.appendHeader(String(k), obj[n + 1]);
          }
        }
      } else if (obj) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          k = keys[i];
          if (k) {
            this.setHeader(k, obj[k]);
          }
        }
      }
      headers = this[kOutHeaders];
    } else {
      headers = obj;
    }
    if (checkInvalidHeaderChar2(this.statusMessage)) {
      throw new ERR_INVALID_CHAR("statusMessage");
    }
    const statusLine = `HTTP/1.1 ${statusCode} ${this.statusMessage}\r
`;
    if (statusCode === 204 || statusCode === 304 || statusCode >= 100 && statusCode <= 199) {
      this._hasBody = false;
    }
    if (this._expect_continue && !this._sent100) {
      this.shouldKeepAlive = false;
    }
    const convertedHeaders = headers && !Array.isArray(headers) ? headers : headers;
    this._storeHeader(statusLine, convertedHeaders ?? null);
    return this;
  }
  // Docs-only deprecated: DEP0063
  writeHeader = this.writeHead;
  fetchResponse;
  _toFetchResponse(status, statusText, sentHeaders, initialDataChunks, finished) {
    const headers = new Headers();
    for (const [header, value] of sentHeaders) {
      headers.append(header, value);
    }
    const _this = this;
    let body = this._hasBody ? new ReadableStream({
      start(controller) {
        for (const dataChunk of initialDataChunks) {
          controller.enqueue(dataChunk);
        }
        if (finished) {
          controller.close();
        } else {
          _this.on("finish", () => {
            finished = true;
            controller.close();
          });
          _this.on("_dataWritten", (e) => {
            if (finished) {
              return;
            }
            const data = _this.dataFromDataWrittenEvent(e);
            controller.enqueue(data);
          });
        }
      }
    }) : null;
    if (body != null && typeof FixedLengthStream !== "undefined") {
      const contentLength = parseInt(headers.get("content-length") ?? "", 10);
      if (contentLength >= 0) {
        body = body.pipeThrough(new FixedLengthStream(contentLength));
      }
    }
    return new Response(body, {
      status,
      statusText,
      headers
    });
  }
};
function toReqRes(req, options) {
  const { createIncomingMessage = () => new FetchIncomingMessage(), createServerResponse = (incoming2) => new FetchServerResponse(incoming2), ctx } = {};
  const incoming = createIncomingMessage(ctx);
  const serverResponse = createServerResponse(incoming, ctx);
  const reqUrl = new URL(req.url);
  const versionMajor = 1;
  const versionMinor = 1;
  incoming.httpVersionMajor = versionMajor;
  incoming.httpVersionMinor = versionMinor;
  incoming.httpVersion = `${versionMajor}.${versionMinor}`;
  incoming.url = reqUrl.pathname + reqUrl.search;
  incoming.upgrade = false;
  const headers = [];
  for (const [headerName, headerValue] of req.headers) {
    headers.push(headerName);
    headers.push(headerValue);
  }
  incoming._addHeaderLines(headers, headers.length);
  incoming.method = req.method;
  incoming._stream = req.body;
  return {
    req: incoming,
    res: serverResponse
  };
}
function toFetchResponse(res) {
  if (!(res instanceof FetchServerResponse)) {
    throw new Error("toFetchResponse must be called on a ServerResponse generated by toReqRes");
  }
  return res.fetchResponse;
}
var HTTPException = class extends Error {
  res;
  status;
  /**
   * Creates an instance of `HTTPException`.
   * @param status - HTTP status code for the exception. Defaults to 500.
   * @param options - Additional options for the exception.
   */
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  /**
   * Returns the response object associated with the exception.
   * If a response object is not provided, a new response is created with the error message and status code.
   * @returns The response object.
   */
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};
var ERROR_MESSAGE = "Payload Too Large";
var BodyLimitError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "BodyLimitError";
  }
};
var bodyLimit = (options) => {
  const onError3 = options.onError || (() => {
    const res = new Response(ERROR_MESSAGE, {
      status: 413
    });
    throw new HTTPException(413, { res });
  });
  const maxSize = options.maxSize;
  return async function bodyLimit2(c, next) {
    if (!c.req.raw.body) {
      return next();
    }
    const hasTransferEncoding = c.req.raw.headers.has("transfer-encoding");
    const hasContentLength = c.req.raw.headers.has("content-length");
    if (hasContentLength && !hasTransferEncoding) {
      const contentLength = parseInt(c.req.raw.headers.get("content-length") || "0", 10);
      return contentLength > maxSize ? onError3(c) : next();
    }
    let size = 0;
    const rawReader = c.req.raw.body.getReader();
    const reader = new ReadableStream({
      async start(controller) {
        try {
          for (; ; ) {
            const { done, value } = await rawReader.read();
            if (done) {
              break;
            }
            size += value.length;
            if (size > maxSize) {
              controller.error(new BodyLimitError(ERROR_MESSAGE));
              break;
            }
            controller.enqueue(value);
          }
        } finally {
          controller.close();
        }
      }
    });
    const requestInit = { body: reader, duplex: "half" };
    c.req.raw = new Request(c.req.raw, requestInit);
    await next();
    if (c.error instanceof BodyLimitError) {
      c.res = await onError3(c);
    }
  };
};
var StreamingApi = class {
  writer;
  encoder;
  writable;
  abortSubscribers = [];
  responseReadable;
  /**
   * Whether the stream has been aborted.
   */
  aborted = false;
  /**
   * Whether the stream has been closed normally.
   */
  closed = false;
  constructor(writable, _readable) {
    this.writable = writable;
    this.writer = writable.getWriter();
    this.encoder = new TextEncoder();
    const reader = _readable.getReader();
    this.abortSubscribers.push(async () => {
      await reader.cancel();
    });
    this.responseReadable = new ReadableStream({
      async pull(controller) {
        const { done, value } = await reader.read();
        done ? controller.close() : controller.enqueue(value);
      },
      cancel: () => {
        this.abort();
      }
    });
  }
  async write(input) {
    try {
      if (typeof input === "string") {
        input = this.encoder.encode(input);
      }
      await this.writer.write(input);
    } catch {
    }
    return this;
  }
  async writeln(input) {
    await this.write(input + "\n");
    return this;
  }
  sleep(ms) {
    return new Promise((res) => setTimeout(res, ms));
  }
  async close() {
    try {
      await this.writer.close();
    } catch {
    }
    this.closed = true;
  }
  async pipe(body) {
    this.writer.releaseLock();
    await body.pipeTo(this.writable, { preventClose: true });
    this.writer = this.writable.getWriter();
  }
  onAbort(listener) {
    this.abortSubscribers.push(listener);
  }
  /**
   * Abort the stream.
   * You can call this method when stream is aborted by external event.
   */
  abort() {
    if (!this.aborted) {
      this.aborted = true;
      this.abortSubscribers.forEach((subscriber) => subscriber());
    }
  }
};
var isOldBunVersion = () => {
  const version = typeof Bun !== "undefined" ? Bun.version : void 0;
  if (version === void 0) {
    return false;
  }
  const result = version.startsWith("1.1") || version.startsWith("1.0") || version.startsWith("0.");
  isOldBunVersion = () => result;
  return result;
};
var contextStash = /* @__PURE__ */ new WeakMap();
var stream = (c, cb, onError3) => {
  const { readable, writable } = new TransformStream();
  const stream2 = new StreamingApi(writable, readable);
  if (isOldBunVersion()) {
    c.req.raw.signal.addEventListener("abort", () => {
      if (!stream2.closed) {
        stream2.abort();
      }
    });
  }
  contextStash.set(stream2.responseReadable, c);
  (async () => {
    try {
      await cb(stream2);
    } catch (e) {
      if (e === void 0) ;
      else if (e instanceof Error && onError3) {
        await onError3(e, stream2);
      } else {
        console.error(e);
      }
    } finally {
      stream2.close();
    }
  })();
  return c.newResponse(stream2.responseReadable);
};
var util2;
(function(util22) {
  util22.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util22.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util22.assertNever = assertNever;
  util22.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util22.getValidEnumValues = (obj) => {
    const validKeys = util22.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util22.objectValues(filtered);
  };
  util22.objectValues = (obj) => {
    return util22.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util22.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util22.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util22.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util22.joinValues = joinValues;
  util22.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util2 || (util2 = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
util2.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
util2.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util2.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var authenticationMiddleware = async (c, next) => {
  const mastra = c.get("mastra");
  const authConfig = mastra.getServer()?.auth;
  const customRouteAuthConfig = c.get("customRouteAuthConfig");
  if (!authConfig) {
    return next();
  }
  const path = c.req.path;
  const method = c.req.method;
  const getHeader = (name) => c.req.header(name);
  if (isDevPlaygroundRequest(path, method, getHeader, authConfig, customRouteAuthConfig)) {
    return next();
  }
  if (!isProtectedPath(c.req.path, c.req.method, authConfig, customRouteAuthConfig)) {
    return next();
  }
  if (canAccessPublicly(c.req.path, c.req.method, authConfig)) {
    return next();
  }
  const authHeader = c.req.header("Authorization");
  let token = authHeader ? authHeader.replace("Bearer ", "") : null;
  if (!token && c.req.query("apiKey")) {
    token = c.req.query("apiKey") || null;
  }
  if (!token) {
    return c.json({ error: "Authentication required" }, 401);
  }
  try {
    let user;
    if (typeof authConfig.authenticateToken === "function") {
      user = await authConfig.authenticateToken(token, c.req);
    } else {
      throw new Error("No token verification method configured");
    }
    if (!user) {
      return c.json({ error: "Invalid or expired token" }, 401);
    }
    c.get("requestContext").set("user", user);
    return next();
  } catch (err) {
    mastra.getLogger()?.error("Authentication error", {
      error: err instanceof Error ? { message: err.message, stack: err.stack } : err
    });
    return c.json({ error: "Invalid or expired token" }, 401);
  }
};
var authorizationMiddleware = async (c, next) => {
  const mastra = c.get("mastra");
  const authConfig = mastra.getServer()?.auth;
  const customRouteAuthConfig = c.get("customRouteAuthConfig");
  if (!authConfig) {
    return next();
  }
  const path = c.req.path;
  const method = c.req.method;
  const getHeader = (name) => c.req.header(name);
  if (isDevPlaygroundRequest(path, method, getHeader, authConfig, customRouteAuthConfig)) {
    return next();
  }
  if (!isProtectedPath(c.req.path, c.req.method, authConfig, customRouteAuthConfig)) {
    return next();
  }
  if (canAccessPublicly(path, method, authConfig)) {
    return next();
  }
  const user = c.get("requestContext").get("user");
  if ("authorizeUser" in authConfig && typeof authConfig.authorizeUser === "function") {
    try {
      const isAuthorized = await authConfig.authorizeUser(user, c.req);
      if (isAuthorized) {
        return next();
      }
      return c.json({ error: "Access denied" }, 403);
    } catch (err) {
      mastra.getLogger()?.error("Authorization error in authorizeUser", {
        error: err instanceof Error ? { message: err.message, stack: err.stack } : err
      });
      return c.json({ error: "Authorization error" }, 500);
    }
  }
  if ("authorize" in authConfig && typeof authConfig.authorize === "function") {
    try {
      const isAuthorized = await authConfig.authorize(path, method, user, c);
      if (isAuthorized) {
        return next();
      }
      return c.json({ error: "Access denied" }, 403);
    } catch (err) {
      mastra.getLogger()?.error("Authorization error in authorize", {
        error: err instanceof Error ? { message: err.message, stack: err.stack } : err,
        path,
        method
      });
      return c.json({ error: "Authorization error" }, 500);
    }
  }
  if ("rules" in authConfig && authConfig.rules && authConfig.rules.length > 0) {
    const isAuthorized = await checkRules(authConfig.rules, path, method, user);
    if (isAuthorized) {
      return next();
    }
    return c.json({ error: "Access denied" }, 403);
  }
  if (defaultAuthConfig.rules && defaultAuthConfig.rules.length > 0) {
    const isAuthorized = await checkRules(defaultAuthConfig.rules, path, method, user);
    if (isAuthorized) {
      return next();
    }
  }
  return c.json({ error: "Access denied" }, 403);
};
var MastraServer = class extends MastraServer$1 {
  createContextMiddleware() {
    return async (c, next) => {
      const originalJson = c.req.json.bind(c.req);
      let jsonPromise;
      c.req.json = () => {
        if (!jsonPromise) {
          jsonPromise = originalJson().then((body) => {
            c.set("cachedBody", body);
            return body;
          });
        }
        return jsonPromise;
      };
      let bodyRequestContext;
      let paramsRequestContext;
      if (c.req.method === "POST" || c.req.method === "PUT") {
        const contentType = c.req.header("content-type");
        if (contentType?.includes("application/json")) {
          try {
            const body = await c.req.raw.clone().json();
            if (body.requestContext) {
              bodyRequestContext = body.requestContext;
            }
          } catch {
          }
        }
      }
      if (c.req.method === "GET") {
        try {
          const encodedRequestContext = c.req.query("requestContext");
          if (encodedRequestContext) {
            try {
              paramsRequestContext = JSON.parse(encodedRequestContext);
            } catch {
              try {
                const json = Buffer.from(encodedRequestContext, "base64").toString("utf-8");
                paramsRequestContext = JSON.parse(json);
              } catch {
              }
            }
          }
        } catch {
        }
      }
      const requestContext = this.mergeRequestContext({ paramsRequestContext, bodyRequestContext });
      c.set("requestContext", requestContext);
      c.set("mastra", this.mastra);
      c.set("registeredTools", this.tools || {});
      c.set("taskStore", this.taskStore);
      c.set("abortSignal", c.req.raw.signal);
      c.set("customRouteAuthConfig", this.customRouteAuthConfig);
      return next();
    };
  }
  async stream(route, res, result) {
    res.header("Content-Type", "text/plain");
    res.header("Transfer-Encoding", "chunked");
    const streamFormat = route.streamFormat || "stream";
    return stream(
      res,
      async (stream2) => {
        const readableStream = result instanceof ReadableStream ? result : result.fullStream;
        const reader = readableStream.getReader();
        stream2.onAbort(() => {
          void reader.cancel("request aborted");
        });
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            if (value) {
              const shouldRedact = this.streamOptions?.redact ?? true;
              const outputValue = shouldRedact ? redactStreamChunk(value) : value;
              if (streamFormat === "sse") {
                await stream2.write(`data: ${JSON.stringify(outputValue)}

`);
              } else {
                await stream2.write(JSON.stringify(outputValue) + "");
              }
            }
          }
          await stream2.write("data: [DONE]\n\n");
        } catch (error) {
          this.mastra.getLogger()?.error("Error in stream processing", {
            error: error instanceof Error ? { message: error.message, stack: error.stack } : error
          });
        } finally {
          await stream2.close();
        }
      },
      async (err) => {
        this.mastra.getLogger()?.error("Stream error callback", {
          error: err instanceof Error ? { message: err.message, stack: err.stack } : err
        });
      }
    );
  }
  async getParams(route, request) {
    const urlParams = request.param();
    const queryParams = normalizeQueryParams(request.queries());
    let body;
    let bodyParseError;
    if (route.method === "POST" || route.method === "PUT" || route.method === "PATCH" || route.method === "DELETE") {
      const contentType = request.header("content-type") || "";
      if (contentType.includes("multipart/form-data")) {
        try {
          const formData = await request.formData();
          body = await this.parseFormData(formData);
        } catch (error) {
          this.mastra.getLogger()?.error("Failed to parse multipart form data", {
            error: error instanceof Error ? { message: error.message, stack: error.stack } : error
          });
          if (error instanceof Error && error.message.toLowerCase().includes("size")) {
            throw error;
          }
          bodyParseError = {
            message: error instanceof Error ? error.message : "Failed to parse multipart form data"
          };
        }
      } else if (contentType.includes("application/json")) {
        const clonedReq = request.raw.clone();
        const bodyText = await clonedReq.text();
        if (bodyText && bodyText.trim().length > 0) {
          try {
            body = JSON.parse(bodyText);
          } catch (error) {
            this.mastra.getLogger()?.error("Failed to parse JSON body", {
              error: error instanceof Error ? { message: error.message, stack: error.stack } : error
            });
            bodyParseError = {
              message: error instanceof Error ? error.message : "Invalid JSON in request body"
            };
          }
        }
      }
    }
    return { urlParams, queryParams, body, bodyParseError };
  }
  /**
   * Parse FormData into a plain object, converting File objects to Buffers.
   */
  async parseFormData(formData) {
    const result = {};
    for (const [key, value] of formData.entries()) {
      if (value instanceof File) {
        const arrayBuffer = await value.arrayBuffer();
        result[key] = Buffer.from(arrayBuffer);
      } else if (typeof value === "string") {
        try {
          result[key] = JSON.parse(value);
        } catch {
          result[key] = value;
        }
      } else {
        result[key] = value;
      }
    }
    return result;
  }
  async sendResponse(route, response, result, prefix) {
    const resolvedPrefix = prefix ?? this.prefix ?? "";
    if (route.responseType === "json") {
      return response.json(result, 200);
    } else if (route.responseType === "stream") {
      return this.stream(route, response, result);
    } else if (route.responseType === "datastream-response") {
      const fetchResponse = result;
      return fetchResponse;
    } else if (route.responseType === "mcp-http") {
      const { server, httpPath, mcpOptions: routeMcpOptions } = result;
      const { req, res } = toReqRes(response.req.raw);
      try {
        const options = { ...this.mcpOptions, ...routeMcpOptions };
        await server.startHTTP({
          url: new URL(response.req.url),
          httpPath: `${resolvedPrefix}${httpPath}`,
          req,
          res,
          options: Object.keys(options).length > 0 ? options : void 0
        });
        return await toFetchResponse(res);
      } catch {
        if (!res.headersSent) {
          res.writeHead(500, { "Content-Type": "application/json" });
          res.end(
            JSON.stringify({
              jsonrpc: "2.0",
              error: { code: -32603, message: "Internal server error" },
              id: null
            })
          );
          return await toFetchResponse(res);
        }
        return await toFetchResponse(res);
      }
    } else if (route.responseType === "mcp-sse") {
      const { server, ssePath, messagePath } = result;
      try {
        return await server.startHonoSSE({
          url: new URL(response.req.url),
          ssePath: `${resolvedPrefix}${ssePath}`,
          messagePath: `${resolvedPrefix}${messagePath}`,
          context: response
        });
      } catch {
        return response.json({ error: "Error handling MCP SSE request" }, 500);
      }
    } else {
      return response.status(500);
    }
  }
  async registerRoute(app, route, { prefix: prefixParam } = {}) {
    const prefix = prefixParam ?? this.prefix ?? "";
    const shouldApplyBodyLimit = this.bodyLimitOptions && ["POST", "PUT", "PATCH"].includes(route.method.toUpperCase());
    const maxSize = route.maxBodySize ?? this.bodyLimitOptions?.maxSize;
    const middlewares = [];
    if (shouldApplyBodyLimit && maxSize && this.bodyLimitOptions) {
      middlewares.push(
        bodyLimit({
          maxSize,
          onError: this.bodyLimitOptions.onError
        })
      );
    }
    app[route.method.toLowerCase()](
      `${prefix}${route.path}`,
      ...middlewares,
      async (c) => {
        const authError = await this.checkRouteAuth(route, {
          path: c.req.path,
          method: c.req.method,
          getHeader: (name) => c.req.header(name),
          getQuery: (name) => c.req.query(name),
          requestContext: c.get("requestContext")
        });
        if (authError) {
          return c.json({ error: authError.error }, authError.status);
        }
        const params = await this.getParams(route, c.req);
        if (params.bodyParseError) {
          return c.json(
            {
              error: "Invalid request body",
              issues: [{ field: "body", message: params.bodyParseError.message }]
            },
            400
          );
        }
        if (params.queryParams) {
          try {
            params.queryParams = await this.parseQueryParams(route, params.queryParams);
          } catch (error) {
            this.mastra.getLogger()?.error("Error parsing query params", {
              error: error instanceof Error ? { message: error.message, stack: error.stack } : error
            });
            if (error instanceof ZodError) {
              return c.json(formatZodError(error, "query parameters"), 400);
            }
            return c.json(
              {
                error: "Invalid query parameters",
                issues: [{ field: "unknown", message: error instanceof Error ? error.message : "Unknown error" }]
              },
              400
            );
          }
        }
        if (params.body) {
          try {
            params.body = await this.parseBody(route, params.body);
          } catch (error) {
            this.mastra.getLogger()?.error("Error parsing body", {
              error: error instanceof Error ? { message: error.message, stack: error.stack } : error
            });
            if (error instanceof ZodError) {
              return c.json(formatZodError(error, "request body"), 400);
            }
            return c.json(
              {
                error: "Invalid request body",
                issues: [{ field: "unknown", message: error instanceof Error ? error.message : "Unknown error" }]
              },
              400
            );
          }
        }
        const handlerParams = {
          ...params.urlParams,
          ...params.queryParams,
          ...typeof params.body === "object" ? params.body : {},
          requestContext: c.get("requestContext"),
          mastra: this.mastra,
          registeredTools: c.get("registeredTools"),
          taskStore: c.get("taskStore"),
          abortSignal: c.get("abortSignal"),
          routePrefix: prefix
        };
        try {
          const result = await route.handler(handlerParams);
          return this.sendResponse(route, c, result, prefix);
        } catch (error) {
          this.mastra.getLogger()?.error("Error calling handler", {
            error: error instanceof Error ? { message: error.message, stack: error.stack } : error,
            path: route.path,
            method: route.method
          });
          if (error && typeof error === "object") {
            if ("status" in error) {
              const status = error.status;
              return c.json({ error: error instanceof Error ? error.message : "Unknown error" }, status);
            }
            if ("details" in error && error.details && typeof error.details === "object" && "status" in error.details) {
              const status = error.details.status;
              return c.json({ error: error instanceof Error ? error.message : "Unknown error" }, status);
            }
          }
          return c.json({ error: error instanceof Error ? error.message : "Unknown error" }, 500);
        }
      }
    );
  }
  async registerCustomApiRoutes() {
    const routes = this.customApiRoutes ?? this.mastra.getServer()?.apiRoutes;
    if (!routes || routes.length === 0) return;
    for (const route of routes) {
      const handler = "handler" in route && route.handler ? route.handler : "createHandler" in route ? await route.createHandler({ mastra: this.mastra }) : void 0;
      if (!handler) continue;
      const middlewares = [];
      if (route.middleware) {
        middlewares.push(...Array.isArray(route.middleware) ? route.middleware : [route.middleware]);
      }
      const allHandlers = [...middlewares, handler];
      const method = route.method.toLowerCase();
      this.app[method](route.path, allHandlers[0], ...allHandlers.slice(1));
    }
  }
  registerContextMiddleware() {
    this.app.use("*", this.createContextMiddleware());
  }
  registerAuthMiddleware() {
    const authConfig = this.mastra.getServer()?.auth;
    if (!authConfig) {
      return;
    }
    this.app.use("*", authenticationMiddleware);
    this.app.use("*", authorizationMiddleware);
  }
};

// ../../node_modules/.pnpm/hono-openapi@1.1.1_@hono+standard-validator@0.2.2_@standard-schema+spec@1.1.0_hono@4.11_3e74ff9abd3c579ae061185f8bb0e452/node_modules/hono-openapi/dist/index.js
var uniqueSymbol = /* @__PURE__ */ Symbol("openapi");
function describeRoute(spec) {
  const middleware2 = async (_c, next) => {
    await next();
  };
  return Object.assign(middleware2, {
    [uniqueSymbol]: {
      spec
    }
  });
}

// src/server/handlers/client.ts
var clients = /* @__PURE__ */ new Set();
var hotReloadDisabled = false;
function handleClientsRefresh(c) {
  const stream2 = new ReadableStream({
    start(controller) {
      clients.add(controller);
      controller.enqueue("data: connected\n\n");
      c.req.raw.signal.addEventListener("abort", () => {
        clients.delete(controller);
      });
    }
  });
  return new Response(stream2, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
function handleTriggerClientsRefresh(c) {
  clients.forEach((controller) => {
    try {
      controller.enqueue("data: refresh\n\n");
    } catch {
      clients.delete(controller);
    }
  });
  return c.json({ success: true, clients: clients.size });
}
function isHotReloadDisabled() {
  return hotReloadDisabled;
}
function handleError(error, defaultMessage) {
  const apiError = error;
  throw new HTTPException$1(apiError.status || 500, {
    message: apiError.message || defaultMessage,
    cause: apiError.cause
  });
}
function errorHandler(err, c, isDev) {
  if (err instanceof HTTPException$1) {
    if (isDev) {
      return c.json({ error: err.message, cause: err.cause, stack: err.stack }, err.status);
    }
    return c.json({ error: err.message }, err.status);
  }
  c.get("mastra").getLogger().error(err);
  return c.json({ error: "Internal Server Error" }, 500);
}

// src/server/handlers/health.ts
async function healthHandler(c) {
  return c.json({ success: true }, 200);
}

// src/server/handlers/restart-active-runs.ts
async function restartAllActiveWorkflowRunsHandler(c) {
  try {
    const mastra = c.get("mastra");
    void mastra.restartAllActiveWorkflowRuns();
    return c.json({ message: "Restarting all active workflow runs..." });
  } catch (error) {
    return handleError(error, "Error restarting active workflow runs");
  }
}

// src/server/handlers/root.ts
async function rootHandler(c) {
  const baseUrl = new URL(c.req.url).origin;
  return c.html(
    /* html */
    `
    <!doctype html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Mastra API</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/inter-ui/3.19.3/inter.min.css" />
        <style>
          body {
            margin: 0;
            padding: 0;
            background-color: #0d0d0d;
            color: #ffffff;
            font-family:
              'Inter',
              -apple-system,
              BlinkMacSystemFont,
              system-ui,
              sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
          }

          main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            text-align: center;
          }

          h1 {
            font-size: 4rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
            background: linear-gradient(to right, #fff, #ccc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1.2;
          }

          .subtitle {
            color: #9ca3af;
            font-size: 1.25rem;
            max-width: 600px;
            margin: 0 auto 3rem auto;
            line-height: 1.6;
          }

          .link {
            color: #ffffff;
          }

          .link:hover {
            text-decoration: none;
          }

          .docs-link {
            background-color: #1a1a1a;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            font-family: monospace;
            font-size: 1rem;
            color: #ffffff;
            text-decoration: none;
            transition: background-color 0.2s;
          }

          .docs-link:hover {
            background-color: #252525;
          }

          .arrow-icon {
            transition: transform 0.2s;
          }

          .docs-link:hover .arrow-icon {
            transform: translateX(4px);
          }
        </style>
      </head>
      <body>
        <main>
          <h1>Welcome to the Mastra API</h1>
          <p class="subtitle">
            Discover all available endpoints through Swagger UI. You can also define your own <a href="https://mastra.ai/docs/server-db/custom-api-routes" target="_blank" class="link">API routes</a>.
          </p>
          <a href="${baseUrl}/swagger-ui" target="_blank" class="docs-link">
            Browse Swagger UI
            <svg
              class="arrow-icon"
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
            >
              <path d="M5 12h14M12 5l7 7-7 7" />
            </svg>
          </a>
        </main>
      </body>
    </html>
    `
  );
}

// src/server/welcome.ts
var html2 = `
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Welcome to Mastra</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/inter-ui/3.19.3/inter.min.css" />
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #0d0d0d;
        color: #ffffff;
        font-family:
          'Inter',
          -apple-system,
          BlinkMacSystemFont,
          system-ui,
          sans-serif;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      main {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        text-align: center;
      }

      h1 {
        font-size: 4rem;
        font-weight: 600;
        margin: 0 0 1rem 0;
        background: linear-gradient(to right, #fff, #ccc);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        line-height: 1.2;
      }

      .subtitle {
        color: #9ca3af;
        font-size: 1.25rem;
        max-width: 600px;
        margin: 0 auto 3rem auto;
        line-height: 1.6;
      }

      .docs-link {
        background-color: #1a1a1a;
        padding: 1rem 2rem;
        border-radius: 0.5rem;
        display: flex;
        align-items: center;
        gap: 1rem;
        font-family: monospace;
        font-size: 1rem;
        color: #ffffff;
        text-decoration: none;
        transition: background-color 0.2s;
      }

      .docs-link:hover {
        background-color: #252525;
      }

      .arrow-icon {
        transition: transform 0.2s;
      }

      .docs-link:hover .arrow-icon {
        transform: translateX(4px);
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Welcome to Mastra</h1>
      <p class="subtitle">
        Prototype and productionize AI features with a modern JS/TS stack.
      </p>

      <a href="https://mastra.ai/docs" class="docs-link">
        Browse the docs
        <svg
          class="arrow-icon"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
        >
          <path d="M5 12h14M12 5l7 7-7 7" />
        </svg>
      </a>
    </main>
  </body>
</html>
`;

// src/server/index.ts
var getStudioPath = () => {
  if (process.env.MASTRA_STUDIO_PATH) {
    return process.env.MASTRA_STUDIO_PATH;
  }
  let __dirname = ".";
  if (import.meta.url) {
    const __filename = fileURLToPath(import.meta.url);
    __dirname = dirname(__filename);
  }
  const studioPath = process.env.MASTRA_STUDIO_PATH || join(__dirname, "studio");
  return studioPath;
};
function getToolExports(tools) {
  try {
    return tools.reduce((acc, toolModule) => {
      Object.entries(toolModule).forEach(([key, tool]) => {
        if (tool instanceof Tool) {
          acc[key] = tool;
        }
      });
      return acc;
    }, {});
  } catch (err) {
    console.error(
      `Failed to import tools
reason: ${err.message}
${err.stack.split("\n").slice(1).join("\n")}
    `,
      err
    );
  }
}
async function createHonoServer(mastra, options = {
  tools: {}
}) {
  if (options.tools) {
    for (const [key, tool] of Object.entries(options.tools)) {
      try {
        mastra.addTool(tool, key);
      } catch {
      }
    }
  }
  const app = new Hono();
  const server = mastra.getServer();
  const a2aTaskStore = new InMemoryTaskStore();
  const routes = server?.apiRoutes;
  const customRouteAuthConfig = /* @__PURE__ */ new Map();
  if (routes) {
    for (const route of routes) {
      const requiresAuth = route.requiresAuth !== false;
      const routeKey = `${route.method}:${route.path}`;
      customRouteAuthConfig.set(routeKey, requiresAuth);
    }
  }
  const customOnError = server?.onError;
  app.onError((err, c) => {
    if (customOnError) {
      return customOnError(err, c);
    }
    return errorHandler(err, c, options.isDev);
  });
  const bodyLimitOptions = {
    maxSize: server?.bodySizeLimit ?? 4.5 * 1024 * 1024,
    // 4.5 MB,
    onError: () => ({ error: "Request body too large" })
  };
  const honoServerAdapter = new MastraServer({
    app,
    mastra,
    tools: options.tools,
    taskStore: a2aTaskStore,
    bodyLimitOptions,
    openapiPath: options?.isDev || server?.build?.openAPIDocs ? "/openapi.json" : void 0,
    customRouteAuthConfig,
    customApiRoutes: routes
  });
  honoServerAdapter.registerContextMiddleware();
  const serverMiddleware = mastra.getServerMiddleware?.();
  if (serverMiddleware && serverMiddleware.length > 0) {
    for (const m of serverMiddleware) {
      app.use(m.path, m.handler);
    }
  }
  if (server?.cors === false) {
    app.use("*", timeout(server?.timeout ?? 3 * 60 * 1e3));
  } else {
    const corsConfig = {
      origin: "*",
      allowMethods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
      credentials: false,
      maxAge: 3600,
      ...server?.cors,
      allowHeaders: ["Content-Type", "Authorization", "x-mastra-client-type", ...server?.cors?.allowHeaders ?? []],
      exposeHeaders: ["Content-Length", "X-Requested-With", ...server?.cors?.exposeHeaders ?? []]
    };
    app.use("*", timeout(server?.timeout ?? 3 * 60 * 1e3), cors(corsConfig));
  }
  app.get(
    "/health",
    describeRoute({
      description: "Health check endpoint",
      tags: ["system"],
      responses: {
        200: {
          description: "Service is healthy"
        }
      }
    }),
    healthHandler
  );
  if (options?.isDev || server?.build?.swaggerUI) {
    app.get(
      "/api",
      describeRoute({
        description: "API Welcome Page",
        tags: ["system"],
        responses: {
          200: {
            description: "Success"
          }
        }
      }),
      rootHandler
    );
  }
  honoServerAdapter.registerAuthMiddleware();
  if (server?.middleware) {
    const normalizedMiddlewares = Array.isArray(server.middleware) ? server.middleware : [server.middleware];
    const middlewares = normalizedMiddlewares.map((middleware2) => {
      if (typeof middleware2 === "function") {
        return {
          path: "*",
          handler: middleware2
        };
      }
      return middleware2;
    });
    for (const middleware2 of middlewares) {
      app.use(middleware2.path, middleware2.handler);
    }
  }
  if (routes) {
    for (const route of routes) {
      const middlewares = [];
      if (route.middleware) {
        middlewares.push(...Array.isArray(route.middleware) ? route.middleware : [route.middleware]);
      }
      if (route.openapi) {
        middlewares.push(describeRoute(route.openapi));
      }
      const handler = "handler" in route ? route.handler : await route.createHandler({ mastra });
      const allHandlers = [...middlewares, handler];
      if (route.method === "ALL") {
        app.all(route.path, allHandlers[0], ...allHandlers.slice(1));
      } else {
        app.on(route.method, route.path, allHandlers[0], ...allHandlers.slice(1));
      }
    }
  }
  if (server?.build?.apiReqLogs) {
    app.use(logger());
  }
  await honoServerAdapter.registerRoutes();
  if (options?.isDev || server?.build?.swaggerUI) {
    if (!options?.isDev && server?.build?.swaggerUI && !server?.build?.openAPIDocs) {
      const logger2 = mastra.getLogger();
      logger2.warn(
        "Swagger UI is enabled but OpenAPI documentation is disabled. The Swagger UI will not function properly without the OpenAPI endpoint. Please enable openAPIDocs in your server.build configuration:\n  server: { build: { swaggerUI: true, openAPIDocs: true } }"
      );
    }
    app.get(
      "/swagger-ui",
      describeRoute({
        hide: true
      }),
      middleware({ url: "/api/openapi.json" })
    );
  }
  if (options?.isDev) {
    app.post(
      "/__restart-active-workflow-runs",
      describeRoute({
        hide: true
      }),
      restartAllActiveWorkflowRunsHandler
    );
  }
  const serverOptions = mastra.getServer();
  const studioBasePath = normalizeStudioBase(serverOptions?.studioBase ?? "/");
  if (options?.studio) {
    app.get(
      `${studioBasePath}/refresh-events`,
      describeRoute({
        hide: true
      }),
      handleClientsRefresh
    );
    app.post(
      `${studioBasePath}/__refresh`,
      describeRoute({
        hide: true
      }),
      handleTriggerClientsRefresh
    );
    app.get(
      `${studioBasePath}/__hot-reload-status`,
      describeRoute({
        hide: true
      }),
      (c) => {
        return c.json({
          disabled: isHotReloadDisabled(),
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
    );
    const studioPath = getStudioPath();
    app.use(
      `${studioBasePath}/assets/*`,
      serveStatic({
        root: join(studioPath, "assets"),
        rewriteRequestPath: (path) => {
          let rewritten = path;
          if (studioBasePath && rewritten.startsWith(studioBasePath)) {
            rewritten = rewritten.slice(studioBasePath.length);
          }
          if (rewritten.startsWith("/assets")) {
            rewritten = rewritten.slice("/assets".length);
          }
          return rewritten;
        }
      })
    );
  }
  app.get("*", async (c, next) => {
    const requestPath = c.req.path;
    if (requestPath === "/api" || requestPath.startsWith("/api/") || requestPath.startsWith("/swagger-ui") || requestPath.startsWith("/openapi.json")) {
      return await next();
    }
    if (requestPath.includes(".") && !requestPath.endsWith(".html")) {
      return await next();
    }
    const isStudioRoute = studioBasePath === "" || requestPath === studioBasePath || requestPath.startsWith(`${studioBasePath}/`);
    if (options?.studio && isStudioRoute) {
      const studioPath = getStudioPath();
      let indexHtml = await readFile(join(studioPath, "index.html"), "utf-8");
      const port = serverOptions?.port ?? (Number(process.env.PORT) || 4111);
      const hideCloudCta = process.env.MASTRA_HIDE_CLOUD_CTA === "true";
      const host = serverOptions?.host ?? "localhost";
      const key = serverOptions?.https?.key ?? (process.env.MASTRA_HTTPS_KEY ? Buffer.from(process.env.MASTRA_HTTPS_KEY, "base64") : void 0);
      const cert = serverOptions?.https?.cert ?? (process.env.MASTRA_HTTPS_CERT ? Buffer.from(process.env.MASTRA_HTTPS_CERT, "base64") : void 0);
      const protocol = key && cert ? "https" : "http";
      const cloudApiEndpoint = process.env.MASTRA_CLOUD_API_ENDPOINT || "";
      const experimentalFeatures = process.env.EXPERIMENTAL_FEATURES === "true" ? "true" : "false";
      const requestContextPresets = process.env.MASTRA_REQUEST_CONTEXT_PRESETS || "";
      const escapeForHtml = (json) => {
        return json.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/</g, "\\u003c").replace(/>/g, "\\u003e").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      };
      indexHtml = indexHtml.replace(`'%%MASTRA_SERVER_HOST%%'`, `'${host}'`);
      indexHtml = indexHtml.replace(`'%%MASTRA_SERVER_PORT%%'`, `'${port}'`);
      indexHtml = indexHtml.replace(`'%%MASTRA_API_PREFIX%%'`, `'${serverOptions?.apiPrefix ?? "/api"}'`);
      indexHtml = indexHtml.replace(`'%%MASTRA_HIDE_CLOUD_CTA%%'`, `'${hideCloudCta}'`);
      indexHtml = indexHtml.replace(`'%%MASTRA_SERVER_PROTOCOL%%'`, `'${protocol}'`);
      indexHtml = indexHtml.replace(`'%%MASTRA_CLOUD_API_ENDPOINT%%'`, `'${cloudApiEndpoint}'`);
      indexHtml = indexHtml.replace(`'%%MASTRA_EXPERIMENTAL_FEATURES%%'`, `'${experimentalFeatures}'`);
      indexHtml = indexHtml.replace(
        `'%%MASTRA_REQUEST_CONTEXT_PRESETS%%'`,
        `'${escapeForHtml(requestContextPresets)}'`
      );
      indexHtml = indexHtml.replaceAll("%%MASTRA_STUDIO_BASE_PATH%%", studioBasePath);
      return c.newResponse(indexHtml, 200, { "Content-Type": "text/html" });
    }
    return c.newResponse(html2, 200, { "Content-Type": "text/html" });
  });
  if (options?.studio) {
    const studioRootPath = getStudioPath();
    const studioPath = studioBasePath ? `${studioBasePath}/*` : "*";
    app.use(
      studioPath,
      serveStatic({
        root: studioRootPath,
        rewriteRequestPath: (path) => {
          if (studioBasePath && path.startsWith(studioBasePath)) {
            return path.slice(studioBasePath.length);
          }
          return path;
        }
      })
    );
  }
  return app;
}
async function createNodeServer(mastra, options = { tools: {} }) {
  const app = await createHonoServer(mastra, options);
  const serverOptions = mastra.getServer();
  const key = serverOptions?.https?.key ?? (process.env.MASTRA_HTTPS_KEY ? Buffer.from(process.env.MASTRA_HTTPS_KEY, "base64") : void 0);
  const cert = serverOptions?.https?.cert ?? (process.env.MASTRA_HTTPS_CERT ? Buffer.from(process.env.MASTRA_HTTPS_CERT, "base64") : void 0);
  const isHttpsEnabled = Boolean(key && cert);
  const host = serverOptions?.host ?? "localhost";
  const port = serverOptions?.port ?? (Number(process.env.PORT) || 4111);
  const protocol = isHttpsEnabled ? "https" : "http";
  const server = serve(
    {
      fetch: app.fetch,
      port,
      hostname: serverOptions?.host,
      ...isHttpsEnabled ? {
        createServer: https.createServer,
        serverOptions: {
          key,
          cert
        }
      } : {}
    },
    () => {
      const logger2 = mastra.getLogger();
      logger2.info(` Mastra API running on ${protocol}://${host}:${port}/api`);
      if (options?.studio) {
        const studioBasePath = normalizeStudioBase(serverOptions?.studioBase ?? "/");
        const studioUrl = `${protocol}://${host}:${port}${studioBasePath}`;
        logger2.info(`\u{1F468}\u200D\u{1F4BB} Studio available at ${studioUrl}`);
      }
      if (process.send) {
        process.send({
          type: "server-ready",
          port,
          host
        });
      }
    }
  );
  await mastra.startEventEngine();
  return server;
}

// @ts-ignore
// @ts-ignore
await createNodeServer(mastra, {
  studio: true,
  isDev: true,
  tools: getToolExports(tools),
});

if (mastra.getStorage()) {
  mastra.__registerInternalWorkflow(scoreTracesWorkflow);
}

var distEDO7GEGI = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createOpenAI: createOpenAI,
  openai: openai
});

export { InvalidResponseDataError as I, NoSuchModelError as N, TooManyEmbeddingValuesForCallError as T, UnsupportedFunctionalityError as U, __commonJS$1 as _, __require2$1 as a, __commonJS as b, require_token_error as c, __require2 as d, e, __toESM$3 as f, __commonJS$3 as g, combineHeaders$1 as h, resolve$1 as i, postJsonToApi$1 as j, createJsonResponseHandler$1 as k, loadApiKey as l, createEventSourceResponseHandler$1 as m, convertUint8ArrayToBase64 as n, createJsonErrorResponseHandler$1 as o, parseProviderOptions as p, generateId as q, require_token_error$1 as r, isParsableJson as s, convertBase64ToUint8Array as t, postFormDataToApi as u, __commonJS$2 as v, withoutTrailingSlash$1 as w, require_token_error$2 as x, __require22 as y };
